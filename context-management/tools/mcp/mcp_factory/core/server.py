"""
MCP Server - Core JSON-RPC 2.0 Server Implementation

A production-grade stdio-based JSON-RPC 2.0 server that serves as the base
for all MCP servers generated by the factory.

Based on: https://www.jsonrpc.org/specification
"""

import sys
import json
import asyncio
import logging
from typing import Dict, Callable, Any, Optional
from dataclasses import dataclass, asdict, field

logger = logging.getLogger(__name__)


@dataclass
class JSONRPCRequest:
    """JSON-RPC 2.0 Request object."""
    jsonrpc: str = "2.0"
    method: str = ""
    params: Optional[Dict[str, Any]] = None
    id: Optional[int] = None


@dataclass
class JSONRPCError:
    """JSON-RPC 2.0 Error object."""
    code: int
    message: str
    data: Optional[Any] = None


@dataclass
class JSONRPCResponse:
    """JSON-RPC 2.0 Response object."""
    jsonrpc: str = "2.0"
    result: Optional[Any] = None
    error: Optional[Dict[str, Any]] = None
    id: Optional[int] = None


class MCPServer:
    """
    Core JSON-RPC 2.0 server implementation over stdio.

    This is the base class for all MCP servers. It handles:
    - JSON-RPC protocol compliance
    - Request routing to handlers
    - Error handling with proper codes
    - Async/sync handler support

    Usage:
        server = MCPServer()
        server.register_handler("search", search_handler)
        asyncio.run(server.run())
    """

    # JSON-RPC 2.0 predefined error codes
    ERROR_PARSE = JSONRPCError(-32700, "Parse error")
    ERROR_INVALID_REQUEST = JSONRPCError(-32600, "Invalid Request")
    ERROR_METHOD_NOT_FOUND = JSONRPCError(-32601, "Method not found")
    ERROR_INVALID_PARAMS = JSONRPCError(-32602, "Invalid params")
    ERROR_INTERNAL = JSONRPCError(-32603, "Internal error")

    def __init__(self, name: str = "mcp-server", version: str = "1.0.0"):
        self.name = name
        self.version = version
        self.handlers: Dict[str, Callable] = {}
        self.running = False

        # Register built-in MCP methods
        self._register_builtin_handlers()

    def _register_builtin_handlers(self) -> None:
        """Register standard MCP protocol handlers."""
        self.register_handler("initialize", self._handle_initialize)
        self.register_handler("tools/list", self._handle_tools_list)

    def _handle_initialize(self, **_params) -> dict:
        """Handle MCP initialize request."""
        return {
            "protocolVersion": "2024-11-05",
            "capabilities": {"tools": {}},
            "serverInfo": {
                "name": self.name,
                "version": self.version
            }
        }

    def _handle_tools_list(self, **_params) -> dict:
        """Handle tools/list request - override in subclass."""
        return {"tools": []}

    def register_handler(self, method: str, handler: Callable) -> None:
        """
        Register a handler for a specific JSON-RPC method.

        Args:
            method: The JSON-RPC method name
            handler: Async or sync callable that processes the request
        """
        self.handlers[method] = handler
        logger.debug(f"Registered handler for method: {method}")

    async def run(self) -> None:
        """
        Main server loop: read requests from stdin, process, write to stdout.

        This method blocks until EOF is received on stdin or the server
        is explicitly stopped.
        """
        self.running = True
        logger.info(f"[{self.name}] Starting MCP server on stdio")
        sys.stderr.write(f"[{self.name}] Starting MCP server\n")
        sys.stderr.flush()

        try:
            while self.running:
                try:
                    line = await self._read_line()
                    if not line:
                        logger.info("EOF on stdin, shutting down")
                        break

                    # Parse JSON-RPC request
                    try:
                        request_data = json.loads(line)
                    except json.JSONDecodeError as e:
                        logger.warning(f"Parse error: {e}")
                        error_response = JSONRPCResponse(
                            error=asdict(self.ERROR_PARSE),
                            id=None
                        )
                        self._write_response(error_response)
                        continue

                    # Handle notification (no id = no response)
                    if request_data.get("method") == "initialized":
                        continue

                    # Process request and send response
                    response = await self._handle_request(request_data)
                    if request_data.get("id") is not None:
                        self._write_response(response)

                except Exception as e:
                    logger.exception(f"Unexpected error in server loop: {e}")
                    error_response = JSONRPCResponse(
                        error=asdict(self.ERROR_INTERNAL),
                        id=None
                    )
                    self._write_response(error_response)

        finally:
            self.running = False
            logger.info(f"[{self.name}] Server shutdown complete")

    async def _read_line(self) -> Optional[str]:
        """Read a complete line from stdin asynchronously."""
        loop = asyncio.get_event_loop()

        def _read_blocking() -> Optional[str]:
            try:
                line = sys.stdin.readline()
                return line.strip() if line else None
            except Exception as e:
                logger.error(f"Error reading from stdin: {e}")
                return None

        return await loop.run_in_executor(None, _read_blocking)

    def _write_response(self, response: JSONRPCResponse) -> None:
        """Write a JSON-RPC response to stdout."""
        try:
            response_dict = asdict(response)
            # Remove None fields for cleaner output
            response_dict = {k: v for k, v in response_dict.items() if v is not None}

            json_line = json.dumps(response_dict, separators=(',', ':'))
            sys.stdout.write(json_line + '\n')
            sys.stdout.flush()
            logger.debug(f"Sent response: {json_line[:100]}...")
        except Exception as e:
            logger.error(f"Error writing response: {e}")

    async def _handle_request(self, request_data: Dict[str, Any]) -> JSONRPCResponse:
        """Process a single JSON-RPC request and return response."""
        request_id = request_data.get("id")

        # Validate JSON-RPC format
        if not isinstance(request_data, dict):
            return JSONRPCResponse(
                error=asdict(self.ERROR_INVALID_REQUEST),
                id=request_id
            )

        if request_data.get("jsonrpc") != "2.0":
            return JSONRPCResponse(
                error=asdict(self.ERROR_INVALID_REQUEST),
                id=request_id
            )

        method = request_data.get("method")
        if not isinstance(method, str):
            return JSONRPCResponse(
                error=asdict(self.ERROR_INVALID_REQUEST),
                id=request_id
            )

        # Dispatch to handler
        if method not in self.handlers:
            return JSONRPCResponse(
                error=asdict(self.ERROR_METHOD_NOT_FOUND),
                id=request_id
            )

        handler = self.handlers[method]
        params = request_data.get("params", {})

        try:
            # Call handler (async or sync)
            if asyncio.iscoroutinefunction(handler):
                result = await handler(**params if isinstance(params, dict) else {})
            else:
                result = handler(**params if isinstance(params, dict) else {})

            return JSONRPCResponse(result=result, id=request_id)

        except TypeError as e:
            logger.warning(f"Invalid parameters for {method}: {e}")
            return JSONRPCResponse(
                error=asdict(self.ERROR_INVALID_PARAMS),
                id=request_id
            )
        except Exception as e:
            logger.exception(f"Handler error for {method}: {e}")
            return JSONRPCResponse(
                error={
                    "code": -32603,
                    "message": "Internal error",
                    "data": str(e)
                },
                id=request_id
            )

    def stop(self) -> None:
        """Signal the server to stop."""
        self.running = False
