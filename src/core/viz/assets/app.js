window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';
    
    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }
    
    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.inflate(binData, { to: 'string' });
    
    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let CURRENT_DENSITY = 1; // Default: show all nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
let SELECTED_NODE_IDS = new Set();
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
let MARQUEE_ACTIVE = false;
let MARQUEE_START = null;
let MARQUEE_ADDITIVE = false;
let SELECTION_BOX = null;
let LAST_MARQUEE_END_TS = 0;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
let DIMENSION_TRANSITION = false;
let STARFIELD = null;
let STARFIELD_OPACITY = 0;
let BLOOM_PASS = null;
let BLOOM_STRENGTH = 0;
let EDGE_MODE = 'gradient-file';  // DEFAULT: Show file regions with gradients!
let EDGE_DEFAULT_OPACITY = 0.2;
let DEFAULT_LINK_DISTANCE = null;
let EDGE_MODE_CONFIG = {
    resolution: {
        internal: '#4dd4ff',
        external: '#ff6b6b',
        unresolved: '#9aa0a6',
        unknown: '#666666'
    },
    weight: { hue_min: 210, hue_max: 50, chroma: null, saturation: 45, lightness: 42 },
    confidence: { hue_min: 20, hue_max: 120, chroma: null, saturation: 45, lightness: 44 },
    width: { base: 1.2, weight_scale: 2.5, confidence_scale: 1.5 },
    dim: { interfile_factor: 0.25 },
    opacity: 0.12
};
let EDGE_COLOR_CONFIG = {
    default: '#333333',
    calls: '#4dd4ff',
    contains: '#00ff9d',
    uses: '#ffb800',
    imports: '#9aa0a6',
    inherits: '#ff6b6b'
};
let FILE_COLOR_CONFIG = {
    strategy: 'golden-angle',
    angle: 137.5,
    chroma: null,
    saturation: 70,
    lightness: 50
};
let EDGE_RANGES = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
let NODE_FILE_INDEX = new Map();
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
let GRAPH_MODE = 'atoms'; // atoms | files | hybrid

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

let FILE_GRAPH = null;
let FILE_NODE_IDS = new Map();
let FILE_NODE_POSITIONS = new Map();
let EXPANDED_FILES = new Set();
let FILE_EXPAND_MODE = 'inline'; // inline | detach
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    edgeOpacity: null,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // =1 linear, >1 amplifies differences, <1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let fileBoundaryMeshes = [];
let fileMode = false;
let fileVizMode = 'color'; // 'color' | 'hulls' | 'cluster'
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();

// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// Amplification function using power law: f(x) = x^(1/) for  values
// Maps normalized [0,1] input to amplified [0,1] output
function amplify(value, gamma = APPEARANCE_STATE.amplifier) {
    if (gamma === 1) return value;
    // Clamp to valid range
    const v = Math.max(0, Math.min(1, value));
    // Power law: v^(1/) - when >1, small diffs become larger
    // Using 1/ so that higher slider = more amplification
    return Math.pow(v, 1 / gamma);
}

// Contrast amplification: expands values away from midpoint
function amplifyContrast(value, strength = APPEARANCE_STATE.amplifier) {
    if (strength === 1) return value;
    const v = Math.max(0, Math.min(1, value));
    // S-curve using tanh for smooth contrast expansion
    const centered = (v - 0.5) * 2;  // [-1, 1]
    const amplified = Math.tanh(centered * strength) / Math.tanh(strength);
    return (amplified + 1) / 2;  // Back to [0, 1]
}

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data  color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;

// =====================================================================
// LEGEND MANAGER: Counts + Visibility + Extraction
// ALL COLORS come from ColorOrchestrator - no duplicates
// =====================================================================
class LegendManager {
    constructor() {
        // Dimension metadata (NO COLORS - those live in ColorOrchestrator)
        this.dimensions = {
            tier: {
                name: 'TIERS',
                icon: '',
                extract: (node) => typeof getNodeTier === 'function' ? getNodeTier(node) : 'UNKNOWN'
            },
            family: {
                name: 'FAMILIES',
                icon: '',
                extract: (node) => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : 'UNKNOWN'
            },
            ring: {
                name: 'RINGS',
                icon: '',
                extract: (node) => typeof getNodeRing === 'function' ? getNodeRing(node) : 'UNKNOWN'
            },
            layer: {
                name: 'LAYERS',
                icon: '',
                extract: (node) => (node.layer || 'VIRTUAL').toUpperCase()
            },
            edgeType: {
                name: 'EDGES',
                icon: '',
                extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
            }
        };

        this.counts = {};      // Computed counts per dimension
        this.visible = {};     // Visibility state for filtering
        this._subscribers = [];
    }

    init(nodes, links) {
        this._computeCounts(nodes, links);
        this._initVisibility();
        return this;
    }

    _computeCounts(nodes, links) {
        this.counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer'].forEach(dim => {
            const extract = this.dimensions[dim]?.extract;
            if (!extract) return;
            this.counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                this.counts[dim][cat] = (this.counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimension
        const edgeExtract = this.dimensions.edgeType?.extract;
        if (edgeExtract) {
            this.counts.edgeType = {};
            (links || []).forEach(link => {
                const cat = edgeExtract(link);
                this.counts.edgeType[cat] = (this.counts.edgeType[cat] || 0) + 1;
            });
        }

        console.log('[Legend] Counts:', this.counts);
    }

    _initVisibility() {
        this.visible = {};
        Object.keys(this.dimensions).forEach(dim => {
            // Initialize with all categories from ColorOrchestrator
            this.visible[dim] = new Set(Color.getCategories(dim));
        });
    }

    // Get legend data - COLORS FROM ColorOrchestrator
    getLegendData(dimension) {
        const counts = this.counts[dimension] || {};
        const visible = this.visible[dimension] || new Set();

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: Color.getLabel(dimension, cat),  // FROM ColorOrchestrator
                color: Color.get(dimension, cat),       // FROM ColorOrchestrator (with transforms!)
                count: counts[cat] || 0,
                visible: visible.has(cat),
                dimension: dimension
            }));
    }

    // Get color - DELEGATES to ColorOrchestrator
    getColor(dimension, category) {
        return Color.get(dimension, category);
    }

    toggleCategory(dimension, category) {
        if (!this.visible[dimension]) return;
        if (this.visible[dimension].has(category)) {
            this.visible[dimension].delete(category);
        } else {
            this.visible[dimension].add(category);
        }
        this._notifySubscribers('visibility-change', { dimension, category });
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => { this._subscribers = this._subscribers.filter(cb => cb !== callback); };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global legend manager instance
let Legend = null;

// 
// DATAMANAGER: Single Gate for ALL Data Access
// 
// This is THE source of truth. All data flows through here.
// NO direct access to FULL_GRAPH or Graph.graphData() - use DM instead.
// 
class DataManager {
    constructor() {
        // 
        // RAW DATA (immutable after init)
        // 
        this.raw = {
            nodes: [],
            links: [],
            fileBoundaries: [],
            markov: {},
            kpis: {},
            meta: {}
        };

        // 
        // ANALYTICS DATA (all 30+ Collider sections)
        // 
        this.analytics = {
            // Structural metrics
            counts: {},
            stats: {},
            coverage: {},
            performance: {},

            // Classification & discovery
            classification: {},
            auto_discovery: {},
            ecosystem_discovery: {},

            // Architecture & dependencies
            dependencies: {},
            architecture: {},
            topology: {},

            // Flow analysis
            execution_flow: {},
            data_flow: {},
            knots: {},

            // Health & recommendations
            warnings: [],
            recommendations: [],
            theory_completeness: {},

            // Distributions
            distributions: {},
            edge_types: {},

            // RPBL profile (Responsibility, Purity, Boundary, Lifecycle)
            rpbl_profile: {},
            purpose_field: {},

            // Special nodes
            top_hubs: [],
            orphans_list: [],

            // Files
            files: [],

            // Semantic analysis
            semantics: {},
            llm_enrichment: {},

            // Brain download (the full report)
            brain_download: {}
        };

        // 
        // INDEXES (O(1) lookups - built once)
        // 
        this.index = {
            nodeById: new Map(),           // id  node
            nodesByTier: new Map(),        // tier  [nodes]
            nodesByFamily: new Map(),      // family  [nodes]
            nodesByRing: new Map(),        // ring  [nodes]
            nodesByFile: new Map(),        // fileIdx  [nodes]
            edgesBySource: new Map(),      // nodeId  [edges from]
            edgesByTarget: new Map(),      // nodeId  [edges to]
            edgeByKey: new Map(),          // "src|tgt"  edge
            fileByIndex: new Map(),        // idx  fileBoundary
            markovBySource: new Map()      // nodeId  sorted edges by weight
        };

        // 
        // CACHED AGGREGATIONS (computed once, invalidated on filter)
        // 
        this.cache = {
            tierCounts: null,
            familyCounts: null,
            ringCounts: null,
            edgeTypeCounts: null,
            edgeRanges: null
        };

        // 
        // CURRENT STATE (filtered view)
        // 
        this.filtered = {
            nodes: [],
            links: []
        };

        // Legend manager
        this.legend = new LegendManager();

        // 
        // COLOR SYSTEM: Single gate for all color access
        // 
        this.color = ColorOrchestrator;  // Reference to ColorOrchestrator
    }

    // 
    // INITIALIZATION
    // 
    init(data) {
        // Store raw data
        this.raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        this.raw.links = Array.isArray(data?.links) ? data.links : [];
        this.raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        this.raw.markov = data?.markov || {};
        this.raw.kpis = data?.kpis || {};
        this.raw.meta = data?.meta || {};

        // Build all indexes
        this._buildAllIndexes();

        // Initialize legend
        this.legend.init(this.raw.nodes, this.raw.links);
        Legend = this.legend;

        console.log('%c[DM] Initialized', 'color: #4ade80; font-weight: bold',
            `${this.raw.nodes.length} nodes, ${this.raw.links.length} edges, ${this.raw.fileBoundaries.length} files`);

        return this;
    }

    _buildAllIndexes() {
        this._buildNodeIndex();
        this._buildSemanticIndexes();
        this._buildEdgeIndexes();
        this._buildFileIndex();
        this._buildMarkovIndex();
        this._invalidateCache();
    }

    _buildNodeIndex() {
        this.index.nodeById.clear();
        for (const node of this.raw.nodes) {
            if (node?.id) {
                this.index.nodeById.set(node.id, node);
            }
        }
    }

    _buildSemanticIndexes() {
        this.index.nodesByTier.clear();
        this.index.nodesByFamily.clear();
        this.index.nodesByRing.clear();
        this.index.nodesByFile.clear();

        for (const node of this.raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = this._getNodeTier(node);
            if (!this.index.nodesByTier.has(tier)) {
                this.index.nodesByTier.set(tier, []);
            }
            this.index.nodesByTier.get(tier).push(node);

            // Family index
            const family = this._getNodeFamily(node);
            if (!this.index.nodesByFamily.has(family)) {
                this.index.nodesByFamily.set(family, []);
            }
            this.index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = this._getNodeRing(node);
            if (!this.index.nodesByRing.has(ring)) {
                this.index.nodesByRing.set(ring, []);
            }
            this.index.nodesByRing.get(ring).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!this.index.nodesByFile.has(fileIdx)) {
                    this.index.nodesByFile.set(fileIdx, []);
                }
                this.index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    _buildEdgeIndexes() {
        this.index.edgesBySource.clear();
        this.index.edgesByTarget.clear();
        this.index.edgeByKey.clear();

        for (const link of this.raw.links) {
            const srcId = this._endpointId(link, 'source');
            const tgtId = this._endpointId(link, 'target');

            if (srcId) {
                if (!this.index.edgesBySource.has(srcId)) {
                    this.index.edgesBySource.set(srcId, []);
                }
                this.index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!this.index.edgesByTarget.has(tgtId)) {
                    this.index.edgesByTarget.set(tgtId, []);
                }
                this.index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                this.index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    _buildFileIndex() {
        this.index.fileByIndex.clear();
        for (let i = 0; i < this.raw.fileBoundaries.length; i++) {
            this.index.fileByIndex.set(i, this.raw.fileBoundaries[i]);
        }
    }

    _buildMarkovIndex() {
        this.index.markovBySource.clear();
        // Group edges by source and sort by markov weight
        for (const link of this.raw.links) {
            const srcId = this._endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!this.index.markovBySource.has(srcId)) {
                    this.index.markovBySource.set(srcId, []);
                }
                this.index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [srcId, edges] of this.index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    _invalidateCache() {
        this.cache.tierCounts = null;
        this.cache.familyCounts = null;
        this.cache.ringCounts = null;
        this.cache.edgeTypeCounts = null;
        this.cache.edgeRanges = null;
    }

    // 
    // HELPER FUNCTIONS (internal)
    // 
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    _getNodeTier(node) {
        if (!node) return 'UNKNOWN';
        if (node.tier) return node.tier;
        if (node.layer === 'foundation') return 'T0';
        if (node.layer === 'domain') return 'T1';
        if (node.layer === 'application') return 'T2';
        return 'UNKNOWN';
    }

    _getNodeFamily(node) {
        if (!node) return 'EXT';
        const family = (node.atom_family || node.family || 'EXT').toUpperCase();
        return ['LOG', 'DAT', 'ORG', 'EXE', 'EXT'].includes(family) ? family : 'EXT';
    }

    _getNodeRing(node) {
        if (!node) return 'UNKNOWN';
        const ring = (node.ring || node.layer || 'UNKNOWN').toUpperCase();
        return ring;
    }

    // 
    // RAW DATA ACCESSORS (replaces FULL_GRAPH.*)
    // 
    getNodes() {
        return this.raw.nodes;
    }

    getLinks() {
        return this.raw.links;
    }

    getFileBoundaries() {
        return this.raw.fileBoundaries;
    }

    getMarkov() {
        return this.raw.markov;
    }

    getKpis() {
        return this.raw.kpis;
    }

    getMeta() {
        return this.raw.meta;
    }

    // 
    // INDEXED LOOKUPS (O(1))
    // 
    getNode(id) {
        return this.index.nodeById.get(id) || null;
    }

    getNodesByTier(tier) {
        return this.index.nodesByTier.get(tier) || [];
    }

    getNodesByFamily(family) {
        return this.index.nodesByFamily.get(family) || [];
    }

    getNodesByRing(ring) {
        return this.index.nodesByRing.get(ring) || [];
    }

    getNodesByFile(fileIdx) {
        return this.index.nodesByFile.get(fileIdx) || [];
    }

    getEdgesFrom(nodeId) {
        return this.index.edgesBySource.get(nodeId) || [];
    }

    getEdgesTo(nodeId) {
        return this.index.edgesByTarget.get(nodeId) || [];
    }

    getEdgeBetween(srcId, tgtId) {
        return this.index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    getFile(idx) {
        return this.index.fileByIndex.get(idx) || null;
    }

    getTopMarkovEdges(nodeId, k = 5) {
        const edges = this.index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    isHighEntropyNode(nodeId) {
        const highEntropy = this.raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // 
    // FILTERED DATA (replaces Graph.graphData())
    // 
    setFiltered(nodes, links) {
        this.filtered.nodes = nodes || [];
        this.filtered.links = links || [];
    }

    getVisibleNodes() {
        // Return filtered if set, otherwise return from Graph
        if (this.filtered.nodes.length > 0) {
            return this.filtered.nodes;
        }
        // Fallback to Graph.graphData() during transition
        return (Graph && Graph.graphData) ? (Graph.graphData().nodes || []) : [];
    }

    getVisibleLinks() {
        if (this.filtered.links.length > 0) {
            return this.filtered.links;
        }
        return (Graph && Graph.graphData) ? (Graph.graphData().links || []) : [];
    }

    // 
    // AGGREGATIONS (cached)
    // 
    getTierCounts() {
        if (!this.cache.tierCounts) {
            this.cache.tierCounts = new Map();
            for (const [tier, nodes] of this.index.nodesByTier) {
                this.cache.tierCounts.set(tier, nodes.length);
            }
        }
        return this.cache.tierCounts;
    }

    getFamilyCounts() {
        if (!this.cache.familyCounts) {
            this.cache.familyCounts = new Map();
            for (const [family, nodes] of this.index.nodesByFamily) {
                this.cache.familyCounts.set(family, nodes.length);
            }
        }
        return this.cache.familyCounts;
    }

    getRingCounts() {
        if (!this.cache.ringCounts) {
            this.cache.ringCounts = new Map();
            for (const [ring, nodes] of this.index.nodesByRing) {
                this.cache.ringCounts.set(ring, nodes.length);
            }
        }
        return this.cache.ringCounts;
    }

    getEdgeTypeCounts() {
        if (!this.cache.edgeTypeCounts) {
            this.cache.edgeTypeCounts = new Map();
            for (const link of this.raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                this.cache.edgeTypeCounts.set(type, (this.cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return this.cache.edgeTypeCounts;
    }

    getEdgeRanges() {
        if (!this.cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of this.raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            this.cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return this.cache.edgeRanges;
    }

    // 
    // SELF-TEST
    // 
    selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of this.raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of this.raw.links) {
            const srcId = this._endpointId(link, 'source');
            const tgtId = this._endpointId(link, 'target');
            if (srcId && !this.index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !this.index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        // Index integrity checks
        const indexChecks = [
            ['nodeById', this.index.nodeById.size, this.raw.nodes.length],
            ['nodesByTier total', [...this.index.nodesByTier.values()].flat().length, this.raw.nodes.length],
            ['edgesBySource total', [...this.index.edgesBySource.values()].flat().length, this.raw.links.length],
        ];

        for (const [name, actual, expected] of indexChecks) {
            if (actual !== expected) {
                warnings.push(`Index ${name}: ${actual} vs expected ${expected}`);
            }
        }

        const status = errors.length === 0 ? ' PASS' : ' FAIL';
        console.log(`%c[DM] Self-Test: ${status}`, errors.length === 0 ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold');
        console.log(`  Raw: ${this.raw.nodes.length} nodes, ${this.raw.links.length} edges, ${this.raw.fileBoundaries.length} files`);
        console.log(`  Indexes: nodeById=${this.index.nodeById.size}, tiers=${this.index.nodesByTier.size}, families=${this.index.nodesByFamily.size}`);
        console.log(`  Edges: bySource=${this.index.edgesBySource.size}, byTarget=${this.index.edgesByTarget.size}, markov=${this.index.markovBySource.size}`);

        if (errors.length > 0) console.error('[DM] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DM] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }
}

function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const rawMarkovEdges = (Array.isArray(data?.links) ? data.links : [])
        .filter(l => (l?.markov_weight || 0) > 0).length;
    const dmMarkovEdges = (Array.isArray(dm.raw.links) ? dm.raw.links : [])
        .filter(l => (l?.markov_weight || 0) > 0).length;
    checks.push({ name: 'Markov edges', dm: dmMarkovEdges, old: rawMarkovEdges, pass: dmMarkovEdges === rawMarkovEdges });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? ' ALL PASS' : ' MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '' : '';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}

let DM = null;

// =====================================================================
// FLOATING PANEL CONTROL SYSTEM
// =====================================================================
let _activePanelId = null;

function openPanel(panelId) {
    const panel = document.getElementById('panel-' + panelId);
    const btn = document.getElementById('cmd-' + panelId);

    // Close any already-open panel
    if (_activePanelId && _activePanelId !== panelId) {
        closePanel(_activePanelId);
    }

    if (panel) {
        panel.classList.add('visible');
        // Short delay for transform animation
        setTimeout(() => { panel.style.opacity = '1'; }, 10);
    }
    if (btn) btn.classList.add('active');
    _activePanelId = panelId;

    // UI_ACTIVE: "Quiet the universe" - dim graph when panel opens
    document.body.classList.add('ui-active');

    // Also dim starfield via JS (CSS filter doesn't reach WebGL)
    if (typeof STARFIELD !== 'undefined' && STARFIELD && STARFIELD.material) {
        STARFIELD.material.opacity = STARFIELD_OPACITY * 0.3;
    }
}

function closePanel(panelId) {
    const panel = document.getElementById('panel-' + panelId);
    const btn = document.getElementById('cmd-' + panelId);
    if (panel) {
        panel.classList.remove('visible');
    }
    if (btn) btn.classList.remove('active');
    if (_activePanelId === panelId) _activePanelId = null;

    // UI_ACTIVE: Restore universe when all panels closed
    if (!_activePanelId) {
        document.body.classList.remove('ui-active');

        // Restore starfield opacity
        if (typeof STARFIELD !== 'undefined' && STARFIELD && STARFIELD.material) {
            const starsBtn = document.getElementById('btn-stars');
            const starsVisible = starsBtn && starsBtn.classList.contains('active');
            STARFIELD.material.opacity = starsVisible ? STARFIELD_OPACITY : 0;
        }
    }
}

function togglePanel(panelId) {
    const panel = document.getElementById('panel-' + panelId);
    if (panel && panel.classList.contains('visible')) {
        closePanel(panelId);
    } else {
        openPanel(panelId);
    }
}

// Wire up command bar and panel controls
function initCommandBar() {
    // Command bar buttons
    const cmdBtns = {
        'cmd-view': 'view',
        'cmd-filter': 'filter',
        'cmd-style': 'style',
        'cmd-settings': 'settings'
    };

    Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.addEventListener('click', () => togglePanel(panelId));
        }
    });

    // Settings panel: Oval margin slider (debounced - apply 300ms after release)
    const ovalSlider = document.getElementById('oval-margin-slider');
    const ovalValue = document.getElementById('oval-margin-value');
    let ovalDebounceTimer = null;
    if (ovalSlider) {
        // Update display value immediately
        ovalSlider.addEventListener('input', (e) => {
            if (ovalValue) ovalValue.textContent = e.target.value + '%';
        });
        // Apply actual change only after 300ms pause (on mouseup/touchend)
        const applyOvalMargin = () => {
            clearTimeout(ovalDebounceTimer);
            ovalDebounceTimer = setTimeout(() => {
                const val = ovalSlider.value;
                document.documentElement.style.setProperty('--oval-margin', val + '%');
            }, 300);
        };
        ovalSlider.addEventListener('mouseup', applyOvalMargin);
        ovalSlider.addEventListener('touchend', applyOvalMargin);
        ovalSlider.addEventListener('change', applyOvalMargin);
    }

    // Oval debug toggle
    const toggleOvalDebug = document.getElementById('toggle-oval-debug');
    if (toggleOvalDebug) {
        toggleOvalDebug.addEventListener('click', () => {
            toggleOvalDebug.classList.toggle('active');
            const ovalDebug = document.querySelector('.oval-debug');
            if (ovalDebug) {
                ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
            }
        });
    }

    // 
    // STYLE PANEL SLIDERS - Connected to appearance system
    // 

    // Node Size Slider
    const nodeSizeSlider = document.getElementById('node-size-slider');
    const nodeSizeValue = document.getElementById('node-size-value');
    if (nodeSizeSlider) {
        nodeSizeSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
            APPEARANCE_STATE.nodeScale = val;
            if (Graph) {
                Graph.nodeVal(node => (node.val || node.size || 1) * val);
            }
        });
    }

    // Edge Opacity Slider
    const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
    const edgeOpacityValue = document.getElementById('edge-opacity-value');
    if (edgeOpacitySlider) {
        edgeOpacitySlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
            APPEARANCE_STATE.edgeOpacity = val / 100;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
        });
    }

    // Density Slider (filter panel duplicate)
    const densitySlider2 = document.getElementById('density-slider2');
    const densityValue2 = document.getElementById('density-value2');
    if (densitySlider2) {
        densitySlider2.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (densityValue2) densityValue2.textContent = val + '%';
            CURRENT_DENSITY = val;
            refreshGraph();
        });
    }

    // Toggle switches
    document.querySelectorAll('.toggle-switch').forEach(toggle => {
        toggle.addEventListener('click', () => {
            toggle.classList.toggle('active');
        });
    });

    // Segmented controls
    document.querySelectorAll('.segmented-control').forEach(control => {
        control.querySelectorAll('.segment').forEach(segment => {
            segment.addEventListener('click', () => {
                control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                segment.classList.add('active');

                // Handle dimension change
                if (control.id === 'dim-control') {
                    const dim = segment.dataset.dim;
                    if (dim === '2') {
                        IS_3D = false;
                        if (Graph) Graph.numDimensions(2);
                    } else {
                        IS_3D = true;
                        if (Graph) Graph.numDimensions(3);
                    }
                }

                // Handle node color mode
                if (control.id === 'node-color-control') {
                    const mode = segment.dataset.mode;
                    if (mode && typeof setNodeColorMode === 'function') {
                        setNodeColorMode(mode);
                    }
                }

                // Handle edge color mode
                if (control.id === 'edge-color-control') {
                    const mode = segment.dataset.mode;
                    if (mode) {
                        EDGE_MODE = mode;
                        if (typeof applyEdgeMode === 'function') applyEdgeMode();
                    }
                }

                // Handle panel layout
                if (control.id === 'layout-control') {
                    const layout = segment.dataset.layout;
                    if (layout) {
                        document.body.setAttribute('data-layout', layout);
                        console.log('[Layout] Switched to:', layout);
                    }
                }
            });
        });
    });

    // 
    // COMMAND BAR DIRECT ACTIONS (no proxy clicks - call functions directly)
    // 

    // File mode toggle - calls setFileModeState directly
    const cmdFiles = document.getElementById('cmd-files2');
    if (cmdFiles) {
        cmdFiles.addEventListener('click', () => {
            if (typeof setFileModeState === 'function') {
                // Toggle file mode
                const newState = !fileMode;
                setFileModeState(newState);
                cmdFiles.classList.toggle('active', newState);
            } else {
                // Fallback: proxy click (temporary)
                const btnFiles = document.getElementById('btn-files');
                if (btnFiles) btnFiles.click();
                cmdFiles.classList.toggle('active');
            }
        });
    }

    // Flow mode toggle - toggles flowMode directly
    const cmdFlow = document.getElementById('cmd-flow2');
    if (cmdFlow) {
        cmdFlow.addEventListener('click', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                cmdFlow.classList.toggle('active', flowMode);
            } else {
                // Fallback: proxy click (temporary)
                const btnFlow = document.getElementById('btn-flow');
                if (btnFlow) btnFlow.click();
                cmdFlow.classList.toggle('active');
            }
        });
    }

    // 3D toggle - toggles IS_3D directly
    const cmd3d = document.getElementById('cmd-3d');
    if (cmd3d) {
        cmd3d.addEventListener('click', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else {
                // Direct implementation
                IS_3D = !IS_3D;
                if (Graph) Graph.numDimensions(IS_3D ? 3 : 2);
                // Update btn-dimensions label for consistency
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = IS_3D ? '2D' : '3D';
            }
            cmd3d.classList.toggle('active', IS_3D);
            // Also update dim-control segment
            const dimControl = document.getElementById('dim-control');
            if (dimControl) {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (IS_3D ? '3' : '2'));
                });
            }
        });
    }

    console.log('[CommandBar] Initialized with direct function calls');
}

// Build chip buttons for filter groups
function buildChipGroup(containerId, items, stateSet, onUpdate) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    // "ALL" chip
    const allChip = document.createElement('button');
    allChip.className = 'chip active';
    allChip.textContent = 'ALL';
    allChip.addEventListener('click', () => {
        // Toggle all on/off
        const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
        if (allActive) {
            stateSet.clear();
            container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        } else {
            items.forEach((count, key) => stateSet.add(key));
            container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
        }
        if (onUpdate) onUpdate();
    });
    container.appendChild(allChip);

    // Individual chips
    items.forEach((count, key) => {
        const chip = document.createElement('button');
        chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
        chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
        chip.addEventListener('click', () => {
            if (stateSet.has(key)) {
                stateSet.delete(key);
                chip.classList.remove('active');
            } else {
                stateSet.add(key);
                chip.classList.add('active');
            }
            // Update "ALL" chip state
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            allChip.classList.toggle('active', allActive);
            if (onUpdate) onUpdate();
        });
        container.appendChild(chip);
    });
}

// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// =====================================================================
// LEGEND RENDERER: Color-coded hierarchical legend using LegendManager
// =====================================================================
function renderLegendSection(containerId, dimension, stateSet, onUpdate) {
    const container = document.getElementById(containerId);
    if (!container || !Legend) return;

    container.innerHTML = '';

    const legendData = Legend.getLegendData(dimension);
    if (!legendData || legendData.length === 0) return;

    // Build legend items
    legendData.forEach(item => {
        const el = document.createElement('div');
        el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
        el.dataset.category = item.id;
        el.dataset.dimension = dimension;

        // Color swatch
        const swatch = document.createElement('span');
        swatch.className = 'topo-legend-swatch';
        swatch.style.backgroundColor = item.color;

        // Label with count
        const label = document.createElement('span');
        label.className = 'topo-legend-label';
        label.textContent = item.id;

        const count = document.createElement('span');
        count.className = 'topo-legend-count';
        count.textContent = `(${item.count})`;

        el.appendChild(swatch);
        el.appendChild(label);
        el.appendChild(count);

        // Click to toggle filter
        if (stateSet) {
            el.addEventListener('click', () => {
                if (stateSet.has(item.id)) {
                    stateSet.delete(item.id);
                    el.classList.add('filtered');
                } else {
                    stateSet.add(item.id);
                    el.classList.remove('filtered');
                }
                if (Legend) Legend.toggleCategory(dimension, item.id);
                if (onUpdate) onUpdate();
            });
        }

        container.appendChild(el);
    });

    console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
}

// Render all legend sections
function renderAllLegends() {
    if (!Legend) {
        console.warn('[Legend] LegendManager not initialized');
        return;
    }

    // Render node legends
    renderLegendSection('topo-tiers', 'tier', VIS_FILTERS.tiers, refreshGraph);
    renderLegendSection('topo-families', 'family', VIS_FILTERS.families, refreshGraph);
    renderLegendSection('topo-rings', 'ring', VIS_FILTERS.rings, refreshGraph);

    // Render edge legend
    renderLegendSection('topo-edges', 'edgeType', VIS_FILTERS.edges, refreshGraph);

    console.log('[Legend] All sections rendered');
}

// =====================================================================
// HUD LAYOUT MANAGER: Smart Text Placement with Collision Avoidance
// =====================================================================
const HudLayoutManager = {
    // Margin from viewport edges
    MARGIN: 16,
    // Panels by priority (higher = more important, won't be moved)
    fixed: ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'],
    // Dynamic panels in priority order (hover-panel > file-panel)
    dynamic: ['hover-panel', 'file-panel'],

    // Throttle state
    _rafPending: false,
    _lastReflow: 0,
    REFLOW_THROTTLE_MS: 50,

    // Mouse position for hover-panel placement
    _mouseX: 0,
    _mouseY: 0,

    // Get viewport rectangle
    getViewport() {
        return {
            left: this.MARGIN,
            top: this.MARGIN,
            right: window.innerWidth - this.MARGIN,
            bottom: window.innerHeight - this.MARGIN,
            width: window.innerWidth - 2 * this.MARGIN,
            height: window.innerHeight - 2 * this.MARGIN
        };
    },

    // Check if sidebar is effectively "open" (occupying space)
    isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        return SIDEBAR_STATE.locked ||
            SIDEBAR_STATE.open ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    },

    // Get rectangle for an element (returns null if hidden/missing)
    getRect(el) {
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    },

    // Get sidebar occupied region (full expanded width when open)
    getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !this.isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        // Sidebar is on the left, vertically centered
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20, // left margin + width + padding
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    },

    // Get all occupied rectangles (fixed panels + sidebar when open)
    getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = this.getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        this.fixed.forEach(id => {
            if (id === 'side-dock') return; // Handled separately above
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = this.getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = this.getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    },

    // Calculate overlap area between two rectangles
    overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    },

    // Check if rect is fully inside viewport
    isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    },

    // Clamp position to keep panel inside viewport
    clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    },

    // Generate candidate positions for file panel (4 corners, biased away from sidebar)
    getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = this.getViewport();
        const margin = 20;
        const sidebarOpen = this.isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        // Candidates: TR, BR, BL, TL (prefer right side when sidebar open)
        const candidates = sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },           // Top-right
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin }, // Bottom-right
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },  // Bottom-left (clear of sidebar)
            { left: sidebarWidth + margin, top: vp.top + margin }                     // Top-left (clear of sidebar)
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },       // Bottom-left (default)
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin }, // Bottom-right
            { left: vp.right - panelWidth - margin, top: vp.top + margin },          // Top-right
            { left: vp.left + margin, top: vp.top + margin }                          // Top-left
        ];

        return candidates;
    },

    // Generate candidate positions for selection panel (prefer right side)
    getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = this.getViewport();
        const margin = 20;
        const sidebarOpen = this.isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin }, // Bottom-right
            { left: vp.right - panelWidth - margin, top: vp.top + margin },                  // Top-right
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },         // Bottom-left
            { left: sidebarWidth + margin, top: vp.top + margin }                           // Top-left
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    },

    // Get screen centroid of selected nodes (for smart tooltip positioning)
    getSelectionCentroid() {
        if (!Graph || !Graph.graphData || SELECTED_NODE_IDS.size === 0) return null;
        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => SELECTED_NODE_IDS.has(n.id));
        if (selectedNodes.length === 0) return null;

        // Calculate centroid in 3D space
        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        // Project to screen coordinates
        const camera = Graph.camera();
        if (!camera) return null;
        const vector = new THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    },

    // Generate candidate positions for hover panel (4 quadrants around anchor point)
    getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = this.getViewport();
        const offset = 16;  // Offset from anchor

        // Smart positioning: If hovering a selected node, position near selection centroid
        let anchorX = mouseX;
        let anchorY = mouseY;

        if (HOVERED_NODE && SELECTED_NODE_IDS.has(HOVERED_NODE.id)) {
            const centroid = this.getSelectionCentroid();
            if (centroid) {
                // Position panel near the selection cluster edge, not centroid center
                // Blend between mouse position and centroid for natural feel
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        // Account for sidebar when it's open
        const sidebarOpen = this.isSidebarOpen();
        const sidebarRect = sidebarOpen ? this.getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        // Candidates: TR, BR, BL, TL around anchor position
        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },        // Top-right
            { left: anchorX + offset, top: anchorY + offset },                       // Bottom-right
            { left: anchorX - panelWidth - offset, top: anchorY + offset },         // Bottom-left
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }  // Top-left
        ];

        // Ensure candidates clear the sidebar
        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    },

    // Update mouse position (called on mousemove)
    updateMousePosition(x, y) {
        this._mouseX = x;
        this._mouseY = y;
    },

    // Place a panel at the best position (least overlap)
    placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = this.getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = this.clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            // Calculate total overlap with all occupied rects
            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += this.overlapArea(panelRect, occRect);
            }

            // Check viewport containment penalty
            if (!this.isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000; // Heavy penalty for going outside viewport
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break; // Perfect position found
            }
        }

        return bestPos;
    },

    // Reflow all dynamic panels
    reflow() {
        const now = Date.now();
        if (now - this._lastReflow < this.REFLOW_THROTTLE_MS) {
            // Throttle: schedule for later via RAF
            if (!this._rafPending) {
                this._rafPending = true;
                requestAnimationFrame(() => {
                    this._rafPending = false;
                    this.reflow();
                });
            }
            return;
        }
        this._lastReflow = now;

        const occupiedRects = this.getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = this.getHoverPanelCandidates(
                this._mouseX, this._mouseY, hoverWidth, hoverHeight
            );
            const pos = this.placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                // Track hover panel rect for file panel to avoid
                hoverPanelRect = {
                    left: pos.left,
                    top: pos.top,
                    right: pos.left + hoverWidth,
                    bottom: pos.top + hoverHeight
                };
            }
        }

        // Build occupied rects for file panel (includes hover panel if visible)
        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) {
            filePanelOccupied.push(hoverPanelRect);
        }

        // Place selection panel (secondary priority)
        const selectionPanel = document.getElementById('selection-panel');
        let selectionPanelRect = null;
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = this.getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = this.placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                selectionPanelRect = {
                    left: pos.left,
                    top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                };
                filePanelOccupied.push(selectionPanelRect);
            }
        }

        // Place file panel (lower priority, avoids hover panel too)
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = this.getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = this.placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto'; // Override default bottom positioning
            }
        }
    },

    // Initialize event listeners for reflow triggers
    init() {
        // Window resize
        window.addEventListener('resize', () => this.reflow());

        // Track mouse position for hover-panel placement
        window.addEventListener('mousemove', (e) => {
            this.updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes (lock toggle is handled separately)
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => this.reflow());
            sideDock.addEventListener('mouseleave', () => {
                // Delay reflow slightly to let CSS transition complete
                setTimeout(() => this.reflow(), 200);
            });
        }

        console.log('[HudLayoutManager] Initialized');
    }
};

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = '#03040a';
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || '#888888';
    }

    function render() {
        ctx.fillStyle = '#03040a';
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    const simulation = physicsConfig.simulation || {};
    const background = appearanceConfig.background || {};
    const stars = background.stars || {};
    const bloom = background.bloom || {};
    // NEW: Render, highlight, flow_mode from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const highlightConfig = appearanceConfig.highlight || {};
    FLOW_CONFIG = appearanceConfig.flow_mode || {};
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || EDGE_MODE_CONFIG.resolution,
        weight: edgeModes.weight || EDGE_MODE_CONFIG.weight,
        confidence: edgeModes.confidence || EDGE_MODE_CONFIG.confidence,
        width: edgeModes.width || EDGE_MODE_CONFIG.width,
        dim: edgeModes.dim || EDGE_MODE_CONFIG.dim,
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : EDGE_MODE_CONFIG.opacity
    };
    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : EDGE_DEFAULT_OPACITY;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = Object.assign({}, EDGE_COLOR_CONFIG, edgeColor);

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    const div = document.getElementById('3d-graph');

    // 
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // 
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale)
            // 
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // 
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;
    
    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.enableRotate = true;
        controls.enablePan = false;

        const baseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.ROTATE
        };

        const applyPanMode = (enabled) => {
            controls.enablePan = enabled;
            controls.mouseButtons = baseButtons;
        };

        applyPanMode(false);

        window.addEventListener('keydown', (e) => {
            if (e.code !== 'Space') return;
            if (SPACE_PRESSED) return;
            SPACE_PRESSED = true;
            applyPanMode(true);
            e.preventDefault();
        });

        window.addEventListener('keyup', (e) => {
            if (e.code !== 'Space') return;
            if (!SPACE_PRESSED) return;
            SPACE_PRESSED = false;
            applyPanMode(false);
        });

        window.addEventListener('blur', () => {
            if (!SPACE_PRESSED) return;
            SPACE_PRESSED = false;
            applyPanMode(false);
        });
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // TOKEN-DRIVEN: Starfield (Cosmic Background)
    // =================================================================
    const scene = Graph.scene();
    const starsGeometry = new THREE.BufferGeometry();
    const starsCount = stars.count || 2000;
    const starsSpread = stars.spread || 5000;
    const posArray = new Float32Array(starsCount * 3);

    for (let i = 0; i < starsCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * starsSpread;
    }

    starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const starsMaterial = new THREE.PointsMaterial({
        size: stars.size || 2,
        color: 0xffffff,
        transparent: true,
        opacity: stars.opacity || 0.8,
    });
    const starMesh = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(starMesh);
    STARFIELD = starMesh;
    STARFIELD_OPACITY = starsMaterial.opacity;

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();
        
        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI elements exist (canonical UI: command bar + floating panels + side dock)

    // Command bar and buttons
    test('command-bar-exists', !!document.getElementById('command-bar'));
    test('cmd-view-exists', !!document.getElementById('cmd-view'));
    test('cmd-filter-exists', !!document.getElementById('cmd-filter'));
    test('cmd-style-exists', !!document.getElementById('cmd-style'));
    test('cmd-settings-exists', !!document.getElementById('cmd-settings'));

    // Floating panels
    test('panel-view-exists', !!document.getElementById('panel-view'));
    test('panel-filter-exists', !!document.getElementById('panel-filter'));
    test('panel-style-exists', !!document.getElementById('panel-style'));
    test('panel-settings-exists', !!document.getElementById('panel-settings'));

    // Side dock
    const sideDock = document.getElementById('side-dock');
    test('side-dock-exists', !!sideDock);
    test('topo-minimap-exists', !!document.getElementById('topo-minimap'));
    test('preset-grid-exists', !!document.getElementById('preset-grid'));
    test('color-scheme-grid-exists', !!document.getElementById('color-scheme-grid'));

    // OKLCH picker
    test('oklch-picker-exists', !!document.getElementById('oklch-picker'));

    // Topo tooltip
    test('topo-tooltip-exists', !!document.getElementById('topo-tooltip'));

    // Bottom dock controls
    const datamapContainer = document.getElementById('datamap-controls');
    test('datamap-controls-exist', !!datamapContainer);
    test('btn-files-exists', !!document.getElementById('btn-files'));
    test('btn-flow-exists', !!document.getElementById('btn-flow'));
    test('btn-edge-mode-exists', !!document.getElementById('btn-edge-mode'));
    test('btn-report-exists', !!document.getElementById('btn-report'));
    test('btn-stars-exists', !!document.getElementById('btn-stars'));
    test('btn-dimensions-exists', !!document.getElementById('btn-dimensions'));

    // Graph state
    test('starfield-initialized', !!STARFIELD);

    // Test 1b: Side dock content visibility
    const sideContent = document.getElementById('side-content');
    if (sideDock && sideContent) {
        const contentVisible = window.getComputedStyle(sideContent).display !== 'none';
        test('side-dock-content-visible', contentVisible);
    }

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE  T0, EXT  T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Metrics panel populated
    test('metric-edge-resolution', document.getElementById('metric-edge-resolution')?.textContent !== '--');
    test('metric-call-ratio', document.getElementById('metric-call-ratio')?.textContent !== '--');
    test('metric-reachability', document.getElementById('metric-reachability')?.textContent !== '--');
    test('metric-dead-code', document.getElementById('metric-dead-code')?.textContent !== '--');
    test('metric-topology', document.getElementById('metric-topology')?.textContent !== '--');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const densitySlider = document.getElementById('density-slider2');
    test('density-slider2-has-value', densitySlider && densitySlider.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// Tier aliases: legacy names  canonical T0/T1/T2
const TIER_ALIASES = {
    'CORE': 'T0', 'T0': 'T0',
    'ARCH': 'T1', 'T1': 'T1',
    'EXT': 'T2', 'T2': 'T2',
    'DISCOVERED': 'T2',  // EXT.DISCOVERED  T2
    'UNKNOWN': 'UNKNOWN'
};

function normalizeTier(tier) {
    if (!tier) return 'UNKNOWN';
    const upper = String(tier).toUpperCase();
    return TIER_ALIASES[upper] || upper;
}

// Prefer canonical node.tier field; fallback to atom prefix inference
function getNodeTier(node) {
    // If node is a string (backward compat: called with atomId), infer from prefix
    if (typeof node === 'string') {
        const atomId = node;
        if (!atomId) return 'UNKNOWN';
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }
    // Prefer canonical field
    if (node.tier) {
        return normalizeTier(node.tier);
    }
    // Fallback: infer from atom prefix
    const atomId = String(node.atom || '');
    if (atomId.startsWith('CORE.')) return 'T0';
    if (atomId.startsWith('ARCH.')) return 'T1';
    if (atomId.startsWith('EXT.')) return 'T2';
    return 'UNKNOWN';
}

// Get atom family from canonical field or infer from atom prefix
function getNodeAtomFamily(node) {
    // Prefer canonical field
    if (node.atom_family) {
        return String(node.atom_family).toUpperCase();
    }
    // Fallback: infer from atom (e.g., "LOG.FNC.M"  "LOG")
    const atomId = String(node.atom || '');
    const dotIdx = atomId.indexOf('.');
    if (dotIdx > 0) {
        return atomId.substring(0, dotIdx).toUpperCase();
    }
    return 'UNKNOWN';
}

function getNodeRing(node) {
    const ring = node.ring || node.layer || 'UNKNOWN';
    return String(ring).toUpperCase();
}

function getNodeColorByMode(node) {
    // 
    // ALL COLORS NOW COME FROM ColorOrchestrator (aliased as Color)
    // This ensures legend colors match visualization colors exactly
    // OKLCH transforms are applied automatically
    // 

    if (NODE_COLOR_MODE === 'file') {
        const fileIdx = node.fileIdx ?? -1;
        if (fileIdx < 0) {
            return Color.get('tier', 'UNKNOWN');  // Use ColorOrchestrator
        }
        // ALL DATA FROM DM
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        const totalFiles = fileBoundaries.length;
        const fileInfo = fileBoundaries[fileIdx] || {};
        const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
        return getFileColor(fileIdx, totalFiles, fileLabel);
    }

    if (NODE_COLOR_MODE === 'family') {
        const atomFamily = getNodeAtomFamily(node);
        return Color.get('family', atomFamily);  // FROM ColorOrchestrator
    }

    if (NODE_COLOR_MODE === 'ring') {
        const ring = getNodeRing(node);
        return Color.get('ring', ring);  // FROM ColorOrchestrator
    }

    if (NODE_COLOR_MODE === 'layer') {
        const layer = (node.layer || 'VIRTUAL').toUpperCase();
        return Color.get('layer', layer);  // FROM ColorOrchestrator
    }

    // Tier color mode (default)
    const tier = getNodeTier(node);
    return Color.get('tier', tier);  // FROM ColorOrchestrator
}

function applyNodeColors(nodes) {
    const fileBoundaries = DM ? DM.getFileBoundaries() : [];  // ALL DATA FROM DM
    nodes.forEach(node => {
        if (node && node.isFileNode) {
            if (!node.color) {
                const totalFiles = fileBoundaries.length;
                const fileInfo = fileBoundaries[node.fileIdx] || {};
                const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                node.color = getFileColor(node.fileIdx, totalFiles, fileLabel);
            }
            return;
        }
        if (fileMode) {
            return;
        }
        node.color = getNodeColorByMode(node);
    });
}

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => n.val >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }

    if (tierFilter.size > 0) {
        visibleNodes = visibleNodes.filter(n => tierFilter.has(getNodeTier(n)));
    }

    if (ringFilter.size > 0) {
        visibleNodes = visibleNodes.filter(n => ringFilter.has(getNodeRing(n)));
    }

    if (roleFilter.size > 0) {
        visibleNodes = visibleNodes.filter(n => roleFilter.has(String(n.role || 'Unknown')));
    }

    // Filter by atom family (LOG, DAT, ORG, EXE, EXT)
    if (familyFilter.size > 0) {
        visibleNodes = visibleNodes.filter(n => familyFilter.has(getNodeAtomFamily(n)));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: Preserve node positions across graph updates
// ====================================================================
function saveNodePositions() {
    if (!Graph) return;
    const nodes = Graph.graphData().nodes || [];
    nodes.forEach(node => {
        if (node.x !== undefined && node.y !== undefined) {
            NODE_POSITION_CACHE.set(node.id, {
                x: node.x, y: node.y, z: node.z || 0,
                vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                fx: node.fx, fy: node.fy, fz: node.fz
            });
        }
    });
}

function restoreNodePositions(nodes) {
    nodes.forEach(node => {
        const cached = NODE_POSITION_CACHE.get(node.id);
        if (cached) {
            node.x = cached.x;
            node.y = cached.y;
            node.z = cached.z;
            node.vx = cached.vx;
            node.vy = cached.vy;
            node.vz = cached.vz;
            // Pin nodes in place when layout is frozen
            if (LAYOUT_FROZEN) {
                node.fx = cached.x;
                node.fy = cached.y;
                node.fz = cached.z;
            }
        }
    });
}

function freezeLayout() {
    LAYOUT_FROZEN = true;
    if (!Graph) return;
    const nodes = Graph.graphData().nodes || [];
    nodes.forEach(node => {
        if (node.x !== undefined) {
            node.fx = node.x;
            node.fy = node.y;
            node.fz = node.z;
        }
    });
    Graph.cooldownTicks(0);  // Stop simulation immediately
}

function unfreezeLayout() {
    LAYOUT_FROZEN = false;
    if (!Graph) return;
    const nodes = Graph.graphData().nodes || [];
    nodes.forEach(node => {
        node.fx = undefined;
        node.fy = undefined;
        node.fz = undefined;
    });
}

function resetLayout() {
    // Clear position cache and reheat simulation
    NODE_POSITION_CACHE.clear();
    unfreezeLayout();
    if (Graph) {
        Graph.cooldownTicks(200);  // Allow simulation to run
        Graph.d3ReheatSimulation();
    }
    showModeToast('Layout reset - physics running');
}

// ====================================================================
// MODE TOASTS: Brief hints when changing modes
// ====================================================================
let _toastTimeout = null;

function showModeToast(message) {
    if (!HINTS_ENABLED) return;

    let toast = document.getElementById('mode-toast');
    if (!toast) {
        toast = document.createElement('div');
        toast.id = 'mode-toast';
        toast.className = 'mode-toast';
        document.body.appendChild(toast);
    }

    toast.textContent = message;
    toast.classList.add('visible');

    if (_toastTimeout) clearTimeout(_toastTimeout);
    _toastTimeout = setTimeout(() => {
        toast.classList.remove('visible');
    }, 1200);
}

function getLinkEndpointId(link, side) {
    const endpoint = link?.[side];
    if (endpoint && typeof endpoint === 'object') {
        return endpoint.id || endpoint;
    }
    return endpoint;
}

function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
    if (totalFiles <= 0) {
        return { x: 0, y: 0, z: 0 };
    }
    const angle = (fileIdx / totalFiles) * Math.PI * 2;
    return {
        x: Math.cos(angle) * radius,
        y: Math.sin(angle) * radius,
        z: IS_3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
    };
}

function stableOffset(node, salt, radius) {
    const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
    const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
    const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
    const dist = radius * spread;
    return {
        x: Math.cos(angle) * dist,
        y: Math.sin(angle) * dist,
        z: zJitter
    };
}

function buildFileGraph(data) {
    // ALL DATA FROM DM (data param kept for backward compatibility)
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const fileNodes = [];
    const fileNodeIds = new Map();
    const nodeFileIdx = new Map();

    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    boundaries.forEach((boundary, idx) => {
        const label = boundary.file_name || boundary.file || `file-${idx}`;
        const atomCount = boundary.atom_count || 1;
        const nodeId = `file:${idx}`;
        fileNodeIds.set(idx, nodeId);
        fileNodes.push({
            id: nodeId,
            name: label,
            fileIdx: idx,
            isFileNode: true,
            val: Math.max(2, Math.sqrt(atomCount)),
            color: getFileColor(idx, totalFiles, label),
            file_path: boundary.file || '',
            atom_count: atomCount
        });
    });

    const edgeMap = new Map();
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx === tgtIdx) return;
        const key = `${srcIdx}->${tgtIdx}`;
        const existing = edgeMap.get(key) || {
            source: fileNodeIds.get(srcIdx),
            target: fileNodeIds.get(tgtIdx),
            weight: 0,
            edge_type: 'file',
            resolution: 'file'
        };
        existing.weight += 1;
        edgeMap.set(key, existing);
    });

    FILE_NODE_IDS = fileNodeIds;
    return {
        nodes: fileNodes,
        links: Array.from(edgeMap.values())
    };
}

function captureFileNodePositions() {
    FILE_NODE_POSITIONS = new Map();
    const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
    nodes.forEach(node => {
        if (node && node.isFileNode && Number.isFinite(node.x) && Number.isFinite(node.y)) {
            FILE_NODE_POSITIONS.set(node.fileIdx, {
                x: node.x,
                y: node.y,
                z: Number.isFinite(node.z) ? node.z : 0
            });
        }
    });
}

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize Smart Text Placement
    HudLayoutManager.init();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Render color-coded legends with counts
    renderAllLegends();
}

/**
 * =================================================================
 * UIManager: Orchestrates the "One Dock" unified interface
 * =================================================================
 */
const UIManager = {
    data: null,

    init(data) {
        this.data = data;
        this.setupSidebar();
        this.setupDock();
        this.setupModes();
        this.populateFilters();
        this.updateStatus();
    },

    setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        // Toggle Sidebar
        const toggle = () => {
            sidebar.classList.toggle('open');
            this.updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                // Optional: Close others for "exclusive" behavior
                // document.querySelectorAll('.accordion').forEach(a => {
                //    if(a !== accordion) a.classList.remove('open');
                // });
                accordion.classList.toggle('open');
            };
        });
    },

    setupDock() {
        // Note: Density slider now in floating panel (density-slider2), set up in setupFloatingPanels()

        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            Graph.zoomToFit(1000);
        };

        // Stars Toggle
        const btnStars = document.getElementById('btn-stars');
        if (btnStars) btnStars.onclick = () => {
            if (typeof toggleStarfield === 'function') {
                toggleStarfield();
                btnStars.classList.toggle('active');
            }
        };

        // Dimensions Toggle (2D/3D - stub for now)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
            // Future: Switch visualization engine
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    },

    setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            // Update buttons
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            // Show specific controls
            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';

            // Set global mode flags if needed
            if (mode === 'files') {
                // Enable file hulls or specific rendering
            }
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (active) => {
            // Toggle hull visibility
            // if(active) showHulls(); else hideHulls();
        });
    },

    populateFilters() {
        const data = this.data;
        if (!data) return;

        // --- Helper: Create Filter Chips ---
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = ''; // Clear previous

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class=\"chip-count\">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    this.updateFilterBadge();
                    // DEBOUNCE REFRESH if needed, otherwise immediate
                    refreshGraph();
                };
                container.appendChild(chip);
            });

            // Update the accordion header count
            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(data.nodes, n => getNodeRing(n));
        const ringDefaults = data.controls?.filters?.rings || [];
        // Ensure defaults are populated if set is empty
        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            ringDefaults.forEach(r => VIS_FILTERS.rings.add(r));
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(data.nodes, n => getNodeTier(n));
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        this.populateDatamaps();

        // Initial Badge Update
        this.updateFilterBadge();
    },

    populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = this.data.controls || {};
        const configs = resolveDatamapConfigs(controls); // Assuming this helper exists globally

        // Add "Global" toggles (e.g. ALL / NONE) if needed
        // For now, just the list

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%'; // Full width for datamaps
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                // Exclusive toggle? Or additive? 
                // Using additive for consistency, or setDatamap implementation
                setDatamap(cfg.id); // This function usually clears others

                // Update UI state manually since visualization state changed
                // (In a reactive framework this would be automatic)
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        if (document.getElementById('count-datamaps')) {
            document.getElementById('count-datamaps').innerText = configs.length;
        }
    },

    updateFilterBadge() {
        // Count active chips in visual filters
        let total = 0;
        // Just summing strict filter sets size might be misleading if "all selected" means 0 filtering
        // But for UI feedback:
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    },

    updateStatus() {
        if (this.data && this.data.nodes) {
            const n = this.data.nodes.length;
            const e = this.data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }
};

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }
    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// 
// 3D TOPOLOGICAL MINIMAP - Interactive filter visualization
// THE STANDARD MODEL TOPOLOGY: 16 Levels  3 Layers  Families
// 

// THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
const SCALE_16_LEVELS = {
    // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
    'L12': { name: 'UNIVERSE', symbol: '', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
    'L11': { name: 'DOMAIN', symbol: '', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
    'L10': { name: 'ORGANIZATION', symbol: '', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
    'L9': { name: 'PLATFORM', symbol: '', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
    'L8': { name: 'ECOSYSTEM', symbol: '', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
    // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
    'L7': { name: 'SYSTEM', symbol: '', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
    'L6': { name: 'PACKAGE', symbol: '', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
    'L5': { name: 'FILE', symbol: '', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
    'L4': { name: 'CONTAINER', symbol: '', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
    // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
    'L3': { name: 'NODE', symbol: '', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
    'L2': { name: 'BLOCK', symbol: '', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
    'L1': { name: 'STATEMENT', symbol: '', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
    // SYNTACTIC (L0) - The event horizon between meaning and data
    'L0': { name: 'TOKEN', symbol: '', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
    // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
    'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
    'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
    'L-3': { name: 'BIT/QUBIT', symbol: '', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
};

// THE THREE PARALLEL LAYERS (shells around the structure) - Depth/Elevation palette
const THREE_LAYERS = {
    'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
    'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
    'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
};

// 
// STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
// The codespace is a high-dimensional space where all software artifacts exist
// 

const SMC_THEORY = {
    // THE THREE FUNDAMENTAL LAYERS
    layers: {
        'PHYSICAL': {
            icon: '',
            title: 'Physical Layer',
            subtitle: 'The Substrate',
            body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
            theory: '"Matter is the canvas upon which computation paints its patterns."',
            examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
        },
        'VIRTUAL': {
            icon: '',
            title: 'Virtual Layer',
            subtitle: 'The Structure',
            body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
            theory: '"Between the physical and the meaningful lies the virtual  pure form without matter or purpose."',
            examples: ['variables', 'functions', 'classes', 'data structures']
        },
        'SEMANTIC': {
            icon: '',
            title: 'Semantic Layer',
            subtitle: 'The Meaning',
            body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
            theory: '"Semantics is where computation meets human intention  the bridge between bits and understanding."',
            examples: ['user stories', 'business rules', 'API contracts', 'domain models']
        }
    },

    // ATOM FAMILIES
    families: {
        'LOG': {
            icon: '',
            title: 'Logic Family',
            subtitle: 'The Reasoners',
            body: 'Elements that transform data through computation: conditionals, loops, calculations.',
            theory: '"Logic atoms are the decision-makers  they take inputs and produce outputs through transformation."',
            examples: ['if/else', 'for loops', 'calculations', 'validators']
        },
        'DAT': {
            icon: '',
            title: 'Data Family',
            subtitle: 'The Containers',
            body: 'Elements that hold and organize information: variables, structures, databases.',
            theory: '"Data atoms store state  they are the nouns in the grammar of code."',
            examples: ['variables', 'arrays', 'objects', 'databases']
        },
        'ORG': {
            icon: '',
            title: 'Organization Family',
            subtitle: 'The Architects',
            body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
            theory: '"Organization atoms create order from chaos  the folders in the file system of abstraction."',
            examples: ['modules', 'classes', 'packages', 'namespaces']
        },
        'EXE': {
            icon: '',
            title: 'Execution Family',
            subtitle: 'The Doers',
            body: 'Elements that perform actions: function calls, I/O, system operations.',
            theory: '"Execution atoms are the verbs  where potential becomes actual."',
            examples: ['function calls', 'API requests', 'file writes', 'renders']
        },
        'EXT': {
            icon: '',
            title: 'External Family',
            subtitle: 'The Connectors',
            body: 'Elements that interface with the outside: APIs, imports, system calls.',
            theory: '"External atoms are portals  they connect isolated systems into larger ecosystems."',
            examples: ['imports', 'API calls', 'env vars', 'dependencies']
        }
    },

    // TIERS
    tiers: {
        'T0': {
            icon: '',
            title: 'Tier 0  Foundation',
            subtitle: 'Low-level primitives',
            body: 'The atomic building blocks: individual statements, expressions, basic operations.',
            theory: '"T0 is where code meets silicon  the ground floor of abstraction."',
            examples: ['assignments', 'operators', 'literals', 'basic types']
        },
        'T1': {
            icon: '',
            title: 'Tier 1  Components',
            subtitle: 'Functional units',
            body: 'Grouped functionality: functions, methods, small modules.',
            theory: '"T1 is the sweet spot  complex enough to be useful, simple enough to understand."',
            examples: ['functions', 'methods', 'handlers', 'utilities']
        },
        'T2': {
            icon: '',
            title: 'Tier 2  Architecture',
            subtitle: 'System structure',
            body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
            theory: '"T2 defines the shape of software  patterns emerge that echo through every line."',
            examples: ['classes', 'modules', 'services', 'controllers']
        }
    },

    // SPECIAL ELEMENTS
    special: {
        'core': {
            icon: '',
            title: 'The Nexus',
            subtitle: 'Singularity Point',
            body: 'The center of the topology: where all paths converge.',
            theory: '"Every codebase has a heart  the central modules that everything depends upon."',
            examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
        },
        'elevator': {
            icon: '',
            title: 'Data Elevator',
            subtitle: 'Cross-tier Highway',
            body: 'Vertical connections that move data between abstraction levels.',
            theory: '"Elevators are the call stacks of architecture."',
            examples: ['API layers', 'ORMs', 'serializers', 'adapters']
        },
        'hub-star': {
            icon: '',
            title: 'Hub Node',
            subtitle: 'High-connectivity Center',
            body: 'A node with many incoming connections. Often a critical dependency.',
            theory: '"Hubs are the load-bearing walls  remove them and everything collapses."',
            examples: ['utils', 'config', 'logger', 'database']
        }
    }
};

// Tooltip state
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

function initTooltips() {
    TOOLTIP_STATE.element = document.getElementById('topo-tooltip');
}

function showTopoTooltip(category, key, x, y) {
    if (!TOOLTIP_STATE.element) initTooltips();
    if (!TOOLTIP_STATE.element) return;
    const content = SMC_THEORY[category]?.[key];
    if (!content) return;
    clearTimeout(TOOLTIP_STATE.hideTimeout);
    document.getElementById('tooltip-icon').textContent = content.icon || '';
    document.getElementById('tooltip-title').textContent = content.title || key;
    document.getElementById('tooltip-subtitle').textContent = content.subtitle || '';
    document.getElementById('tooltip-body').textContent = content.body || '';
    document.getElementById('tooltip-theory').textContent = content.theory || '';
    const examplesEl = document.getElementById('tooltip-examples');
    examplesEl.innerHTML = (content.examples || []).map(ex => `<span class="topo-tooltip-example">${ex}</span>`).join('');
    const tooltip = TOOLTIP_STATE.element;
    let left = x + 15, top = y + 15;
    if (left + 280 > window.innerWidth) left = x - 295;
    if (top + 200 > window.innerHeight) top = y - 215;
    if (left < 0) left = 15;
    if (top < 0) top = 15;
    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
    tooltip.classList.add('visible');
    TOOLTIP_STATE.visible = true;
    TOOLTIP_STATE.currentKey = `${category}:${key}`;
}

function hideTopoTooltip(immediate = false) {
    if (!TOOLTIP_STATE.element) return;
    if (immediate) {
        TOOLTIP_STATE.element.classList.remove('visible');
        TOOLTIP_STATE.visible = false;
    } else {
        TOOLTIP_STATE.hideTimeout = setTimeout(() => {
            TOOLTIP_STATE.element.classList.remove('visible');
            TOOLTIP_STATE.visible = false;
        }, 150);
    }
}

// ZONES define which levels belong to which visual band
const LEVEL_ZONES = {
    'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
    'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
    'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
    'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
    'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
};

const TOPO_COLORS = {
    // Tiers: Map to operational zones (T0=Semantic, T1=Architectural, T2=External)
    tiers: {
        'T0': { h: 200, s: 80, l: 55 },  // Cyan-blue (core/semantic)
        'T1': { h: 280, s: 70, l: 50 },  // Purple (architecture)
        'T2': { h: 35, s: 85, l: 50 },   // Orange (external/ecosystem)
        'UNKNOWN': { h: 0, s: 0, l: 40 } // Gray
    },
    // Atom families: Semantic domains - each has a distinct angular position
    families: {
        'LOG': { h: 180, s: 70, l: 45, angle: 0 },      // Teal (logic/control) - 0
        'DAT': { h: 45, s: 80, l: 50, angle: 72 },      // Gold (data) - 72
        'ORG': { h: 270, s: 60, l: 50, angle: 144 },    // Violet (organization) - 144
        'EXE': { h: 120, s: 60, l: 45, angle: 216 },    // Green (execution) - 216
        'EXT': { h: 15, s: 75, l: 50, angle: 288 },     // Orange-red (external) - 288
        'UNKNOWN': { h: 0, s: 0, l: 35, angle: 0 }      // Gray
    },
    // Rings: Concentric semantic layers
    rings: {
        'KERNEL': { h: 200, s: 90, l: 60 },
        'CORE': { h: 220, s: 75, l: 55 },
        'SERVICE': { h: 260, s: 65, l: 50 },
        'ADAPTER': { h: 300, s: 60, l: 50 },
        'INTERFACE': { h: 340, s: 55, l: 50 },
        'EXTERNAL': { h: 20, s: 70, l: 50 },
        'UNKNOWN': { h: 0, s: 0, l: 40 }
    }
};

// 
// VISUALIZATION PRESETS - Different ways to see the topology
// 
const VIS_PRESETS = {
    'tier': {
        name: 'By Tier (T0/T1/T2)',
        description: 'Core  Architecture  External',
        colorBy: 'tier',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },
    'family': {
        name: 'By Atom Family',
        description: 'LOG, DAT, ORG, EXE, EXT',
        colorBy: 'family',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },
    'layer': {
        name: 'By Layer',
        description: 'Physical  Virtual  Semantic',
        colorBy: 'layer',
        sizeBy: 'uniform',
        edgeBy: 'resolution'
    },
    'ring': {
        name: 'By Ring (Domain)',
        description: 'Domain architecture layers',
        colorBy: 'ring',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },
    'file': {
        name: 'By File',
        description: 'Each file gets unique hue',
        colorBy: 'file',
        sizeBy: 'uniform',
        edgeBy: 'resolution'
    },
    'flow': {
        name: 'Markov Flow',
        description: 'Edge width = transition probability',
        colorBy: 'tier',
        sizeBy: 'entropy',
        edgeBy: 'weight'
    },
    'depth': {
        name: 'By Depth (Call Distance)',
        description: 'Distance from entry points',
        colorBy: 'depth',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },

    // 
    // OKLCH COLOR SCHEMES - BOLD & DRAMATIC
    // Each scheme creates a distinct, unmistakable visual transformation
    // 

    'thermal': {
        name: 'THERMAL',
        description: 'Heat signature - activity glows hot',
        colorBy: 'family',
        sizeBy: 'entropy',
        edgeBy: 'weight',
        isColorScheme: true,
        oklch: {
            L: { base: 0.70, range: 0.3 },
            C: { base: 0.25, boost: 2.2 },    // HIGH saturation
            H: { shift: -60, compress: 0.6 }, // STRONG red shift
            edgeL: 0.55, edgeC: 0.20, bgL: 0.02
        },
        amplifier: 4.0,
        lightness: 8
    },

    'spectrum': {
        name: 'SPECTRUM',
        description: 'Full rainbow - structure as color',
        colorBy: 'file',
        sizeBy: 'fanout',
        edgeBy: 'gradient-file',
        isColorScheme: true,
        oklch: {
            L: { base: 0.75, range: 0.15 },
            C: { base: 0.30, boost: 2.5 },    // MAXIMUM chroma
            H: { shift: 0, compress: 1.0 },
            edgeL: 0.65, edgeC: 0.25, bgL: 0.01
        },
        amplifier: 3.0,
        lightness: 12
    },

    'neon': {
        name: 'NEON',
        description: 'Cyberpunk - electric on void',
        colorBy: 'family',
        sizeBy: 'fanout',
        edgeBy: 'gradient-tier',
        isColorScheme: true,
        oklch: {
            L: { base: 0.82, range: 0.2 },    // VERY bright
            C: { base: 0.35, boost: 2.8 },    // EXTREME chroma
            H: { shift: 180, compress: 0.8 }, // Cyan/magenta
            edgeL: 0.75, edgeC: 0.30, bgL: 0.0
        },
        amplifier: 5.0,
        lightness: 18
    },

    'ocean': {
        name: 'OCEAN',
        description: 'Deep sea - cool depths',
        colorBy: 'ring',
        sizeBy: 'uniform',
        edgeBy: 'gradient-file',
        isColorScheme: true,
        oklch: {
            L: { base: 0.55, range: 0.25 },
            C: { base: 0.22, boost: 1.8 },
            H: { shift: 200, compress: 0.4 }, // STRONG blue shift
            edgeL: 0.50, edgeC: 0.18, bgL: 0.02
        },
        amplifier: 2.5,
        lightness: -5
    },

    'plasma': {
        name: 'PLASMA',
        description: 'Energy field - purple/pink plasma',
        colorBy: 'tier',
        sizeBy: 'entropy',
        edgeBy: 'gradient-flow',
        isColorScheme: true,
        oklch: {
            L: { base: 0.72, range: 0.22 },
            C: { base: 0.28, boost: 2.4 },    // HIGH saturation
            H: { shift: 280, compress: 0.5 }, // STRONG purple shift
            edgeL: 0.62, edgeC: 0.24, bgL: 0.01
        },
        amplifier: 4.5,
        lightness: 10
    },

    'matrix': {
        name: 'MATRIX',
        description: 'Hacker - phosphor green glow',
        colorBy: 'tier',
        sizeBy: 'fanout',
        edgeBy: 'type',
        isColorScheme: true,
        oklch: {
            L: { base: 0.68, range: 0.3 },
            C: { base: 0.26, boost: 2.2 },
            H: { shift: 130, compress: 0.3 }, // STRONG green shift
            edgeL: 0.55, edgeC: 0.22, bgL: 0.0
        },
        amplifier: 4.0,
        lightness: 5
    },

    'infrared': {
        name: 'INFRARED',
        description: 'Night vision - heat on black',
        colorBy: 'file',
        sizeBy: 'entropy',
        edgeBy: 'weight',
        isColorScheme: true,
        oklch: {
            L: { base: 0.60, range: 0.35 },
            C: { base: 0.24, boost: 2.0 },
            H: { shift: -90, compress: 0.4 }, // Red/orange/yellow
            edgeL: 0.50, edgeC: 0.20, bgL: 0.0
        },
        amplifier: 5.0,
        lightness: -2
    },

    'aurora': {
        name: 'AURORA',
        description: 'Northern lights - ethereal shimmer',
        colorBy: 'ring',
        sizeBy: 'fanout',
        edgeBy: 'gradient-tier',
        isColorScheme: true,
        oklch: {
            L: { base: 0.75, range: 0.18 },
            C: { base: 0.28, boost: 2.3 },
            H: { shift: 150, compress: 0.7 }, // Green  cyan  purple
            edgeL: 0.65, edgeC: 0.24, bgL: 0.01
        },
        amplifier: 3.5,
        lightness: 12
    }
};

// 
// LAYOUT PRESETS - Geometric arrangements of nodes in 3D space
// 

let CURRENT_LAYOUT = 'force';
let LAYOUT_ANIMATION_ID = null;
let LAYOUT_TIME = 0;

const LAYOUT_PRESETS = {
    'force': { name: 'FORCE', icon: '', description: 'Physics-based clustering', motion: 'settle', cooldown: 200, getPosition: null },
    'orbital': {
        name: 'ORBITAL', icon: '', description: 'Planetary orbit bands', motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
        getPosition: (node, idx, total, time) => {
            const tier = getNodeTier(node), family = getNodeAtomFamily(node);
            const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
            const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
            const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
            const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
            return { x: Math.cos(angle) * (r + wobble), y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0), z: Math.sin(angle) * (r + wobble) };
        }
    },
    'radial': {
        name: 'RADIAL', icon: '', description: 'Concentric tier rings', motion: 'static', cooldown: 0,
        getPosition: (node, idx, total, time, tierGroups) => {
            const tier = getNodeTier(node), r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
            const tierNodes = tierGroups?.[tier] || [], tierIdx = tierNodes.indexOf(node), tierTotal = tierNodes.length || 1;
            const angle = (tierIdx / tierTotal) * Math.PI * 2;
            return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
        }
    },
    'spiral': {
        name: 'SPIRAL', icon: '', description: 'DNA-like helix', motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
        getPosition: (node, idx, total, time) => {
            const t = idx / Math.max(1, total), angle = t * Math.PI * 2 * 4 + (time || 0), r = 100 + t * 150;
            return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
        }
    },
    'sphere': {
        name: 'SPHERE', icon: '', description: 'Globe surface', motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
        getPosition: (node, idx, total, time) => {
            const tier = getNodeTier(node), family = getNodeAtomFamily(node);
            const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
            const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
            const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
            const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0), r = 200;
            return { x: Math.sin(lat) * Math.cos(lon) * r, y: Math.cos(lat) * r, z: Math.sin(lat) * Math.sin(lon) * r };
        }
    },
    'torus': {
        name: 'TORUS', icon: '', description: 'Donut surface', motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.002,
        getPosition: (node, idx, total, time) => {
            const tier = getNodeTier(node), family = getNodeAtomFamily(node), majorR = 180, minorR = 70;
            const famAngle = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 0 }[family] || 0;
            const u = (famAngle * Math.PI / 180) + (idx * 0.05) + (time || 0);
            const tierV = { T0: 0.25, T1: 0.5, T2: 0.75, UNKNOWN: 0.5 }[tier] || 0.5;
            const v = tierV * Math.PI * 2 + Math.sin(idx * 0.2) * 0.3;
            return { x: (majorR + minorR * Math.cos(v)) * Math.cos(u), y: minorR * Math.sin(v), z: (majorR + minorR * Math.cos(v)) * Math.sin(u) };
        }
    },
    'grid': {
        name: 'GRID', icon: '', description: '3D lattice', motion: 'static', cooldown: 0,
        getPosition: (node, idx, total) => {
            const tier = getNodeTier(node), family = getNodeAtomFamily(node);
            const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
            const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
            const row = Math.floor(idx / 15), col = idx % 15;
            return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
        }
    },
    'cylinder': {
        name: 'CYLINDER', icon: '', description: 'Vertical tube', motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.0015,
        getPosition: (node, idx, total, time) => {
            const tier = getNodeTier(node), family = getNodeAtomFamily(node);
            const famAngle = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 0 }[family] || 0;
            const angle = (famAngle * Math.PI / 180) + (idx * 0.1) + (time || 0);
            const tierY = { T0: -120, T1: 0, T2: 120, UNKNOWN: 0 }[tier] || 0;
            return { x: Math.cos(angle) * 150, y: tierY + Math.sin(idx * 0.3) * 30, z: Math.sin(angle) * 150 };
        }
    },
    'tree': {
        name: 'TREE', icon: '', description: 'Hierarchical tree', motion: 'static', cooldown: 0,
        getPosition: (node, idx, total, time, tierGroups) => {
            const tier = getNodeTier(node), tierY = { T0: 150, T1: 0, T2: -150, UNKNOWN: 0 }[tier] || 0;
            const tierNodes = tierGroups?.[tier] || [], tierIdx = tierNodes.indexOf(node), tierTotal = tierNodes.length || 1;
            const spread = 300 * (1 + (tier === 'T2' ? 0.5 : tier === 'T1' ? 0.2 : 0));
            return { x: ((tierIdx / tierTotal) - 0.5) * spread, y: tierY, z: Math.sin(tierIdx * 0.7) * 50 };
        }
    },
    'flock': {
        name: 'FLOCK', icon: '', description: 'Swarming birds', motion: 'flock', cooldown: Infinity,
        flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 }, getPosition: null
    },
    'galaxy': {
        name: 'GALAXY', icon: '', description: 'Spiral arms', motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
        getPosition: (node, idx, total, time) => {
            const family = getNodeAtomFamily(node), tier = getNodeTier(node);
            const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
            const baseAngle = (armOff / 5) * Math.PI * 2, dist = 50 + (idx / total) * 250;
            const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
            const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
            return { x: Math.cos(spiralAngle) * dist, y: tierY + Math.sin(idx * 0.5) * 20, z: Math.sin(spiralAngle) * dist };
        }
    }
};

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => { const tier = getNodeTier(n); (groups[tier] || groups.UNKNOWN).push(n); });
    return groups;
}

function applyLayoutPreset(presetKey, animate = true) {
    const preset = LAYOUT_PRESETS[presetKey]; if (!preset) return;
    CURRENT_LAYOUT = presetKey;
    const nodes = Graph?.graphData()?.nodes || [], total = nodes.length, tierGroups = groupNodesByTier(nodes);
    if (LAYOUT_ANIMATION_ID) { cancelAnimationFrame(LAYOUT_ANIMATION_ID); LAYOUT_ANIMATION_ID = null; }
    if (presetKey === 'force') {
        nodes.forEach(n => { n.fx = undefined; n.fy = undefined; n.fz = undefined; });
        Graph.cooldownTicks(preset.cooldown); Graph.d3ReheatSimulation();
        showModeToast(' FORCE layout'); return;
    }
    if (preset.getPosition) {
        const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
        const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));
        if (animate) {
            const duration = 1500, startTime = Date.now();
            function animateTransition() {
                const progress = Math.min(1, (Date.now() - startTime) / duration);
                const eased = progress * progress * (3 - 2 * progress);
                nodes.forEach((n, i) => {
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                });
                Graph.refresh();
                if (progress < 1) requestAnimationFrame(animateTransition);
                else if (preset.motion === 'rotate' || preset.motion === 'orbit') startLayoutMotion(presetKey);
            }
            animateTransition();
        } else {
            nodes.forEach((n, i) => { const p = targetPos[i]; n.fx = p.x; n.fy = p.y; n.fz = p.z; });
            Graph.refresh();
            if (preset.motion === 'rotate' || preset.motion === 'orbit') startLayoutMotion(presetKey);
        }
    }
    if (preset.motion === 'flock') startFlockSimulation(preset.flockParams);
    Graph.cooldownTicks(preset.cooldown); showModeToast(`${preset.icon} ${preset.name} layout`);
}

function startLayoutMotion(presetKey) {
    const preset = LAYOUT_PRESETS[presetKey]; if (!preset || !preset.getPosition) return;
    const nodes = Graph?.graphData()?.nodes || [], total = nodes.length;
    const tierGroups = groupNodesByTier(nodes), speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;
    function animate() {
        LAYOUT_TIME += speed;
        nodes.forEach((n, i) => { const pos = preset.getPosition(n, i, total, LAYOUT_TIME, tierGroups); n.fx = pos.x; n.fy = pos.y; n.fz = pos.z; });
        Graph.refresh(); LAYOUT_ANIMATION_ID = requestAnimationFrame(animate);
    }
    LAYOUT_ANIMATION_ID = requestAnimationFrame(animate);
}

function startFlockSimulation(params) {
    const nodes = Graph?.graphData()?.nodes || [];
    const { separation, alignment, cohesion, maxSpeed } = params;
    nodes.forEach(n => { n._vx = (Math.random() - 0.5) * 2; n._vy = (Math.random() - 0.5) * 2; n._vz = (Math.random() - 0.5) * 2; });
    function flockStep() {
        nodes.forEach(n => {
            let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0, alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
            let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0; const myFamily = getNodeAtomFamily(n);
            nodes.forEach(other => {
                if (other === n) return;
                const dx = (other.x || 0) - (n.x || 0), dy = (other.y || 0) - (n.y || 0), dz = (other.z || 0) - (n.z || 0);
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;
                if (dist < separation * 2) { sepX -= dx / dist; sepY -= dy / dist; sepZ -= dz / dist; sepCount++; }
                if (getNodeAtomFamily(other) === myFamily && dist < 150) {
                    alignX += other._vx || 0; alignY += other._vy || 0; alignZ += other._vz || 0; alignCount++;
                    cohX += other.x || 0; cohY += other.y || 0; cohZ += other.z || 0; cohCount++;
                }
            });
            if (sepCount > 0) { n._vx += (sepX / sepCount) * separation * 0.05; n._vy += (sepY / sepCount) * separation * 0.05; n._vz += (sepZ / sepCount) * separation * 0.05; }
            if (alignCount > 0) { n._vx += ((alignX / alignCount) - n._vx) * alignment; n._vy += ((alignY / alignCount) - n._vy) * alignment; n._vz += ((alignZ / alignCount) - n._vz) * alignment; }
            if (cohCount > 0) { n._vx += (cohX / cohCount - (n.x || 0)) * cohesion; n._vy += (cohY / cohCount - (n.y || 0)) * cohesion; n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion; }
            n._vx -= (n.x || 0) * 0.0005; n._vy -= (n.y || 0) * 0.0005; n._vz -= (n.z || 0) * 0.0005;
            const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
            if (speed > maxSpeed) { n._vx = (n._vx / speed) * maxSpeed; n._vy = (n._vy / speed) * maxSpeed; n._vz = (n._vz / speed) * maxSpeed; }
            n.fx = (n.x || 0) + n._vx; n.fy = (n.y || 0) + n._vy; n.fz = (n.z || 0) + n._vz;
        });
        Graph.refresh(); LAYOUT_ANIMATION_ID = requestAnimationFrame(flockStep);
    }
    LAYOUT_ANIMATION_ID = requestAnimationFrame(flockStep);
}

const TOPO_MINIMAP = {
    scene: null,
    camera: null,
    renderer: null,
    meshes: [],
    tierRings: {},
    familySegments: {},
    animationId: null,
    container: null,
    canvas: null,
    data: null,
    rotation: 0,
    hoveredMesh: null
};

function hslToHex(h, s, l) {
    s /= 100;
    l /= 100;
    const a = s * Math.min(l, 1 - l);
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return parseInt(f(0) + f(8) + f(4), 16);
}

function initTopoMinimap(data) {
    const container = document.getElementById('topo-minimap');
    const canvas = document.getElementById('topo-canvas');
    if (!container || !canvas) return;

    TOPO_MINIMAP.container = container;
    TOPO_MINIMAP.canvas = canvas;
    TOPO_MINIMAP.data = data;

    // Create Three.js scene
    const width = container.clientWidth || 200;
    const height = container.clientHeight || 180;

    TOPO_MINIMAP.scene = new THREE.Scene();
    TOPO_MINIMAP.camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 100);
    TOPO_MINIMAP.camera.position.set(0, 3.5, 4);
    TOPO_MINIMAP.camera.lookAt(0, 0, 0);

    TOPO_MINIMAP.renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true
    });
    TOPO_MINIMAP.renderer.setSize(width, height);
    TOPO_MINIMAP.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    TOPO_MINIMAP.renderer.setClearColor(0x000000, 0);

    // Add subtle ambient light
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    TOPO_MINIMAP.scene.add(ambient);

    // Add directional light for depth
    const directional = new THREE.DirectionalLight(0xffffff, 0.6);
    directional.position.set(2, 4, 3);
    TOPO_MINIMAP.scene.add(directional);

    // Build the topology visualization
    buildTopoGeometry(data);

    // Build the interactive legends
    buildTopoLegends(data);

    // Start animation
    animateTopoMinimap();

    // Add mouse interaction
    canvas.addEventListener('mousemove', onTopoMouseMove);
    canvas.addEventListener('click', onTopoClick);
    canvas.addEventListener('mouseout', onTopoMouseOut);
}

function buildTopoGeometry(data) {
    if (!data || !data.nodes) return;

    // 
    // ANALYTICAL GEOMETRY - Calculus-based smooth parametric surface
    // Using partial derivatives for exact normals, Hermite interpolation
    // for seamless color gradients, and integral-based curvature
    // 

    const tiers = ['T0', 'T1', 'T2'];
    const families = ['LOG', 'DAT', 'ORG', 'EXE', 'EXT'];

    // Layer definitions with smooth transition zones
    const LAYERS = [
        { name: 'PHYSICAL', color: { h: 220, s: 75, l: 35 } },
        { name: 'VIRTUAL', color: { h: 175, s: 65, l: 45 } },
        { name: 'SEMANTIC', color: { h: 210, s: 30, l: 88 } }
    ];

    // Count nodes by tier and family
    const tierFamilyCounts = new Map();
    tiers.forEach(t => {
        tierFamilyCounts.set(t, new Map());
        families.forEach(f => tierFamilyCounts.get(t).set(f, 0));
    });

    data.nodes.forEach(node => {
        const tier = getNodeTier(node);
        const family = getNodeAtomFamily(node);
        if (tierFamilyCounts.has(tier)) {
            const familyMap = tierFamilyCounts.get(tier);
            if (familyMap.has(family)) {
                familyMap.set(family, familyMap.get(family) + 1);
            }
        }
    });

    let maxCount = 1;
    tierFamilyCounts.forEach(fm => fm.forEach(c => { if (c > maxCount) maxCount = c; }));

    TOPO_MINIMAP.meshes = [];

    // 
    // PARAMETRIC SURFACE S(u,v) - Hyperboloid of revolution
    // S(u,v) = (r(v)cos(u), h(v), r(v)sin(u))
    // where u  [0, 2], v  [0, 1]
    // 

    // Profile function r(v) - Hyperboloid with smooth organic variation
    // r(v) = acosh(k(v - 0.5)) + density_modulation
    const a = 0.42;   // Minimum radius at waist
    const k = 1.8;    // Curvature parameter

    // Height function h(v) - Maps v to vertical position
    // h(v) = H(v - 0.5) where H = total height
    const H = 3.0;

    // Density field D(u,v) - Smooth 2D scalar field from node counts
    // Uses bicubic interpolation for C continuity
    function getDensity(u, v) {
        const famIdx = (u / (Math.PI * 2)) * families.length;
        const tierIdx = v * 3;

        // Bicubic kernel for smooth interpolation
        function cubic(t) {
            const at = Math.abs(t);
            if (at < 1) return (1.5 * at - 2.5) * at * at + 1;
            if (at < 2) return ((-0.5 * at + 2.5) * at - 4) * at + 2;
            return 0;
        }

        let sum = 0, weight = 0;
        for (let ti = 0; ti < 3; ti++) {
            for (let fi = 0; fi < families.length; fi++) {
                const count = tierFamilyCounts.get(tiers[ti])?.get(families[fi]) || 0;
                const wv = cubic(tierIdx - ti - 0.5);
                const wu = cubic(famIdx - fi - 0.5);
                const w = wv * wu;
                sum += count * w;
                weight += w;
            }
        }
        return weight > 0 ? sum / weight / maxCount : 0;
    }

    // Parametric surface with analytical derivatives
    function surface(u, v) {
        const density = getDensity(u, v);
        const densityMod = 1 + density * 0.18;

        // r(v) = acosh(k(v - 0.5)) with density modulation
        const vCentered = v - 0.5;
        const coshVal = Math.cosh(k * vCentered);
        const r = (a * coshVal + 0.35) * densityMod;

        // h(v) = H(v - 0.5)
        const h = H * vCentered;

        // S(u,v) = (rcos(u), h, rsin(u))
        return {
            x: r * Math.cos(u),
            y: h,
            z: r * Math.sin(u)
        };
    }

    // Partial derivatives for exact normals (S/u  S/v)
    function surfaceNormal(u, v) {
        const eps = 0.001;

        // Central differences for partial derivatives
        const Su0 = surface(u - eps, v);
        const Su1 = surface(u + eps, v);
        const Sv0 = surface(u, v - eps);
        const Sv1 = surface(u, v + eps);

        // S/u
        const dSdu = {
            x: (Su1.x - Su0.x) / (2 * eps),
            y: (Su1.y - Su0.y) / (2 * eps),
            z: (Su1.z - Su0.z) / (2 * eps)
        };

        // S/v
        const dSdv = {
            x: (Sv1.x - Sv0.x) / (2 * eps),
            y: (Sv1.y - Sv0.y) / (2 * eps),
            z: (Sv1.z - Sv0.z) / (2 * eps)
        };

        // Cross product: S/u  S/v
        const nx = dSdu.y * dSdv.z - dSdu.z * dSdv.y;
        const ny = dSdu.z * dSdv.x - dSdu.x * dSdv.z;
        const nz = dSdu.x * dSdv.y - dSdu.y * dSdv.x;

        // Normalize
        const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
        return { x: nx / len, y: ny / len, z: nz / len };
    }

    // Hermite basis functions for C continuous color interpolation
    function hermite(t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return {
            h00: 2 * t3 - 3 * t2 + 1,      // Position at p0
            h10: t3 - 2 * t2 + t,        // Tangent at p0
            h01: -2 * t3 + 3 * t2,         // Position at p1
            h11: t3 - t2               // Tangent at p1
        };
    }

    // HSL to RGB (analytical)
    function hslToRgb(h, s, l) {
        s /= 100; l /= 100;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;
        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        return [r + m, g + m, b + m];
    }

    // 
    // BUILD CONTINUOUS MESH with vertex colors
    // 

    const uSegments = 96;   // Radial resolution (seamless wrap)
    const vSegments = 64;   // Vertical resolution

    const positions = [];
    const normals = [];
    const colors = [];
    const indices = [];

    for (let vi = 0; vi <= vSegments; vi++) {
        const v = vi / vSegments;

        // Tier blending (smooth transitions at 0.33 and 0.66)
        let tierIdx, tierBlend;
        if (v < 0.33) {
            tierIdx = 0;
            tierBlend = hermite(v / 0.33).h01;  // Fade into tier 1
        } else if (v < 0.66) {
            tierIdx = 1;
            tierBlend = hermite((v - 0.33) / 0.33).h01;  // Fade into tier 2
        } else {
            tierIdx = 2;
            tierBlend = 0;
        }

        const layerCurr = LAYERS[tierIdx];
        const layerNext = LAYERS[Math.min(tierIdx + 1, 2)];

        for (let ui = 0; ui <= uSegments; ui++) {
            const u = (ui / uSegments) * Math.PI * 2;

            // Family blending (smooth around the circle)
            const famFloat = (ui / uSegments) * families.length;
            const famIdx = Math.floor(famFloat) % families.length;
            const famNext = (famIdx + 1) % families.length;
            const famT = famFloat - Math.floor(famFloat);
            const famH = hermite(famT);
            const famBlend = famH.h01;  // Smooth transition

            // Surface position
            const pos = surface(u, v);
            positions.push(pos.x, pos.y, pos.z);

            // Analytical normal
            const norm = surfaceNormal(u, v);
            normals.push(norm.x, norm.y, norm.z);

            // === SMOOTH COLOR FIELD ===
            const famColor0 = TOPO_COLORS.families[families[famIdx]] || { h: 180, s: 50, l: 50 };
            const famColor1 = TOPO_COLORS.families[families[famNext]] || famColor0;

            // Hermite interpolation for family colors
            const famH_h = famColor0.h * (1 - famBlend) + famColor1.h * famBlend;
            const famH_s = famColor0.s * (1 - famBlend) + famColor1.s * famBlend;
            const famH_l = famColor0.l * (1 - famBlend) + famColor1.l * famBlend;

            // Hermite interpolation for layer colors
            const layH_h = layerCurr.color.h * (1 - tierBlend) + layerNext.color.h * tierBlend;
            const layH_s = layerCurr.color.s * (1 - tierBlend) + layerNext.color.s * tierBlend;
            const layH_l = layerCurr.color.l * (1 - tierBlend) + layerNext.color.l * tierBlend;

            // Blend: 55% family, 45% layer
            const density = getDensity(u, v);
            const finalH = famH_h * 0.55 + layH_h * 0.45;
            const finalS = (famH_s * 0.55 + layH_s * 0.45) * (0.75 + density * 0.25);
            const finalL = Math.min(78, (famH_l * 0.5 + layH_l * 0.5) + density * 12);

            // Subtle iridescence (view-angle dependent hue shift)
            const iridescence = 6 * Math.sin(u * 2 + v * Math.PI);

            const [r, g, b] = hslToRgb(finalH + iridescence, finalS, finalL);
            colors.push(r, g, b);
        }
    }

    // Build triangle indices (seamless wrap)
    for (let vi = 0; vi < vSegments; vi++) {
        for (let ui = 0; ui < uSegments; ui++) {
            const a = vi * (uSegments + 1) + ui;
            const b = a + 1;
            const c = a + (uSegments + 1);
            const d = c + 1;

            indices.push(a, c, b);
            indices.push(b, c, d);
        }
    }

    const shellGeom = new THREE.BufferGeometry();
    shellGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    shellGeom.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
    shellGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    shellGeom.setIndex(indices);

    // 
    // CHAOS  COSMOLOGY GRADIENT SHADER
    // Bottom (chaos) = deep blue OKLCH(0.2, 0.1, 200)
    // Top (cosmology) = warm orange OKLCH(0.6, 0.15, 30)
    // 

    const chaosCosmosVertexShader = `
                varying vec3 vNormal;
                varying vec3 vPosition;
                varying vec3 vColor;
                varying vec2 vUv;

                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    vColor = color;
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

    const chaosCosmosFragmentShader = `
                uniform float uTime;
                uniform vec3 uChaosColor;      // Deep blue (bottom)
                uniform vec3 uCosmosColor;     // Warm orange (top)
                uniform float uGradientMix;    // How much gradient vs vertex color

                varying vec3 vNormal;
                varying vec3 vPosition;
                varying vec3 vColor;
                varying vec2 vUv;

                // Simple noise for organic feel
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                               mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
                }

                void main() {
                    // Normalize Y position to 0-1 range (cone goes from -1.5 to 1.5)
                    float gradientT = (vPosition.y + 1.5) / 3.0;
                    gradientT = clamp(gradientT, 0.0, 1.0);

                    // Smooth step for better gradient transition
                    float smoothT = gradientT * gradientT * (3.0 - 2.0 * gradientT);

                    // Add subtle animated noise to the gradient
                    float n = noise(vPosition.xz * 3.0 + uTime * 0.15) * 0.08;
                    smoothT = clamp(smoothT + n, 0.0, 1.0);

                    // Chaos  Cosmos gradient
                    vec3 gradientColor = mix(uChaosColor, uCosmosColor, smoothT);

                    // Blend gradient with vertex colors
                    vec3 finalColor = mix(gradientColor, vColor, uGradientMix);

                    // Add subtle rim lighting
                    vec3 viewDir = normalize(cameraPosition - vPosition);
                    float rim = 1.0 - max(0.0, dot(viewDir, vNormal));
                    rim = pow(rim, 3.0) * 0.35;
                    finalColor += vec3(rim * 0.4, rim * 0.6, rim * 1.0);

                    // Pulsing glow at tier boundaries
                    float tierGlow = 0.0;
                    float y = vPosition.y;
                    tierGlow += exp(-pow((y - (-0.5)) * 8.0, 2.0)) * 0.15;  // T0/T1 boundary
                    tierGlow += exp(-pow((y - 0.5) * 8.0, 2.0)) * 0.15;     // T1/T2 boundary
                    tierGlow *= 0.5 + 0.5 * sin(uTime * 2.0);
                    finalColor += vec3(0.3, 0.6, 1.0) * tierGlow;

                    // Basic lighting
                    vec3 lightDir = normalize(vec3(2.0, 4.0, 3.0));
                    float diff = max(0.0, dot(vNormal, lightDir)) * 0.6 + 0.4;
                    finalColor *= diff;

                    gl_FragColor = vec4(finalColor, 0.92);
                }
            `;

    // OKLCH-inspired colors (converted to linear RGB for Three.js)
    // Chaos (bottom): OKLCH(0.25, 0.12, 240)  deep cosmic blue
    // Cosmos (top): OKLCH(0.65, 0.16, 45)  warm stellar orange
    const chaosColor = new THREE.Color(0.05, 0.08, 0.25);   // Deep blue
    const cosmosColor = new THREE.Color(0.85, 0.55, 0.25);  // Warm orange

    const shellMat = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uChaosColor: { value: chaosColor },
            uCosmosColor: { value: cosmosColor },
            uGradientMix: { value: 0.45 },  // 45% vertex colors, 55% gradient
            cameraPosition: { value: TOPO_MINIMAP.camera.position }
        },
        vertexShader: chaosCosmosVertexShader,
        fragmentShader: chaosCosmosFragmentShader,
        vertexColors: true,
        transparent: true,
        side: THREE.DoubleSide
    });

    // Store reference for animation updates
    TOPO_MINIMAP.shellMaterial = shellMat;

    const shellMesh = new THREE.Mesh(shellGeom, shellMat);
    shellMesh.userData = { type: 'shell', interactive: true };
    TOPO_MINIMAP.scene.add(shellMesh);
    TOPO_MINIMAP.meshes.push(shellMesh);

    // 
    // TIER BOUNDARY RINGS - Smooth torus rings at tier transitions
    // 

    [0.33, 0.66].forEach((v, i) => {
        const pos = surface(0, v);
        const r = Math.sqrt(pos.x * pos.x + pos.z * pos.z) + 0.015;

        const ringGeom = new THREE.TorusGeometry(r, 0.012, 12, 72);
        const ringMat = new THREE.MeshBasicMaterial({
            color: i === 0 ? 0x44aaff : 0x88ddff,
            transparent: true,
            opacity: 0.5
        });
        const ring = new THREE.Mesh(ringGeom, ringMat);
        ring.rotation.x = Math.PI / 2;
        ring.position.y = pos.y;
        ring.userData = { type: 'tier-boundary', tier: i };
        TOPO_MINIMAP.scene.add(ring);
    });

    // 
    // FAMILY MERIDIANS - Geodesic curves along the surface
    // 

    families.forEach((family, famIdx) => {
        const u = (famIdx / families.length) * Math.PI * 2;
        const points = [];

        for (let j = 0; j <= 60; j++) {
            const v = j / 60;
            const pos = surface(u, v);
            points.push(new THREE.Vector3(pos.x * 1.005, pos.y, pos.z * 1.005));
        }

        const curve = new THREE.CatmullRomCurve3(points);
        const tubeGeom = new THREE.TubeGeometry(curve, 50, 0.006, 6, false);
        const famColor = TOPO_COLORS.families[family] || { h: 180, s: 50, l: 60 };
        const tubeMat = new THREE.MeshBasicMaterial({
            color: hslToHex(famColor.h, famColor.s * 0.6, Math.min(75, famColor.l + 20)),
            transparent: true,
            opacity: 0.4
        });
        const tube = new THREE.Mesh(tubeGeom, tubeMat);
        tube.userData = { type: 'meridian', family: family };
        TOPO_MINIMAP.scene.add(tube);
    });

    // 
    // CENTRAL AXIS - Vertical data highway through the core
    // 

    // Single central vertical axis line
    const axisPoints = [];
    for (let j = 0; j <= 40; j++) {
        const t = j / 40;
        const y = (t - 0.5) * 3.2;  // Slightly longer than the shape
        axisPoints.push(new THREE.Vector3(0, y, 0));
    }
    const axisCurve = new THREE.CatmullRomCurve3(axisPoints);
    const axisGeom = new THREE.TubeGeometry(axisCurve, 20, 0.025, 8, false);
    const axisMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.6
    });
    const axisTube = new THREE.Mesh(axisGeom, axisMat);
    axisTube.userData = { type: 'elevator', subtype: 'central-axis' };
    TOPO_MINIMAP.scene.add(axisTube);

    // 
    // HORIZONTAL TIER RINGS - 3 parallel rings orthogonal to axis
    // These cut the toroidal shape at T0, T1, T2 boundaries
    // 

    const tierYPositions = [-1.0, 0, 1.0];  // Bottom (T0), Middle (T1), Top (T2)
    const tierColors = [0x4488cc, 0x33ccbb, 0xe8f0ff];  // Physical, Virtual, Semantic colors

    tierYPositions.forEach((yPos, tierIdx) => {
        // Calculate radius at this Y position on the hyperboloid
        const vCentered = (yPos / 3.0) + 0.5;  // Map to 0-1 range
        const coshVal = Math.cosh(1.8 * (vCentered - 0.5));
        const baseR = (0.42 * coshVal + 0.35) * 1.02;  // Slightly outside surface

        // Create ring with multiple segments for smooth appearance
        const ringGeom = new THREE.TorusGeometry(baseR, 0.018, 8, 64);
        const ringMat = new THREE.MeshBasicMaterial({
            color: tierColors[tierIdx],
            transparent: true,
            opacity: 0.55
        });
        const ring = new THREE.Mesh(ringGeom, ringMat);
        ring.rotation.x = Math.PI / 2;  // Lay flat (orthogonal to Y axis)
        ring.position.y = yPos;
        ring.userData = { type: 'tier-ring', tier: tierIdx };
        TOPO_MINIMAP.scene.add(ring);
    });

    // 
    // SINGULARITY CORE - The nexus point
    // 

    const coreGeom = new THREE.SphereGeometry(0.15, 32, 32);
    const coreMat = new THREE.MeshPhongMaterial({
        color: 0x00ffff,
        emissive: 0x00aaff,
        emissiveIntensity: 0.8,
        transparent: true,
        opacity: 0.9
    });
    const coreMesh = new THREE.Mesh(coreGeom, coreMat);
    coreMesh.userData = { type: 'core' };
    TOPO_MINIMAP.scene.add(coreMesh);

    // Add glow ring around core
    const ringGeom = new THREE.TorusGeometry(0.25, 0.03, 8, 32);
    const ringMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.5
    });
    const ringMesh = new THREE.Mesh(ringGeom, ringMat);
    ringMesh.rotation.x = Math.PI / 2;
    ringMesh.userData = { type: 'glow' };
    TOPO_MINIMAP.scene.add(ringMesh);

    // 
    // ORBITAL PARTICLE SYSTEM - Micro Solar Systems
    // Nodes orbit at different levels like planets around stars
    // 

    TOPO_MINIMAP.particles = [];
    TOPO_MINIMAP.solarSystems = [];

    // Create orbital particles based on actual node distribution
    const maxParticles = Math.min(data.nodes.length, 80);  // Limit for performance
    const sampleRate = Math.max(1, Math.floor(data.nodes.length / maxParticles));

    // Identify hub nodes (high in-degree) for micro solar systems
    const inDegree = new Map();
    (data.links || []).forEach(link => {
        const targetId = link.target?.id || link.target;
        inDegree.set(targetId, (inDegree.get(targetId) || 0) + 1);
    });

    // Sort nodes by in-degree to find hubs
    const sortedByDegree = [...data.nodes].sort((a, b) =>
        (inDegree.get(b.id) || 0) - (inDegree.get(a.id) || 0)
    );
    const hubNodes = sortedByDegree.slice(0, 5);  // Top 5 hubs become "stars"
    const hubIds = new Set(hubNodes.map(n => n.id));

    // Create micro solar systems for each hub
    hubNodes.forEach((hub, hubIdx) => {
        const tier = getNodeTier(hub);
        const family = getNodeAtomFamily(hub);
        const tierIdx = tiers.indexOf(tier);
        const famIdx = families.indexOf(family);

        // Hub position in the hyperboloid
        const hubY = (tierIdx - 1) * 1.0;  // -1, 0, 1 for T0, T1, T2
        const hubAngle = (famIdx / families.length) * Math.PI * 2 + hubIdx * 0.3;
        const hubRadius = 0.7 + tierIdx * 0.35;

        const hubColor = TOPO_COLORS.families[family] || TOPO_COLORS.families['UNKNOWN'];

        // Create the hub "star"
        const starGeom = new THREE.SphereGeometry(0.08, 16, 16);
        const starMat = new THREE.MeshPhongMaterial({
            color: hslToHex(hubColor.h, hubColor.s, hubColor.l + 15),
            emissive: hslToHex(hubColor.h, hubColor.s * 0.6, hubColor.l * 0.4),
            emissiveIntensity: 0.6,
            transparent: true,
            opacity: 0.9
        });
        const starMesh = new THREE.Mesh(starGeom, starMat);
        starMesh.userData = {
            type: 'hub-star',
            nodeId: hub.id,
            tier: tier,
            family: family,
            baseAngle: hubAngle,
            baseRadius: hubRadius,
            baseY: hubY,
            orbitSpeed: 0.3 + Math.random() * 0.2
        };
        TOPO_MINIMAP.scene.add(starMesh);
        TOPO_MINIMAP.solarSystems.push(starMesh);

        // Find satellite nodes (nodes that call this hub)
        const satellites = data.nodes.filter(n => {
            if (n.id === hub.id) return false;
            return (data.links || []).some(l => {
                const src = l.source?.id || l.source;
                const tgt = l.target?.id || l.target;
                return src === n.id && tgt === hub.id;
            });
        }).slice(0, 6);  // Max 6 satellites per hub

        // Create satellite particles orbiting the hub
        satellites.forEach((sat, satIdx) => {
            const satTier = getNodeTier(sat);
            const satFamily = getNodeAtomFamily(sat);
            const satColor = TOPO_COLORS.families[satFamily] || TOPO_COLORS.families['UNKNOWN'];

            const particleGeom = new THREE.SphereGeometry(0.03, 8, 8);
            const particleMat = new THREE.MeshBasicMaterial({
                color: hslToHex(satColor.h, satColor.s, satColor.l),
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(particleGeom, particleMat);

            // Orbital parameters
            const orbitRadius = 0.12 + satIdx * 0.04;
            const orbitSpeed = 1.5 - satIdx * 0.15;  // Inner orbits faster
            const orbitTilt = (satIdx % 3) * 0.3;    // Different orbital planes
            const startAngle = (satIdx / satellites.length) * Math.PI * 2;

            particle.userData = {
                type: 'satellite',
                parentHub: starMesh,
                orbitRadius: orbitRadius,
                orbitSpeed: orbitSpeed,
                orbitTilt: orbitTilt,
                orbitAngle: startAngle,
                nodeId: sat.id
            };

            TOPO_MINIMAP.scene.add(particle);
            TOPO_MINIMAP.particles.push(particle);
        });
    });

    // Create free-floating particles for non-hub nodes
    let particleCount = 0;
    data.nodes.forEach((node, idx) => {
        if (hubIds.has(node.id)) return;
        if (idx % sampleRate !== 0) return;
        if (particleCount >= maxParticles - hubNodes.length * 6) return;

        const tier = getNodeTier(node);
        const family = getNodeAtomFamily(node);
        const tierIdx = tiers.indexOf(tier);
        const famIdx = families.indexOf(family);
        const color = TOPO_COLORS.families[family] || TOPO_COLORS.families['UNKNOWN'];

        const particleGeom = new THREE.SphereGeometry(0.025, 6, 6);
        const particleMat = new THREE.MeshBasicMaterial({
            color: hslToHex(color.h, color.s, color.l),
            transparent: true,
            opacity: 0.6
        });
        const particle = new THREE.Mesh(particleGeom, particleMat);

        // Orbital parameters based on tier and family
        const baseRadius = 0.5 + tierIdx * 0.5 + Math.random() * 0.2;
        const baseY = (tierIdx - 1) * 0.8 + (Math.random() - 0.5) * 0.4;
        const baseAngle = (famIdx / families.length) * Math.PI * 2 + Math.random() * 0.5;
        const orbitSpeed = 0.2 + Math.random() * 0.3;
        const orbitTilt = (famIdx % 3) * 0.2 + Math.random() * 0.1;

        particle.userData = {
            type: 'free-particle',
            baseRadius: baseRadius,
            baseY: baseY,
            baseAngle: baseAngle,
            orbitSpeed: orbitSpeed,
            orbitTilt: orbitTilt,
            orbitAngle: Math.random() * Math.PI * 2,
            tier: tier,
            family: family,
            nodeId: node.id
        };

        TOPO_MINIMAP.scene.add(particle);
        TOPO_MINIMAP.particles.push(particle);
        particleCount++;
    });

    // Store layers for animation
    TOPO_MINIMAP.layers = LAYERS;
}

function buildTopoLegends(data) {
    if (!data || !data.nodes) return;

    // Count by category
    const tierCounts = collectCounts(data.nodes, n => getNodeTier(n));
    const familyCounts = collectCounts(data.nodes, n => getNodeAtomFamily(n));
    const ringCounts = collectCounts(data.nodes, n => getNodeRing(n));
    const edgeCounts = collectCounts(data.links || [], l => String(l.edge_type || l.type || 'default'));

    // Build tier legend
    const tierContainer = document.getElementById('topo-tiers');
    if (tierContainer) {
        tierContainer.innerHTML = '';
        tierCounts.forEach(([tier, count]) => {
            const color = TOPO_COLORS.tiers[tier] || TOPO_COLORS.tiers['UNKNOWN'];
            const item = createTopoLegendItem(tier, count, color, 'tier');
            tierContainer.appendChild(item);
        });
    }

    // Build family legend
    const famContainer = document.getElementById('topo-families');
    if (famContainer) {
        famContainer.innerHTML = '';
        familyCounts.forEach(([family, count]) => {
            const color = TOPO_COLORS.families[family] || TOPO_COLORS.families['UNKNOWN'];
            const item = createTopoLegendItem(family, count, color, 'family');
            famContainer.appendChild(item);
        });
    }

    // Build ring legend
    const ringContainer = document.getElementById('topo-rings');
    if (ringContainer) {
        ringContainer.innerHTML = '';
        ringCounts.forEach(([ring, count]) => {
            const color = TOPO_COLORS.rings[ring] || TOPO_COLORS.rings['UNKNOWN'];
            const item = createTopoLegendItem(ring, count, color, 'ring');
            ringContainer.appendChild(item);
        });
    }

    // Build edge filter chips
    const edgeContainer = document.getElementById('topo-edges');
    if (edgeContainer) {
        edgeContainer.innerHTML = '';
        edgeCounts.forEach(([edgeType, count]) => {
            const chip = document.createElement('div');
            chip.className = 'topo-edge-chip active';
            chip.dataset.value = edgeType;
            chip.textContent = `${edgeType} (${count})`;
            chip.onclick = () => toggleEdgeFilter(edgeType, chip);
            edgeContainer.appendChild(chip);
        });
    }
}

function createTopoLegendItem(label, count, color, filterType) {
    const item = document.createElement('div');
    item.className = 'topo-legend-item';
    item.dataset.value = label;
    item.dataset.filterType = filterType;

    const swatch = document.createElement('div');
    swatch.className = 'topo-legend-swatch';
    swatch.style.backgroundColor = `hsl(${color.h}, ${color.s}%, ${color.l}%)`;

    const text = document.createElement('span');
    text.textContent = `${label} (${count})`;

    item.appendChild(swatch);
    item.appendChild(text);

    item.onclick = () => toggleTopoFilter(filterType, label, item);

    // Add semantic tooltip on hover
    const category = filterType === 'tier' ? 'tiers' : filterType === 'family' ? 'families' : null;
    if (category && SMC_THEORY[category]?.[label]) {
        item.addEventListener('mouseenter', (e) => {
            showTopoTooltip(category, label, e.clientX, e.clientY);
        });
        item.addEventListener('mouseleave', () => hideTopoTooltip());
        item.addEventListener('mousemove', (e) => {
            if (TOOLTIP_STATE.visible) {
                const tooltip = TOOLTIP_STATE.element;
                let left = e.clientX + 15, top = e.clientY + 15;
                if (left + 280 > window.innerWidth) left = e.clientX - 295;
                if (top + 200 > window.innerHeight) top = e.clientY - 215;
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
            }
        });
    }

    return item;
}

function toggleTopoFilter(filterType, value, element) {
    let filterSet;
    switch (filterType) {
        case 'tier': filterSet = VIS_FILTERS.tiers; break;
        case 'family': filterSet = VIS_FILTERS.families || new Set(); break;
        case 'ring': filterSet = VIS_FILTERS.rings; break;
        default: return;
    }

    // Initialize families filter if needed
    if (filterType === 'family' && !VIS_FILTERS.families) {
        VIS_FILTERS.families = new Set(['LOG', 'DAT', 'ORG', 'EXE', 'EXT', 'UNKNOWN']);
    }

    if (filterSet.has(value)) {
        filterSet.delete(value);
        element.classList.add('filtered');
    } else {
        filterSet.add(value);
        element.classList.remove('filtered');
    }

    // Update minimap visuals
    updateTopoMinimapFilters();

    // Refresh main graph
    refreshGraph();
}

function toggleEdgeFilter(edgeType, element) {
    if (VIS_FILTERS.edges.has(edgeType)) {
        VIS_FILTERS.edges.delete(edgeType);
        element.classList.remove('active');
    } else {
        VIS_FILTERS.edges.add(edgeType);
        element.classList.add('active');
    }
    refreshGraph();
}

// 
// DISSOLUTION PARTICLE SYSTEM - Particles disperse when layers toggle
// 

const DISSOLUTION_PARTICLES = {
    pool: [],
    active: [],
    maxParticles: 50,
    geometry: null,
    material: null
};

function initDissolutionParticles() {
    if (!TOPO_MINIMAP.scene) return;

    // Create particle geometry once
    DISSOLUTION_PARTICLES.geometry = new THREE.SphereGeometry(0.015, 6, 6);
    DISSOLUTION_PARTICLES.material = new THREE.MeshBasicMaterial({
        color: 0x88ccff,
        transparent: true,
        opacity: 0.8
    });

    // Pre-create particle pool
    for (let i = 0; i < DISSOLUTION_PARTICLES.maxParticles; i++) {
        const particle = new THREE.Mesh(
            DISSOLUTION_PARTICLES.geometry,
            DISSOLUTION_PARTICLES.material.clone()
        );
        particle.visible = false;
        particle.userData = { type: 'dissolution', velocity: new THREE.Vector3(), life: 0, maxLife: 1 };
        TOPO_MINIMAP.scene.add(particle);
        DISSOLUTION_PARTICLES.pool.push(particle);
    }
}

function spawnDissolutionParticles(position, color, count = 8, disperse = true) {
    if (DISSOLUTION_PARTICLES.pool.length === 0) initDissolutionParticles();

    for (let i = 0; i < count && DISSOLUTION_PARTICLES.pool.length > 0; i++) {
        const particle = DISSOLUTION_PARTICLES.pool.pop();
        if (!particle) continue;

        particle.visible = true;
        particle.position.copy(position);

        // Random velocity for dispersion
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const speed = disperse ? (0.02 + Math.random() * 0.03) : 0;

        particle.userData.velocity.set(
            Math.sin(phi) * Math.cos(theta) * speed,
            Math.cos(phi) * speed + (disperse ? 0.01 : -0.01),
            Math.sin(phi) * Math.sin(theta) * speed
        );
        particle.userData.life = disperse ? 1.0 : 0;
        particle.userData.maxLife = 0.8 + Math.random() * 0.4;
        particle.userData.targetPos = disperse ? null : position.clone();
        particle.userData.startPos = particle.position.clone();
        particle.userData.disperse = disperse;

        // Set particle color based on source
        if (particle.material && color) {
            particle.material.color.setHSL(color.h / 360, color.s / 100, color.l / 100);
        }

        DISSOLUTION_PARTICLES.active.push(particle);
    }
}

function updateDissolutionParticles(deltaTime = 0.016) {
    const toRemove = [];

    DISSOLUTION_PARTICLES.active.forEach((particle, idx) => {
        const ud = particle.userData;

        if (ud.disperse) {
            // Dispersing: fade out and move away
            ud.life -= deltaTime / ud.maxLife;

            particle.position.add(ud.velocity);
            ud.velocity.y -= 0.0003; // Gravity
            ud.velocity.multiplyScalar(0.98); // Drag

            if (particle.material) {
                particle.material.opacity = Math.max(0, ud.life * 0.8);
            }
            particle.scale.setScalar(ud.life * 0.8 + 0.2);

            if (ud.life <= 0) toRemove.push(idx);
        } else {
            // Converging: fade in and move toward target
            ud.life += deltaTime / ud.maxLife;

            if (ud.targetPos) {
                const t = Math.min(1, ud.life);
                const eased = t * t * (3 - 2 * t); // Smooth step
                particle.position.lerpVectors(ud.startPos, ud.targetPos, eased);
            }

            if (particle.material) {
                particle.material.opacity = Math.min(0.8, ud.life * 0.8);
            }
            particle.scale.setScalar(0.2 + ud.life * 0.8);

            if (ud.life >= 1) toRemove.push(idx);
        }
    });

    // Return particles to pool
    toRemove.reverse().forEach(idx => {
        const particle = DISSOLUTION_PARTICLES.active.splice(idx, 1)[0];
        particle.visible = false;
        DISSOLUTION_PARTICLES.pool.push(particle);
    });
}

function updateTopoMinimapFilters() {
    if (!TOPO_MINIMAP.meshes) return;

    TOPO_MINIMAP.meshes.forEach(mesh => {
        if (mesh.userData.type !== 'cell') return;

        const tier = mesh.userData.tier;
        const family = mesh.userData.family;

        const tierActive = VIS_FILTERS.tiers.has(tier);
        const familyActive = !VIS_FILTERS.families || VIS_FILTERS.families.has(family);

        const isActive = tierActive && familyActive;
        const wasActive = mesh.userData.wasActive !== undefined ? mesh.userData.wasActive : true;

        // Spawn dissolution particles on state change
        if (wasActive !== isActive) {
            const color = TOPO_COLORS.families[family] || { h: 200, s: 70, l: 55 };
            spawnDissolutionParticles(mesh.position, color, 6, wasActive); // disperse if was active
        }

        mesh.userData.wasActive = isActive;

        // Update material opacity
        if (mesh.material) {
            mesh.material.opacity = isActive ? 0.9 : 0.15;
            mesh.material.emissiveIntensity = isActive ? 0.4 : 0.1;
        }
    });
}

// 
// MUSICAL HARMONIC RATIOS - Orbital periods encode relationships
// Like clockwork: related nodes have harmonically related periods
// 
const HARMONIC_RATIOS = {
    // Musical intervals as orbit period multipliers
    unison: 1,        // Same frequency
    octave: 2,        // 2:1 ratio
    fifth: 1.5,       // 3:2 ratio (perfect fifth)
    fourth: 1.333,    // 4:3 ratio (perfect fourth)
    majorThird: 1.25, // 5:4 ratio
    minorThird: 1.2,  // 6:5 ratio
    // Tier-based base periods (T0 fastest, T2 slowest)
    tierPeriods: { T0: 1.0, T1: 1.5, T2: 2.0 },
    // Family-based phase offsets (creates visual "chords")
    familyPhases: { LOG: 0, DAT: Math.PI / 3, ORG: 2 * Math.PI / 3, EXE: Math.PI, EXT: 4 * Math.PI / 3 }
};

function animateTopoMinimap() {
    if (!TOPO_MINIMAP.renderer || !TOPO_MINIMAP.scene || !TOPO_MINIMAP.camera) return;

    TOPO_MINIMAP.rotation += 0.004;
    const time = Date.now() * 0.001;

    // Update chaoscosmology shader time uniform
    if (TOPO_MINIMAP.shellMaterial && TOPO_MINIMAP.shellMaterial.uniforms) {
        TOPO_MINIMAP.shellMaterial.uniforms.uTime.value = time;
    }

    // Rotate the entire scene (cells follow hyperboloid)
    TOPO_MINIMAP.meshes.forEach(mesh => {
        mesh.rotation.y = TOPO_MINIMAP.rotation;
    });

    // 
    // CLOCKWORK ORBITAL PHYSICS - Particles orbit with harmonic periods
    // 

    // Animate hub stars (they orbit the core slowly)
    if (TOPO_MINIMAP.solarSystems) {
        TOPO_MINIMAP.solarSystems.forEach(star => {
            const ud = star.userData;
            if (ud.type !== 'hub-star') return;

            // Hub stars orbit the hyperboloid structure
            const tierPeriod = HARMONIC_RATIOS.tierPeriods[ud.tier] || 1.5;
            const familyPhase = HARMONIC_RATIOS.familyPhases[ud.family] || 0;
            const orbitAngle = ud.baseAngle + time * ud.orbitSpeed / tierPeriod + familyPhase;

            //  TIER-BASED IMPORTANCE PULSING 
            // T2 (architecture) pulses stronger than T0 (foundation)
            const tierImportance = { T0: 0.4, T1: 0.6, T2: 0.9 }[ud.tier] || 0.5;
            const importancePulse = Math.sin(time * (2 + tierImportance * 2)) * tierImportance * 0.3;

            // Position with importance-based breathing
            const y = ud.baseY;
            const r = ud.baseRadius + Math.sin(time * 0.5) * 0.05 + importancePulse * 0.02;

            star.position.set(
                Math.cos(orbitAngle) * r,
                y + Math.sin(time * tierPeriod) * 0.08,
                Math.sin(orbitAngle) * r
            );

            //  IMPORTANCE GLOW + SCALE PULSE 
            const beat = Math.abs(Math.sin(orbitAngle * 2));
            const scalePulse = 1 + Math.sin(time * 3 + familyPhase) * 0.15 * tierImportance;
            star.scale.set(scalePulse, scalePulse, scalePulse);

            if (star.material) {
                const baseGlow = 0.3 + tierImportance * 0.4;
                star.material.emissiveIntensity = baseGlow + beat * 0.3 + importancePulse * 0.2;
            }
        });
    }

    // Animate satellite particles (orbit their parent hubs)
    if (TOPO_MINIMAP.particles) {
        TOPO_MINIMAP.particles.forEach(particle => {
            const ud = particle.userData;

            if (ud.type === 'satellite' && ud.parentHub) {
                // Satellite orbits around its parent hub star
                const hubPos = ud.parentHub.position;
                ud.orbitAngle += ud.orbitSpeed * 0.02;  // Kepler: inner = faster

                // Tilted orbital plane
                const x = Math.cos(ud.orbitAngle) * ud.orbitRadius;
                const z = Math.sin(ud.orbitAngle) * ud.orbitRadius;
                const tiltedY = Math.sin(ud.orbitAngle) * Math.sin(ud.orbitTilt) * ud.orbitRadius * 0.5;

                particle.position.set(
                    hubPos.x + x,
                    hubPos.y + tiltedY,
                    hubPos.z + z
                );

                // Brightness pulses when aligned (conjunction)
                const conjunction = Math.abs(Math.cos(ud.orbitAngle));
                if (particle.material) {
                    particle.material.opacity = 0.5 + conjunction * 0.4;
                }
            }

            if (ud.type === 'free-particle') {
                // Free particles orbit the core with harmonic periods
                const tierPeriod = HARMONIC_RATIOS.tierPeriods[ud.tier] || 1.5;
                const familyPhase = HARMONIC_RATIOS.familyPhases[ud.family] || 0;

                ud.orbitAngle += ud.orbitSpeed * 0.015 / tierPeriod;

                // Orbital position with tilt
                const angle = ud.baseAngle + ud.orbitAngle + familyPhase;
                const r = ud.baseRadius + Math.sin(time * 0.3 + familyPhase) * 0.08;
                const y = ud.baseY + Math.sin(angle * 2) * Math.sin(ud.orbitTilt) * 0.15;

                particle.position.set(
                    Math.cos(angle) * r,
                    y,
                    Math.sin(angle) * r
                );

                // Harmonic resonance glow (brighten when multiple orbits align)
                const resonance = Math.abs(Math.sin(time * tierPeriod + familyPhase));
                if (particle.material) {
                    particle.material.opacity = 0.4 + resonance * 0.3;
                }
            }
        });
    }

    // Animate scene elements (core, glow, elevators)
    TOPO_MINIMAP.scene.children.forEach(child => {
        if (!child.userData) return;

        if (child.userData.type === 'core') {
            // Pulsing core - "heartbeat" of the system
            const pulse = 1 + Math.sin(time * 3) * 0.15;
            child.scale.set(pulse, pulse, pulse);
            if (child.material) {
                // Core pulses brighter when orbital "chords" align
                const chordResonance = Math.abs(Math.sin(time) * Math.sin(time * 1.5) * Math.sin(time * 2));
                child.material.emissiveIntensity = 0.5 + chordResonance * 0.5;
            }
        }

        if (child.userData.type === 'glow') {
            // Rotating glow ring
            child.rotation.z = time * 0.5;
            const ringPulse = 1 + Math.sin(time * 2.5) * 0.1;
            child.scale.set(ringPulse, ringPulse, 1);
        }

        if (child.userData.type === 'elevator') {
            // Central axis - pulsing data flow
            if (child.userData.subtype === 'central-axis' && child.material) {
                const pulse = 0.4 + Math.abs(Math.sin(time * 2)) * 0.35;
                child.material.opacity = pulse;
            }
        }

        //  HORIZONTAL TIER RINGS 
        if (child.userData.type === 'tier-ring') {
            const tierIdx = child.userData.tier;
            const tierPhase = tierIdx * Math.PI * 0.667;
            const ringPulse = 1 + Math.sin(time * 2 + tierPhase) * 0.08;
            child.scale.set(ringPulse, ringPulse, 1);
            if (child.material) {
                child.material.opacity = 0.4 + tierIdx * 0.1 + Math.abs(Math.sin(time * 1.5 + tierPhase)) * 0.2;
            }
        }

        //  TIER BOUNDARY RING PULSING 
        if (child.userData.type === 'tier-boundary') {
            const tierIdx = child.userData.tier;
            // T0/T1 boundary pulses differently than T1/T2
            const tierImportance = tierIdx === 0 ? 0.6 : 0.85;
            const ringPulse = 1 + Math.sin(time * (2.5 + tierIdx) + tierIdx * Math.PI) * 0.12 * tierImportance;
            child.scale.set(ringPulse, ringPulse, 1);

            if (child.material) {
                // Glow intensity varies with tier importance
                const baseOpacity = 0.35 + tierImportance * 0.25;
                const glowPulse = Math.sin(time * 2 + tierIdx * 1.5) * 0.2;
                child.material.opacity = baseOpacity + Math.abs(glowPulse);
            }
        }
    });

    // Subtle camera bob for depth perception
    const bobY = Math.sin(time * 0.3) * 0.1;
    TOPO_MINIMAP.camera.position.y = 3.5 + bobY;
    TOPO_MINIMAP.camera.lookAt(0, 0, 0);

    // Update dissolution particles
    updateDissolutionParticles(0.016);

    TOPO_MINIMAP.renderer.render(TOPO_MINIMAP.scene, TOPO_MINIMAP.camera);
    TOPO_MINIMAP.animationId = requestAnimationFrame(animateTopoMinimap);
}

function onTopoMouseMove(event) {
    if (!TOPO_MINIMAP.renderer) return;

    const rect = TOPO_MINIMAP.canvas.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(x, y), TOPO_MINIMAP.camera);

    // Include hub stars, particles, and all scene objects for intersection
    const allObjects = [...TOPO_MINIMAP.meshes, ...(TOPO_MINIMAP.solarSystems || []), ...(TOPO_MINIMAP.particles || [])];
    const intersects = raycaster.intersectObjects(allObjects.filter(Boolean));

    // Reset previous hover
    if (TOPO_MINIMAP.hoveredMesh && TOPO_MINIMAP.hoveredMesh.material) {
        TOPO_MINIMAP.hoveredMesh.material.emissiveIntensity =
            TOPO_MINIMAP.hoveredMesh.userData.baseEmissive || 0.3;
    }

    if (intersects.length > 0) {
        const mesh = intersects[0].object;
        const ud = mesh.userData;

        // Highlight hovered mesh
        if (mesh.material && mesh.material.emissiveIntensity !== undefined) {
            ud.baseEmissive = ud.baseEmissive || mesh.material.emissiveIntensity;
            mesh.material.emissiveIntensity = 0.8;
        }
        TOPO_MINIMAP.hoveredMesh = mesh;
        TOPO_MINIMAP.canvas.style.cursor = 'pointer';

        // Show semantic tooltip based on element type
        if (ud.type === 'cell') {
            const { tier, family } = ud;
            if (family && SMC_THEORY.families[family]) {
                showTopoTooltip('families', family, event.clientX, event.clientY);
            } else if (tier && SMC_THEORY.tiers[tier]) {
                showTopoTooltip('tiers', tier, event.clientX, event.clientY);
            }
        } else if (ud.type === 'shell') {
            const point = intersects[0].point;
            if (point.y < -0.3) showTopoTooltip('tiers', 'T0', event.clientX, event.clientY);
            else if (point.y < 0.3) showTopoTooltip('tiers', 'T1', event.clientX, event.clientY);
            else showTopoTooltip('tiers', 'T2', event.clientX, event.clientY);
        } else if (ud.type === 'hub-star') {
            showTopoTooltip('special', 'hub-star', event.clientX, event.clientY);
        } else if (ud.type === 'core') {
            showTopoTooltip('special', 'core', event.clientX, event.clientY);
        } else if (ud.type === 'elevator') {
            showTopoTooltip('special', 'elevator', event.clientX, event.clientY);
        } else if (ud.type === 'tier-boundary') {
            showTopoTooltip('tiers', ud.tier === 0 ? 'T1' : 'T2', event.clientX, event.clientY);
        } else if (ud.type === 'tier-ring') {
            showTopoTooltip('tiers', ['T0', 'T1', 'T2'][ud.tier] || 'T1', event.clientX, event.clientY);
        } else if (ud.type === 'meridian' && ud.family) {
            showTopoTooltip('families', ud.family, event.clientX, event.clientY);
        }
    } else {
        TOPO_MINIMAP.hoveredMesh = null;
        TOPO_MINIMAP.canvas.style.cursor = 'default';
        hideTopoTooltip();
    }
}

function onTopoMouseOut(event) { hideTopoTooltip(true); }

// 
// EXPAND-ON-CLICK - Toggle fullscreen minimap view
// 
function toggleMinimapExpand(event) {
    // Don't expand if clicking on interactive elements
    if (event.target.tagName === 'CANVAS') {
        const container = document.getElementById('topo-minimap');
        if (!container) return;

        const isExpanded = container.classList.toggle('expanded');

        // Resize renderer for better quality when expanded
        if (TOPO_MINIMAP.renderer && TOPO_MINIMAP.camera) {
            setTimeout(() => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                TOPO_MINIMAP.renderer.setSize(width, height);
                TOPO_MINIMAP.camera.aspect = width / height;
                TOPO_MINIMAP.camera.updateProjectionMatrix();
            }, 50); // Wait for CSS transition to start
        }

        // Update hint
        const hint = container.querySelector('.topo-expand-hint');
        if (hint) hint.textContent = isExpanded ? 'Click to collapse' : 'Click to expand';

        // Escape key to close
        if (isExpanded) {
            const closeOnEscape = (e) => {
                if (e.key === 'Escape') {
                    container.classList.remove('expanded');
                    resizeMinimapRenderer();
                    document.removeEventListener('keydown', closeOnEscape);
                }
            };
            document.addEventListener('keydown', closeOnEscape);
        }
    }
}

function resizeMinimapRenderer() {
    const container = document.getElementById('topo-minimap');
    if (!container || !TOPO_MINIMAP.renderer || !TOPO_MINIMAP.camera) return;
    setTimeout(() => {
        const width = container.clientWidth;
        const height = container.clientHeight;
        TOPO_MINIMAP.renderer.setSize(width, height);
        TOPO_MINIMAP.camera.aspect = width / height;
        TOPO_MINIMAP.camera.updateProjectionMatrix();
    }, 400); // Wait for CSS transition to complete
}

function onTopoClick(event) {
    if (!TOPO_MINIMAP.renderer) return;

    const rect = TOPO_MINIMAP.canvas.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(x, y), TOPO_MINIMAP.camera);

    const intersects = raycaster.intersectObjects(TOPO_MINIMAP.meshes);

    if (intersects.length > 0) {
        const mesh = intersects[0].object;
        if (mesh.userData.type === 'cell') {
            const { tier, family } = mesh.userData;

            // Toggle this specific cell's tier and family in filters
            // For now, just show what was clicked
            showToast(`Clicked: ${tier} / ${family}`, 2000);

            // Filter to show only this tier+family
            // (Could implement solo/isolate mode here)
        }
    }
}

function collectCounts(items, keyFn) {
    const counts = new Map();
    items.forEach(item => {
        const key = keyFn(item);
        if (!key) return;
        counts.set(key, (counts.get(key) || 0) + 1);
    });
    return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
}

function resolveDefaults(defaults, available) {
    if (!Array.isArray(defaults) || defaults.length === 0) {
        return available;
    }
    const availableSet = new Set(available);
    const intersection = defaults.filter(value => availableSet.has(value));
    return intersection.length ? intersection : available;
}

function buildCheckboxRow(container, id, label, count, checked, onChange) {
    const row = document.createElement('div');
    row.className = 'filter-item';
    const input = document.createElement('input');
    input.type = 'checkbox';
    input.id = id;
    input.checked = checked;
    input.onchange = () => onChange(input.checked);
    const text = document.createElement('label');
    text.setAttribute('for', id);
    text.textContent = label;
    const countEl = document.createElement('span');
    countEl.className = 'filter-count';
    countEl.textContent = (typeof count === 'number') ? String(count) : '';
    row.appendChild(input);
    row.appendChild(text);
    if (countEl.textContent) {
        row.appendChild(countEl);
    }
    container.appendChild(row);
    return input;
}

function buildFilterGroup(containerId, items, stateSet, onUpdate) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    const allId = `${containerId}-all`;
    let allCheckbox = null;

    allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
        stateSet.clear();
        if (checked) {
            items.forEach(([value]) => stateSet.add(value));
        }
        container.querySelectorAll('input[type="checkbox"]').forEach(box => {
            if (box.id !== allId) box.checked = checked;
        });
        onUpdate();
    });

    items.forEach(([value, count], index) => {
        const id = `${containerId}-${index}`;
        const checked = stateSet.has(value);
        buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
            if (isChecked) {
                stateSet.add(value);
            } else {
                stateSet.delete(value);
            }
            const allChecked = items.every(([v]) => stateSet.has(v));
            allCheckbox.checked = allChecked;
            onUpdate();
        });
    });
}

function normalizeDatamapConfig(raw) {
    if (!raw || typeof raw !== 'object') return null;
    const id = String(raw.id || raw.key || raw.label || '').trim();
    if (!id) return null;
    const normalizeList = (value) => {
        if (!Array.isArray(value)) return [];
        return value.map(item => String(item).toUpperCase());
    };
    // Normalize tier list with aliases (CORET0, ARCHT1, EXTT2)
    const normalizeTierList = (value) => {
        if (!Array.isArray(value)) return [];
        return value.map(item => normalizeTier(item));
    };
    const match = raw.match || {};
    return {
        id: id.toUpperCase(),
        label: String(raw.label || raw.id || id).toUpperCase(),
        match: {
            atom_families: normalizeList(match.atom_families),  // NEW: canonical atom family
            atom_prefixes: normalizeList(match.atom_prefixes),  // backward compat
            tiers: normalizeTierList(match.tiers),  // applies aliases
            rings: normalizeList(match.rings),
            roles: normalizeList(match.roles)
        },
        default: Boolean(raw.default)
    };
}

function resolveDatamapConfigs(controlsConfig) {
    const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
    const normalized = fromTokens
        .map(normalizeDatamapConfig)
        .filter(Boolean);
    if (normalized.length) return normalized;

    const fallback = controlsConfig.buttons?.datamaps || {};
    return Object.entries(fallback).map(([label, config]) => {
        const prefix = config.filter || null;
        return normalizeDatamapConfig({
            id: label.toUpperCase(),
            label: label.toUpperCase(),
            match: prefix ? { atom_prefixes: [prefix] } : {},
            default: false
        });
    }).filter(Boolean);
}

function datamapMatches(node, config) {
    const match = config.match || {};
    const atomId = String(node.atom || '');
    const atomFamily = getNodeAtomFamily(node);  // canonical or inferred
    const tier = getNodeTier(node);  // canonical or inferred (with aliases)
    const ring = getNodeRing(node);
    const role = String(node.role || 'Unknown').toUpperCase();

    // NEW: atom_families matching (canonical field)
    if (Array.isArray(match.atom_families) && match.atom_families.length) {
        if (!match.atom_families.includes(atomFamily)) return false;
    }

    // Backward compat: atom_prefixes matches atom_family OR atom prefix
    if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
        const matchesFamily = match.atom_prefixes.includes(atomFamily);
        const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
        if (!matchesFamily && !matchesPrefix) return false;
    }

    // Tier matching (aliases already normalized in config)
    if (Array.isArray(match.tiers) && match.tiers.length) {
        if (!match.tiers.includes(tier)) return false;
    }

    if (Array.isArray(match.rings) && match.rings.length) {
        if (!match.rings.includes(ring)) return false;
    }

    if (Array.isArray(match.roles) && match.roles.length) {
        if (!match.roles.includes(role)) return false;
    }
    return true;
}

function buildDatamapToggle(container, id, label, checked, count, onChange) {
    const wrapper = document.createElement('label');
    wrapper.className = 'datamap-toggle';
    wrapper.setAttribute('data-id', id);

    const input = document.createElement('input');
    input.type = 'checkbox';
    input.checked = checked;
    input.onchange = () => onChange(input.checked);

    const text = document.createElement('span');
    text.textContent = label;

    const countEl = document.createElement('span');
    countEl.className = 'datamap-count';
    countEl.textContent = (typeof count === 'number') ? String(count) : '';

    wrapper.appendChild(input);
    wrapper.appendChild(text);
    wrapper.appendChild(countEl);
    container.appendChild(wrapper);

    return { wrapper, input, count: countEl };
}

// Deprecated buildDatamapControls - replaced by UIManager

function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    const inputs = [];
    options.forEach((option, index) => {
        const id = `${containerId}-${index}`;
        const input = buildCheckboxRow(
            container,
            id,
            option.label,
            null,
            option.value === activeValue,
            (checked) => {
                if (!checked) {
                    input.checked = true;
                    return;
                }
                inputs.forEach(other => {
                    if (other !== input) other.checked = false;
                });
                onSelect(option.value);
            }
        );
        inputs.push(input);
    });
}

function buildMetadataControls(containerId, metadata) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    const toggles = [
        { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
        { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
        { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
        { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
    ];

    toggles.forEach((toggle) => {
        buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
            metadata[toggle.key] = checked;
            applyMetadataVisibility();
            refreshGraph();
        });
    });
}

function buildAppearanceSliders(containerId, sliderConfigs) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // 
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // =1 linear, >1 amplifies small differences, <1 compresses
        // Formula: amplified = value^(1/)
        // 
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER ()',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: '>1 amplifies differences, <1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    sliderDefs.forEach(def => {
        const wrapper = document.createElement('div');
        wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

        // Header row with label and value
        const header = document.createElement('div');
        header.className = 'slider-header';
        const label = document.createElement('span');
        label.className = 'slider-label';
        label.textContent = def.label;
        const valueDisplay = document.createElement('span');
        valueDisplay.className = 'slider-value';
        valueDisplay.id = def.id + '-value';
        valueDisplay.textContent = def.value.toFixed(def.step < 1 ? 2 : 0);
        header.appendChild(label);
        header.appendChild(valueDisplay);

        // The slider input
        const input = document.createElement('input');
        input.type = 'range';
        input.className = 'slider-input';
        input.id = def.id;
        input.min = def.min;
        input.max = def.max;
        input.step = def.step;
        input.value = def.value;
        input.oninput = () => {
            const val = parseFloat(input.value);
            valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
            def.onChange(val);
        };

        wrapper.appendChild(header);
        wrapper.appendChild(input);

        // Optional description for meta-sliders
        if (def.description) {
            const desc = document.createElement('div');
            desc.className = 'slider-desc';
            desc.textContent = def.description;
            wrapper.appendChild(desc);
        }

        container.appendChild(wrapper);
    });
}

function updateBackgroundBrightness() {
    if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
    const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
    const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
    const adjusted = baseColor.clone().multiplyScalar(brightness);
    Graph.backgroundColor(`#${adjusted.getHexString()}`);
}

function applyMetadataVisibility() {
    const reportPanel = document.getElementById('report-panel');
    const reportButton = document.getElementById('btn-report');
    const filePanel = document.getElementById('file-panel');
    if (!VIS_FILTERS.metadata.showReportPanel) {
        reportPanel.style.display = 'none';
        reportButton.classList.remove('active');
        reportButton.style.display = 'none';
    } else {
        reportButton.style.display = 'inline-flex';
    }
    if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
        filePanel.classList.remove('visible');
    }
}

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// 
// OKLCH COLOR SCHEME BUTTONS - L, C, H move together coherently
// 
const colorSchemeGrid = document.getElementById('color-scheme-grid');
if (colorSchemeGrid) {
    colorSchemeGrid.querySelectorAll('.color-scheme-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;
            const preset = VIS_PRESETS[presetKey];
            if (!preset || !preset.isColorScheme) return;

            // Update active states
            colorSchemeGrid.querySelectorAll('.color-scheme-btn').forEach(b => b.classList.remove('active'));
            if (presetGrid) presetGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            // Apply node color mode
            setNodeColorMode(preset.colorBy === 'layer' ? 'tier' : preset.colorBy);

            // Apply edge mode
            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';

            // OKLCH transforms - BOLD application
            if (preset.oklch) {
                const oklch = preset.oklch;
                const hue = document.getElementById('hue-shift');
                const chroma = document.getElementById('chroma-scale');
                const light = document.getElementById('light-shift');
                const bg = document.getElementById('background-brightness');

                // Apply hue shift
                if (oklch.H && hue) {
                    hue.value = oklch.H.shift || 0;
                    hue.dispatchEvent(new Event('input'));
                }
                // Apply chroma boost (use full value for dramatic effect)
                if (oklch.C && chroma) {
                    chroma.value = oklch.C.boost || 1;
                    chroma.dispatchEvent(new Event('input'));
                }
                // Apply lightness from preset
                if (light) {
                    const lightVal = preset.lightness !== undefined ? preset.lightness : 0;
                    light.value = lightVal;
                    light.dispatchEvent(new Event('input'));
                }
                // Apply background darkness
                if (oklch.bgL !== undefined && bg) {
                    bg.value = Math.min(1, oklch.bgL * 12);
                    bg.dispatchEvent(new Event('input'));
                }
            }

            // Apply amplifier (higher = more contrast)
            if (preset.amplifier) {
                const amp = document.getElementById('amplifier');
                if (amp) {
                    amp.value = preset.amplifier;
                    amp.dispatchEvent(new Event('input'));
                }
            }

            applyEdgeMode();

            // Re-render legends with updated colors from ColorOrchestrator
            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            // Handle flow mode
            if (preset.edgeBy === 'weight' || preset.edgeBy === 'gradient-flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof clearFlowVisualization === 'function') {
                clearFlowVisualization();
            }

            console.log('[OKLCH] Applied:', preset.name, '| Color.transform:', Color.transform);
        });
    });
}

// 
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// 
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const layoutKey = btn.dataset.layout;
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

function setupCollapsibleSections() {
    // Standard sidebar sections
    const titles = document.querySelectorAll('.side-title.collapsible');
    titles.forEach(title => {
        title.onclick = () => {
            const targetId = title.dataset.target;
            const content = document.getElementById(targetId);
            const icon = title.querySelector('.collapse-icon');
            if (content) {
                const isCollapsed = content.classList.toggle('collapsed');
                title.classList.toggle('collapsed', isCollapsed);
                if (icon) icon.textContent = isCollapsed ? '' : '';
            }
        };
    });

    // Topology section collapsibles (GEOMETRY panel)
    const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
    topoTitles.forEach(title => {
        title.onclick = () => {
            const targetId = title.dataset.target;
            const content = document.getElementById(targetId);
            const icon = title.querySelector('.collapse-icon');
            if (content) {
                const isCollapsed = content.classList.toggle('collapsed');
                title.classList.toggle('expanded', !isCollapsed);
                if (icon) icon.textContent = isCollapsed ? '' : '';
            }
        };
    });
}

function setupReport(data) {
    const panel = document.getElementById('report-panel');
    const content = document.getElementById('report-content');
    const report = (data && data.brain_download) ? data.brain_download : '';
    content.textContent = report || 'No report available.';
}

function setupMetrics(data) {
    const kpis = (data && data.kpis) ? data.kpis : {};
    const setText = (id, value) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.textContent = value;
    };
    const asNumber = (val) => {
        const num = Number(val);
        return Number.isFinite(num) ? num : null;
    };
    const formatPercent = (val) => {
        const num = asNumber(val);
        return num === null ? '--' : `${num.toFixed(1)}%`;
    };
    const formatCount = (val) => {
        const num = asNumber(val);
        return num === null ? '--' : `${Math.round(num)}`;
    };
    const formatScore = (val) => {
        const num = asNumber(val);
        return num === null ? '--' : `${num.toFixed(1)}/10`;
    };

    setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
    setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
    setText('metric-reachability', formatPercent(kpis.reachability_percent));
    setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
    setText('metric-knot-score', formatScore(kpis.knot_score));
    setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
    setText('metric-orphans', formatCount(kpis.orphan_count));
    setText('metric-top-hubs', formatCount(kpis.top_hub_count));

    // Set health indicators (traffic light bars)
    const setHealth = (id, level) => {
        const el = document.getElementById(id);
        if (el) {
            el.classList.remove('good', 'medium', 'bad', 'neutral');
            el.classList.add(level);
        }
    };

    // Edge Resolution: >90% good, 70-90% medium, <70% bad
    const edgeRes = asNumber(kpis.edge_resolution_percent);
    setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

    // Call Ratio: >60% good, 40-60% medium, <40% bad
    const callRatio = asNumber(kpis.call_ratio_percent);
    setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

    // Reachability: >90% good, 70-90% medium, <70% bad
    const reach = asNumber(kpis.reachability_percent);
    setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

    // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
    const dead = asNumber(kpis.dead_code_percent);
    setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

    // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
    const knot = asNumber(kpis.knot_score);
    setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

    // Topology: neutral (informational only)
    setHealth('health-topology', 'neutral');

    // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
    const orphans = asNumber(kpis.orphan_count);
    setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

    // Top Hubs: neutral (informational only)
    setHealth('health-top-hubs', 'neutral');
}

function setupHudFade() {
    const idleDelay = 2200;
    let timer = null;
    const activate = () => {
        document.body.classList.remove('hud-quiet');
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(() => {
            document.body.classList.add('hud-quiet');
        }, idleDelay);
    };
    ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
        window.addEventListener(evt, activate, { passive: true });
    });
    activate();
}

// =================================================================
// HUD STATS: Update all header and stats panel elements
// =================================================================
function updateHudStats(data) {
    if (!data) return;

    // Stats panel: NODES, EDGES, ENTROPY
    const nodeCount = (data.nodes || []).length;
    const edgeCount = (data.links || []).length;

    const statNodes = document.getElementById('stat-nodes');
    const statEdges = document.getElementById('stat-edges');
    const statEntropy = document.getElementById('stat-entropy');

    if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
    if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
    if (statEntropy) {
        const entropy = data.meta?.entropy ?? data.entropy ?? '--';
        statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
    }

    // Header panel: target name and timestamp
    const targetName = document.getElementById('target-name');
    const timestamp = document.getElementById('timestamp');

    if (targetName) {
        const target = data.meta?.target || data.target || 'Unknown';
        // Show just the last part of the path
        const shortTarget = target.split('/').pop() || target;
        targetName.textContent = shortTarget;
    }

    if (timestamp) {
        const ts = data.meta?.timestamp || data.timestamp || '';
        // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
        const formatted = ts.replace('T', ' ').substring(0, 16);
        timestamp.textContent = formatted || 'Live';
    }
}

function showToast(message) {
    const toast = document.getElementById('hud-toast');
    if (!toast) return;
    toast.textContent = message;
    toast.classList.add('visible');
    clearTimeout(toast._timer);
    toast._timer = setTimeout(() => {
        toast.classList.remove('visible');
    }, 2200);
}

function updateDatamapControls() {
    if (!DM) return;  // ALL DATA FROM DM
    const datamapEnabled = GRAPH_MODE === 'atoms';
    const base = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // DM used internally
    const nodes = base.nodes || [];
    const totalCount = nodes.length;

    const allUI = DATAMAP_UI.get('__ALL__');
    if (allUI) {
        allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
        if (allUI.count) {
            allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
        }
        allUI.input.disabled = !datamapEnabled;
        allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
        allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
    }

    DATAMAP_CONFIGS.forEach((config) => {
        const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
        const ui = DATAMAP_UI.get(config.id);
        if (!ui) return;
        if (ui.count) {
            ui.count.textContent = datamapEnabled ? String(count) : '--';
        }
        ui.input.disabled = !datamapEnabled || count === 0;
        ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
        ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
        ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
    });
}

// Callable function for direct invocation (no proxy click needed)
function toggleDimensions() {
    if (DIMENSION_TRANSITION) return;
    DIMENSION_TRANSITION = true;
    const target3d = !IS_3D;
    const button = document.getElementById('btn-dimensions');
    animateDimensionChange(target3d, () => {
        IS_3D = target3d;
        DIMENSION_TRANSITION = false;
        if (button) button.textContent = IS_3D ? '2D' : '3D';
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
    });
}

function setupDimensionToggle() {
    const button = document.getElementById('btn-dimensions');
    const updateLabel = () => {
        button.textContent = IS_3D ? '2D' : '3D';
    };
    updateLabel();
    button.onclick = () => toggleDimensions();
}

function stableSeed(node, salt) {
    const id = String(node.id || node.name || '');
    const combined = `${id}|${salt}`;
    let hash = 0;
    for (let i = 0; i < combined.length; i++) {
        hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
    }
    return ((hash >>> 0) % 1000) / 1000;
}

function stableZ(node) {
    const normalized = stableSeed(node, 'z');
    return (normalized - 0.5) * 60;
}

function animateDimensionChange(target3d, done) {
    const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
    const startTime = performance.now();
    const duration = 3000;
    const delayMin = 0;
    const delayMax = 2000;
    const lockPositionsAfterTransition = true;
    const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);
    const starStart = STARFIELD ? STARFIELD.material.opacity : 0;
    const starTarget = target3d ? STARFIELD_OPACITY : 0;
    const bloomStart = BLOOM_PASS ? BLOOM_PASS.strength : 0;
    const bloomTarget = BLOOM_PASS ? (target3d ? BLOOM_STRENGTH : 0) : 0;
    const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
    const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
    const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
    const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;
    if (Graph && Graph.cooldownTicks) {
        Graph.cooldownTicks(Infinity);
    }
    if (Graph && Graph.cooldownTime) {
        Graph.cooldownTime(Infinity);
    }
    if (Graph && Graph.d3VelocityDecay) {
        Graph.d3VelocityDecay(1);
    }
    if (Graph && Graph.d3AlphaTarget) {
        Graph.d3AlphaTarget(0);
    }
    if (Graph && Graph.d3ReheatSimulation) {
        Graph.d3ReheatSimulation();
    }

    nodes.forEach((node) => {
        node.__xStart = node.x || 0;
        node.__yStart = node.y || 0;
        node.__zStart = node.z || 0;
        node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
        node.fx = node.__xStart;
        node.fy = node.__yStart;
        node.vx = 0;
        node.vy = 0;
        node.vz = 0;
        if (target3d) {
            if (node.__z3d === undefined || node.__z3d === null) {
                node.__z3d = node.__zStart || stableZ(node);
            }
        } else {
            node.__z3d = node.__zStart;
        }
    });

    const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

    Graph.numDimensions(3);

    const animate = (now) => {
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        const eased = easeInOutSine(t);

        nodes.forEach((node) => {
            const startZ = node.__zStart || 0;
            const targetZ = target3d ? (node.__z3d || 0) : 0;
            const delay = node.__delay || 0;
            const localDuration = Math.max(600, duration - delay);
            const localElapsed = Math.max(0, elapsed - delay);
            const localT = Math.min(1, localElapsed / localDuration);
            const localEase = easeInOutSine(localT);
            const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
            const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
            const progress = Math.pow(localEase, distanceCurve);
            const nextZ = startZ + (targetZ - startZ) * progress;
            node.z = nextZ;
            node.fz = nextZ;
            node.vz = 0;
        });

        if (STARFIELD) {
            const nextOpacity = starStart + (starTarget - starStart) * eased;
            STARFIELD.material.opacity = nextOpacity;
            STARFIELD.visible = nextOpacity > 0.02;
        }
        if (BLOOM_PASS) {
            BLOOM_PASS.strength = bloomStart + (bloomTarget - bloomStart) * eased;
        }

        if (t < 1) {
            requestAnimationFrame(animate);
        } else {
            nodes.forEach((node) => {
                delete node.fz;
                delete node.__zStart;
                delete node.__xStart;
                delete node.__yStart;
                delete node.__delay;
                if (!target3d) {
                    node.z = 0;
                    node.fz = 0;
                } else if (lockPositionsAfterTransition) {
                    node.z = node.__z3d || node.z || 0;
                    node.fz = node.z;
                } else {
                    delete node.fx;
                    delete node.fy;
                }
            });
            Graph.numDimensions(target3d ? 3 : 2);
            if (!target3d && STARFIELD) {
                STARFIELD.visible = false;
            }
            if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                Graph.d3VelocityDecay(previousVelocityDecay);
            }
            if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                Graph.d3AlphaTarget(previousAlphaTarget);
            }
            if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                Graph.cooldownTicks(previousCooldownTicks);
            }
            if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                Graph.cooldownTime(previousCooldownTime);
            }
            if (done) done();
        }
    };

    requestAnimationFrame(animate);
}

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // SourceTarget tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': ' TIER FLOW',
    'gradient-file': ' FILE REGIONS',
    'gradient-flow': ' HOT PATHS',
    'gradient-depth': ' CALL DEPTH',
    'gradient-semantic': ' SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0T1T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue)  Core (purple)  Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// Build file hue map for consistent coloring
let FILE_HUE_MAP = new Map();
function buildFileHueMap() {
    if (!DM) return;  // ALL DATA FROM DM
    const files = DM.getFileBoundaries();
    const goldenAngle = 137.508;  // Golden angle for good distribution
    files.forEach((file, idx) => {
        const hue = (idx * goldenAngle) % 360;
        FILE_HUE_MAP.set(idx, hue);
    });
}

// Get node tier value (0=T0, 1=T1, 2=T2)
function getNodeTierValue(node) {
    if (!node) return 1;
    const tier = getNodeTier(node);
    if (tier === 'T0') return 0;
    if (tier === 'T1') return 1;
    if (tier === 'T2') return 2;
    return 1;
}

// Get node depth (distance from entry points)
function getNodeDepth(node) {
    // Use y-position as proxy for depth (force layout tends to layer)
    if (node && typeof node.y === 'number') {
        return Math.abs(node.y) / 500;  // Normalize
    }
    return 0.5;
}

// Get semantic similarity between two nodes
function getSemanticSimilarity(srcNode, tgtNode) {
    if (!srcNode || !tgtNode) return 0.5;
    let score = 0;
    // Same type = high similarity
    if (srcNode.type === tgtNode.type) score += 0.4;
    // Same file = high similarity
    if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
    // Same tier = moderate similarity
    if (getNodeTier(srcNode) === getNodeTier(tgtNode)) score += 0.2;
    // Same ring/layer
    if (srcNode.ring === tgtNode.ring) score += 0.1;
    return score;
}

// Interpolate between two HSL colors
function interpolateHSL(hsl1, hsl2, t) {
    t = clamp01(t);
    // Handle hue interpolation (shortest path on color wheel)
    let h1 = hsl1.h, h2 = hsl2.h;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }
    const h = (h1 + (h2 - h1) * t) % 360;
    const s = hsl1.s + (hsl2.s - hsl1.s) * t;
    const l = hsl1.l + (hsl2.l - hsl1.l) * t;
    return hslColor(h, s, l);
}

// Create gradient color for edge based on source and target
function getGradientEdgeColor(link, mode) {
    const srcNode = typeof link.source === 'object' ? link.source :
        (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
    const tgtNode = typeof link.target === 'object' ? link.target :
        (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

    if (mode === 'gradient-tier') {
        // Color by tier transition: T0(blue)  T1(purple)  T2(orange)
        const srcTier = getNodeTierValue(srcNode);
        const tgtTier = getNodeTierValue(tgtNode);
        const avgTier = (srcTier + tgtTier) / 2;

        // Blend based on tier flow direction
        const palette = GRADIENT_PALETTES.tier;
        let color;
        if (avgTier < 0.5) {
            color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
        } else if (avgTier < 1.5) {
            color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
        } else {
            color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
        }

        // Highlight tier transitions (edges crossing tiers)
        if (srcTier !== tgtTier) {
            // Make cross-tier edges brighter/more saturated
            return hslColor(
                parseInt(color.slice(4)),
                75,  // Higher saturation
                55   // Brighter
            );
        }
        return color;
    }

    if (mode === 'gradient-file') {
        // Color by file - each file gets unique hue
        const srcFile = srcNode?.fileIdx ?? -1;
        const tgtFile = tgtNode?.fileIdx ?? -1;
        const palette = GRADIENT_PALETTES.file;

        if (srcFile === tgtFile && srcFile >= 0) {
            // Same file: use file's hue
            const hue = FILE_HUE_MAP.get(srcFile) ?? (srcFile * 37 % 360);
            return hslColor(hue, palette.saturation, palette.lightness);
        } else {
            // Cross-file: blend hues or use distinct "boundary" color
            const srcHue = FILE_HUE_MAP.get(srcFile) ?? 0;
            const tgtHue = FILE_HUE_MAP.get(tgtFile) ?? 180;
            // Use midpoint hue with reduced saturation (shows boundary)
            let midHue = (srcHue + tgtHue) / 2;
            if (Math.abs(srcHue - tgtHue) > 180) {
                midHue = (midHue + 180) % 360;
            }
            return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
        }
    }

    if (mode === 'gradient-flow') {
        // Color by markov weight (probability flow)
        const mw = link.markov_weight ?? link.weight ?? 0;
        const palette = GRADIENT_PALETTES.flow;

        if (mw < 0.3) {
            return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
        } else if (mw < 0.7) {
            return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
        } else {
            // Very hot - extra bright
            return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
        }
    }

    if (mode === 'gradient-depth') {
        // Color by call depth (position in graph)
        const srcDepth = getNodeDepth(srcNode);
        const tgtDepth = getNodeDepth(tgtNode);
        const avgDepth = (srcDepth + tgtDepth) / 2;
        const palette = GRADIENT_PALETTES.depth;

        if (avgDepth < 0.33) {
            return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
        } else if (avgDepth < 0.66) {
            return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
        } else {
            return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
        }
    }

    if (mode === 'gradient-semantic') {
        // Color by semantic similarity
        const similarity = getSemanticSimilarity(srcNode, tgtNode);
        const palette = GRADIENT_PALETTES.semantic;

        if (similarity > 0.7) {
            return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
        } else if (similarity > 0.3) {
            return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
        } else {
            return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
        }
    }

    // Fallback
    return '#444444';
}

function clamp01(value) {
    return Math.max(0, Math.min(1, value));
}

function clampValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

function hslColor(hue, saturation, lightness) {
    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}

function parseOklchString(value) {
    if (typeof value !== 'string') return null;
    const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
    if (!match) return null;
    return {
        L: parseFloat(match[1]),
        C: parseFloat(match[2]),
        H: parseFloat(match[3]),
        A: match[4] !== undefined ? parseFloat(match[4]) : 1
    };
}

function applyColorTweaks(lightness, chroma, hue, alpha = 1) {
    const L = clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
    const C = clampValue(chroma * (COLOR_TWEAKS.chromaScale || 1), 0, 0.4);
    const H = (hue + (COLOR_TWEAKS.hueShift || 0) + 360) % 360;
    return [L, C, H, alpha];
}

function oklchToSrgb(L, C, H) {
    const hRad = (H * Math.PI) / 180;
    const a = C * Math.cos(hRad);
    const b = C * Math.sin(hRad);

    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l = l_ ** 3;
    const m = m_ ** 3;
    const s = s_ ** 3;

    let r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
    let g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
    let bChan = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    const linearToSrgb = (channel) => {
        if (channel <= 0.0031308) {
            return 12.92 * channel;
        }
        return 1.055 * Math.pow(channel, 1 / 2.4) - 0.055;
    };

    r = linearToSrgb(r);
    g = linearToSrgb(g);
    bChan = linearToSrgb(bChan);

    if (![r, g, bChan].every(Number.isFinite)) {
        return [0.5, 0.5, 0.5];
    }

    return [
        Math.min(1, Math.max(0, r)),
        Math.min(1, Math.max(0, g)),
        Math.min(1, Math.max(0, bChan))
    ];
}

function oklchColor(lightness, chroma, hue, alpha = 1) {
    const rawL = (typeof lightness === 'number') ? lightness : 50;
    const rawC = (typeof chroma === 'number') ? chroma : 0.1;
    const rawH = (typeof hue === 'number') ? hue : 0;
    const [LAdj, CAdj, HAdj, alphaAdj] = applyColorTweaks(rawL, rawC, rawH, alpha);
    const L = LAdj / 100;
    const C = CAdj;
    const H = HAdj;
    const [r, g, b] = oklchToSrgb(L, C, H);
    const rByte = Math.round(r * 255);
    const gByte = Math.round(g * 255);
    const bByte = Math.round(b * 255);
    if (![rByte, gByte, bByte].every(Number.isFinite)) {
        return 'rgb(128, 128, 128)';
    }
    if (alphaAdj < 1) {
        return `rgba(${rByte}, ${gByte}, ${bByte}, ${alphaAdj})`;
    }
    return `rgb(${rByte}, ${gByte}, ${bByte})`;
}

function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
    if (color === null || color === undefined) {
        return fallback;
    }
    if (typeof color !== 'string') {
        return color;
    }
    const parsed = parseOklchString(color);
    if (parsed) {
        return oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
    }
    return color;
}

function toColorNumber(color, fallback = '#777777') {
    // Returns CSS hex string (polished-compatible) instead of JS hex int
    if (typeof color === 'number') {
        // Convert JS hex int to CSS hex string
        return '#' + color.toString(16).padStart(6, '0');
    }
    if (typeof color !== 'string') {
        return fallback;
    }
    const normalized = normalizeColorInput(color);
    if (typeof normalized === 'string') {
        color = normalized;
    }
    if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
        return color;  // Already valid CSS color
    }
    try {
        // Convert any valid color to CSS hex string
        const hex = new THREE.Color(color).getHex();
        return '#' + hex.toString(16).padStart(6, '0');
    } catch (err) {
        return fallback;
    }
}

function updateEdgeRanges() {
    const links = (Graph && Graph.graphData().links) ? Graph.graphData().links : [];
    let minWeight = Infinity;
    let maxWeight = -Infinity;
    let minConf = Infinity;
    let maxConf = -Infinity;
    links.forEach(link => {
        const weight = typeof link.weight === 'number' ? link.weight : 1;
        const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
        minWeight = Math.min(minWeight, weight);
        maxWeight = Math.max(maxWeight, weight);
        minConf = Math.min(minConf, confidence);
        maxConf = Math.max(maxConf, confidence);
    });
    EDGE_RANGES = {
        weight: {
            min: isFinite(minWeight) ? minWeight : 1,
            max: isFinite(maxWeight) ? maxWeight : 1
        },
        confidence: {
            min: isFinite(minConf) ? minConf : 1,
            max: isFinite(maxConf) ? maxConf : 1
        }
    };
}

function refreshNodeFileIndex() {
    NODE_FILE_INDEX = new Map();
    const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
    nodes.forEach(node => {
        if (node && node.id) {
            NODE_FILE_INDEX.set(node.id, node.fileIdx ?? -1);
        }
    });
}

function getLinkFileIdx(link, side) {
    const endpoint = link?.[side];
    if (endpoint && typeof endpoint === 'object') {
        return endpoint.fileIdx ?? -1;
    }
    if (endpoint) {
        return NODE_FILE_INDEX.get(endpoint) ?? -1;
    }
    return -1;
}

function normalizeMetric(value, range) {
    // If range is degenerate (all same values), return based on absolute value:
    // - For 0-1 metrics like confidence: return the value itself
    // - This prevents "all low" coloring when all edges have same high confidence
    if (!range || range.max <= range.min) {
        return clamp01(value);
    }
    return clamp01((value - range.min) / (range.max - range.min));
}

function getEdgeColor(link) {
    // 
    // ALL EDGE COLORS NOW COME FROM ColorOrchestrator (aliased as Color)
    // This ensures legend colors match visualization colors exactly
    // OKLCH transforms are applied automatically
    // 

    // NEW GRADIENT MODES (default!)
    if (EDGE_MODE.startsWith('gradient-')) {
        return getGradientEdgeColor(link, EDGE_MODE);
    }

    const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

    if (EDGE_MODE === 'type') {
        return Color.get('edgeType', edgeKey);  // FROM ColorOrchestrator
    }

    if (EDGE_MODE === 'weight') {
        const weight = typeof link.weight === 'number' ? link.weight : 1;
        const t = normalizeMetric(weight, EDGE_RANGES.weight);
        return Color.getInterval('weight', t);  // FROM ColorOrchestrator intervals
    }

    if (EDGE_MODE === 'confidence') {
        const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
        const t = normalizeMetric(confidence, EDGE_RANGES.confidence);
        return Color.getInterval('confidence', t);  // FROM ColorOrchestrator intervals
    }

    if (EDGE_MODE === 'mono') {
        return Color.get('edgeType', 'unknown');  // Neutral from ColorOrchestrator
    }

    // Default: type-based coloring
    return Color.get('edgeType', edgeKey);  // FROM ColorOrchestrator
}

function getEdgeWidth(link) {
    // 
    // EDGE WIDTH: Constrained to narrow range for visual coherence
    // Min: 0.6px, Max: 2.2px - prevents chaotic thin/thick variance
    // 
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;

    // For most modes, return uniform width for visual consistency
    if (EDGE_MODE !== 'weight' && EDGE_MODE !== 'confidence') {
        return BASE_WIDTH;
    }

    // Weight/confidence modes: subtle variation within tight bounds
    let t = 0.5;  // Default middle
    if (EDGE_MODE === 'weight') {
        const weight = typeof link.weight === 'number' ? link.weight : 1;
        t = normalizeMetric(weight, EDGE_RANGES.weight);
    } else if (EDGE_MODE === 'confidence') {
        const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
        t = normalizeMetric(confidence, EDGE_RANGES.confidence);
    }

    // Linear interpolation within tight bounds (no amplifier blowup)
    return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
}

function applyEdgeMode() {
    updateEdgeRanges();
    refreshNodeFileIndex();
    buildFileHueMap();  // Build hue map for gradient-file mode
    if (Graph) {
        Graph.linkColor(link => toColorNumber(getEdgeColor(link), 0x222222));
        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? EDGE_DEFAULT_OPACITY);
            if (fileMode && GRAPH_MODE === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = EDGE_MODE_CONFIG.dim?.interfile_factor ?? 0.25;
                    return baseOpacity * dimFactor;
                }
            }
            return baseOpacity;
        });
        if (!flowMode) {
            Graph.linkWidth(link => getEdgeWidth(link));
        }
    }
}

function cycleEdgeMode() {
    const currentIndex = EDGE_MODE_ORDER.indexOf(EDGE_MODE);
    const nextIndex = (currentIndex + 1) % EDGE_MODE_ORDER.length;
    setEdgeMode(EDGE_MODE_ORDER[nextIndex]);
}

function setEdgeMode(mode) {
    if (!EDGE_MODE_ORDER.includes(mode)) return;
    EDGE_MODE = mode;
    const button = document.getElementById('btn-edge-mode');
    if (button) {
        button.textContent = EDGE_MODE_LABELS[EDGE_MODE] || 'EDGE';
    }
    applyEdgeMode();
    // Update legend to reflect edge mode colors
    if (typeof renderAllLegends === 'function') {
        renderAllLegends();
    }
    // Show mode toast hint
    showModeToast(EDGE_MODE_HINTS[mode] || `Edge mode: ${mode}`);
}

// Datamap toggles are wired in buildDatamapControls().
document.getElementById('btn-report').onclick = () => {
    const panel = document.getElementById('report-panel');
    const btn = document.getElementById('btn-report');
    const isOpen = panel.style.display === 'block';
    panel.style.display = isOpen ? 'none' : 'block';
    btn.classList.toggle('active', !isOpen);
};

// ====================================================================
// STARFIELD TOGGLE: Show/hide background stars (with localStorage)
// ====================================================================
const STARS_STORAGE_KEY = 'collider_stars_visible';

function setStarsVisible(visible) {
    const btn = document.getElementById('btn-stars');
    if (btn) btn.classList.toggle('active', visible);
    if (STARFIELD) {
        STARFIELD.visible = visible;
        STARFIELD.material.opacity = visible ? STARFIELD_OPACITY : 0;
    }
    try {
        localStorage.setItem(STARS_STORAGE_KEY, visible ? '1' : '0');
    } catch (e) { /* localStorage unavailable */ }
}

// Initialize from localStorage (default: visible)
try {
    const stored = localStorage.getItem(STARS_STORAGE_KEY);
    if (stored === '0') {
        // Defer to after STARFIELD is initialized
        setTimeout(() => setStarsVisible(false), 100);
    }
} catch (e) { /* localStorage unavailable */ }

document.getElementById('btn-stars').onclick = () => {
    const btn = document.getElementById('btn-stars');
    const isActive = btn.classList.contains('active');
    setStarsVisible(!isActive);
};

// Reset Layout button - explicitly re-run physics
document.getElementById('btn-reset-layout').onclick = () => {
    resetLayout();
};

// Hints toggle - enable/disable mode toasts
document.getElementById('btn-hints').onclick = () => {
    const btn = document.getElementById('btn-hints');
    HINTS_ENABLED = !HINTS_ENABLED;
    btn.classList.toggle('active', HINTS_ENABLED);
    if (HINTS_ENABLED) {
        showModeToast('Hints enabled');
    }
};

document.getElementById('btn-edge-mode').onclick = () => cycleEdgeMode();

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
let flowMode = false;
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// Callable function for direct invocation (no proxy click needed)
function toggleFlowMode() {
    flowMode = !flowMode;
    const btn = document.getElementById('btn-flow');
    if (btn) btn.classList.toggle('active', flowMode);

    // Show/hide flow legend
    const legend = document.getElementById('flow-legend');
    if (legend) legend.classList.toggle('visible', flowMode);

    if (flowMode) {
        applyFlowVisualization();
        showModeToast('FLOW: edge width = transition probability, particles = direction');
    } else {
        clearFlowVisualization();
        showModeToast('Flow mode off');
    }
}

document.getElementById('btn-flow').onclick = () => toggleFlowMode();

function applyFlowVisualization() {
    const markov = DM ? DM.getMarkov() : {};  // ALL DATA FROM DM
    const highEntropy = markov.high_entropy_nodes || [];

    // Get flow config from tokens (THE REMOTE CONTROL)
    const flowCfg = FLOW_CONFIG || {};
    const highlightColor = flowCfg.highlightColor || '#ff8c00';
    const sizeMult = flowCfg.sizeMultiplier || 1.8;
    const edgeScale = flowCfg.edgeWidthScale || 3.0;  // Increased for visibility
    const particles = flowCfg.particles || {};
    const topK = flowCfg.topKEdges || 3;  // Show only top K outgoing edges per node
    const minWeight = flowCfg.minWeight || 0.1;  // Minimum weight threshold

    // Build set of high entropy node names
    highEntropyNodes.clear();
    highEntropy.forEach(n => highEntropyNodes.add(n.node));

    const graphNodes = Graph.graphData().nodes;
    const graphLinks = Graph.graphData().links;

    // THRESHOLDING: Build a map of top-K outgoing edges per source node
    const edgesBySource = new Map();
    graphLinks.forEach(link => {
        const srcId = typeof link.source === 'object' ? link.source.id : link.source;
        if (!edgesBySource.has(srcId)) {
            edgesBySource.set(srcId, []);
        }
        edgesBySource.get(srcId).push(link);
    });

    // For each source, keep only top-K by markov_weight (transition probability)
    const visibleEdges = new Set();
    edgesBySource.forEach((edges, srcId) => {
        const sorted = edges
            .filter(e => (e.markov_weight || 0) >= minWeight)
            .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
            .slice(0, topK);
        sorted.forEach(e => visibleEdges.add(e));
    });

    // Store original colors and apply flow coloring
    graphNodes.forEach(node => {
        if (!originalNodeColors.has(node.id)) {
            originalNodeColors.set(node.id, node.color);
        }
        // High entropy nodes highlighted (decision points)
        if (highEntropyNodes.has(node.name)) {
            node.color = highlightColor;
            node.val = (node.val || 1) * sizeMult;
        }
    });

    // Update link widths based on markov_weight (with amplification)
    // Find max markov weight for normalization
    const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));

    Graph.linkWidth(link => {
        if (!visibleEdges.has(link)) return 0.1;  // Dim non-top edges
        const mw = link.markov_weight || 0;
        // Normalize to [0,1], then amplify, then scale
        const normalized = mw / maxMarkov;
        const amplified = amplify(normalized);
        // Map to visible width range: 0.5 (min) to edgeScale*2 (max)
        return 0.5 + amplified * edgeScale * 2;
    });

    // Update link opacity to emphasize important edges (with amplification)
    Graph.linkOpacity(link => {
        if (!visibleEdges.has(link)) return 0.05;  // Nearly invisible
        const mw = link.markov_weight || 0;
        const normalized = mw / maxMarkov;
        const amplified = amplify(normalized);
        // Map to opacity range: 0.3 (min visible) to 1.0 (full)
        return 0.3 + amplified * 0.7;
    });

    // Add directional particles only on visible edges
    Graph.linkDirectionalParticles(link => {
        if (!visibleEdges.has(link)) return 0;
        return particles.count || 3;
    });
    Graph.linkDirectionalParticleWidth(particles.width || 2.5);
    Graph.linkDirectionalParticleSpeed(particles.speed || 0.008);
    Graph.linkDirectionalParticleColor(() => '#ffaa00');

    // Update node coloring
    Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

    updateSelectionVisuals();

    // Debug: count edges with markov weights
    const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
    console.log(`Flow mode: ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK} per node), ${edgesWithMarkov}/${graphLinks.length} edges with markov weights`);
}

function clearFlowVisualization() {
    const graphNodes = Graph.graphData().nodes;
    const sizeMult = (FLOW_CONFIG || {}).sizeMultiplier || 1.8;

    // Restore original node colors and sizes
    graphNodes.forEach(node => {
        if (originalNodeColors.has(node.id)) {
            node.color = originalNodeColors.get(node.id);
        }
        // Reset size if it was a high entropy node
        if (highEntropyNodes.has(node.name)) {
            node.val = (node.val || sizeMult) / sizeMult;
        }
    });

    // Reset link widths
    Graph.linkWidth(1);

    // Remove directional particles
    Graph.linkDirectionalParticles(0);

    // Update coloring
    Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

    highEntropyNodes.clear();
    applyEdgeMode();
    updateSelectionVisuals();
}

function setDatamap(prefix) {
    const nextSet = new Set(ACTIVE_DATAMAPS);
    if (!prefix) {
        nextSet.clear();
    } else if (nextSet.has(prefix)) {
        nextSet.delete(prefix);
    } else {
        nextSet.add(prefix);
    }

    if (!DM) {  // ALL DATA FROM DM
        ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, nextSet, VIS_FILTERS);  // DM used internally
    if (!subset.nodes.length) {
        showToast('No nodes for that datamap selection.');
        updateDatamapControls();
        return;
    }

    ACTIVE_DATAMAPS = nextSet;
    updateDatamapControls();
    refreshGraph();
}

function setNodeColorMode(mode) {
    NODE_COLOR_MODE = mode;
    // Update legend to reflect current color mode
    if (typeof renderAllLegends === 'function') {
        renderAllLegends();
    }
    refreshGraph();
    // Refresh gradient edges to reflect new node colors
    if (typeof window.refreshGradientEdgeColors === 'function') {
        window.refreshGradientEdgeColors();
    }
}

function applyDatamap(prefix) {
    setDatamap(prefix);
}

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

function hashToUnit(value) {
    const str = String(value || '');
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
    }
    return (hash >>> 0) / 0xffffffff;
}

function getFileHue(fileIdx, totalFiles, fileName) {
    const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
    if (strategy === 'sequential') {
        const denom = Math.max(1, totalFiles);
        return (fileIdx / denom) * 360;
    }
    if (strategy === 'hash') {
        const seed = fileName || String(fileIdx);
        return hashToUnit(seed) * 360;
    }
    const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
    return (fileIdx * angle) % 360;
}

function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
    const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
    const lightness = (lightnessOverride !== null)
        ? lightnessOverride
        : (FILE_COLOR_CONFIG.lightness ?? 50);
    const hue = getFileHue(fileIdx, totalFiles, fileName);
    if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
        return oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
    }
    const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
    const adjustedLightness = clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
    return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
}

// Track last hovered node to avoid unnecessary re-renders
// (variable declared early at top of file to avoid TDZ)

function updateHoverPanel(node) {
    const hoverPanel = document.getElementById('hover-panel');
    if (!hoverPanel) return;

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (_lastHoveredNodeId === null) {
                hoverPanel.classList.remove('visible');
            }
        }, 200);
        _lastHoveredNodeId = null;
        return;
    }

    // Only update if node changed (performance)
    const nodeId = node.id || node.name || '';
    if (nodeId === _lastHoveredNodeId) return;
    _lastHoveredNodeId = nodeId;

    // Update hover panel content with canonical taxonomy fields
    document.getElementById('hover-name').textContent = node.name || node.id || 'Unknown';
    document.getElementById('hover-kind').textContent = node.kind || node.symbol_kind || 'node';
    document.getElementById('hover-atom').textContent = node.atom || '--';
    document.getElementById('hover-family').textContent = getNodeAtomFamily(node);
    document.getElementById('hover-ring').textContent = getNodeRing(node);
    document.getElementById('hover-tier').textContent = getNodeTier(node);
    document.getElementById('hover-role').textContent = node.role || '--';

    // Show file path (truncated if long)
    const filePath = node.file_path || node.file || '';
    const shortPath = filePath.length > 50 ? '...' + filePath.slice(-47) : filePath;
    document.getElementById('hover-file').textContent = shortPath || '--';

    // Show panel and trigger smart placement
    hoverPanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function buildDatasetKey(data) {
    const meta = (data && data.meta) ? data.meta : {};
    const target = meta.target || meta.project || 'dataset';
    const version = meta.version || '';
    const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const edgeCount = Array.isArray(data?.links)
        ? data.links.length
        : (Array.isArray(data?.edges) ? data.edges.length : 0);
    const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
    return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
}

function loadGroups() {
    GROUPS = [];
    try {
        const stored = localStorage.getItem(GROUPS_STORAGE_KEY);
        if (stored) {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed)) {
                GROUPS = parsed;
            }
        }
    } catch (e) {
        // localStorage unavailable
    }
    GROUPS = GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
    GROUPS.forEach(group => {
        if (group.visible === undefined) group.visible = true;
    });
}

function saveGroups() {
    try {
        localStorage.setItem(GROUPS_STORAGE_KEY, JSON.stringify(GROUPS));
    } catch (e) {
        // localStorage unavailable
    }
}

function getNextGroupColor() {
    const hue = (GROUPS.length * 137.5) % 360;
    return hslColor(hue, 65, 55);
}

function getGroupById(groupId) {
    return GROUPS.find(group => group.id === groupId) || null;
}

function getPrimaryGroupForNode(nodeId) {
    const visibleGroups = GROUPS.filter(group =>
        group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
    );
    if (!visibleGroups.length) return null;
    if (ACTIVE_GROUP_ID) {
        const active = visibleGroups.find(group => group.id === ACTIVE_GROUP_ID);
        if (active) return active;
    }
    return visibleGroups[0];
}

function renderGroupList() {
    const container = document.getElementById('group-list');
    if (!container) return;
    container.innerHTML = '';

    if (!GROUPS.length) {
        const empty = document.createElement('div');
        empty.style.fontSize = '9px';
        empty.style.color = 'rgba(255,255,255,0.4)';
        empty.textContent = 'No groups yet';
        container.appendChild(empty);
        return;
    }

    GROUPS.forEach(group => {
        const row = document.createElement('div');
        row.className = 'group-item';
        row.classList.toggle('active', group.id === ACTIVE_GROUP_ID);

        const dot = document.createElement('span');
        dot.className = 'group-color';
        dot.style.background = group.color || '#6fe8ff';

        const name = document.createElement('span');
        name.className = 'group-name';
        name.textContent = group.name || 'Group';

        const count = document.createElement('span');
        count.className = 'group-count';
        count.textContent = String((group.node_ids || []).length);

        const toggle = document.createElement('input');
        toggle.type = 'checkbox';
        toggle.className = 'group-toggle';
        toggle.checked = group.visible !== false;
        toggle.onchange = (e) => {
            e.stopPropagation();
            group.visible = toggle.checked;
            saveGroups();
            updateSelectionVisuals();
            renderGroupList();
        };

        row.onclick = (e) => {
            if (e.target === toggle) return;
            ACTIVE_GROUP_ID = group.id;
            renderGroupList();
            setSelection(group.node_ids || []);
            updateSelectionVisuals();
        };

        row.appendChild(dot);
        row.appendChild(name);
        row.appendChild(count);
        row.appendChild(toggle);
        container.appendChild(row);
    });
}

function updateGroupButtonState() {
    const btn = document.getElementById('btn-create-group');
    if (!btn) return;
    const hasSelection = SELECTED_NODE_IDS.size > 0;
    btn.classList.toggle('disabled', !hasSelection);
    btn.disabled = !hasSelection;
}

function createGroupFromSelection() {
    if (SELECTED_NODE_IDS.size === 0) return;
    const nodeIds = Array.from(SELECTED_NODE_IDS);
    const groupId = `group_${Date.now().toString(36)}`;
    const groupName = `Group ${GROUPS.length + 1}`;
    const groupColor = getNextGroupColor();
    GROUPS.push({
        id: groupId,
        name: groupName,
        color: groupColor,
        node_ids: nodeIds,
        visible: true
    });
    ACTIVE_GROUP_ID = groupId;
    saveGroups();
    renderGroupList();
    updateSelectionVisuals();
    showToast(`Created ${groupName} (${nodeIds.length})`);
}

function getSelectedNodes() {
    if (!Graph || !Graph.graphData) return [];
    const nodes = Graph.graphData().nodes || [];
    return nodes.filter(node => node && node.id && SELECTED_NODE_IDS.has(node.id));
}

function setSelection(ids, additive = false) {
    if (!additive) {
        SELECTED_NODE_IDS.clear();
    }
    (ids || []).forEach(id => {
        if (id) SELECTED_NODE_IDS.add(id);
    });
    updateSelectionPanel();
    updateSelectionVisuals();
    updateGroupButtonState();
}

function toggleSelection(node) {
    if (!node || !node.id) return;
    if (SELECTED_NODE_IDS.has(node.id)) {
        SELECTED_NODE_IDS.delete(node.id);
    } else {
        SELECTED_NODE_IDS.add(node.id);
    }
    updateSelectionPanel();
    updateSelectionVisuals();
    updateGroupButtonState();
}

function clearSelection() {
    SELECTED_NODE_IDS.clear();
    updateSelectionPanel();
    updateSelectionVisuals();
    updateGroupButtonState();
}

function maybeClearSelection() {
    const now = Date.now();
    if (MARQUEE_ACTIVE) return;
    if (now - LAST_MARQUEE_END_TS < 250) return;
    clearSelection();
}

function formatCountList(items, limit = 4) {
    return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join('  ') || '--';
}

function appendSelectionRow(container, label, value) {
    const row = document.createElement('div');
    row.className = 'selection-row';
    const labelEl = document.createElement('span');
    labelEl.className = 'label';
    labelEl.textContent = label;
    const valueEl = document.createElement('span');
    valueEl.textContent = value || '--';
    row.appendChild(labelEl);
    row.appendChild(valueEl);
    container.appendChild(row);
}

function updateSelectionPanel() {
    const panel = document.getElementById('selection-panel');
    const body = document.getElementById('selection-body');
    const title = document.getElementById('selection-title');
    if (!panel || !body) return;

    const nodes = getSelectedNodes();
    if (!nodes.length) {
        panel.classList.remove('visible');
        body.innerHTML = '';
        return;
    }

    panel.classList.add('visible');
    if (title) title.textContent = `SELECTION (${nodes.length})`;
    body.innerHTML = '';

    if (nodes.length <= 3) {
        nodes.forEach(node => {
            const item = document.createElement('div');
            item.className = 'selection-item';
            const name = document.createElement('div');
            name.className = 'selection-name';
            name.textContent = node.name || node.id || 'Unknown';
            item.appendChild(name);
            appendSelectionRow(item, 'Family', getNodeAtomFamily(node));
            appendSelectionRow(item, 'Ring', getNodeRing(node));
            appendSelectionRow(item, 'Tier', getNodeTier(node));
            appendSelectionRow(item, 'Role', node.role || '--');
            const filePath = node.file_path || node.file || '';
            if (filePath) {
                const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                appendSelectionRow(item, 'File', shortPath);
            }
            body.appendChild(item);
        });
    } else {
        const summary = document.createElement('div');
        summary.className = 'selection-summary';

        const families = collectCounts(nodes, n => getNodeAtomFamily(n));
        const rings = collectCounts(nodes, n => getNodeRing(n));
        const tiers = collectCounts(nodes, n => getNodeTier(n));

        const total = document.createElement('div');
        total.textContent = `Total: ${nodes.length} nodes`;
        summary.appendChild(total);

        const familyRow = document.createElement('div');
        familyRow.textContent = `Family: ${formatCountList(families)}`;
        summary.appendChild(familyRow);

        const ringRow = document.createElement('div');
        ringRow.textContent = `Ring: ${formatCountList(rings)}`;
        summary.appendChild(ringRow);

        const tierRow = document.createElement('div');
        tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
        summary.appendChild(tierRow);

        const numericKeys = [
            ['tokens', 'TOKENS'],
            ['bytes', 'BYTES'],
            ['loc', 'LOC'],
            ['lines', 'LINES'],
            ['lines_of_code', 'LOC'],
            ['size', 'SIZE']
        ];
        const totals = {};
        nodes.forEach(node => {
            numericKeys.forEach(([key]) => {
                const value = Number(node[key]);
                if (Number.isFinite(value)) {
                    totals[key] = (totals[key] || 0) + value;
                }
            });
        });
        numericKeys.forEach(([key, label]) => {
            if (totals[key]) {
                const row = document.createElement('div');
                row.textContent = `${label}: ${Math.round(totals[key])}`;
                summary.appendChild(row);
            }
        });

        body.appendChild(summary);
    }

    HudLayoutManager.reflow();
}

// 
// SELECTION DETAIL MODAL: Consolidated view of selected nodes
// 
function showSelectionModal() {
    const nodes = getSelectedNodes();
    if (!nodes.length) {
        showToast('No nodes selected');
        return;
    }

    const overlay = document.getElementById('selection-modal-overlay');
    const title = document.getElementById('selection-modal-title');
    const statsContainer = document.getElementById('selection-modal-stats');
    const body = document.getElementById('selection-modal-body');

    if (!overlay || !body) return;

    // Calculate aggregates
    let totalTokens = 0, totalBytes = 0, totalLoc = 0;
    const tierCounts = {};
    const ringCounts = {};
    const familyCounts = {};
    const levelCounts = {};

    nodes.forEach(node => {
        totalTokens += Number(node.tokens) || 0;
        totalBytes += Number(node.bytes) || 0;
        totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

        const tier = getNodeTier(node);
        const ring = getNodeRing(node);
        const family = getNodeAtomFamily(node);
        const level = node.level || node.scale_level || 'L3';

        tierCounts[tier] = (tierCounts[tier] || 0) + 1;
        ringCounts[ring] = (ringCounts[ring] || 0) + 1;
        familyCounts[family] = (familyCounts[family] || 0) + 1;
        levelCounts[level] = (levelCounts[level] || 0) + 1;
    });

    // Calculate max relevance for normalization
    const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

    // Update title
    title.textContent = `SELECTED NODES (${nodes.length})`;

    // Build stats bar
    statsContainer.innerHTML = '';
    const stats = [
        ['NODES', nodes.length.toLocaleString()],
        ['TOKENS', totalTokens.toLocaleString()],
        ['BYTES', totalBytes.toLocaleString()],
        ['LOC', totalLoc.toLocaleString()],
        ['TIERS', Object.keys(tierCounts).join(', ')],
        ['FAMILIES', Object.keys(familyCounts).length]
    ];
    stats.forEach(([label, value]) => {
        if (value && value !== '0') {
            const stat = document.createElement('div');
            stat.className = 'selection-modal-stat';
            stat.innerHTML = `
                        <span class="selection-modal-stat-label">${label}</span>
                        <span class="selection-modal-stat-value">${value}</span>
                    `;
            statsContainer.appendChild(stat);
        }
    });

    // Build table
    const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

    body.innerHTML = `
                <table class="selection-modal-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Tier</th>
                            <th>Ring</th>
                            <th>Family</th>
                            <th>Level</th>
                            <th>Tokens</th>
                            <th>LOC</th>
                            <th>Relevance</th>
                        </tr>
                    </thead>
                    <tbody id="selection-modal-tbody"></tbody>
                </table>
            `;

    const tbody = document.getElementById('selection-modal-tbody');
    sortedNodes.forEach(node => {
        const tier = getNodeTier(node);
        const ring = getNodeRing(node);
        const family = getNodeAtomFamily(node);
        const level = node.level || node.scale_level || 'L3';
        const tokens = Number(node.tokens) || '--';
        const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
        const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

        const row = document.createElement('tr');
        row.innerHTML = `
                    <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                    <td><span class="level-badge tier-badge">${tier}</span></td>
                    <td><span class="level-badge ring-badge">${ring}</span></td>
                    <td><span class="level-badge family-badge">${family}</span></td>
                    <td>${level}</td>
                    <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                    <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                    <td>
                        <div class="relevance-bar">
                            <div class="relevance-fill" style="width: ${relevance}%"></div>
                        </div>
                    </td>
                `;
        tbody.appendChild(row);
    });

    // Show modal
    overlay.classList.add('visible');
}

function hideSelectionModal() {
    const overlay = document.getElementById('selection-modal-overlay');
    if (overlay) overlay.classList.remove('visible');
}

function initSelectionModal() {
    const overlay = document.getElementById('selection-modal-overlay');
    const closeBtn = document.getElementById('selection-modal-close');
    const selectionTitle = document.getElementById('selection-title');

    if (closeBtn) {
        closeBtn.addEventListener('click', hideSelectionModal);
    }

    if (overlay) {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) hideSelectionModal();
        });
    }

    // Click on selection panel title to open modal
    if (selectionTitle) {
        selectionTitle.style.cursor = 'pointer';
        selectionTitle.addEventListener('click', showSelectionModal);
    }

    // Keyboard shortcut: 'i' for info when nodes selected
    document.addEventListener('keydown', (e) => {
        if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
            if (getSelectedNodes().length > 0) {
                e.preventDefault();
                showSelectionModal();
            }
        }
        if (e.key === 'Escape') {
            hideSelectionModal();
        }
    });
}

function updateOverlayScale(node) {
    const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE.nodeScale || 1));
    const selectionScale = base * 2.5;  // BIGGER halo - was 1.9
    const groupScale = base * 1.8;      // Slightly bigger group halo
    if (node.__selectionHalo) {
        node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
    }
    if (node.__groupHalo) {
        node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
    }
}

function ensureNodeOverlays(node) {
    if (!node) return null;
    if (node.__overlayGroup) return node.__overlayGroup;

    const group = new THREE.Group();

    const selectionMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,      // BRIGHT CYAN - unmissable!
        transparent: true,
        opacity: 0.85,        // MUCH BRIGHTER - was 0.35
        depthWrite: false
    });
    const selectionHalo = new THREE.Mesh(SELECTION_HALO_GEOMETRY, selectionMaterial);
    selectionHalo.visible = false;
    selectionHalo.renderOrder = 3;

    const groupMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.45,        // BRIGHTER - was 0.18
        depthWrite: false
    });
    const groupHalo = new THREE.Mesh(GROUP_HALO_GEOMETRY, groupMaterial);
    groupHalo.visible = false;
    groupHalo.renderOrder = 2;

    group.add(selectionHalo);
    group.add(groupHalo);

    node.__selectionHalo = selectionHalo;
    node.__groupHalo = groupHalo;
    node.__overlayGroup = group;
    return group;
}

// Store original colors/sizes for selection restore
// (selectionOriginals declared early at top of file to avoid TDZ)
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// 
// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
// Two coupled pendulums creating organic color movement in 3D color space
// 
const PENDULUM = {
    // Pendulum 1: Controls HUE (FULL RAINBOW - dramatic cycling!)
    hue: {
        angle: Math.random() * Math.PI * 2,  // Random start
        velocity: 0,
        damping: 0.9995,      // Very low damping for perpetual motion (Token Default)
        gravity: 0.0008,     // Stronger gravity = faster oscillations
        length: 1.0,
        rotationSpeed: 0.8   // Base rotation speed
    },
    // Pendulum 2: Controls CHROMA (DRAMATIC VIBRANCE!)
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: 0.998,
        gravity: 0.0004,
        length: 1.0,
        center: 0.32,        // High saturation center
        amplitude: 0.08      // Vibrance variation
    },
    // Lightness for SELECTED nodes (SUBTLE RIPPLE)
    lightness: {
        phase: 0,
        speed: 0.02,
        center: 82,          // Bright center
        amplitude: 10        // Pulse amplitude
    },
    // Ripple effect
    ripple: {
        speed: 0.035,
        scale: 200
    },
    // Current hue (continuous rotation)
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};

// Initialize from Config (if available)
// We call this immediately to load overrides from the graph data
if (typeof graph !== 'undefined' && graph.appearance && graph.appearance.animation) {
    const cfg = graph.appearance.animation;
    if (cfg.hue) Object.assign(PENDULUM.hue, cfg.hue);
    if (cfg.chroma) Object.assign(PENDULUM.chroma, cfg.chroma);
    if (cfg.lightness) Object.assign(PENDULUM.lightness, cfg.lightness);
    if (cfg.ripple) Object.assign(PENDULUM.ripple, cfg.ripple);
    console.log("Animation Config Loaded:", PENDULUM);
}

// Store original colors for dimming non-selected nodes
// NOTE: originalColorsForDim declared at top of file

// OKLCH to sRGB conversion (simplified, clamped)
function oklchToHex(L, C, H) {
    // Convert OKLCH to OKLab
    const hRad = H * Math.PI / 180;
    const a = C * Math.cos(hRad);
    const b = C * Math.sin(hRad);

    // OKLab to linear sRGB (approximate)
    const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

    const l = l_ * l_ * l_;
    const m = m_ * m_ * m_;
    const s = s_ * s_ * s_;

    // Linear sRGB
    let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
    let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
    let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    // Gamma correction & clamp
    const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    let rOut = Math.round(gamma(rLin) * 255);
    let gOut = Math.round(gamma(gLin) * 255);
    let bOut = Math.round(gamma(bLin) * 255);

    // Clamp to valid range
    rOut = Math.max(0, Math.min(255, rOut));
    gOut = Math.max(0, Math.min(255, gOut));
    bOut = Math.max(0, Math.min(255, bOut));

    return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
}

function updatePendulums(dt) {
    const p1 = PENDULUM.hue;
    const p2 = PENDULUM.chroma;

    // Pendulum 1: Modulates the SPEED of hue rotation (organic variation)
    const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
    p1.velocity += accel1 * dt;
    p1.velocity *= p1.damping;
    p1.angle += p1.velocity * dt;

    // Hue rotates CONTINUOUSLY through full rainbow!
    // Pendulum modulates the speed for organic feel
    const speedMod = 1 + Math.sin(p1.angle) * 0.5;  // 0.5x to 1.5x speed
    PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

    // Pendulum 2: Controls chroma with coupling to hue pendulum
    const coupling = 0.00015 * Math.sin(p1.angle);
    const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
    p2.velocity += accel2 * dt;
    p2.velocity *= p2.damping;
    p2.angle += p2.velocity * dt;

    // Update lightness phase (pulsing brightness)
    PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
}

// Get selection color with optional spatial phase offset
// Brightness reduced 17% from original (center 62 instead of 75)
// Get selection color with optional spatial phase offset
// Dynamic brightness/chroma based on PENDULUM config
function getSelectionColor(phaseOffset = 0) {
    const p2 = PENDULUM.chroma;
    const p3 = PENDULUM.lightness;

    // Full rainbow hue (continuous rotation) + Ripple offset (45 degrees spread)
    const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;

    // Chroma with gentle spatial variation (Ripple)
    const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);

    // Bright lightness with Ripple pulse
    const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

    return oklchToHex(L, C, H);
}

// Calculate spatial phase for RIPPLE EFFECT based on distance from center
function getNodeSpatialPhase(node) {
    const x = node.x || 0;
    const y = node.y || 0;
    const z = node.z || 0;

    // Calculate distance from origin (radial ripple)
    const distance = Math.sqrt(x * x + y * y + z * z);

    // Normalize distance to create concentric ripples
    // Ripples expand outward from center
    const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
    const ripplePhase = (distance / scale) % 1;

    // Add subtle angular variation for more organic feel
    const angle = Math.atan2(y, x);
    const angularOffset = Math.sin(angle * 3) * 0.1;  // Subtle angular modulation

    return (ripplePhase + angularOffset + 1) % 1;
}

// Dim a color by reducing its lightness (for non-selected nodes)
function dimColor(hexColor, factor = 0.33) {
    // Simple approach: reduce RGB values
    const hex = hexColor.replace('#', '');
    const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
    const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
    const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
    return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
}

function animateSelectionColors(timestamp) {
    if (!PENDULUM.running) return;

    const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
    PENDULUM.lastTime = timestamp;

    // Update physics
    updatePendulums(dt);

    // Apply color to selected nodes with SPATIAL VARIATION
    // Each node gets a different phase based on its position
    if (SELECTED_NODE_IDS.size > 0 && Graph && Graph.graphData) {
        const nodes = Graph.graphData().nodes || [];

        nodes.forEach(node => {
            if (SELECTED_NODE_IDS.has(node.id)) {
                // SELECTED: Rainbow color with spatial phase offset
                // Different regions of the selection pulse at different phases
                const spatialPhase = getNodeSpatialPhase(node);
                node.color = getSelectionColor(spatialPhase);
            }
            // Non-selected nodes stay dimmed (set in updateSelectionVisuals)
        });

        Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
    }

    requestAnimationFrame(animateSelectionColors);
}

function startSelectionAnimation() {
    if (!PENDULUM.running) {
        PENDULUM.running = true;
        // Give pendulums initial push
        PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
        PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
        PENDULUM.lastTime = 0;
        requestAnimationFrame(animateSelectionColors);
    }
}

function stopSelectionAnimation() {
    PENDULUM.running = false;
}

function updateSelectionVisuals() {
    if (!Graph || !Graph.graphData) return;
    const nodes = Graph.graphData().nodes || [];
    const hasSelection = SELECTED_NODE_IDS.size > 0;

    nodes.forEach(node => {
        const isSelected = SELECTED_NODE_IDS.has(node.id);

        // Save original color/size for ALL nodes when selection starts
        if (hasSelection && !originalColorsForDim.has(node.id)) {
            originalColorsForDim.set(node.id, {
                color: node.color,
                val: node.val || 1
            });
        }

        // Also track selected nodes separately for size restore
        if (isSelected && !selectionOriginals.has(node.id)) {
            selectionOriginals.set(node.id, {
                color: node.color,
                val: node.val || 1
            });
        }

        // Apply styling based on selection state
        if (hasSelection) {
            if (isSelected) {
                // SELECTED: Make bigger, color will be animated
                const orig = selectionOriginals.get(node.id);
                node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
            } else {
                // NOT SELECTED: Dim by 33%
                const orig = originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = dimColor(orig.color, 0.33);
                }
            }
        } else {
            // NO SELECTION: Restore all original colors and sizes
            if (originalColorsForDim.has(node.id)) {
                const orig = originalColorsForDim.get(node.id);
                node.color = orig.color;
                node.val = orig.val;
            }
            if (selectionOriginals.has(node.id)) {
                const orig = selectionOriginals.get(node.id);
                node.color = orig.color;
                node.val = orig.val;
                selectionOriginals.delete(node.id);
            }
        }

        // Also update overlays (halos)
        ensureNodeOverlays(node);
        updateOverlayScale(node);
        if (node.__selectionHalo) {
            node.__selectionHalo.visible = isSelected;
        }
        if (node.__groupHalo) {
            const group = getPrimaryGroupForNode(node.id);
            if (group) {
                node.__groupHalo.visible = group.visible !== false;
                node.__groupHalo.material.color.set(group.color || '#88d0ff');
                node.__groupHalo.material.opacity =
                    (group.id === ACTIVE_GROUP_ID) ? 0.7 : 0.45;
            } else {
                node.__groupHalo.visible = false;
            }
        }
    });

    // Clear dim cache when no selection
    if (!hasSelection) {
        originalColorsForDim.clear();
    }

    // Start/stop animation based on selection state
    if (hasSelection) {
        startSelectionAnimation();
    } else {
        stopSelectionAnimation();
    }

    // Force re-render with new colors
    Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
}

function syncSelectionAfterGraphUpdate() {
    if (!Graph || !Graph.graphData) return;
    const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
    let changed = false;
    Array.from(SELECTED_NODE_IDS).forEach(id => {
        if (!visibleIds.has(id)) {
            SELECTED_NODE_IDS.delete(id);
            changed = true;
        }
    });
    if (changed) {
        updateSelectionPanel();
    }
    updateSelectionVisuals();
    updateGroupButtonState();
}

function updateSelectionBox(rect) {
    if (!SELECTION_BOX) return;
    SELECTION_BOX.style.display = 'block';
    SELECTION_BOX.style.left = `${rect.left}px`;
    SELECTION_BOX.style.top = `${rect.top}px`;
    SELECTION_BOX.style.width = `${rect.width}px`;
    SELECTION_BOX.style.height = `${rect.height}px`;
}

function getBoxRect(start, end) {
    const left = Math.min(start.x, end.x);
    const top = Math.min(start.y, end.y);
    const width = Math.abs(start.x - end.x);
    const height = Math.abs(start.y - end.y);
    return {
        left,
        top,
        width,
        height,
        right: left + width,
        bottom: top + height
    };
}

function getNodeScreenPosition(node) {
    if (!Graph || !Graph.camera || !node) return null;
    if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
    const camera = Graph.camera();
    const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
    vector.project(camera);
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
    return { x, y };
}

function selectNodesInBox(rect, additive = true) {
    if (!Graph || !Graph.graphData) return;
    const nodes = Graph.graphData().nodes || [];
    const selected = [];
    nodes.forEach(node => {
        const pos = getNodeScreenPosition(node);
        if (!pos) return;
        if (pos.x >= rect.left && pos.x <= rect.right &&
            pos.y >= rect.top && pos.y <= rect.bottom) {
            if (node.id) selected.push(node.id);
        }
    });
    if (selected.length) {
        setSelection(selected, additive);
    }
}

function setupSelectionInteractions() {
    const clearBtn = document.getElementById('selection-clear');
    if (clearBtn) {
        clearBtn.onclick = () => clearSelection();
    }

    const groupBtn = document.getElementById('btn-create-group');
    if (groupBtn) {
        groupBtn.onclick = () => createGroupFromSelection();
    }

    SELECTION_BOX = document.getElementById('selection-box');
    if (!Graph || !Graph.renderer || !SELECTION_BOX) return;

    const canvas = Graph.renderer().domElement;
    if (!canvas) return;

    const onPointerDown = (e) => {
        // Left-drag = marquee selection (space+drag reserved for pan)
        if (e.button !== 0) return;
        if (SPACE_PRESSED) return;
        if (e.target !== canvas) return;
        if (HOVERED_NODE) return;
        MARQUEE_ACTIVE = true;
        MARQUEE_ADDITIVE = !!e.shiftKey;
        MARQUEE_START = { x: e.clientX, y: e.clientY };
        updateSelectionBox(getBoxRect(MARQUEE_START, MARQUEE_START));
        if (Graph.controls()) {
            Graph.controls().enabled = false;
        }
        e.preventDefault();
    };

    const onPointerMove = (e) => {
        if (!MARQUEE_ACTIVE || !MARQUEE_START) return;
        updateSelectionBox(getBoxRect(MARQUEE_START, { x: e.clientX, y: e.clientY }));
    };

    const finishSelection = (e) => {
        if (!MARQUEE_ACTIVE || !MARQUEE_START) return;
        const rect = getBoxRect(MARQUEE_START, { x: e.clientX, y: e.clientY });
        SELECTION_BOX.style.display = 'none';
        const additive = MARQUEE_ADDITIVE;
        MARQUEE_ACTIVE = false;
        MARQUEE_START = null;
        MARQUEE_ADDITIVE = false;
        if (Graph.controls()) {
            Graph.controls().enabled = true;
        }
        const didDrag = rect.width > 4 && rect.height > 4;
        if (didDrag) {
            LAST_MARQUEE_END_TS = Date.now();
            selectNodesInBox(rect, additive);
        }
    };

    canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
    canvas.addEventListener('pointermove', onPointerMove, { passive: true });
    canvas.addEventListener('pointerup', finishSelection, { passive: true });
    canvas.addEventListener('pointerleave', finishSelection, { passive: true });
}

function initSelectionState(data) {
    DATASET_KEY = buildDatasetKey(data);
    GROUPS_STORAGE_KEY = `collider_groups_${DATASET_KEY}`;
    loadGroups();
    renderGroupList();
    updateSelectionPanel();
    updateGroupButtonState();
}

function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content
    document.getElementById('file-name').textContent = fileInfo.file_name || 'unknown';
    document.getElementById('file-cohesion').textContent =
        `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`;
    document.getElementById('file-purpose').textContent = fileInfo.purpose || '--';
    document.getElementById('file-atom-count').textContent = fileInfo.atom_count || 0;
    document.getElementById('file-lines').textContent =
        fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--';
    document.getElementById('file-classes').textContent =
        (fileInfo.classes || []).join(', ') || 'none';
    document.getElementById('file-functions').textContent =
        'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none');

    // Show code preview from node body
    const code = node.body || '// no source available';
    document.getElementById('file-code').textContent = code;

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}

function toggleFileExpand(fileIdx) {
    if (!Number.isFinite(fileIdx)) return;
    captureFileNodePositions();
    const fileInfo = DM ? DM.getFile(fileIdx) : {};  // ALL DATA FROM DM
    const fileLabel = fileInfo?.file_name || fileInfo?.file || `file-${fileIdx}`;
    if (EXPANDED_FILES.has(fileIdx)) {
        EXPANDED_FILES.delete(fileIdx);
        showToast(`Collapsed ${fileLabel}`);
    } else {
        EXPANDED_FILES.clear();
        EXPANDED_FILES.add(fileIdx);
        showToast(`Expanded ${fileLabel}`);
    }
    GRAPH_MODE = (EXPANDED_FILES.size > 0) ? 'hybrid' : 'files';
    refreshGraph();
}

function sampleFileNodes(nodes, maxPoints) {
    if (nodes.length <= maxPoints) return nodes;
    const step = Math.ceil(nodes.length / maxPoints);
    return nodes.filter((_, idx) => idx % step === 0);
}

function buildHull2D(points) {
    if (points.length < 3) return null;
    const unique = new Map();
    points.forEach(p => {
        const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
        if (!unique.has(key)) unique.set(key, p);
    });
    const pts = Array.from(unique.values()).sort((a, b) => {
        if (a.x === b.x) return a.y - b.y;
        return a.x - b.x;
    });
    if (pts.length < 3) return null;
    const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
    const lower = [];
    for (const p of pts) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
            lower.pop();
        }
        lower.push(p);
    }
    const upper = [];
    for (let i = pts.length - 1; i >= 0; i--) {
        const p = pts[i];
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
            upper.pop();
        }
        upper.push(p);
    }
    upper.pop();
    lower.pop();
    return lower.concat(upper);
}

function computeCentroid(points) {
    const centroid = new THREE.Vector3();
    points.forEach(p => centroid.add(p));
    return centroid.divideScalar(Math.max(1, points.length));
}

function quantile(values, q) {
    if (!values.length) return 0;
    const sorted = values.slice().sort((a, b) => a - b);
    const pos = (sorted.length - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    if (sorted[base + 1] !== undefined) {
        return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
    }
    return sorted[base];
}

function drawFileBoundaries(data) {
    // ALL DATA FROM DM - the rendering pipeline
    let drawn = 0;
    const boundaryConfig = data?.appearance?.boundary || {};
    const fillOpacity =
        (typeof APPEARANCE_STATE.boundaryFill === 'number')
            ? APPEARANCE_STATE.boundaryFill
            : (boundaryConfig.fill_opacity || 0.08);
    const wireOpacity =
        (typeof APPEARANCE_STATE.boundaryWire === 'number')
            ? APPEARANCE_STATE.boundaryWire
            : (boundaryConfig.wire_opacity || 0.3);
    const padding = boundaryConfig.padding || 1.2;
    const minExtent = boundaryConfig.min_extent || 6;
    const quantileRange = boundaryConfig.quantile || 0.9;
    const lowQ = Math.max(0, (1 - quantileRange) / 2);
    const highQ = Math.min(1, 1 - lowQ);
    const boundaryPhysics = data?.physics?.boundary || {};
    const hullType = String(boundaryPhysics.hullType || 'convex').toLowerCase();
    const fileBoundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const totalFiles = fileBoundaries.length;

    const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
    const scene = Graph.scene();

    // Clear existing boundary meshes
    fileBoundaryMeshes.forEach(mesh => scene.remove(mesh));
    fileBoundaryMeshes = [];

    if (!fileMode) return drawn;

    // Group nodes by file (only use nodes with stable positions)
    const fileGroups = {};
    const validNodes = graphNodes.filter(node => {
        if (!node) return false;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return false;
        if (IS_3D && !Number.isFinite(node.z)) return false;
        return true;
    });

    if (!validNodes.length) return drawn;

    validNodes.forEach(node => {
        const idx = node.fileIdx;
        if (idx >= 0) {
            if (!fileGroups[idx]) fileGroups[idx] = [];
            fileGroups[idx].push(node);
        }
    });

    // Draw boundary for each file group
    Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
        const sampled = sampleFileNodes(nodes, 180);
        const xs = sampled.map(n => n.x || 0);
        const ys = sampled.map(n => n.y || 0);
        const zs = sampled.map(n => n.z || 0);

        const minX = quantile(xs, lowQ);
        const maxX = quantile(xs, highQ);
        const minY = quantile(ys, lowQ);
        const maxY = quantile(ys, highQ);
        const minZ = quantile(zs, lowQ);
        const maxZ = quantile(zs, highQ);

        const filtered = sampled.filter(n => {
            const x = n.x || 0;
            const y = n.y || 0;
            const z = n.z || 0;
            return x >= minX && x <= maxX && y >= minY && y <= maxY && z >= minZ && z <= maxZ;
        });
        const hullNodes = filtered.length >= 3 ? filtered : sampled;
        const positions = hullNodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
        const centroid = computeCentroid(positions);
        const zRange = maxZ - minZ;
        const extentX = Math.max(0.001, maxX - minX);
        const extentY = Math.max(0.001, maxY - minY);
        const extentZ = Math.max(0.001, maxZ - minZ);
        const scaleFixX = Math.max(1, minExtent / extentX);
        const scaleFixY = Math.max(1, minExtent / extentY);
        const scaleFixZ = IS_3D ? Math.max(1, minExtent / extentZ) : 1;
        const scaleX = padding * scaleFixX;
        const scaleY = padding * scaleFixY;
        const scaleZ = padding * scaleFixZ;
        const sizeX = extentX * scaleX;
        const sizeY = extentY * scaleY;
        const sizeZ = extentZ * scaleZ;

        const fileIndex = Number.parseInt(fileIdx, 10);
        const safeFileIdx = Number.isFinite(fileIndex) ? fileIndex : 0;
        const fileInfo = (data.file_boundaries || [])[safeFileIdx] || {};
        const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
        const color = new THREE.Color(
            getFileColor(safeFileIdx, totalFiles, fileLabel)
        );

        let mesh = null;
        let wireMesh = null;

        if (nodes.length < 3) {
            const rawPositions = nodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
            const smallCentroid = computeCentroid(rawPositions);
            const maxRadius = rawPositions.reduce((acc, p) => {
                return Math.max(acc, p.distanceTo(smallCentroid));
            }, 0);
            const bubbleRadius = Math.max(minExtent * 0.5, maxRadius + minExtent * 0.35);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: fillOpacity,
                wireframe: false,
                side: THREE.DoubleSide
            });
            if (IS_3D) {
                const geometry = new THREE.SphereGeometry(bubbleRadius, 14, 10);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(smallCentroid);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            } else {
                const geometry = new THREE.CircleGeometry(bubbleRadius, 32);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(smallCentroid.x, smallCentroid.y, smallCentroid.z);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            }
        }

        if (!mesh && hullType === 'convex') {
            if (IS_3D && zRange > 0.001 && positions.length >= 4) {
                const ConvexCtor =
                    (typeof ConvexGeometry !== 'undefined')
                        ? ConvexGeometry
                        : (THREE.ConvexGeometry || null);
                const relPoints = positions.map(p => p.clone().sub(centroid));
                let boundaryGeometry = null;
                if (ConvexCtor) {
                    try {
                        boundaryGeometry = new ConvexCtor(relPoints);
                    } catch (err) {
                        boundaryGeometry = null;
                    }
                }
                if (boundaryGeometry) {
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: fillOpacity,
                        wireframe: false,
                        side: THREE.DoubleSide
                    });
                    mesh = new THREE.Mesh(boundaryGeometry, material);
                    mesh.position.copy(centroid);
                    mesh.scale.set(scaleX, scaleY, scaleZ);

                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(boundaryGeometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(centroid);
                    wireMesh.scale.copy(mesh.scale);
                }
            }

            if (!mesh) {
                const hull2d = buildHull2D(positions.map(p => new THREE.Vector2(p.x, p.y)));
                if (!hull2d || hull2d.length < 3) return;
                const localHull = hull2d.map(p => new THREE.Vector2(p.x - centroid.x, p.y - centroid.y));
                const shape = new THREE.Shape(localHull);
                const boundaryGeometry = new THREE.ShapeGeometry(shape);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: fillOpacity,
                    wireframe: false,
                    side: THREE.DoubleSide
                });
                mesh = new THREE.Mesh(boundaryGeometry, material);
                mesh.position.set(centroid.x, centroid.y, centroid.z);
                mesh.scale.set(scaleX, scaleY, 1);

                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const wireGeometry = new THREE.BufferGeometry().setFromPoints(
                    localHull.map(p => new THREE.Vector3(p.x, p.y, 0))
                );
                wireMesh = new THREE.LineLoop(wireGeometry, wireMaterial);
                wireMesh.position.copy(mesh.position);
                wireMesh.scale.copy(mesh.scale);
            }
        } else if (!mesh && hullType === 'box') {
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: fillOpacity,
                wireframe: false,
                side: THREE.DoubleSide
            });
            if (IS_3D) {
                const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(centroid);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            } else {
                const geometry = new THREE.PlaneGeometry(sizeX, sizeY);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(centroid.x, centroid.y, centroid.z);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            }
        } else if (!mesh) {
            const radius = 0.5 * Math.max(sizeX, sizeY, IS_3D ? sizeZ : 0);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: fillOpacity,
                wireframe: false,
                side: THREE.DoubleSide
            });
            if (IS_3D) {
                const geometry = new THREE.SphereGeometry(radius, 18, 14);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(centroid);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            } else {
                const geometry = new THREE.CircleGeometry(radius, 40);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(centroid.x, centroid.y, centroid.z);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            }
        }

        if (!mesh) return;
        scene.add(mesh);
        fileBoundaryMeshes.push(mesh);
        drawn += 1;
        if (wireMesh) {
            scene.add(wireMesh);
            fileBoundaryMeshes.push(wireMesh);
        }
    });
    return drawn;
}

// 
// FILE CONTAINMENT SYSTEM - Spherical fields with particle physics
// "Metaphysical force from another dimension" - holding particles together
// 

const FILE_CONTAINMENT = {
    spheres: [],              // Three.js sphere meshes
    directoryTree: null,      // Parsed directory hierarchy
    particleActivity: {},    // FileIdx  activity level (0-1)
    boundariesPopped: false,  // Animation state
    popProgress: 0,           // 0 = contained, 1 = fully free
    slowMotionFactor: 0.15,   // Time multiplier for dreamy slow motion
    collisionEnabled: true,   // Enable soft collisions
    spatialGrid: null,        // For efficient collision detection
    gridCellSize: 20,         // Size of spatial hash cells
    animationFrame: null,
    isAnimating: false
};

// 
// SPATIAL HASHING - O(n) collision detection instead of O(n)
// 

function buildSpatialGrid(nodes, cellSize) {
    const grid = new Map();

    nodes.forEach(node => {
        if (!node || !Number.isFinite(node.x)) return;
        const cellX = Math.floor(node.x / cellSize);
        const cellY = Math.floor(node.y / cellSize);
        const cellZ = IS_3D ? Math.floor((node.z || 0) / cellSize) : 0;
        const key = `${cellX},${cellY},${cellZ}`;

        if (!grid.has(key)) grid.set(key, []);
        grid.get(key).push(node);
    });

    FILE_CONTAINMENT.spatialGrid = grid;
    return grid;
}

function getNeighborCells(cellX, cellY, cellZ) {
    const neighbors = [];
    for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
            for (let dz = IS_3D ? -1 : 0; dz <= (IS_3D ? 1 : 0); dz++) {
                neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
            }
        }
    }
    return neighbors;
}

// Soft collision - push particles apart smoothly
function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
    if (!FILE_CONTAINMENT.collisionEnabled) return;

    const grid = buildSpatialGrid(nodes, cellSize);
    const minDist = 8;  // Minimum distance between particles
    const minDistSq = minDist * minDist;

    nodes.forEach(node => {
        if (!node || !Number.isFinite(node.x)) return;
        if (!node.__physics) {
            node.__physics = { vx: 0, vy: 0, vz: 0 };
        }

        const cellX = Math.floor(node.x / cellSize);
        const cellY = Math.floor(node.y / cellSize);
        const cellZ = IS_3D ? Math.floor((node.z || 0) / cellSize) : 0;
        const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

        neighborKeys.forEach(key => {
            const cellNodes = grid.get(key);
            if (!cellNodes) return;

            cellNodes.forEach(other => {
                if (other === node) return;

                const dx = node.x - other.x;
                const dy = node.y - other.y;
                const dz = IS_3D ? ((node.z || 0) - (other.z || 0)) : 0;
                const distSq = dx * dx + dy * dy + dz * dz;

                if (distSq < minDistSq && distSq > 0.001) {
                    const dist = Math.sqrt(distSq);
                    const overlap = minDist - dist;
                    const force = (overlap / minDist) * repulsionStrength;

                    // Push apart
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const nz = IS_3D ? dz / dist : 0;

                    node.__physics.vx += nx * force;
                    node.__physics.vy += ny * force;
                    if (IS_3D) node.__physics.vz += nz * force;
                }
            });
        });
    });
}

// Build directory tree from file paths
function buildDirectoryTree(fileBoundaries) {
    const tree = { name: '/', path: '', depth: 0, children: {}, files: [], totalNodes: 0 };

    fileBoundaries.forEach((file, idx) => {
        const filePath = file.file || file.file_name || '';
        const parts = filePath.split('/').filter(p => p);
        let current = tree;

        parts.forEach((part, partIdx) => {
            const isFile = partIdx === parts.length - 1;
            if (isFile) {
                current.files.push({
                    name: part, path: filePath, fileIdx: idx,
                    nodeCount: (file.atom_ids || []).length, activity: 0
                });
            } else {
                if (!current.children[part]) {
                    current.children[part] = {
                        name: part, path: parts.slice(0, partIdx + 1).join('/'),
                        depth: partIdx + 1, children: {}, files: [], totalNodes: 0
                    };
                }
                current = current.children[part];
            }
        });
    });

    FILE_CONTAINMENT.directoryTree = tree;
    return tree;
}

// Compute activity levels from markov transitions
function computeFileActivity(data) {
    const markov = data.markov || {};
    const highEntropy = markov.high_entropy_nodes || [];
    const transitions = markov.transitions || {};
    const fileActivity = {};

    (data.file_boundaries || []).forEach((file, idx) => {
        const atomIds = file.atom_ids || [];
        let activity = 0;
        atomIds.forEach(atomId => {
            if (highEntropy.some(h => h.node === atomId)) activity += 0.3;
            const fanout = Object.keys(transitions[atomId] || {}).length;
            activity += Math.min(fanout / 10, 0.5);
        });
        fileActivity[idx] = Math.min(1, activity / Math.max(1, atomIds.length));
    });

    FILE_CONTAINMENT.particleActivity = fileActivity;
    return fileActivity;
}

// Draw containment spheres
function drawContainmentSpheres(data) {
    // ALL DATA FROM DM - the containment pipeline
    const scene = Graph.scene();
    if (!scene) return;
    const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);

    // Clear existing
    FILE_CONTAINMENT.spheres.forEach(s => {
        if (s.mesh) scene.remove(s.mesh);
        if (s.wireframe) scene.remove(s.wireframe);
        if (s.glow) scene.remove(s.glow);
    });
    FILE_CONTAINMENT.spheres = [];

    if (!fileMode || FILE_CONTAINMENT.boundariesPopped) return;

    const fileBoundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    if (!FILE_CONTAINMENT.directoryTree) {
        buildDirectoryTree(fileBoundaries);
        computeFileActivity(data);
    }

    // Group nodes by file
    const fileGroups = {};
    graphNodes.filter(n => n && Number.isFinite(n.x)).forEach(node => {
        if (node.fileIdx >= 0) {
            if (!fileGroups[node.fileIdx]) fileGroups[node.fileIdx] = [];
            fileGroups[node.fileIdx].push(node);
        }
    });

    const totalFiles = fileBoundaries.length;

    Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
        if (nodes.length < 1) return;
        const idx = parseInt(fileIdx);
        const fileInfo = fileBoundaries[idx] || {};
        const fileLabel = fileInfo.file || fileInfo.file_name || '';
        const activity = FILE_CONTAINMENT.particleActivity[idx] || 0;

        // Compute bounding sphere
        const positions = nodes.map(n => new THREE.Vector3(n.x, n.y, n.z || 0));
        const centroid = computeCentroid(positions);
        const maxDist = positions.reduce((max, p) => Math.max(max, p.distanceTo(centroid)), 0);
        const radius = Math.max(8, maxDist * 1.3);
        const color = new THREE.Color(getFileColor(idx, totalFiles, fileLabel));

        // Translucent sphere (render inside)
        const sphereGeom = new THREE.SphereGeometry(radius, 24, 18);
        const sphereMat = new THREE.MeshBasicMaterial({
            color, transparent: true, opacity: 0.06 + activity * 0.1,
            side: THREE.BackSide, depthWrite: false
        });
        const sphere = new THREE.Mesh(sphereGeom, sphereMat);
        sphere.position.copy(centroid);

        // Wireframe
        const wireGeom = new THREE.SphereGeometry(radius * 1.01, 16, 12);
        const wireMat = new THREE.MeshBasicMaterial({
            color, transparent: true, opacity: 0.12 + activity * 0.18, wireframe: true
        });
        const wireframe = new THREE.Mesh(wireGeom, wireMat);
        wireframe.position.copy(centroid);

        // Glow for active files
        let glow = null;
        if (activity > 0.4) {
            const glowGeom = new THREE.SphereGeometry(radius * 1.15, 12, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color, transparent: true, opacity: (activity - 0.4) * 0.12, side: THREE.BackSide
            });
            glow = new THREE.Mesh(glowGeom, glowMat);
            glow.position.copy(centroid);
            scene.add(glow);
        }

        scene.add(sphere);
        scene.add(wireframe);

        // Store original positions for restoration
        nodes.forEach(n => {
            if (!n.__originalPos) n.__originalPos = { x: n.x, y: n.y, z: n.z || 0 };
        });

        FILE_CONTAINMENT.spheres.push({
            mesh: sphere, wireframe, glow, fileIdx: idx,
            centroid: centroid.clone(), radius, activity, nodes: nodes.map(n => n.id)
        });
    });
}

// 
// SLOW MOTION PARTICLE ANIMATION - Dreamy physics with collisions
// 

function startContainmentAnimation() {
    if (FILE_CONTAINMENT.isAnimating) return;
    FILE_CONTAINMENT.isAnimating = true;

    function animate() {
        if (!FILE_CONTAINMENT.isAnimating) return;

        const time = Date.now() * 0.001 * FILE_CONTAINMENT.slowMotionFactor;
        const graphNodes = Graph.graphData().nodes;

        if (FILE_CONTAINMENT.boundariesPopped) {
            // FREE PARTICLE MODE - Brownian motion with collisions
            applySoftCollisions(graphNodes, FILE_CONTAINMENT.gridCellSize, 0.4);

            graphNodes.forEach(node => {
                if (!node || !node.__physics) return;
                const p = node.__physics;

                // Perlin-like wandering
                const wander = 0.08;
                p.vx += (Math.sin(time * 0.7 + (node.__wanderPhase || 0)) - 0.5) * wander;
                p.vy += (Math.cos(time * 0.5 + (node.__wanderPhase || 0) * 1.3) - 0.5) * wander;
                if (IS_3D) p.vz += (Math.sin(time * 0.6 + (node.__wanderPhase || 0) * 0.7) - 0.5) * wander;

                // Damping
                p.vx *= 0.985;
                p.vy *= 0.985;
                p.vz *= 0.985;

                // Apply velocity
                node.x += p.vx;
                node.y += p.vy;
                if (IS_3D) node.z = (node.z || 0) + p.vz;
            });

        } else {
            // CONTAINED MODE - Activity-based oscillation inside spheres
            FILE_CONTAINMENT.spheres.forEach(sphere => {
                const activity = sphere.activity;

                // Pulse sphere opacity
                const pulse = Math.sin(time * 2 + sphere.fileIdx) * 0.5 + 0.5;
                if (sphere.mesh?.material) {
                    sphere.mesh.material.opacity = 0.04 + activity * 0.12 * pulse;
                }
                if (sphere.wireframe?.material) {
                    sphere.wireframe.material.opacity = 0.08 + activity * 0.2 * pulse;
                }

                if (activity < 0.05) return;

                // Perturb particles inside based on activity
                sphere.nodes.forEach(nodeId => {
                    const node = graphNodes.find(n => n.id === nodeId);
                    if (!node || !Number.isFinite(node.x)) return;

                    if (!node.__activityPhase) {
                        node.__activityPhase = {
                            x: Math.random() * Math.PI * 2,
                            y: Math.random() * Math.PI * 2,
                            z: Math.random() * Math.PI * 2
                        };
                    }

                    const amp = activity * 0.4;
                    const freq = 0.5 + activity * 0.5;
                    const phase = node.__activityPhase;

                    node.__renderOffsetX = Math.sin(time * freq + phase.x) * amp;
                    node.__renderOffsetY = Math.sin(time * freq * 1.2 + phase.y) * amp;
                    if (IS_3D) node.__renderOffsetZ = Math.sin(time * freq * 0.9 + phase.z) * amp;
                });
            });
        }

        if (Graph) Graph.refresh();
        FILE_CONTAINMENT.animationFrame = requestAnimationFrame(animate);
    }

    animate();
}

function stopContainmentAnimation() {
    FILE_CONTAINMENT.isAnimating = false;
    if (FILE_CONTAINMENT.animationFrame) {
        cancelAnimationFrame(FILE_CONTAINMENT.animationFrame);
    }
}

// 
// POP THE BOUNDARIES - Release particles into free Brownian motion
// 

function popBoundaries(duration = 3000) {
    if (FILE_CONTAINMENT.boundariesPopped) {
        restoreBoundaries(duration);
        return;
    }

    console.log('[Containment] Popping boundaries...');
    FILE_CONTAINMENT.boundariesPopped = true;
    const startTime = Date.now();
    const scene = Graph.scene();
    const graphNodes = Graph.graphData().nodes;

    // Initialize physics for each node
    graphNodes.forEach(node => {
        if (!node || !Number.isFinite(node.x)) return;
        node.__physics = {
            vx: (Math.random() - 0.5) * 1.5,
            vy: (Math.random() - 0.5) * 1.5,
            vz: IS_3D ? (Math.random() - 0.5) * 1.5 : 0
        };
        node.__wanderPhase = Math.random() * Math.PI * 2;
    });

    function animatePop() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(1, elapsed / duration);
        FILE_CONTAINMENT.popProgress = progress;
        const eased = 1 - Math.pow(1 - progress, 3);

        // Fade out spheres
        FILE_CONTAINMENT.spheres.forEach(s => {
            if (s.mesh?.material) s.mesh.material.opacity = (1 - eased) * 0.1;
            if (s.wireframe?.material) s.wireframe.material.opacity = (1 - eased) * 0.25;
            if (s.glow?.material) s.glow.material.opacity = (1 - eased) * 0.08;
        });

        if (progress < 1) {
            requestAnimationFrame(animatePop);
        } else {
            // Remove spheres
            FILE_CONTAINMENT.spheres.forEach(s => {
                if (s.mesh) scene.remove(s.mesh);
                if (s.wireframe) scene.remove(s.wireframe);
                if (s.glow) scene.remove(s.glow);
            });
            FILE_CONTAINMENT.spheres = [];
            console.log('[Containment] Particles now FREE - Brownian motion with collisions');
        }

        if (Graph) Graph.refresh();
    }

    animatePop();
    startContainmentAnimation();
}

function restoreBoundaries(duration = 2000) {
    if (!FILE_CONTAINMENT.boundariesPopped) return;

    console.log('[Containment] Restoring boundaries...');
    const startTime = Date.now();
    const graphNodes = Graph.graphData().nodes;

    graphNodes.forEach(node => {
        if (!node || !Number.isFinite(node.x)) return;
        node.__freePos = { x: node.x, y: node.y, z: node.z || 0 };
    });

    function animateRestore() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(1, elapsed / duration);
        FILE_CONTAINMENT.popProgress = 1 - progress;
        const eased = Math.pow(progress, 2);

        graphNodes.forEach(node => {
            if (!node || !node.__freePos || !node.__originalPos) return;
            node.x = node.__freePos.x + (node.__originalPos.x - node.__freePos.x) * eased;
            node.y = node.__freePos.y + (node.__originalPos.y - node.__freePos.y) * eased;
            if (IS_3D) node.z = node.__freePos.z + ((node.__originalPos.z || 0) - node.__freePos.z) * eased;
        });

        if (progress < 1) {
            requestAnimationFrame(animateRestore);
        } else {
            FILE_CONTAINMENT.boundariesPopped = false;
            if (DM) drawContainmentSpheres(null);  // Uses DM internally
            console.log('[Containment] Boundaries restored');
        }

        if (Graph) Graph.refresh();
    }

    animateRestore();
}

// Expose to global for button binding
window.popBoundaries = popBoundaries;
window.restoreBoundaries = restoreBoundaries;
window.FILE_CONTAINMENT = FILE_CONTAINMENT;

// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// FILES button - toggle file mode on/off
function setFileModeState(enabled) {
    fileMode = enabled;
    const btn = document.getElementById('btn-files');
    btn.classList.toggle('active', fileMode);

    const filePanel = document.getElementById('file-panel');
    const modeControls = document.getElementById('file-mode-controls');
    const expandControls = document.getElementById('file-expand-controls');

    if (fileMode) {
        filePanel.classList.add('visible');
        modeControls.classList.add('visible');
        expandControls.classList.toggle('visible', fileVizMode === 'map');
        applyFileVizMode();
        applyEdgeMode();
        HudLayoutManager.reflow();
    } else {
        filePanel.classList.remove('visible');
        modeControls.classList.remove('visible');
        expandControls.classList.remove('visible');
        EXPANDED_FILES.clear();
        GRAPH_MODE = 'atoms';
        HudLayoutManager.reflow();
        clearAllFileModes();
        applyEdgeMode();
        refreshGraph();
    }
}

document.getElementById('btn-files').onclick = () => {
    setFileModeState(!fileMode);
};

// COLOR mode - atoms colored by file
document.getElementById('btn-file-color').onclick = () => {
    setFileVizMode('color');
};

// HULLS mode - draw boundary spheres
document.getElementById('btn-file-hulls').onclick = () => {
    setFileVizMode('hulls');
};

// CLUSTER mode - force clustering by file
document.getElementById('btn-file-cluster').onclick = () => {
    setFileVizMode('cluster');
};

// MAP mode - show file nodes
document.getElementById('btn-file-map').onclick = () => {
    setFileVizMode('map');
};

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
document.getElementById('btn-expand-inline').onclick = () => {
    FILE_EXPAND_MODE = 'inline';
    updateExpandButtons();
    if (GRAPH_MODE === 'hybrid') {
        refreshGraph();
    }
};

document.getElementById('btn-expand-detach').onclick = () => {
    FILE_EXPAND_MODE = 'detach';
    updateExpandButtons();
    if (GRAPH_MODE === 'hybrid') {
        refreshGraph();
    }
};

function updateExpandButtons() {
    document.getElementById('btn-expand-inline').classList.toggle('active', FILE_EXPAND_MODE === 'inline');
    document.getElementById('btn-expand-detach').classList.toggle('active', FILE_EXPAND_MODE === 'detach');
}

function setFileVizMode(mode) {
    fileVizMode = mode;
    // Update button states
    document.querySelectorAll('.file-mode-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById('btn-file-' + mode).classList.add('active');
    const expandControls = document.getElementById('file-expand-controls');
    expandControls.classList.toggle('visible', fileVizMode === 'map');
    if (fileVizMode === 'map') {
        updateExpandButtons();
    }
    if (fileVizMode === 'map') {
        GRAPH_MODE = (EXPANDED_FILES.size > 0) ? 'hybrid' : 'files';
    } else {
        EXPANDED_FILES.clear();
        GRAPH_MODE = 'atoms';
    }
    if (!fileMode) {
        setFileModeState(true);
    } else if (fileVizMode === 'map') {
        applyFileVizMode();
    } else {
        refreshGraph();
    }
}

function applyFileVizMode() {
    if (!fileMode) return;

    // Clear previous state
    clearFileBoundaries();
    if (fileVizMode !== 'hulls') {
        hullRedrawAttempts = 0;
    }

    // ALL DATA FROM DM
    const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);

    if (fileVizMode === 'color') {
        // Color mode is already applied via node colors
        // Just ensure nodes have file colors
        applyFileColors(graphNodes);
    }
    else if (fileVizMode === 'hulls') {
        // Draw boundary hulls
        applyFileColors(graphNodes);
        const drawn = drawFileBoundaries(null);  // Uses DM internally
        if (drawn === 0) {
            showToast('No hulls drawn. Try increasing HULL OPACITY.');
        }
        scheduleHullRedraw();
    }
    else if (fileVizMode === 'cluster') {
        // Apply clustering force
        applyFileColors(graphNodes);
        applyClusterForce(data);
    }
    else if (fileVizMode === 'map') {
        // File map uses file nodes + optional expansion
        GRAPH_MODE = (EXPANDED_FILES.size > 0) ? 'hybrid' : 'files';
        refreshGraph();
        showToast('File map active. Click a file node to expand.');
    }
    else if (fileVizMode === 'spheres') {
        // Containment spheres mode - particles held by transparent force fields
        applyFileColors(graphNodes);

        // Build directory tree and compute activity levels
        buildDirectoryTree(data);
        computeFileActivity(data, graphNodes);

        // Draw containment spheres
        drawContainmentSpheres(data, graphNodes);

        // Start the slow-motion animation with collisions
        startContainmentAnimation();

        showToast('Containment spheres active. Files as force fields. Click POP! to release.');
    }
}

function scheduleHullRedraw(delayMs = 1200) {
    if (hullRedrawTimer) {
        clearTimeout(hullRedrawTimer);
    }
    hullRedrawTimer = setTimeout(() => {
        if (!(fileMode && fileVizMode === 'hulls')) {
            hullRedrawAttempts = 0;
            return;
        }
        const drawn = drawFileBoundaries(null);  // Uses DM internally
        if (drawn === 0 && hullRedrawAttempts < 3) {
            hullRedrawAttempts += 1;
            scheduleHullRedraw(1200 + (hullRedrawAttempts * 700));
        } else {
            hullRedrawAttempts = 0;
        }
    }, delayMs);
}

function applyFileColors(graphNodes) {
    // Generate file colors and apply to nodes - ALL DATA FROM DM
    const boundaries = DM ? DM.getFileBoundaries() : [];
    const totalFiles = boundaries.length;
    graphNodes.forEach(node => {
        if (node.fileIdx >= 0) {
            const fileInfo = boundaries[node.fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
            node.color = getFileColor(node.fileIdx, totalFiles, fileLabel);
        }
    });
    Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
}

function clearFileBoundaries() {
    const scene = Graph.scene();
    fileBoundaryMeshes.forEach(mesh => scene.remove(mesh));
    fileBoundaryMeshes = [];
}

function clearAllFileModes() {
    clearFileBoundaries();
    // Reset cluster force if active
    if (clusterForceActive) {
        Graph.d3Force('cluster', null);
        clusterForceActive = false;
        if (DEFAULT_LINK_DISTANCE !== null) {
            Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
        }
        Graph.d3ReheatSimulation();
    }
    // Stop containment animation if active
    stopContainmentAnimation();
    // Clear containment spheres
    if (FILE_CONTAINMENT && FILE_CONTAINMENT.spheres) {
        const scene = Graph.scene();
        FILE_CONTAINMENT.spheres.forEach(s => {
            if (s.mesh) scene.remove(s.mesh);
        });
        FILE_CONTAINMENT.spheres = [];
        FILE_CONTAINMENT.boundariesPopped = false;
    }
    // Reset POP button state
    const popBtn = document.getElementById('btn-file-pop');
    if (popBtn) {
        popBtn.classList.remove('active');
        popBtn.textContent = 'POP!';
    }
}

function applyClusterForce(data) {
    // ALL DATA FROM DM - the physics pipeline
    const clusterConfig = data?.physics?.cluster || {};
    const modeStrength =
        (typeof clusterConfig.modes?.strong === 'number') ? clusterConfig.modes.strong : null;
    const sliderStrength =
        (typeof APPEARANCE_STATE.clusterStrength === 'number') ? APPEARANCE_STATE.clusterStrength : null;
    const clusterStrength =
        (typeof sliderStrength === 'number')
            ? sliderStrength
            : ((typeof modeStrength === 'number')
                ? modeStrength
                : ((typeof clusterConfig.strength === 'number') ? clusterConfig.strength : 0.3));
    const clusterRadius =
        (typeof clusterConfig.radius === 'number') ? clusterConfig.radius : 150;
    const clusterZSpacing =
        (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing : 30;
    const linkDistance =
        (typeof clusterConfig.linkDistance === 'number')
            ? clusterConfig.linkDistance
            : (data?.physics?.forces?.link?.distance || 50);

    const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const numFiles = boundaries.length;

    // FIXED TARGET POSITIONS: Arrange files in a circular pattern
    // This creates CLEAR visual separation instead of clustering around mixed centroids
    const radius = clusterRadius;  // Separation radius
    const fileTargets = {};

    for (let i = 0; i < numFiles; i++) {
        fileTargets[i] = getFileTarget(i, numFiles, radius, clusterZSpacing);
    }

    // Reduce link distance to keep intra-file nodes tighter
    Graph.d3Force('link').distance(linkDistance);

    // Apply strong clustering force toward fixed targets
    Graph.d3Force('cluster', (alpha) => {
        const k = alpha * clusterStrength;
        graphNodes.forEach(node => {
            const target = fileTargets[node.fileIdx];
            if (target) {
                node.vx = (node.vx || 0) + (target.x - node.x) * k;
                node.vy = (node.vy || 0) + (target.y - node.y) * k;
                if (IS_3D) {
                    node.vz = (node.vz || 0) + (target.z - node.z) * k;
                }
            }
        });
    });

    clusterForceActive = true;
    Graph.d3ReheatSimulation();

    // Also draw hulls after clustering settles
    scheduleHullRedraw(1500);
}

// 
// OKLCH COLOR PICKER - Embedded (self-contained)
// 
const oklchState = { l: 70, c: 0.15, h: 220, a: 100 };

function oklchToRgb(l, c, h) {
    // Convert OKLCH to sRGB (simplified)
    const L = l / 100;
    const hr = h * Math.PI / 180;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    // Oklab to LMS
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;
    const lms = [l_ * l_ * l_, m_ * m_ * m_, s_ * s_ * s_];
    // LMS to XYZ
    const x = 1.2270138511 * lms[0] - 0.5577999807 * lms[1] + 0.281256149 * lms[2];
    const y = -0.0405801784 * lms[0] + 1.1122568696 * lms[1] - 0.0716766787 * lms[2];
    const z = -0.0763812845 * lms[0] - 0.4214819784 * lms[1] + 1.5861632204 * lms[2];
    // XYZ to linear RGB
    let rl = 3.2409699419 * x - 1.5373831776 * y - 0.4986107603 * z;
    let gl = -0.9692436363 * x + 1.8759675015 * y + 0.0415550574 * z;
    let bl = 0.0556300797 * x - 0.2039769589 * y + 1.0569715142 * z;
    // Linear to sRGB
    const toSrgb = v => v <= 0.0031308 ? 12.92 * v : 1.055 * Math.pow(Math.abs(v), 1 / 2.4) - 0.055;
    return {
        r: Math.round(Math.max(0, Math.min(1, toSrgb(rl))) * 255),
        g: Math.round(Math.max(0, Math.min(1, toSrgb(gl))) * 255),
        b: Math.round(Math.max(0, Math.min(1, toSrgb(bl))) * 255),
        inGamut: rl >= -0.001 && rl <= 1.001 && gl >= -0.001 && gl <= 1.001 && bl >= -0.001 && bl <= 1.001
    };
}

function updateOklchPicker() {
    const { l, c, h, a } = oklchState;
    const rgb = oklchToRgb(l, c, h);
    const hex = '#' + [rgb.r, rgb.g, rgb.b].map(v => v.toString(16).padStart(2, '0')).join('');

    // Update swatch
    const swatch = document.getElementById('oklch-swatch');
    if (swatch) swatch.style.background = `oklch(${l}% ${c} ${h} / ${a}%)`;

    // Update CSS output
    const cssInput = document.getElementById('oklch-css');
    if (cssInput) cssInput.value = a < 100
        ? `oklch(${l}% ${c.toFixed(3)} ${h} / ${a}%)`
        : `oklch(${l}% ${c.toFixed(3)} ${h})`;

    // Update value displays
    const lVal = document.getElementById('oklch-l-val');
    const cVal = document.getElementById('oklch-c-val');
    const hVal = document.getElementById('oklch-h-val');
    const aVal = document.getElementById('oklch-a-val');
    if (lVal) lVal.textContent = l + '%';
    if (cVal) cVal.textContent = c.toFixed(3);
    if (hVal) hVal.textContent = h + '';
    if (aVal) aVal.textContent = a + '%';

    // Update gamut info
    const gamutInfo = document.getElementById('oklch-gamut');
    if (gamutInfo) {
        if (rgb.inGamut) {
            gamutInfo.textContent = 'sRGB ';
            gamutInfo.classList.remove('out-of-gamut');
        } else {
            gamutInfo.textContent = 'Outside sRGB (P3/Rec2020)';
            gamutInfo.classList.add('out-of-gamut');
        }
    }

    // Update hue gradient background
    const cSlider = document.getElementById('oklch-c');
    if (cSlider) cSlider.style.background = `linear-gradient(90deg, #888, oklch(${l}% 0.4 ${h}))`;
    const aSlider = document.getElementById('oklch-a');
    if (aSlider) aSlider.style.background = `linear-gradient(90deg, transparent, oklch(${l}% ${c} ${h}))`;

    // Draw 2D canvas (L vs H at current C)
    drawOklch2D();
}

function drawOklch2D() {
    const canvas = document.getElementById('oklch-canvas-2d');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width = canvas.clientWidth * 2;
    const h = canvas.height = canvas.clientHeight * 2;
    const c = oklchState.c;

    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const hue = (x / w) * 360;
            const lightness = 100 - (y / h) * 100;
            const rgb = oklchToRgb(lightness, c, hue);
            ctx.fillStyle = rgb.inGamut
                ? `rgb(${rgb.r},${rgb.g},${rgb.b})`
                : `rgba(${rgb.r},${rgb.g},${rgb.b},0.3)`;
            ctx.fillRect(x, y, 1, 1);
        }
    }

    // Draw current position marker
    const markerX = (oklchState.h / 360) * w;
    const markerY = ((100 - oklchState.l) / 100) * h;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(markerX, markerY, 8, 0, Math.PI * 2);
    ctx.stroke();
}

function initOklchPicker() {
    ['l', 'c', 'h', 'a'].forEach(key => {
        const slider = document.getElementById('oklch-' + key);
        if (slider) {
            slider.value = oklchState[key];
            slider.oninput = function () {
                oklchState[key] = parseFloat(this.value);
                updateOklchPicker();
            };
        }
    });

    // Canvas click to pick color
    const canvas = document.getElementById('oklch-canvas-2d');
    if (canvas) {
        canvas.onclick = function (e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            oklchState.h = Math.round((x / rect.width) * 360);
            oklchState.l = Math.round(100 - (y / rect.height) * 100);
            document.getElementById('oklch-h').value = oklchState.h;
            document.getElementById('oklch-l').value = oklchState.l;
            updateOklchPicker();
        };
    }

    updateOklchPicker();
}

function toggleOklchPicker() {
    const picker = document.getElementById('oklch-picker');
    const isVisible = picker.classList.toggle('visible');
    const btn = document.getElementById('cmd-oklch');
    if (btn) btn.classList.toggle('active', isVisible);
    if (isVisible && !picker.dataset.init) {
        picker.dataset.init = 'true';
        initOklchPicker();
    }
}
