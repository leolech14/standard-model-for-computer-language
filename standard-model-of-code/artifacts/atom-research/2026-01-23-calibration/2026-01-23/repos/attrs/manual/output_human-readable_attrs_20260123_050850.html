<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>