<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>