<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>