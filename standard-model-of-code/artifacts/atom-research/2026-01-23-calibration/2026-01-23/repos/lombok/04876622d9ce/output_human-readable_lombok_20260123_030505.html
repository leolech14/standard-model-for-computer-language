<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>