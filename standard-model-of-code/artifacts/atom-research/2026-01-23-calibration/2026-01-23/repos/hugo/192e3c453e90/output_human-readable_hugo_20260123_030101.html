<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>