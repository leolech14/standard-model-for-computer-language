<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "H4sIAAAAAAAC/+y9W3fbuLKo+1fmmPvlnDGWO7pLXm+ObKfdHcduS0nWPuchAyYhmW3eApC21Xuc/37AiyQCBCV3T6ebVayHOVusQiyB/FAsAIWq//PvMHK5/Pd//+v//T//9lz1339LFrr30cu7RDDHC9fvooT7C56k8U+J/O//3l39+7/+9e+QBTz7J5qQJVGQCT/efPjp8tP8p+tM+MR8Jev/1FOfnciPRNZCrO//r35v8F//2v7f/5019dmG5+rP4WMYPYeZTKgfYooiP//uqzDhIlR/XslWXiE71IVtuyv3RTU97c/U9X3kbrJ/9+/8cxq6TOTXXuVvy4QlxR/PPvhc5n/J91bc2TjF16aSZzJPfnMiNwr4t8rfWjFfcqV89ML8Lq/S0Em8KO9K2VpGqXCyPxSmvr+9T98e1I/Yy7zwm8vXgmfNsnsZpYkuWLHwmxdWLlSL8sqJgtjnL16yKQV+5KhPJ/2J+pyIVOYNfxpmN5fLOAqld+/5RfOxEsap2F/sOv5NOpHgpXTbYU3o8FA9CH//vYKFj/lX9Xq94WyqJC6Pk4ftz3xIxbYDbJ336//7r3810aluJ3/JyQyYF1ah3F7/zTzOI9XbyPfVvzlA5PZnmzROicZTjcYpCBrvmfScE/ld/VkODUnrbze57HWeyxFALF3hPXFxwlwWq0ck30nhvAt5FP70kCQxHEKPdcOEtU+wIoE19lnIE+kwn8PGVe+ICeyIgMVkXZ8lAtuad8IEdUDuaR8JqQmXSY6pDKJHvlRXVVY1YYtm9Ad6YrI66TyrEOf1B1Fd2FBd2FC9ufvw09mHD38dVfXgSnO9JbUiaQOoq9T/jzh1fFaQ/k+/+YdYfNV4DdxHzTtg0jkm3xQLoND5tOE57DyeY7DrpXEkE9V3CXPFtPbrDTR7p4QmJDQd4cWJfHefBvEJD9deyCFM4+2/2kBxQMv3xiYnUBZFqqFYXrZhfk4cvo7D4RjSpLx8qmvB4ocT9e+4etWFjlfSuOYhF+r5fMjUVS5rihYRau2LySl5lYMBHk5BvMGJy9dNxiG+x6PQ35ww34+eT+IwDn76XUEZB5ciCj5LLs6UudRWNC2qFhnQemdMSmk7sw/Ret4rs/MAaMpT/lxzRYim3SOIU50dfO2f4xB4TU5jH6DZcx6487ids55ET1wIz+Vw7GDj7zdfyxQWB3E90vHexem978mHcs6dfGTZRvI8CgIv+ZlJY+ZtVbfIemr9MRGl+KL8PAo4E6ozql7Zd1ymfmK8x/dC4pHWK/9WHtvtURKDh1/bI/gM3rHnW+Y8Zu0rKOrSfz547cfxiCVcbdbHxKK0wyiJRiA0Ing7qymLjUZDTG9rKG/rnArgTFpe1fSeBmUZ+70JGgylhUN6RUMBEcOKzv5lfF4JULC/rs0W9OaGs2vdw4Gq8GTADpFqbUCgggF1PEUB6twTTuozcQDVpiYEK5zI8xEOq1pc3gi32Ieu2lNDRXCCgXOKwDv9g4voJlX+Z+Jom+GmnLCEswuO4wX/iT+f86cvXMjyvlaMZk1HeMLJUTjDgmdGwVqw7MY2YmpvQ7jCOcvTxzFdSoVQ35S/zy8jkf+3BLI2bTrSlOAFA+/oFIutzSk85A9YGhCoYCLlejh81mv2skfwKnQED4zzaQcbEbBggEXiFigW6x7qAXCPNCaAwQA8nGABuOqgHkC3sRlBCyegfogC2jPf306oyuV/7qqZlsHsgVaELBhkp2MkU7CX5NoLI7FI2L3Pa/OvmpYQBXPkHWS+mjqiCx48cZGl/8hf9e/VtzjmAc/GNoQrGFxHCKZe5Wctc81eRDCCgXGMY4X1okiB0Hgw3qonTMFUM8Aw289SM9ii+k05YQkGSwz7UyufJQnXdqQqIoIRDIwTBDYyf1SS7+7plkhTTliCwXLaw4ClIziTPF8j0rk0FAQmHDARBPKpR6qeVVN4vl1LiIJBFEModPnZNvOxqAhOKHBOewiW3T25ePTimLvaS70qJCDBJB/BsA/0rH4aX0a3j+tfpD4FqmsITTBoDkdI0LTEL5tywhIMlkji64ucDtYNc1NFcIKBc4Jgn5wJfuFEciMTHmR1quUtkzLDpULpoTaEK5zUd0MkuZ6aYo8o4ggqmjMEO0NF6MZVuIqqWOpSyokHIG3tKQKfc+Ez5/FamQj1L87EWlvUtOkIzPaDedpDEOkueehWAayCadPRSxzKS/y0jyPK/WMWh2mWLdrKCEcwOGKIYv/gJT+n93bP0qaj1ziA1/gIx4E1O5U1BVlMMBZzAmmBKC5jMt7J777qUXbWnIuT7ykXm5OErZVcOO/UTeYvP2Xx6zm1WShcwq8j5zGrWslftEPsVmUL6P3zHdXRnk1mb4d2cZNArjEhZVthnSuWTJ/la0JgGNcIpurFgylefp+95OE3G8M1BXEMvlziADfH11ysudtIs0VNTIMPNAVpm5nL4uwx3/Mk+4969F7Ch/mj5kJEQhYucxQ+cZGcC0/95yKTaz6zVdsmol/TS53oUY9y6uDlOWBxA8t1DXEMvhQPXpAbKG5A+B9bEP77AcayTjzVPeUpJng92YBvTUE2mJzjdmFc+LzZWYIc5S/MT7Uohp0AhO3VeqPDOzzttv3FzW3m7nLHX25ibnrBFTEQ8/v2FOOqCNQJlJng7jzy0yDM6JUWqi0tCHAMPsYEN+B5UIUV7LqGgMYQitHDDbQXrrjYg6snLKqpCGkMTkh/1AGmb+5/505iZVpXEdMYmB72cTP9OeQvsaKWuxm3tdW6BjUtfIBe+OgPZ8hWnuvzxbvo2ZgflhKyyxjs8gj/4t2ZWBsElxIiGEWNeWwxGLqoOKScuHPfM2rJaUIQnkStZwbNs057E4MBfpDf56LFbx8zyR2XqZ8suEZ1cwtCHD7io44hfs0T1kj3Vklggwd72OsY2Hlgvll+sbkFIQ4e8VHX3JOl+gGS1eqXHGpDmCNY0zvFz3mZSrUguZCfFX+gSvrhVsQ6fNYnY2Tr18ds+lUYp8ktEyyQjTbdaEOcw5929oddtumXykGJ1AN6lWmvNCby/5OMHu1ZVhzgN/LFs9HMeH3B/GAjIJtBPwZ3ZBlsBiPQYa5uH+vZcrNnxhmwMZ0nx8Ut9DPkxCvqAzN1YKGeFf8hoNL58HZCCvtMONlU1Ge0ysfr9k8ekiQujGr/Z/XxrugDN/Pg2rWtNbH7jhngdjtX8wAptOy5iEGyEFtVEa7A4jX6yHCNws+hTB1HvQfVM9JtapXdY+1a7DG8McqYXAbYsRlWnD/wkAvPKQitebpNesIXJL4zdPhaiCVIYedjHiKDNOZiFYlA+bF5qGYVVouKoAUJLTbL6snijV+P4alrCFmQGV0GKFcSrAHzFhWtJACLoeyNUfLaEP1uVRKzwJidTZExW8QzFnA2RrLX1MQtsE2G3gjBTu4RbhujdZtadZlioDG5wx6GkARkuTdtvTLA7dOCAgLHAV2KTSIXbT29I+jKq8XNefkG3C+EVYSEK9QosCFSS7tIMn6sllZXEbpUyKZd6H5Kg3surOjqKkIXKLozrP4t6HTbhO5r0D3Fhy6WrNo/DGAsK7unE3zrYdCSZ5OV7cx2L/Ak2UTqq1K7IwmkeY7EIxdlaEJx5EZ+9ZKHYl32kyJW6hEKzW3avFW266ZB8pDOleGC+LYIrr26qZ8ss6gIWXDITtEhC7H+AGF6BNMZQvfga37REGtrURK24EJnhmixbQy5taoJXXih4vg8g21oYoHogdDbWgPiFxy/AyTht8f4PRCC29Su2zRDTY3b66MDGvLR87cFFdNi7qCPYzFXs7k2+9pyW1pnc9RxlwAfljkRK+ZwG5+akkClZYO/E9Qwcvk735PJieoV809clrB7JnmRFjRTfMzk51txFWC7tsX+wKHOGmhPyD8AuU3m5NsHJzxceyE/EWmYeAF/d89D56H4/5M08fyCbpevuBDcfZ/Jq2DXFG1i+vU91JHuj0cU0IgdabkJnRrOmpBQRmKeB9hZLlaA5lG48tapssbXkfNoWQ0+0uzNePfClWBS3XEnUV9Txd6iAUM/4Io8k24MgJyhWHD1/zdxdu9lnX57GzL1aGDvD/rYab9LwzCLoViknn74uKZozxrJ3001norIPew4K22N5KqMjDOSmPjhGBvK3t6b+CmXbIHOJ5EBE4/SoFpXQEHb1k8TcFoH7I+w8R2oGeJJuTSco51NGYsyV5b5pVUJwwUxOmqyPe14xkqIgRp/muuGCFCLipgGz/TkFJutllx46gv/QO6KWLppkn1KadxROiLZJnSZ7DLkQj2yzwqGu+jZSHdZ10Fhu9pLE+rZf1F57k5A/YnLhLtZoIgNa11LYKPYoES3xJc96pOAxTFyZ8TWT5NvqqmMKJYki437XUbhSSyiJFI3MAc7jESQ+6S/KNVtqfnC/FSPAjzSrP3Q23pv4D4h53vUx867J5dsveZuzq6e/dhQENNIssr2O2PDG9Bu0hPhSJyUCXbClZ9aZJuteyYWFXGNJWfiEDvYLt8tCmee9V3RO66fU2hsQqAjAb0/6RDoDV5KcwvCHEuQCTJXfB8IyKSCN/nEn/SwEkMMA+SGMMAprXbPsOLryXPO46yMjpNcfE+L51gpkF5XEsrAbfEYK8tu9CvfyGuWGMd9dTHxC3xHfYDXlTjnjhfoNlgTEruw2Z0M8bL7Pl2tTB94LyNyqbhka62uUQ51LyFqqThfa+2tt77S0+tXZUQu8GBoxOQWlU91cvcyIpfqnbUUXclW+U5cUXXaW2n5nq1Kghn6/twpMpglFycr5iiGTniW47momirz1ORKWK+YWle1/SRhUz9NvLt9mHCM53xsM9iCJw8iej6Te4y1GH67GojV/mGIozqn0gkDbgH5jj3XjPmRZsQ9ooD+QRe4X/Mkp3ceuVw/eajLiWw8ZI8n3bDooctFDvG1enjZX9YMuU1LlGOaeY67g/lc9Ur9GE9fz7bpCHFEiJ8i21R0xCZOopzref6xSvNeAmH9ZNcVM5i53+2sYmiBVR5znVlNCMP0vjG4qBxntPCqb1J39vPnq3PNf9CkhC/4jUVc/N5nEclFJYAofOIimauOMyfhrpkerEkPA+ltP02ie7Q2jWwl43vKxeYk9llYni0paiDmx/lufebwh8h39ciPQ21g4K112pzkEePj7iD+oUh3FzUDrrUgvCl9euv4Fuz55ECemTv2XM0DZsta8Jq2MNC33QtzBJBb3h92agQ051gClrWA6H6Vi47Mvsvv/onqa8DDbRWBVcZvsvjuzwtxlW2bDgbdZj9Nsgdkt6fYyWZx7G/28HKhLarYtUQ3hT/BoPs+9XzXbrYtKuIaTbFQbIfIrYabhw1s23QENyXsbSPZ6suyEKCcaTXLevJcLpbRjXpoi41MeFDlukkPg+19T02qhzSFPMVL9bOXPPyWrRAvYhaehe7Fk2GuGxsQ1+BdbGQTyGd+n+1zJNmiRw53FDraSt/2Gga6RndMfikpKTKzXCl3/E7B6Lksu8+F78FFRsGXnVRzPGxKGIg3dtkMNaGD7OPOwO5GXC7UpVxt7lJfTzRdVxHotB0JlfTifEzj6TBwB8OI8tf73qPOUI7riC8x/vrVwAFexr3wJOBBlEXWichRD62yTJhd3nH1Q11pLBAaGnjEN3TbZH9E9r276N+EvGDcAr+mI/ypuDRC/oti6c0vgJqexgHeWgeT7o6DaxZumkeBoaUxgNcV6uIYcD2ZeOoRvNdSzOpSYh5vnZBpF+0+U//OKMVQlRHveOs09DrM+0IJfP5R2XYb+bqWxgDi9BZdHARrnhRu/K98Y6zua3ICH3GmQ8SrnS5L2EmQBa0Xoe3n6vo6v6wlZ7aoIGSKa+6tifqg06njZrjy7R+CXBnvS4/77oX6SR6Xhl03VfBM+4/AHFdiz+4Y9PwYaWm6a8dLK3KiHN0m1aw7lKuPZ0KwzY24uf+dO9pM1aYj2um0B2jarZgT34iXIEed4jt3wg28dzKiG19UfLfwrmXpqsoIb3R4jwfdwXuXcC6rUr9U/8Kaja6qJODRBYYNEEfFFClnK5Ic+zyLwF3xT+aRUr5o7nmDGtoKuq3vJv7jTq+jD2edJP9qL6xhb+iIeXS1mvtdYz7HKuCup55izZm3Kol6dJZ+Ouwa9p68COJkoxcQ2Ing+fE/DnJU3vx03DXQmTQDHvcSwhwp5rNB9zD/lAb3ustelRHqWFGfdA/1+rHtqoxQR4r6aecWZPDtnxLqr4qB6XXOT/8l8sKLFyWQUj2Dr17yYDmTfbARrctgW5cZ9aedc26ShDkP8wfPdwUPl9EtU/9J9HoyzU3ofYC1yEznJrRcYZv7OVehl3h5pIE2uW3S0xDAmp2ju0PgJs6K+RrptO1awh9rVHznJr/5waay+FK9oF5VQdAjzSXfR5ypoMidfZKTUMmyncfZ1HNs78TwWDc6amI+oaDiWYcoz9yWVD3AM7E2vZmKmCinTPLwbfmSB1lhJL747tctuqEk4qnKJHziLwVbm4VU6xpiHWFupXGHYM/qmLHk1mcOf4h8V1+ZtCoJeToLiMC+37FnqzOzlxPoCEGfdAj0rHbfHf+eeoJfFJNSY+G9sQGhjw/9SZdmrVsfPQusuWWCBdqyu10LLermhyCPJeCmqAbXFdzVXw8f65wbYrLq+BLqjaddwzxPnFejfCclyPGFy2M+y73mYRb0EgmZI/5he3nH155M9A1UqxKa26J12IR92GmnZdoZzD9FzzuYq4SbcoIbTwh8d+j+nHquFe+agvjGk3Bm3Bm+5018z4lvtHxPOmS//Sb77RPfaJ3v0+543yyMruyEW1TEOJ6CSt3xUW5F5KZOYoXcpiPK0VB+ithTkVwUR0RP5Hc/B30nMcJZTDm8hXGzryblUzpW1EnQ66FbFhXhjjCGZdRV3mv5fK1KYh7hDn83mZ9HfhqEy01sp15XE/dU27314KsvCyXLb+9JwELVWthk+TBY7uVfRV7SpToK7FoIE9jX3wNjQEy7Hc04GNNYUPJF/nDtI2Gno3GAuLzBkMaBkl8X4oaRUNHSWEAcb9DhseAIXtbqU/fpanXOV+qvabmFm1vAmCz83aPCOnUobiLIkGFsJc9eycMJFyJqel9cZLrDL41dE0Rvjt09MUfKqNu+lDZApp0eIJ+i5DLrxKERUmtDQwT9IcI+jZGddu5Hkh8cIUYLGh/ox8cpjY+d9i7yfe6+V99yaIxYWtE46djybbfHySJhIikn5odGirUdjRX00xLyufbaixfupNmHV4yXxrY0ZvBXfaYxs9NuCZxn3ZcJD53NoWFzqDmNHPSHkjs/g7kKFdCeWx0RMvLzTHAf+RP3a2Pn1f+ARk/HjjxPO7MFyWWSD57ryHk8F94TF2cuixN9S96qRLUjX9wGc0x0u9LjsNfxMSHzefu+hRa/a9Eh249/yzGBKZ53BjKOPeQvye/yJIhC9U1xdPIciUcmsu8/if1UUfJO3Wn+8tPvCvw1T26FJwN27mnvAVPeJuBf3z+d6NmAItT7/c4QfakevLQyvdMQ1UjOGw2wU12Ae5uL9awAurw9rvrfzTNSXxxKEGAUrrx17nUWSM5zQe5c50sv6gldvMRceFkOc+ZfcpakQrfPx9q1yulu7K9O82QwJOsMtPbcAaRjJiSvShcPTD/12dzizTD2wpVgUt1XJxsiVZotGoL6jaGeDbFB/a0qqYKyZbqxQYsWCH8wwni8DJghCwfwvVff4B5D+GAjsswoMu/38bsbW1iOux21lgQ5CsgHM2yQB+yRHzPfh9oQ2FjOQQItnXLMgJ/zFUv95OIljkRSM9o1LS13QK38MwaOr1ugWOFXk2jVOE0FCCtsdtCEmHa+ZzgQXnJpwXgvtaCsKyHhrHXWRJoqsk3gI+2FvDv7KkZ/TaBp17vfx0Z0VWCYZk0OxSoTvwfPMUxw8lu1s00s29sQ1xi4BlqU5yjXC+eBb2f+daJNLbGMgeVTpD7GtbcW+fEv2cSzrQUxjSNL9xAn1FlqeXfxvdHpqOsJaBwTwTFOoL94/LnRQBvKN0M5Vrcu88u3D3cLck1OGL8xxoMpUrvM7tVzarTKhpZsMgqYh0hngRdhGjSybCgJZRQoj5FOAs9ZwsqbWiNZ19EWCVB0Jz2sa8wJV304sH5ha0H2GAfU0DdO/Ii5xQO+FFGQHcfO0f5YE1+FcaqFyh1o0spDKNaemkifdjsh8xT4SZQGmuviKsh2LQgD/QOZRrV1MsBppffipbwRv0g71XsdMY3I9Zj2cEKdp8VaRSK4ZcmDvApLiKOzexn5qV7A8TVtCXpER73H0JfyePiUU149u3ERPtXSpDbpW+laF50ycZ1125cG7kpvQVXw/co3VTT3EoIRCIwzJDCq/1ZJLC9buiT8liDi2lxG8g5X//1fA+IR/v4wIh6HxCN4HqEnTfn2LUtjLb99Kx7xJuZyn99beY85ICum7/Wa8lb6lgd6ZnLc8dIOwB3OYwhn8bsGvVsRgQsZXJgFfQR31R/21D09kYn6tvyZF0l9M2DP0uTB3PWqylqE7MGeGKjm+XnJxsJyE46gOt/rF5m6iqxNR+iCrGgLcwmgKO9S1nU5SRPPl/lDzu7UsninKoRv7n/nTpLF335hfqoRbFG1rqLT4e7pHA/yQ4kd5riHmGPJk3l2nz9l8FarMBnyFlZg+jsYRpX/YYqY40/bK6tJtmvJKkN2jEeIaT6/z4idb2/1FmNDTPwC5neC2av4RUahleCaghiGzDBmj+Is3FgRNuVEMGCCp5i9CE8WDkOV3qqM5nTwDz3g5nfrLugEV6XEMIL8UH3UEJcOg85wRUgII0B4hgphnp1EkNvaE3mrkqQ7/j3lMsmPKuR8l/JccMsECzRn2a4F4DK/+g4Yg2HW7Wq6I5CRFW8wDI60sZz6OdSUBgiFHgEdIF+K6gfqvbwfHDdxnthV2yTfi2DCXu+nCXq3TyMNuwj6AX3TG8DSjAYEysVyjAMif9RfveThPUuch6tdhN8Dk3tJFf2aAsTs92BvTcwHnZ8Oj7FPhu/SJt9/p2my91oDmJa+2nsT/nG38wGg9Hr8qEiFuObJtbJS2V+qwK1LIZnzol8mwZSApY9yMbNC8Xv1b9QvcEyONTmRjCCV0AQzyZ68ZaHn6BtLOxHxSyHbbec38yQ/Rmud4IqQGEYwGezjZzifDVlBrmqIZgQ0jzHT7EThExemSdalRDHlSm67Tf4t5WJTs8dVKVGMIeoKJcbVo7f4zujaO2mGFPbIRGPfQ/nVGkf164Fgwl/RhBL++oo4qREFEmIOH/n1aBjhr68NIvwVTwghDYzjxYexj4yr0MsSLHl/HAiusrRpGh0NTWGOD/u9MUfIkCIPMQ+QbF0x3+ZpDkHZqw/Foeit4AajaDfDHAwTGgzQBoP87qv+BDx7Oif5hvyJE6mLl6Sabm+bqdURXD2w68h5XKqmirifuR9zDfwDTdo0af4z/dYxn03fcMZc3C2Ik2aQ26Wve+r5uuaCZf129WXNihAezDWO6TApzNIZr6Y4180LlVHmTZMTyxi2S0EGYDGXxdmTjn0W8kQ6zC/y/Fauc5TvIt+/V/+o5mjXFO3xrV/XNyOTcbcrJg9AVkx+LcS3+fUiu843SNm9nkO+SU9IQ54WzjDbZcuKoGXlrw2Oxd+ILq6d/x5mfmMmJM95tZy3sSqJafhM9/uYma64EcusoDfb3XeLo2G0IFcD8oblCDfX+V5Ehd2z4h/W913sbYhtyGzPBqinhg3cXirTHInNaxCvNCXS/9r+SmuWQUYjTLAXe8nVYw/nwlP/qU0d7VoIHveuiwbKVH53jMklqZAcsLiB4rqGCKaC5m1BONtKywF2ubqv/HOymlXh1aUQwC07pGM7pWMNY5TUpuq+zc6EYJpPrEuJWjqM0y5q7zcJ1w7Y7ATEKjkG7YDV5SvlA3K3Eul5XorqAZ5VDQSEK50z/NspRXOaGVOBg1ysIkh1Z3OUVx733WU0j/w0CLPCGlWarUoIQGudNJCeUDanU8RAByw+E2tjxaGUELrwN6d7mI1xJAKWnKtntvT0FAt1DbEMnuXRsBMs2zkmhlEwPBmgZ9hui8kO42EY5HG9NQ+5UPSJk4f8EGn+pH+XUXgiYqc8p5fvsd0VfeH6ab2aqk0gH+ubwfCYIIaZYdr6nD9shbcictQjylk2hZZSXgeatCfk57U9NgkfdDu+rSt018Il6hpiGfgpvh7E6LXXs6x8itRPfmah6+vRxzUFkQz88N64Wz7HIWeDeEaQ67GHhuedsDS3ZcUhXahXHarr3mxGyOLY9xy2nSptoTbFf5lsS29Nsse0zDHATXfRGS0aoyJq/eoGMfwKhmd4PI5v37IEavLbN8uT32aUW/Pk4oU7aWLmwqgpWo/38e6atA8pRnmCkHbBmet7YZZNczU7kcoDSCopFCPf507yUemlfvRJlwPC/UB/TeJH5KPMOkd8HhW5SNR/gksRBfOHNHyU9ZBSWwsaBWhDToegz6cETHjMvcd6vNXaPR1jsuVG5QwcBEM/1krk4t1tPIJuA7cN0LYnN8aPQxZPYqMx5HwYDbx6soHYmoIMLVhDOx5gsbTl5xzd6+zz+b01i61N126ju++Zwe+422EcfcToNmRGtGsJX4D4Tk8x4ltkfysxbUyAWNcTwiArEA6w+L3HGG5MdNjYrPNEA01u2J/OMEK95smcxSzvgafv7VlUbZ/RvTG+qM6h9EcYHQsvXHHRRLBVSQzDZXg4wciw4M/q52alzUKe3+pFkgOlBcw1NiGe4fI8HmPkOc9oeB25vDhYUuXYoqIpHsRFNphHs21PuJ6myJ5zq6Zou+E9kFyAYjhPRgO8AIPKs0XIvr6o2QQvs3fRs8FsKSFmKZdWG5mFnhOOGH790u8IPcOwcsERu69m9xS3/YWXA47YfT27IE8dJZuYn9zz0HlQj/rxJD9p8253rmi7IrV3dL3wH0B1HqmuZ4f3hBXWQ33QOT3tUaklmPEOhzmVD1Hqu59jNzvjFrJYXSfa5lpjgzYZXeL4T9VTQGhv1zwp8+twS2pCu5YIhkrwFCfBS/X50vMTMzWQoSBuwdYPG6Ll9twTPIt+rEeXWbREMFiCT1ES/H6rU1a2BnBdSfzS5lqLABZpuHVvtWgyXUzQwq26NEAJ7c6wGtRqcsIWLrZTfNjGip2kCGvU/ARTTtjCjWXAg+09k57zzvE99ZUnUbH09VPeKIf5PZO8OMg2z5tUgbbp2hPE++d7a4I+7XhkL0g/uHy2qldBFOZ7q8pdSLyAn7OEZQHnfs61GwSrZXRnqKp0N7d4M8P9HzP+qs7qWPf/Ygp5XMeHEJMdKyk/BHZjA+IaONdDzBb7PvV895rFl5Eo4a1Cbde2ycX+p5mGm2p13MOBtaOcz3BdJFplsZeor/xDg1iXthveXWcMZPPS9ZRXFReu6t5agTXlhCzUFQ0kHvG5l99R9fU5t498817LybMTtJtUrRsmrbT+NsYBq8/+2NyKKOYiKXCtCqrUmvJ2w2t0y3Rpe4QvDnznzHngObf5pwv1rRq1urQ9C8PNPTEtbbcXgPsoMa0RSnCCrASKA8409L6n/P2mnGUVF/oMay9r92u/0hXzlU8n2JAszEaBV8Q4ZB+qmG6v241o+fNNPPs0/YeIZ/Zo1iIvTlzu7usVzb59KwqdZZ8rbZfbOJ1rtrnnaqISeNIoAKDL2+Mc/Gc9Nsq4TToe3tBJ5hfqZzHhRVXeqzJiHWcoTxdZz/ZV75lu26syYh1l2YxZJ+06TxLFnhZvXJUR6yhX6LrpxNwK/uTx50vOklRwveSGqSHwUYI/nHYT/H2wvc3iN+lpEOCsKjro8hR2kRiHWWsKwh4l9uPTLmLvZWnaZFwU/bjSG+ilbg63a9MKfRuGBa78tJ2cD5Rx9AcGRXMLGg6YK5110kFiK/Vwz3x/6w9pUwSrkgYB4kEw6aS7dM9X6ic2jQK7loYB4mEw66RrJHmSxrZN35qC4Ed9hnIw6+S+WMKZcBV6tiFg09EoeMUocNU3iGgD8oT8qJPDYJVnBs4ure5Qg5oGA+ZUEZ3cQVvzHeLnnplD29AQ/ojxn/U6jr9s5l/SAOjAAOik/Q/YY55vp7jt79XNeNRrMFnVNBBQz42Hp+NObpvx0OVCD5nTpgWNDd5sPMTqD6p7w7YgbAdFTU6viH/giG0P5bGBiv5dHMlE3ST53VcN3PJswNZTmkdhWIRRLJIcTN1bsqkhvShecx+MQTGlk5KDKfYxsS1LemhAXIWrqHE4bJVQB4P1BpivB0rCNByhHwmbYy8G3ONgc/R9QLmchkP0o0B2exTIY6NgQukjhyAD7aTzwAN2kj1KeeJHTE12cxAyDD4nni+LpHxeqB0z2F63CejX9ESndjYmaid4oV15L9lqzS1Tf17b6NXEhDD8YoWIDW+mcLOKmpr51aREMPxaWpgIzj7ecV89I3eRN8kLwu5wrqtMtO0tIGDe2HWT+RExP+wI81m+fZ+bJlyXEtu4Fsi7Ys9X6t4XsrsoSnQv29QQ47Tc0WrGbc7KAS8FqHtymOsx+SV97FzHInLUA6vVKjDlRDQSok8xEZ1mqwjveChTwZebuNiK2V9WgdalEHC2dM7geULbjWNMOKufHvlP6sJhki/Uk/cS78krayEV4aSZZfukkF5Gv/LNNYtjrgWtH2wEAfoDt8A05jMK1cXK/1z1NlKPPidZ3pXiomaNVaUVsWls0Z78Z3/9DpijYNLt3Ge9rvFfVJX56un7mLoUlKH/waRTOfPW034VXvMgEps67FvNp8jVnHlTDsiwN3XWpJ2qmXUR9GV21yygb+UEOrqcxR0lvdF9b2xA7GNjH2TqGeayWD2Zk5CXRfS4EJEoVtOdKFQPOjkXnvrPRSbXFmes2jY56819M0K86dzbCBu7AYsbuK1riFmYmz8TbNB6soHZmoKQhYnsYIiC2eLdL9VNzbn9HMo0jiORcPcTSxSoWZIVc8vyYKP2eMOH+2oQ3ev2ssYAI8wrj/vuMppHfhqEJsRWZauN8dvji6ukBkqDHEYiUF/6B//GhGBaKJRFRfwCTv8/wc1vmAZceI6d4IqSGAacc2eEm2HXqGRX1xC9gCtPILfAWWUt9dSC2I6wpiaO4XIMM0vmX+A4+eMIyUUDYhkwy6f4WW6GmOiFHRfXm+Kn94ANJusLnF+Y5wxfz28QhbxhTW2nIn4BH/9Gzu9L4NvpLRXELmB2ZxjZTaJfZHF/d9X9dhKiFXCOaZSWtoyMfL9J9NQappzIBXx2CbeP8N5LrC5CKSdyqTJku8gNWHwm1kacbykhWuHSeopyd22V2dPkXD2spbGSW9cQvXBPVQyHuOm1k0vUwqZ2PMBLrd3ekq1FQC0Ovzb7kPN6dnd39r+/Xd+cX3y7+HT2/uPFeZVbu7bFxyjKfhncDjp9gGIwwoXsLReZPb26ueMy9bUVBIuKYIUF6wQXrJ/Uh99SLjbsXs9fX1MQqKBAHfbxgfpVNqJqqAhWULDOTvHBulTfIdluYlCF1VARrLBS3AyR0XorPBmwDMyzoo3mstqURCwsYic6sVN0xF4qaxrp1Q4Otekwv38yLXZr5l1DtAj/nCTxQcNrNCDjC4vccRfIPWiA7e3ICINbU+iNIKLs+N476QgvTuS7WHAvVM/F93OWr9nvkbj2Qj3RmC5tD6eNHdFBnXY7BSnIE7yvYvSWJc6DHdSdimiFResEGa1bRPYBiN4/cUBhHql+R75fuMx/M5uYIgpmyN74/EV9n5MseMDCxHO+FLEkt0wk2imFI83aFCJDLL8+8SgyYxsrZpJr9YRUw7PQvVBdvlpVU4xGLi/R1QuB/ql/RrCDTP8xhAr7A/djRd87kYYnCZeJBOZY2H6/gSfVvRpD9St2T7coAfLT74rN8nMVz4qobfaz3gODTiqpPIZuO+9Tz3fLc7jxZu576hu/MhncpaGZNqmxQVu53fbNoHZE1GLC9iGI3P/RON1JCExoE6/RCA+Zgsc+c/ilJ2Ty0QuNt35dR7RCo3UMd51AOO+uQi/JQb3ja2Piv5e0bJtg/7ONcnodD+I+RQHiLnHGLdNLXNcUrVtqemMwUS0w9aco6DznK5b6yTwKV976KoxT7ciWXUvmE0ToFcwchjVCsw96OV2voxRCjV6dTlCAqO5mVuyWJay4k7cievJcPW71UBt6vcN5vU8nQ8jMLtL7eRQELCwm7XdpGGaHA7PtG/6iWVOLqn2GVeuOweqo4y95hJja+CQwgU3eMYH5KQ6uiliLWllmi4owBYTpBGyEXx3TqyCLYKohaogJT7DllWHjec7D6FOULLaBdjVQGxsQsoCQnSFCdn9Z5VSXEpyATkdNIcN5zu/T9VW4ikpzWl7pJrQibB+Z1R4YO++n3Z7Hg16rn3+8ypFU/63CWF62D8Pi9xoAzrqdJWUMGcAv6i9nhbRzCrcXVRSrsvbxWPn5xut68l+UHBUqlJd5XukcyeJjFci9pH047n64AWOPltrBwrjkPg94IjY5j7urKpKasH1UVntggDnueIIzyGDeeyG0o/O7X61jeHra+W3z0x7k+fUWxQcWuuqhhq735Lkpq2/6NDZoY4gHodqQmQx0AOcHHnKxnfFsL6qMVmXte5lXfr7xLu93e/W8hwbKNU/mqRDqC4vzlZZUDAeatNGSvjW0uOr4gvZCv1SqRFlAtYDZotWjhopQs27nFoNZBn23h5ekrlds9BQf1f+vVtoupC5u4TbktgsGlsNup7ybIMEyC3K/Z1JzOqsyAhLI8lG/h8pQ1m0k0QhpyweLfVSTm8/Cf6+soXnwt67Z0nnxP8uf7i7O5kv1Y/qHCc2WL4bKxRn0pz9swvO2iKIqNToFvV/uhV7yLnugJ8/q53FRbFKq66/5pbZRqUnbZ0YtXdFpzb+fciwDBnVdrru4J9lTldqSp5vxKW0Ln3tNS6Gtd8sEt9uuwBAluEVwhWlkq0LCFWZsMWiPIPZZklVnfsccR3lq2YN+x/OTlzm1F7WDmRctPpZ5sDMGtf1uU3uKDVrXkztqz4vP2grVXgSD231/THAHBC58cNPk4Z0frcvIkznz/XvVOFtH1SLpDXmb0a32yES226eP+jOMzH7MPlVh3QmIUpArsCgt6yIx4qN2AqIUZh3yCR5M5UP0XFCqPmiQltdtZ7TsgIlot08vwd5XrRkh1eHt+z7Ss4TuJQBsadENk9QxzaXAg/ociUep1By0Pa31wkB1MCNUwaMap+ruIlhfNfphojoiVJGgimJV1eyKiSvtBMDH9Zvv3edFXnJUf1Yf8sy2oeawGuIWI1vtjrnd2u2MOSM8uAZFMVpZ1q0p76hWuWYvazuslc6Yk6w+xWGhBDZ0udDjWaoyAhbsEitSYm/uf+dO8oX5Kd+CKmulbw42IqYpzdk/zvTvMgqzGNec6V/URQ5rlWFN2HZmK90xme3RxAwhsnf8yXsy/YadiHClba928fqeKwW/ZUI/82qIiVuw52CRcnsTZ4fmtDMyFRHxCpXXAR5eM2nMhKJTPbViksbE+kYsH4S+gatL25gk6EjHzEXcWeeP0vZxrOTGIsoWDN4VRTqLaO5dvc5dHPdO0uZtMrMn5j7Z29ldoBVNT1ERCzlaxuiDSSodkcGDqaveeqVhPc8/6nVPthIAsO56YuLaJ1zB4yq5ePIcvoweeYjAGbB3xwR3TB4BOnYhuwW2jpjMTsnY4gIWvoNg744J7oTABQ8uD588EYWB+jYEToK1N+Zq7ZR8BGzkQnYRLP0wiT0lQ4sKV/gOgrU3JrZ0QAwstgEL1XX2eE9Y7L1LMkfwRCaRUNKc21wil5FyC1zVylMPoQpxg7qN+2RHumruk006v082RQ22syd2GeUTIA3sBjWBjWEDeIya7Cx4JSd2UQjN5Mqmrn3ux99CNJr0SUNENGdJM3KIz9SHWhlETdh6bMu+mLSO6TwE2IKdTbT6Zko630xJ12KH4U05RVWxc4LRsubZEmvZ6XQp2VaItnXaR8briZNX6dzO19SjyjyAbFrmZHnhr3f/4uz2ypi8HW0LxDDvb4HJ+ujt7POf3N9okYkGneA2TTxfvvMj5s6jcOWtS1die6n7E1Xpm7HrhSvBpLqBTpIKXkXYovkzJFu6ZvA7HNE6xBg+vTybjhUHKC6Y8DdnjqOe0KXP1rXZW5O+fc6G0TWT3G4H+Q4hT+CKJxsrPpLPsaueynWRuCAHuC6u4mvXttGNONBJE+VT2uWAb4MbcA7YI78K1QPz/XkUKN/SreJs1xLO8H3icR8+0muezPOJz77WfF7gtCSWu7fCkwHT2hgVT481bS/qls6boFNB1BleyC3AXooo+BS5/DpyU6P85Kv/AQFPs0VYxH+MHObfFn8qSy31Ouxt/4rYB83+8BQp+4J/Tz3Bs3yr/hPP6K0ybtcSy6BZnozgs5xwmZw8qDmjz29Z6DnlfFPfA99e/828Znm21We/yOp2hFhLRwxiRxQvN4a/4ie9rGvnPPsBTrE8oouq4NY17TW5tY6Z+FIYxwS+vXUeuPMYR165Fy7ScL6TFG/c/FrzHQ60aS/OWkfNc6i0WD2YoWM5EZtldMeZm5UazlzchWoQaMWIDzQhkqGuZvQRTOmK2JwT1ds4TU5iVkbYuVnuvcALeWF2b3L1rdJWoT7YqMVY27psTvJ6hPcALd1qkr/I7+q5J4wFOU1ODEN3NkadYDhzKJabmC8c4cVJPfTuNW2hBOQR+a8r9YVgq8UpgjrykP4t8/OKzPRHGtQttuJ6B02K+52n+BQhxFlE8Y24Cr3sZLb3B68ia8ZLH2pHWMN1racIuXbZRi680OGXnpCJJVyvsQGRDHdXG8FqXhyvr8JVtAvkKC7NQI29tMUBpruemKRSyQQEJjeM5bvsuaTFYZVbEbmfYrnIJR+j6DGNq9A2qNt6VEXrnIlvt9Nj9Cc42HVYnE38i5NWT9luXiGoH7OyKdsM7r5nJrndPs6NIOzCBPc2kslDtC7p1AxuTUPIAjS2I3zGtiSzalYt4JpqohdgJq0+Ejc3FU98k8OrfNj6joYmbLVLu+2IyWm3Syn0hxg5XeRXd1ymfmLQaqqIWXjMTvEym7/7rcjuNEQsPG9ggGP+VSE2i6H0vZDngKyYHvVuVRK38LjFZ2mLAzo7q1ql1qJq7xbDD6AW1X7YBB25RRaRBVvxrXm9FdHLpp6s0NqESIabhWU6w26Gr1THD5jirZoghho/NsBnjrNzwU5yybl7z/TzchYVkQs1RGyIbyU3j8/NFm2tgbtVBZRgdIL4SOBCDx3EypuzJDfWpYQvEnxH6PB9Vr+U1/k1xAQwDoBn+ACW6X3gJQ27FlYl+cBQ8T3F5z4kXsCznldzQ+xFhCpYVE/RoerJr16ibt1S8ane1YG21WZVEr5Qz8ljSPYQC9W7pLxwOY8vXhIeuiXLi5g73spzvjA/NUiuqdqcQr6pj2bSNDoCP+zhZtrxo5A3Ym3XEtkoyB7hJju7nGf8ngnBNnrKKVNDRKPIz9rHTbRkK/4hS/cexVwkGtIWFTGNImnrKTKmH7ivEC0OH7PdXd5yvJcAwXffHZNdyuswwGaP89pb+xJ5tSPHuhQIwdtOmfxShYIhMnw9ee6JC3W9XZrbXuorGVUpEIa1npkgD8gxRgZywlU/1TOS72QkkuvI5X7hUOwvNedYk74Z0m98lOM1PTTRptrRoNEOnPjd9fx2V8ugnu5Ml7bRGu/7YMDZox0R2Ic9q3ReO1paqPKyfafi3ppGNMXKQfuy375l9ankt2/W6sdK1VC2PE9THR0uXr5v00br+pqe66SfUpY+JKwzkWTbbh7zT+KiJtuWdNWdRP2ei/BpEbJYPkSJHkZs07ab7qa+6mzPqF4M7BiL/QN38jDhPdKSZTmq/+A2oG26duOs984w0FSJbjTFAfG3bYLn7GmfqP8k/KXAuYiCnxeSKss1Rft86OP9M6zyrNOuNRKWV95LdoZCvrsX0SMPT/gLy/p7Eovod+4k7zKUAJa3/dMdNIw1Vb0dQk7/Y3n8Qeon3onMSyeeZE9avlOUeu6Jo/oYBWVRIES8/7kOG/zTIh4S/ssqFPLdOb9Pywz/9fmkfR4JweFu6p3BM0Vl9MdYZpDNQKsfykLbVLKmIKyxmOk+MqwvIxGwBKWR1rtmoEzhGrBLdVie95fM3cyrXyGE2eycgTOF0aFzOL5wIdWtRexuGD00kKaooyE2pOcfryo458kmlaienrMUAsG40isD4R6l5gReGHfNQy7UjX/3lSXOAxdlYm8Z+U9GOu+dqH1bLZZOmHFLvW7HLaFDNM8o9FvK9YPWupRABV6kDgOo5ecqpRURIQrPlvZRMOpl+2Ay5k6y+O4XB5mqEu0sk6loo9/a2DGTXlrj7feQEiy/++eeMDMa61JiF/ZhaKzsZlmLl5uYu0pwmUUXmCmNa0oiGTbJI7Qkhy4X+fl9A2JdTvzCPjIK1RKrv3tSPudInCTZKWGp/l/NLrhIThJlZqUjvDg58eRJHuGVU32WqzMjvMi1VzLfsboKYz2D7LF2rZrx/ZVboY+EwfSUFiwAhrX9tUHA7HBrqYeam7yZwV+q31oFf3fdeuxpQ7q97O9E+y085rrbbeds/rgoT1Bpq3mH2rSd+FqXDcpnlDmu38dFeXEW6T71fPcDT74yGVxHbupXgoqu2SPf2+98ulnzcg61geDhHLsL5jjov5mT8yf3uVtTcH2Ey9E5PgyCOuL6+RWruu0W/+8BH1mER/+0a++AeRTceyHL7v8no9qERUUWH9u0dnTaSXOvLip41+29RU8GH6HBHw+wGPxsUdsNglXOeGavpWrO882ka6YlI7Mq223ZK50zMB53e1VyhBLfS3XDNr+l6otXHndNv8SuJYBBAnyKEuDz6+vLn/NM91VwdSkBCxJYPMuEGrGrgyZ3ddDktmRf/8czjGq5ezTGBLJIw6yk60nCxJonRXbzmAnJ7wrFMpdrqU2tWghM1/tq4D2hLEz9UffozlLzVhhrBt1oSMwjSRPZw8R89mxPeFbpLDtaXTCf7b5cbEW/enruf6uy/V52vZ8m2d1eoe4PsFP9VGbE0ACukt3YAILl/lF8k7cCifHcCdH4PeStHGpIzCM5FjHtBPMfyoMGbqN1P9KMeEeSA2fWCd6vgjgSyWHYG9oQ6Ujmoeg99t3lMlqkq5X3UkXcqiS2kbA9wc72uuqJZFs91yw2NjIPNCHOkRz6RG/DvZ0TYoe8SU+EIyEcvSW/CldcWHztm7gW9PqKprSSDn0lfYJ+f8hrwFhPctXchmw7Dts+mXSV9Lw8ryyq5r2GerP9m40A9YWCSfUMnKyqUnUgWDQ0Hn7seJihHw9BlsRSAfaLtBr9BjXZeyxn91HFkWdPO3toy2hLzPk2TnfNk7n6gcnZWt2xtXqMN3k1OjNg90gzCNw33gQTf0pdMe4I/HaVufZub0HI47L4w+4Y/GztUZEmDQNfFRPdlPy2tXTnJ9O3MC/Ug3Js/oqugAD0tl9mxjiqyDdDju88T3hwzcLNWeje8UT9/UaiD7QlyEG7IAPklH+O3VdTfqAtUU7FVVtJ+VXo+KnLLUwbGiKYnOk2E/w6d+R4Y+Kc6ky0mfPXOSTHGxPnoDnHO7u02OZi4ybL1Gbu7xxrS5SDPi6Ed3ZpscyNlB9tS5SDphzv7PIm8GzL3FUxsUvpVlrJ7i5sxAJwTUcUg6YY76wxj4DaewtNMVL1FkQ0aKLxzg8/iCiN328sJBsaIpgOX7bTs3haH3QuLGpimY5ZtnOXPA0OsWxTE8ugj5XhnfFde+Ehlm1qYhk0y3jnfdfs5SDLFjWxDJrlGe41jB2ueenVo2e9tFZENmSyp4OOkI32GCOx3cj2BP/+SW6KLdva9gbEM+hDLz3s685nYi2b156rWiIZNMkj7CTfso0fMbcZZqMB8Qya5xl+T6PBNlv1RDNkmk8H+Gn+wJNDMFfUxDJoljswB1w4zGfiCNG1RsQ16FOzPbyTwUuP+65yJyw4myqCGDbEiPcII5f7W1xtjrO9wZsB/cOSYBPOzUki+7hxtttkU0UIU57TNiLcvCRHa3Go8slMcXvGd3wlG46bWPWEM2icp3h9ZMu+Ne1U44AW74aIMq9nvh89c7fBCNsbENCggZ4h3RPJqs6F7uLRi01jXNcQwqARPkW1OrET7NJh5JGbt0x9gZEQQ1NAgLjaNzN3+ZDScw3xcnwrPBmwed52KT9sdVWiDzRpfwXFtycbS+3EYQ8v1TETks9Vx9XTFu9Tz3ezqnAVa7ll+2hDst7gAzJQLWfk5tdzZLaFdxWuohz3ZfTFk15ylfCgCrchbr+xtnTO4Hkw7Xa9W/Qol8KtrIqzRUVIg0e6j2ySmJxfX1/udgArrnMmN7cBLWoYDse2l6a7MaIzgIhxtiBM2FLpn9bOBnlhWnN8z3m48T2ZXAihL2/UFGAWNfbdM3kedNqlMNLpT9GxfJ8tVBTXVZINMaCli7cm2WqZnby8AMhsMKfIjXMZh+Euvvt3aZh4AX/PpC1Sw9KCMMfhgIyn6CGvinS4TQ1BjSQsqY8c6mf1u/mleujXLK4ibcoJaCRb4RPkQCsmvaxAT1bJ/WytZmsy2c4QtXL1x9oR8DiAH4/x+95lTIe64+eekGb6mJqS0MZRqWrUw492OVnMgqIvI7FkQsnM8OmGJoQ5DszHI+SYu+p5bROJKhtdxduiIqyR1BlEtSgYRG7q85NVJAKW7GP4rnPxZS6txe2ZSghkm/00wR5TvF7HsD4UmXqgHcGOYnrZx037VbjiokrxTZzdeW2OeahN+/fifwzjaLbikVtzz2S3CrZVSXYbx6QSN9cr5Wws5TwKV966ILgKtl37ZmSrcSOYVHfXSVLBq4BbNMT5D6112Md94oDLrR2P0+Tm/nfu1HKEWFQQbHhTX83TBxOK2O4c4nd81UB4qSHAcSUo6wbhqywZmeanbAXEM649+W7wLPMM6oax1oTENa4N+Q7ZaQPrqoyoxkT1aNANqt0g0IjeXhPNqBZE8FXBeJefG9ud882vypioc5awPNt67ZiZrQGQPOxaf820fSM6b4Ztwlg8dFEAexXEkSgMdonwxUsmqQJeU7R/F9LeRxPuSaf3IqddgFqTFAmBq2g3qMEkWv1BiFP8VKsxZ657q16mwb3PixzC++tltMjvc3bUTIsqOdQGDu56z03YKblff4rVHef36foq9BJPffsf+fGbvXduUdYc9IY2cNA/cBvMcTAmpx1bBp+CgWcmgxx7ZZ7khbvmX5WgdM+rxDeo4cBedtQEe0Z7PSPEVOcm7gNPMmzrUVZ2LTGNwVgPZoixdrm6u3l+nsnoTGb46kfSbFrCGn4cFWamlaVx97NIbUmlpiGWEZQlnWH3OzLLa0ncY9MR0CgmiLgOLRQPPNnEvFwrmEdBoGfILAT1FJl7ORyyrR01OZ8S58iKJCRl0sviyecpMH9LudjklL/XZZazlc0t2r+neaDr5kGd0zfb2PyT2Ldlb3PWGeYNWc246yoI9v2Hc07RKaBhv+My9WvH0iwqgh2hM4PYsl+FLn/ZOzL5ZZMPYyqhuS/bvpqQz7ruuUy7wPf+smbCd1J41vttmUa32oIS7O2Hou6kulCfcwNtMdwNakCmu9Jbc6mlT1X7kNO991CVxD7PLBWgTPebM41ta76H1yM5v78I00AWBdHyz1oltJ0Emne975fpi1C94M6gLD96MqnzvBMT1OR7QKK6KqiHd+/l8CaOb002Mg9k1BGzzdWnZfQ5NI4vGGLCG9X5+dNusP0929T4nB1LMM13XUOEYyJ8gnPhL2BxtuQhdwt/1yyOFWRFFlhz2a+mBOR8V3pqLpD0aDaJG+w1T66ybJjmbrspB2Wy3xxoVKcWRp2guigBZcFaVxDXWLiezTrBdaMXYtPBy1BPrL9qRbA36ATs2aTLYsKrYjLgaKDGleZ4uSiKOb6bq99SHNLJP1VZ3gnaP1usdcdMlXna7T2aAXJ2ldnNL7KMqRaTXNNBsMs/iGlUs8VTlFwXk8D9rmOe0rUQ3ooo5iKpH7RpaNP+JLD1XhucDymAFVsewUbS7esiFhUoA05kdycj/RG0L82iODYdwU3BI2Dg5uVyxyemJwE05QQ1Ep8bp7nO/ecix3yxwBdUBFWuTTkgD9voo8k2JevGucT3wH01H9zv0fDkIXJ/WZxHzvvsaRu7NHUtKMu976yB95jKB886hncz2oQ1pqTEQ/RcPwsWW/KnGWIiGgvR0y5Y6jOxzpc8bLa6piO2sZRVxW+tuXRYzH+RxkEaTUo8UwnKNvO89qN75t8EXrnBvru0xPZZdPBi++w9N3kf0fofStyzoL0cdDMLA5wcDGZfzOW9bqfIwYntQpkWJ7kKHT91+c5Ylyn6cmG2BXPLBAtsSfwsLQBxbuu8Af2o3/WEfqcd4v7eoNqS3U/TgfLBfxztlJAYuKnPrg7Y+bqajDwuIz+YdM3Kb5muh1JVFGTfMdr34aBr9r1QHbDwtgZk43HZ+HHnbPye6pqV11Vk51HWWhh2CPg8qrCoH3LxknDVR9VPE/2DjQDFIf7NQ4AKuEIx+A7zmThk9i0NyPhjNP6zQTe9nRuxVd7/ri4bHB9LKxoGKE99dm4YFMcTatzvxQQ6ykX7Xpc2qvL8hbkoD3KUtdyGho6YR1jSfoQS+CzLSs74Nt1KvkCp6KsgblEBWq0se2hmY5lRpEGV5ykSnvM8sznQ+afa+X1dCgjjbcfMMLERZcrCZ5X3FJdxMI2pKOw8g3A83pZobHXURl0Ae6HY8gvH2b6AWNcT4pRrBQjiGcquNSF+XUNY4ziy3++C2T7z/Z1NrhdXq2mJbTzLfj3kfL9EokZ1VUYsI0kPjt2/tvodVpeDFj/ALn7MkEOcJUz56iUPZ8lHzmQtl4qhItuMwzbPcEYSlpX9crCLxqXknK+80EuMQq4HmoACfd9tc1dxSKjPukV6ntFSvoJ3W0NAEbPE/IGV7dNuMX+TPHDxGuZtDcnSU3Q4YEtfHH54tb23NSerjyR+aoJ+AMRs40fMXUYFx1XYLSoy7VjQHuFcS1T9DaIwJ7uIET0LtxlZqmjbdICWFne9NMHu9tribNIZprOYZyvQWwXRDJ3m0z52mm+FJwP27dut5zxWYTblxDJ4lk+xs5xt62T3oYJxRUQEg9+3HKJ3Lq5k/UBwVUYQg4d4PMAO8bdvF162Jl2FuCojiMFDPEW/dFHgukiEp1tjU04wg4d51usGzB+jSPI6yzsxoQwfZfzOhcW3INcCE8LoXYtv11ysNUO8lxDA0AEe9NGvUvzKtXLC5SWhCx7dAXpP+CypT+mqMoIYPsR9/BDXpnIVESEMH2H807g7rn6PlpemIiKEwSOMf6/uU3TxErNQY7gqI4jBQzxC70p8q7vD38gbRoTwGP2ULk8ac8uSBy35hi4lkMGDfDpFb4uXqer6MvocGkeeagrCGTrOQ/yrFE00E8z4YB50wsm44ytreiSrkrAGj/Vwhh3rPPFicdZj8ejFy3pWRlMJ6vjpG4ONrcLuCGfCpALZ4iKnnGdVFF15K6KYi2RjzytwsBEo6o3+m+z36OT1oBvc37PEUXdzvVTfL1l+9+3sH21I/KNKpTTtBv/508xwfuJHh8Br2tIowDQKJr1ujILvKRebO/Zs596uJdIxkY40jYHFz+dOmvBG1pv0RDsu737QLcOerTi6h627pQlBjwr6cUfWckQazqMgYKHbaOYPNCHocaXBPu0G9GueVGXzbIPkPHIyytWlUVb6SEsaAqiWcvrjbgyBGtX1bGWGEtAG7A/BHE8ULk7XJs9dnbOdf6ryvBMAYnjbHbMwzbjT8CINvzXYPVfv1HW5C64xXFUQy8BZHs2ww5xHvGjgXvPkIaqXT29oA6jowNsijiwyZoL04M+edDVP/BSFZ2t1n/YIn4m1NCaTzY1AzSP/Btqh7oJORl1E/UP2Dz3nlgkWHEXebEzo46ithDQO7Aj65zzmoctDZ/NF/TaXZU/juNlv/Fc0GHAMBqRBYfvB8IEndzxRfzXbDL2Ja9g36WneCnzeOp2O8dv5PbqGKdcVZK2RlIWc4kf60k+V7KtgcawnfLXpCGwUYM/Qb/bkJjkr5mi11VUFIY0D6fGgC8vmmkVuOGZ0pB0Bj2UBfTbBvoAeiyjwJJ8z379neu08i4rIxnGQYjxDjnWSrX2I24Lgj96j5qFYlYQ2DrSn2C22TO8l14Jl9xKCGAnE2Ff6VlXv+VPGcYVnq5LQRoI2zrMOv0s3cnK0f1mcR440V0V0KaC9mG3HDJTHk44HcyOnmLnuRy98XEYZtlWQawpQhvltacZkmIdD5ESveXLOY8GdPOYjSw6uGNPXra164hsH3ziXPG7Zxo+Ya4R9l1J7vHdFCSjQe99R06k+pZVq5VejpHv7oUjEXF5oSZgrMkBOdaVf5iHJQbf9asQL09v0ynJ/4Gwnqp040zTQQveqPTWt9bTb5yhR4q0lDq/nGW/MMQ6MbbObJtoDQhsd2ud8xVI/yU6Lnfkek7yw3nVxFXK7FhDp1l6buHc7nQPObcYPhYbPI/UAX5LywIEm088a1FSAKK931kR82G3EcTrjaeL58l0WBHKSL4pwUdj0KPA0uLfXoBYA7Z0zlwNntBzYKbTLUD5LdB8BjvVoTccAzzKP3dowNxQEO8YMmv1ueSr5qV6m5VqryohxlKmRETO+5km+cnyW32253bCvyoy9elMFaCuzqcsm89POM48T+ewZ79Xy3Twv77eruikvlT4fAcV2tKHOtNpgONwK1LvglXfG3DOdUQSAej8MOzFYihzDWVS4VH+EvxfRs+TCGDLNjeoD53Bb0MPn4L0y3zYDGkRqEJ12YhDZR83BYYJpXBwcCCM6+ZwNhEknBkLugZsO115YHwa6DtCk42DPzXdBn4aAGgK97gwB2wg4MACw8N+Af4/w/9fJpIvTicPziFdNIDDOHBrGyZDGyb9OBsNuD5S8+cVLwlWHVaf3qZD0RarDzWiwdGEHYzTq9FDJt7eKf2PJ22vX0sDoyny7G6+RQmzucOyEln0NTQd7N6Pad3PVaUqjQI2CaRcHQW75b9VDC+71EVBTEP6o8Z92Y8XpIkwDc811J6u/ATQV6BFQ7bg5AOgUez5D6Ij9Z7IW5bGV2Vygigr4K2DfcXMATGgA/Otk0OvgALAVez9WDJ6GAu7jOdMuvggKvKNw5a3ra6d7+Ztx74UrwaS6zU6SCl7F36KhUfD3VyoGuSbEXBarp3MSSPndzx8/FyIqjy44UfjERXIuPPWfi0yukW7VtsnOH+iczi+dWDjBR2/A4gZy6xqils7ZtATbBmYbgP3nMzf8aFzxJGjQg3SmCFj1ZAOtNQUZWKAG9nSAw8IqbzXk+V09kXm64K2PcCUjP88i/JE/cf9SREE93fCRZu2G29Zzg3Oavc0wU85f1Jc7ycJ54AHL0J3vmtVZf1VjIh7+hG+EGfmYCckPYd7YgNCGfxJ9iB7tszR5UL/CKwogWCIUD7ciyMFDPuihpnzlCZn8yjdarbGKjAiGT/AMz9zyiYvsqMR2UjmP/DQIzbpiNUXrId53y6CX0t3ATGP2Gnj1pY6D6yAEMfDEk0OsEJ8JcwWvlBCugAuSosX1Lno2cC0lhCtgF2E4RsnrKhIBS87V01p6RjXomob4BczvdIScXzu7xC30TeshYm7tNpfsLQZukWxD55+KyonZp99SLjbMOC9b17Q5pm3bI4PZ006HtA1GKHFdqq+RbGcUNGANHSELDNlpHxuyxWm7HM6zolkVWruWsIUWPGyUd5ti5PZS2dVIbA7jW2nUaYr/5LHp1oA8OcUG8pkQbJNlKL3jMvW1qoQWFZleaE4uzDgbL8xOBAfqb+e7tfnzLazpla7JGa6fY66fYP7nif0zfdIZnkwmHYcYP8NWTd2ZsDQgwhEQPsBCeFZj7IkvBXMUQz9zP+Yi59sS5GuJ6G0nw/Y+mQSPu03wDDvBPFx7IV/ELPxV3ftldJNwf3ulHUE60q5Nexx/N+2ojiANsRNvkWvzQ7uabDl0Wz5CT7bryZglzsPFzlZXwbZryW4j2afudcBVcU2mKyICGUv6IPR22pO3Igo8yT96j1xP0WIoCGosUZs97FDLhyj13at1qH6UaaZtOkKbApL/UbSLhyMrMZDJXHA3O5uvxNvM4tvrZfRZeEZq8ZquXUwf7aAB8+yUYO6hZVn94mVUEVZZtumIZejpswZoWXZZwu6Z5NmZ/WWkfOYkUndVW+xobEFcg6+COEELdlyCqqxxka0kEmbCigNNCG3oaBuReCDR/spkUGQqLFaaP0bMLeeIa55UNarldeSm+hmUQ23aC3hjpw3I88lSx/NbdAzxIAsTYqFzhHKtGYFOifBbQ/otCz3njq89mYhNDnlNWkXbqmzT9vmx/pkkD7t9zAU+xM/qIefcfvCje+Z/9ZKHRnoPNGkrw2X3dGynHT8igGCO+GFb5qtgd3ul0VoVtpXPaj9M2zrotm0dYKP0FxmFd7FjhdWmI2bBndbuYWP2KrwVkaMmHlZq7VriFhq3pwhmY5KHbu6W5twutldVXDVhWymt9sNwW/sdr0g2xUaptFEqbZS2b7Hr7TlFlSsenUVd82QeBQHTjz7pUqIV6LYDAsuqfnDkP/H3XsjKlVjFZnH1iQXmBoOuaC+3Zq9MdmknAcNOQp1dTVJlt6YgdgF7CX2M7Eq2yhII2fm1KolhuAxjCMupMxywzT2fR/FmGS2DWC91YGqIXsCeL4K9MD9ar8sIG/Wxymp52V5Adz/dJHNAfu0AFZnPTGjH3rbXxCbNuf5pNr1wFWlHjctrYhNknVlUbHIh9D3XnYDohEjnEBWd37N6GFU6dwKiEyKdEzRz+Zs0idOkupb6KXJ5cVxGvmeSWxZVLS1aP7ff9dOkmbIvTBHDXEgsDO8VhC7gTJMjjOzKRHjxHc/qcT/xW6b+fHVjwKYkhuEyPELAcD7ZuuNxJBJFTZErJPYj5v4/nrYpoAnbC22tOwa1vT5Z3j5KaovyOxd7hZGuqa4kiv9C2aI2md8BSpAD9lgldZ73PuGuvkXb3Iawho31GCfWgn9PuTQmdDsRQQs5QAYBsWue3CoNd28L/Ta+VhMaIbY1XXsptnTP5JgSMCGI84p3pxnuVD9qJ280YVvPh8UNpxgoEwcaOD1pxdMQt9ecvi2iuBJC4+J0lyJI51QTE6cAFw9Q2VPl3mVEXpihNKacSAVIKp7jX7ePa22LV3wOXb7yQn1xy65t/UZZ0TmT3wnNqrDiqy4t2JZSwpUixP65vAaVFK1l8oIiw/jHaP2RP3EtWX5V1tqUMfYOmfROqVwxYnIvPe670kB3LyR2IbN7ipjdmAnJs/yHlyIKFonLhTZJa1C3ONXMjyQa1dQNM9UOC8saJMvovCy4o8XcNOiJa/gbvpg9jSJyxEp0TUMsY4i4AVs9+1U8uyKKbTSbcmIZQXG0IWKQ+Qt3mCVDoyknkBGUQkNgkR+89YOv/pfsP+Uc764y6xtErr4cZ9e+GdNvvLhh76MJdI885g7gvPhuB7mUt9csE8Sd2ck7CvFyYWW4EBPC4B2LYQcYthJM/FJ4Zdv4jYVX1uZbRo9cy563E0BgdtsPk1c6GjSaIQU2Lwuh7uFlJBabMGEvv3qWuhG2BgQ0ZKDHGLKW8nwF6sQpl6DeiSIpifdHnpbkKrxdfMxDhstoN7tSj31rbtPio52vvw1GNbVTOiw3wTcM8tR++9VZ1ZciH0roe+HjkgfxbknOTO1zoElbV+5e1XkTeyok1O91hvtiQ3eR71l8UT/JZdkzqNn+I83gmP+/ewTA3TAfDjszCPLgvN/2uhr+jQ0IfGwezxgf9QEX69J2F7xfVwQ11q3KtsZdH+mqyXfH4691t2aKku2qQMumZcjhWO4fwjSq9UeE09Q1T4qX9RcupLrN2/VITWgsRdZ0cBi3dNfknKp8TTuCeVZc8cMB1Jv0hDuyQFfEvMurcBXpRj0XWU36TgOQ8G1HTb4psziKHM3H+S5TERRiSy6FvYLoxuSsINxC9ZW6mIgVx9V3l7dMsEA/tW7RQVlE0bppkj3p9BLKtBNQn3tsHUYy8RyzxJRdS2CDB/sUPdj7S622tCaF44H8AJRRJXgaoef5QQl9nhnkWupSi4rIxjJr7KEnW82uMna/MhEqwqSxJGKqiGws2zjTrpF9Jpf8JTnA974BUY4lwAS/Z/Jc0LuMFkmOWIVvi4rIxrLiN0NPdlYTIAfYLBSwExLNSGieIVy/fioit4u6V2UYdz3YtaaAsrxX6Z5Z96pHgX/IAv80lrcXVYyrMjhW+c0ZpkC/1u+Yz6Nw5RVVBz5srw6cxTnUBoqprvba9D0GnbbVwzE+W93AeDPZxDMankcj7DzvrmqZIbbCN3M/vHAlmFR300lSwas0WzRtpBrVekcfuzdSRui990L125ZMKK20RPDV9KAC+YjwAxlaT7EjvopEwJLc39DQNuWENBKkT8cokT4PgtXWu84+23xrTQ7Isy77ZsLc7VLhRjGlKTaOs8/X15eGT70VgTLHb8ovqjxrCG0xzwzsz9yPuSgOpDPXLU/5nfOEeb5cRrkRvlYPMvuWCuCvaAoHfONGmPTTajbCcKfCa65smF9WBPVDMnYtFM/E6KwJeL/T7km/3wG6q4L65BHisYIfwjTllgfGdXF+oLDODYcLDCURjidAtQuEn0dOGqgf8ll4VbYNMXkiCDwRjIF8NZ6zYwJbeLUKC4aciMZA9KhDFrpwNBIFWX3+eKgNkY7hVPq4M7PIr0wG9TnkVkr+NaLk8giiWNc8OVnzkAsFpsg3OT7srnKoi5iQrD6CvHniQniuttLdoG6r0T7SXTNSu+MRrKMO8K1JjE1KXdFe0/23UI3qTFgXyP7Eucu3+5Aa2nUN2WsM9ro/7pjBbrLXZK5xpcoZzjoAtnz04qvQ5S9aiuyqkJDGg/Ro2AGkt4dg7R62XUuQ44F83AWHRD1z1d6OuE1HgOM5x97HZ8XTxFOK++Io2Cbmy6jIkJ59znm3q6rUN7cAw/6Ru2AOBQoBHyEdCGaFl8tob86ttZyqDQ7VdTLbARsaR+6LOUCouBnWNwXf2cVl9H5nL/OhYVdVB0VzC2DDofEumAOBykFhfVPECq+9w1w5mmxTaEWJG/RQsk38mbthDgcqVNy54WDI5tvdk/0BZ7seyB7V34A/mvjHrqGvWt8IT3kKzNdyrXxhfsqNycLhhsDcI3ob/LVsAF3xjs5ZwoLI5f7N/e/cSWrekUX/ZiMA/OsAlTc07hr/oefwIom+t9pUwa8pyOYjzZ4xQMr8ynvRvJecd/VTQpkFl1dV2fL6U80LekVTYGPCckfM8UAVZ8ddGg6mUN89fgGUkpGA73DNzqY9osr5kPebcqtoOxW26YxJcFMTeJtlDTfCHAxUrwVDEHNp++TJ9r4yP4feEVw9rSVbr7m72MiEB7X0jgeatBd6e38NtvOljTdiu7hLILeBZ1jw9uQ8FUJ9nTJtV6F6Vr7P3Q9+dK8+bMoqWwda6JW3jjRsO/rH7oUxFIbk86Cx8nma5vzM9Fcvebh44U5aCQ2yqGrVBawt2k58Y7dN1Omg+BAL6rHwZMBuI5moGyJLE3+rCXWrXte1HetaFw2cxxTp2Z90iOdz/nQI6VJNVMPfeB2goZoJyc++Lj5FLv9d3qVh4gU8XzMX1QWY4820XdhXtW79OHjNrTHGxog2qPp4hkbyUMKfPCwjZRC9F51yTdx+nPPumMacMrL3e+iI9aNQtcnnXFGYLSPfCr7S6T3QhEgmt6SdJB+hmAim6Ja2EMyk5CL5xJ94sbxXudaKv+jitoOr98rcs6Ez3oMpouWOsCwp+JWJUDEk9xG4urwWgFtXQzmddKjvprUm2od4dievwk9x8HH7236Oosdyha+u0Jf47Pr2b0FaO2xux9BB7BEWxF3Bnt9HLznVAXv56IX8Iw/X6k9XcK4p2s7xvlemL0Kb5oMhRnbLz1VqKyLilXzndrgTyn1MmLKlYudH7CSmA6EpIHgO1b6ZLgPFpKLBuKj5lld7yyH+eX9dRdgQt/Xkva1PJrzdLi7e72Ml98FO7oOd3Laa3h/BLioHAi2/+adzj/mRlgvIEJPlhWp5MSRysJMb28mN7eSS5QW6ENzHM3W7FVHgSf7Re+S7IM+dxAzv1BTtn7rpfTM5PqVQICwYOw9B5N76qfyf4ijh7lI7PahJ206v1iVz9YwSZaKJs+cv6ouc5FbwJ48/X3KWbecWe892lZYitrHFm+Edqz+obgbbPvct4zX5XwW98QaY0NNSG5pzgUlU1E6V+rJxXaxlvLFq227HrV01YysI7c6gnZ0ILWJtzj073rUWsKKJCPiOrT43EB+kfuKprpfKZdlq10hzZF7VmEw9rVu3MOj5zH9mG1mJei4E9bDnvRxG3POuY6YnTmkL+mgC5WLPKWI/sw/amnV53frDJUUHTDtLjPYxxRcpKVM39qlYpL6JE7Nud0XU7o1BszfmsnS3yx6M8ewMypvn8FZEsXqTbsqwjKpIj8wwNe3fIjS6Z2JMS9Ro7K/MZzWX2cMN4zSprk3vp2nq11hWpmv6tnNd76vpWBDYaPZesvTpLAnKZNPlhZZkuiJrfYbRfWfM+RplaUHjVihMisoY0bNWD6O4bDujxa83kwjRktgQG55Z7ij1lIJ4GZ2XyYh3+xx1FWFLqYTawa3gocuFiawuJVqB7juM8CyIfVHf4/4ir1z1nd7K2x27q8n1CE6ruv1xnLbemnxTMiE0TkQaet/TYqG3+FiFeC9pO7e7bpgrCJRmYoIqn+y25to+daytYFtNASIhbKVvpsWl+Pl+HznHWnmyRqgbWxHh4H0KNKf7FZsfvOTn9P5KypR/Fv62CokuNQqQ1JUAao/U+mnuzVEqNzyW2851fmGJkjDl7Q6V+HEsYwmXGA5xc/wcpb77v6M0O8K5jOZ5ZbuzT/w5b1QF+2hDstso8hOi4T1g8a+8DBsuP+upCXeitpO774npPxOvaNyMlTzJP1RKtZ574mr1KUouXjyp1+Zu0gMo0rrtpGl633B5GW591v4AJc7P6tfyLORLcyiqQgIX8r5fDyW1ymFcRvFH/sT9y8h3uZBXoXGk9EATIppSx7aQ6E9cJtw9wLO9AdFMa8wtpDlzH6wU6wqiF/KKBE6fWPAgeuIXQZxsFKVSj4arqYhgyLHxiNbUNvf8KszWUbcVbXSRvsJmatq/0GZ0z1xvo6IKaBLLPmUhj+rhFCXVy+JcXvJwzhJW3Nwc70LxpWisHsGFEJHmbDQ2aPfO36u6b8bVdfvktO5FT9GjX4YFV1tZgp1NNaxcWn/jMKDCwIDHwpejzfLTzNXx8Sf+Cb0qsOXfn3RsfBxvVh0ar2tNbxLK9A8u18GS3fvFkJB+uvZWWhaaighGsoNtb8x8B3TABi22l/trS3irXdtu/+VHoEzZwFqOceW6nm9mJyYrTKuR7cgAxpN5ZhI+KU4L76Ei0FwIQ976dF96x0wHmBbU0SDsMN+/Ccv54JnchM5lWCW3Imq3v1DpiGlxO17PFSWq24ubcJE6TmlZdoHWNmXrK1u9NcCoJm6YDrjc3P/OnSQ/Xb076FKVGQdeTBWAgy9GD80NeeK5jwfnlxLhl6JATxAzoQgVOsQWZfsxfrGgS2lu8WS3q7D7fmPw+n5DjALe6Uazk+d7YRGxl32oMrq9bjuiZQdMRqkOCZq0i1HgFcnvsw9VRLfXbUe07ICJKC3UorGi374lXCby27d3npx7P2UXZTi/VN5olutKj+SvSttOr71vBsx9ytmFEmatZhJWqi2dNFfI6LgKgj1hx/eyAkoPfHdS8FZE2ULSz0poHBU0NO3FWeuUju1kRtnHTzFiO/94dcuSBwu2hoawpeQZ/yi3P3M/LjOK57TMoyBg6m5rmcVNTbupLbtkMksewgQZstmH2sE+TdjWiIU3xxRNrMII/mm97OFmGYY2MZeO8OLkCxdSWYCKT5uFJBRbpHWvVte129Q2dNNkmsLF+jhM7yGsawoz45ZNT3jTlnC7+P7AQ56HKJSRY9fqf6r1Liu+XW2mx29u1Xrim2+AyT1F8WCISnsF98V5BotZrymIblrjgEn3TZoYmQBMObFNB5jbyPbCeeABy1E+5yuW+snHKHpM47vU55fM88sj8lusD7Vp83pJtacmz6Nup63Az3Jtmc+uJX4RpF2ZYrTFXKrPzWZ4pyaCQZabQmmBP2yvtpxYMkscakMsQ2R5NMLIclFcphBkARi1vG+NDVo/7XtjjpHV5hkPMOK8u8qO1WW4GgvQdSVhDHexYtrvBMOF68D8gyxXGxHTgOM+TzEyHSt8yuuPEXO5a9kfPNSGiIZcOxulmVaen1tcXoooWCiY/FpRwENtCGnISI/xI33uCe4kkdg0E601IaAhB2z08AOdWd4b8QqsLQ0JbsBwj3qdmCdWoWmcJ1YbEdSAoZ4i9apDl4uGzW2rkiCGHEk3wgvx4UCNQ20IacBI45waZke0fe9WRE+ey7eusrHacagNIQ0Y6eEEK9J5XaPjVB9oBqWsE2F+FPMxVstdehmF0GC7piNLDTm9J5Ldw31h+eK0Sf38SftRtVeQn8yoSt4UG6RMaLWEy0vCE+p6MTY+PVlbf6iIiFOgZ/WQbGu42422Yp5VEBuu+H4HzlKuvUEPaTpW77fJ+IBsMZKlB5lPWtSDTvhLkYw2i3FbVKWWUySH2rT5FInZW5PrblcpHY2xMu2bvGqFGWzKdvseP4ZjVNmVh51h+X8NiGbsNE+6Q/OQaMZO8xQrzXGRDrQgtp5DoEFNPANfNp5h5Xm3q3XOElbc3nK3WViDOe3NiG/op0qQLOipJ+08fg5lGseRSLib4apAfdkUKQeatFragUON2g36od6b0FO1vwGCCeS+JlMlPGFbdCqJPofei5mLQJe2F+gDXTNYntKGTH+KnWX1YZ8KRuO5piGmkcQzY2L6gYWuz29Z6Dm2soCLkMXyIUrs5QGrWgh0Wzpr8k3VL0eobHZtS7lquQ9spzeooeymH70BJvdUmgLDXHP/2Hm49kJ+4hS12OQ7xajnqieG38gf67lJPi2z9IeYyc9C+oNg1T3wjY6b3FNpTpgW31XPtFhai8InLgqmlYFjQeRy/yJMg2VUzOGyz1W0DzZ6M8L/4+gpSwcNdodUlgKkyXaFpx7oCXNZrJ7RSVG/PXvSQeQ85hxnH84KdZVcQ9xeL/xYD02QyQjDPFvwp0i+ZLX0SnYtcY0qozTM4wivQ/vaWwuW3eezZyb4YdCPtSXsUWE/GqDC/t7L8tLk4OcHxO742lMkbWzJxRobtOdswvF+mlB3u8pF/xQrzU4Ubxab4D7yZZ6Mt7jB1ZCTpgZtWg35u3hGNXmcYGX6WbD4TG5Cp8qxJiR2gc8XB1PM8C4s7C4IXSRLHbjQFflBghzd6LEKbXEFAtddH0xcaVuwP8NKKxfa6nJ5SbxSpe4W8ZpsYi73yw5zpU8znC4rd1xbd7C2ALDwsO2oSfSs0+sOw96wEzjnzKyYvvJwoAkBDRZoXCtpPGO0KOCdNyn3NeoF6K1aABhvO2hiPO42xhBL0L8CYk8exrhJD3Dz7m3BpkjQf5ru7ROO1/vHK8stjjyCrCC3hrRd26ZpYFPPDHJpaW04xQVuwOIGaOsaAhYgsJMeLmC37kGj30C4ws46iszALiLnkSc1Wg1xe2ZpP5RUNLE6RkKkKQI3oAHUuobsKsg9tik2P6AB2JqCeAVZnxIdr0vfVguiKiVSIZI6wLCWVSxRSXVLc1orSdQ+sURNq7JUastNrG2eHWzUWo9W66m5Mttpr3Y8wAfyyuO+u4zmkZ8GoQmwVdliI/z26OJycREa4jArued7f/BvTAimnXizqIhdqE7E9BQzu2EacOE5dnorSuIXKr8olhca+XXLE7J1eLcaIhcquaeoLW/iBVw9syC246upiWGw5ShnnWA4+eMIxUUD4hjswYoBdo6bASZyIZM76GEn94DtJasLm90RZnaDKOQN62Y7FbELld0hanZfAt9ObqkgbqFyO+rj4zaJfpH6ceG9hEiFSuoYoYUtD+S83yRcWg7q7ORELdhjOpj9gvdeYnULSjlRC5XaGcJVhIDFZ2JthJSXEiIVau2uHsJds1VmR5Nz9aiWxkptXUPkQiV3NMFMrp1aIhYysZMxVmLtdpZsLPjKnhj82HhdHOBN3LnvqS/Uju9Wha096pD3wKCz20mVBjM8YC7V35YsH/N1QK1KAhUOqKd4QL1d/5ZysWH3vvayN8QEJ5zUdH1McFZMpY6noSBA4eTnGCF6z98KTwbsdm0pV2lREaVwKJ0NEWSRsVNqqdDX3KKjzP7JynutcU0nA4jYBnlxSJ4/16JQJM/BLT8veJLGV2GcatMoq7I9uNr7pAM7nfS7bWVBOqtHaL2JM69UWlCtaIhTUGZ1gJBTC6BEJryCCtDJXDgPPGAX4doL+fzjVVEdJL+qZeQyxO0ktd4fk9gBEQvaQ7URa8jsHuvBRkQzRJpHQ4z215AdYJjIBZtRboSRXMmFl8db37JQT2pU17QphuXvIBdX6QTwSwdbZA0D22qjasex1+1FLPBTsH1ZxrvYyadXd0UHtDUCm66dlNprL05Ph7SIhYTTzzLfpFKo1BYJLCqiFNDywBD68sC9tz1c5YX60SrvnzhuPY9UhyPfL0IQDhJZ/HKDxzz7abedzfEQ05LVVyaD2iz/micPkSubZvoVdftn+2UHTS+1429/VNN9K8OZ8PjCa70VEU3nBdpL9CGOiV64GwcTlPRiW399U3Zx5YMFvwBbFIOPFTLJVTZHkjF3Eu4Wjz+nuUFXxfpAk7byfazfOuyzfp8mgDhQl7EXhlwUabbyAOdFIdHybJmKdmO875OB7eANN8n+ZDR4m0ooTHCg63syKWIAswjanGBdVEW4rmk3w7XOGSj3JlRAbISDY0+W3mUQJ5ttsdy9xCiWqyvaDbHZM5PhMbnMOBCuFM6dR+HKW39RX+rmtqu2GdfYoJ2rFkYHTYS7Hecwgr4JUsP3U1SYrMvs99TYtWsJXOinzDCQe35/m8qHq3WofsVXJkJFkPzqJQ+XPqtHRLyqMXEN8LAvOq7LY16fOHflZaTuag3m5hZEMLxgnylWgu+45MlF+PQpCnNUslQ1T400H2lNZMNzlmdYyT7nT6/m+mBbohoc1ZMeQk/6XETxAYejsQHxC47f6RAHv2uepQ5n90zyL0Wq4wVbFckd7Koq0M0t2r3A3Nhpk3E6HddHstRc7LvutsaKNWddVov1bNK32VzX+2keCpl2PbPZFC/RhqwejKGp2m2kfxTJyMIy+gO8OH9VP3kvWjjCi5OalT7YiEw14EVpxK7HswXaKtRNejLZ4EM3el2x1x8j5zF/9octdq0Z2WzAi9X9rtjsLbbNVrvaguw2/GpXOMhOQ+9locjkyXaRr7i6FFGwXRSbC+6qn+Opp2Es9x1t227Qtc6bUf4UVjpAYr1ldij7eiO/++VJwu2lfoqwKm350ZRqh0xue7QMgiH/uxXdhDNxrtip0VtTEMC5g89lIqINORj/8CnYzDsobqTcH3+tCGvnXg0dgAOvehfNnUNKdQQ/qcYBnrfAZPJFLp9vZ+BbrA80afMKxw9jG02k6agLdjqIXO7f3P/OncRqqw39m9lrSESjykswwOI/czcnmb9wJ81qenF3HgUBU3e8wrFd23YfOu+amVODTnRjcpz30Ubu3iBXhDVjbOgAOM56F02cKeRu2CGc5SGeJQGNI4YUydpcwmVyopXUKFwHCTRJ8/FemSt1lKwOywnwYkF2sfjt43YbML8osmwYm36G5s2A9sKVYFLdTCdJBa9ybdH8J+vOZTdNyzwjmnuYdk12NO8v6xt+WymE/ZIfzy3gdHQzlOju9vVMemsKAhj4ht8YyUSPeSeSrXiZhI55Z2v1xbm7IIJ8WjR/4M5jHGU3tAL00YbtBrzaazNabkRrGGOMbLs84U5yVoBbZbmmIHYBb4WgcoqjcB1VnOLssu4Ub6UQfIqyQ6ZPcUpO8b9OTlGS64V5Xvkau6ac6IUcLoST3d20zYS3piB6oQdwIgmhUKTk6Kr/VoEtL9uNafHbzfAeOr3Ux4Vm4gXKTrAgXkbnpau2s6t1FSELEdkZLmQFD10uTFp1KYEK0nPFFBB8qR5tJRQ4v6zF6OykAIJzth0yfdZe57mdIMc2O6V8MNSssRVhDdnVnSKKNntgoesXdU7hB5npnTFjy2jjAUlKWW9XCXRRnmLe1wZdKKb8LEl96ifGYbmGFm0+K2f21PSNR50+KNdHsqJb51mT6DsShqLlhfZ+CL+oTHIXGM4t7m8pF5sGlvUGxDTwhbUBWqblchNzV11ehOze565eBNWiJJahH8fAks1b9SAK5tltK9Yxsm3QcP1B3R1twmeIW55XUO+UGWpG5y/6qOG90w2wJiRwYcdIogb3vZ/yOrlbKaELGl1McWa3kUzU3ZD7AN+tpBbjW1UACDWr9MxcKO5TpC+esh91jLeBkTaSbTqCGX7o5HCClWaRhvnCmY1mm45oBh5UgWVKp748uc6S/Mmz0M1Wzgqe55lco3gvaXXhDmt/TO940u3MlrjRtci1Anl2dZszW/5IqCmUuH1gszhLh7NIXNXlwhpXJZpRNhWtts1Gv0yAx522ylgOxvFQqoe8LRtz8eLJpIzYZOL/Z+9dl9vGmUXtW1lVe/9cGltnaf9zfJh4xo49ljPzrv3VrhQtwjITimRA0oe5+g/gQSKaICVn7AzR6FW13hHRcCSQTzcbjUYjZtv6vOfBvbJRrkHcbUe5YbCQbNr2ORwipzsXHDvBcRgEbJlk25KyTko94tZexDqSxWrssC/S5VI8sEvx//IfrABel3TZI3lXpNHkd6L3THSCutWuy8le47DXwz5ywFcsObm7CJdOeccrVV9VASGNZHPUAPtskrMk8e5frnn46Ln5BqXtrr+6jMDGAfYcSUoSZ+vwkeX12Le7WmutahEBjbDbXOtGCbeyUnbzGNGq+HG4/MZDZ/mwzVXaNNWSlRSJAUvi1cFBjKeUroSm1oCG5DIlSQuzVkg8Y8hYQhLKi526swHaFOvsGOZo1McHeR6Tm4ED5XvfWZ1yXqbynz5HjHtr8eWOf1aKqiw3duhyZFoZJNwP2Lc6Hj3CUT4DYHzN2aPHnrQE62QEr6GLKSjpPXW4/3KULf3pbXCDnCg2M1cJCcURFwNMzkK+qQz3SQC7OSmv2niVJpGae9fco8tUNw4Z+stDqwkfYymauDfgbWibUCzxXbGmwyC7x3ZeZvBUIJgKgVw788M4d0dy0eeAPbNlmsgqMIuERUqEo6VLt0lvHDZ0UYh0TJVvt5nR2/K327ZazVtVZEChW2V8EGWqZmC+0f7yRRaHjb98yZceiuXuOBG/4TR4VNe5q61dZbc+HpCtMSVqR3ig5dHyF/m54DbyHblHJV9yAFkadVn3Ga4MD2JMJz9MJzM8IOcTJHbCHrc8ix/p8OtsCnUefGVLmCbaJO8+1/XRArwntC44QmSmv3x5YH7EuPws/Mp47WQHT6+Kogbyoyxqz57VbbRQ0M0I3l7DhHzPKI5nAdp+6Lhn3rPcX523VvHWCt/MdnvBPXdicZOX8guqqGskHUaeaj93n/tlGLievMeOf8vKrQAui5fcu2OXTsK9Z/W8dijpvseyY7iQdfLOZzOLWI+/eZGSqFdcE9cIQ36HSMFGV99mv3FCxO2uQtbHA/fJ3bW4Twfxd3Gn+SPj28BK7ATCzv3NFn9cLDLRuQvX2lu6dN+oN40cok57vMw/JWv71O/zuWQsn7uXsJ7bL2Zkvyy3M1KwqANWc7pqv/cYGoyPTyjAggxrJvdfC6p67l3vyeGB+Bj31mGwCt27yupl9qm2p9EMw/26sUJzPqe9jv/Vm9pLvhdkp1Wpx8htmoh+/BVzMDozjLm9ex6ue/kbv5e/8fP2wh34GhfuQNb6y1cjj2p+q7FDR4iqwvdN3xbxg2gkcY/FawWPxCbV0I4fqgfNgW1VDxmkj3viuzlbin/K7RX/uDCpYVClptLHrnfLD94hqGIDUjFSsXaASK+abgtUJto/YqsyfRXuzLP4aT2Hr6ye8DTfBqgsh1Rdxtq5j83znh1zHkquNv4dIga2dgI3LlPpb1jM8sXtakMVd9jezTW/pnHBmruHdlf6MH6VY/OcT+4WpYHOP1aZ3bZ0nNbNKACnM7tPz5qhwbS6Y2lrZMWlxsQWrWYY2HxEEFu7t6cMEXIb+eGLiq5s0dJbCkwBuBgaZHhqt4swQeQinPAwKlwE+VF1EcqWzrsIxSggp5YXrRsj4vQ6jR8KTuVHldOypfOcFqOAnI7+mw6CxeQTLMTjSeOqT5C3aHyCrcAMn2AzNBg2GFDYAI+t9f2NrfV9aGvzFgNsbTYKaGvtLvM5RGdrT7z7e2X2Ja51c6+i2ZCZVz4oyK7d57KOZ2jZXbHkJjs5zL11uLi4drjAVzzQj/KuqoVq2zt2NRf9XQlHdXA8KlfiOP9YeBPFlepQVBo771NshwPBtXvVbIJw0Tf0HxlY9pVN+oXfUmLM0m8xOjiLo2MecHkYVfurNmk4NscS10YHzfGEzDEKc3xyd5rVq2eFB1FcqR5EpbHk9vQ/t7/cfF7cil80bEd3LH6uXJUc9Kc/x4fYDghCa3cIbWR8gRR5Zll5XsGf8vP5VYbtx2pLNmNTIsEN4m6aYP0YQf36gd3md3CIlWSlpX66SEXwZnGISNw6eZRlOT0vGa61d4lkVAEJtHY5L8WhobkmIJoR1TEZDdAC7TMnuGD3SfjIOGRaI+tqsJhM834kz41czWPBygvkhhvxpMU9Zc/lEshpLrh2kgew5gEkXeJWNxqV1MmQVjUQgXoaxLLIqbibH7zA4R6LT2VRpfMAHJe6q1935nfvhzCa2q1DPPyyjMtPjLnMVciswtvaicyvcZsyp6bzK881iJL4QAxIfE8gnlCRo2bG3uM9hgKoHdEOe3AG5NRcaqNQVl3EAK06EsgsVcTrj7Eymwd8LsLltzMJSi1cVpV01UP46RQbHCXrY3EZaiDLSFgaaUmuiwhlww97NHK3ZvzdlykDTD6i3veU8ZeeeMje6iFRpjqb80wzM3MpsNUc9qgVdgnrVw0WRIEnQzLWhpZmfyXjsjTTBydmk9FnruxJqgmIbTzu9MgCsiOHx+wP2e0871WlWyskwumcJBMIl3Bn9fKqACvJbw1iAwGvsU31zwczjGxH5Z4772+mXJRnrmtOW+/eOev/ZJSQdLtLsY1H9lHuxbfOasXcPx0/VSIoNYFJlvz9mUdVAHliI/cL8QyzJ3Dp8G/5wsmWfY2Q+MfK/2RsJf8hT048zjZPoUI/FBH7aNmf28f+iiXHD57vajx8jYjYx8r+1EK/p9oAopNKO1GPNoN7ajf1V3dfwQnAeilpAN5DgId2q0AWpW/SgI2QFABvbuMAvQJkx0IdRDyMGE88FldybJzAUfHftrwZ87cs32JRAr+5fnPamwYKsaddlmaWc3gr6sWM1hF/eFynvyYhLcCsBWPrbX+2pnXE7+rvgKqEtABzMZSRxVogUBB9rkS7YJwDRdAKSRdo/RenLjw9MM7OPOa7ureCXkragDk+arN/FHvypvwlqQeaUJeQFqDesm1ziIgzP6vgdpb5QkATtEJSBszK0B/a7iEd+454eDrvSJGQGmBWg8HcYjVwncTJV4eBFtQEpASo185mFitBID4w90QSnwWIxDMB2tDcg9QCs1pMbH433IsbK5GHoVS1mRQA87La0Ob3Qlzul4FRI9BOKoBZBUY2vwNC7jL+4QUogNpK+GPGf27zOtoy5XFtLVlpJPhRHy5jc0JF9peA/WoboY/6oOe57asDf2j4rwlICTArwXho+dqATgdgO6kAZhWYjK1fGdjUTdFpQ0sXUgzMijFFueU4fnAilv9vpgFXd1+rtBeX5hSKU8cDMZ7afW7UwAaCvbi+Ob7aZtKO4PegmQoym0f06TpKXlSgN03EMyKeZ3bwvMjy8DdONCjcVhcS47R11yzGs0+1erRqK1GNaHo4tIbqWuEdtZWopk213ab6PuRrJyn+g/1IH+1gIel0MNvMItBxn/BDwCM+RP6VD1/AnoRamw6aDQa8xvaAqh/YgXb+scmQ66UEOqpYipErOvcsWT708uODswe9fFiH7rWfxv/Js3A3l0oartLaJY7bxwMPQaZDBocooE0Tz4/LoxhuwjA5dpYP7MTj4CgGKOo0ueWgALRj8pf7A3zUNhBLtCJI48NH64lgxQ8dF8zk6hJi1sxg8wgZs+Ej40/it7IzSUV1PyUUELFmnr00RUYsZ2vBpqTy/P702YvV07H1UmLXzBgZDn/WLV79/9eL8piY7HD8wJbf4nSthMOgoNPcqsOCIQTKxh8MUdJbuVZ2YKnNRK7JXu4cFbkZth88eexEOQv7LVQ2TGmF3dlQ0jYySO/Y6u0j4wE+cssLnbU1xtS+GamozoRGSKuMzYZ+lhf/yD44tbgtlBG9xq42zKf48L3LPAHhAcS3Ye4VXDvJgxJiaOlCMJs7WRtghfkTY65ElZX+LXPrODd0IqDNrRE5Rulc/Ml4DLbjqa2ErLn7k0Yokc2dhE+SVpVaVUDgmnvG5RAfuL8WSTZuTulVJG+24gg396DQmXmhs+FohjMaUUFUTtR0iWRATJaYqiN2COJyStZoiBs7kB020A7PEK9h5ITqVjK2ErK+xlrfGcKF49jJ88luw8xVUIpK1EUEr6nwjgYI7e7aebljx2H0chverpV8nbqE0DUWXYxpDxHcXBkZsa+SQG0DdYoDVD9cbYK7tRQHExIb8gHAjPND8mBR4MmCxwxPGc864+H6NHislfnTyTocLsiHBC2q5bWy56ho3SyIZUhyTaxWJ+60mX1LanElJ2AjN4fyNvwcw0VeICFeTfRbZ6h4dXz/NGvN2YwXTKnK1CAmck3c/ovDoxV29KMTP5TWVn4GZrZs6jSl22FAUmdkY3GUCfOZE6RRth6QFwqrNCilwkB7t4uFqaOC8I5oL0Qfi5m95uHzy9FKfF+lfuPHME4CkL9Yl3Td9CpDgwzPiWGsDGfloj+FWev/DQNWKyUNZMSx2RxPkHIsfu95ULBaZRi2E79mr0FgtcNli1x2+HxzDiZwUEQUmz2dmyOnOGvRMbwREMFmH7eCY3v7ly/ZAdpfvohPWak58Uk8fJm3uClbml0AljdtncZ4x+gg1VSO38gwmxfE4jfLUxgceRt7y1B+yzLJLZkf3jn+9uigJWfimV2Gy2+3oo8A7SPzI6Zk6bR06RLtrxg2AH3yhhX885tlZH0dtKzL/ZnZx9sHL/7LSx6uuRevnXP1b5XNmvt1704K0H73AXI/sjojaI4ZePFaLyBuMuvNPYyz6m8ENqqkoT5muuOddMdEN2a//BAz3XIBme/gu60PEY6gqrCRqUhL3xP/bm/FAsYFhbzH2coTALxkj7u8KCqmFH1uila1WIpG2B1ve+9hqlwPBnZv1jcympIfYxn5TtBjz2yZisedPeUkt7rZfxnPD9tIg/PgKKvXuogcZUKpEXXJSu89SHBi55hChHOMUMeC0cLR5p749r8zan+Xd1/xsTVCk7Auhgmhpp19oz5qqiWv2XrecZi5p0vRU1MpaEe37vgjP5VzNKcfzOxgXEs08Ws8v2ZuVtmb38Rbs/MgSpPb8CO/9dR0aq2QPA8Ucesxylkii5Pe9ljGgD2du5sgR5XsusSoeWJ1mBBuOqJxZgHaJ54YUezc+ew2CxoId+PRc9XgdVsfc7ySd4Adi28yGFlA+oolt6KlGfPGDmTSEVWzt430RsKJbCrj0Xmyl/mRemG+YlMsnR+XjVW2dTJznJPqOAHbP3hmL6X9dRjrBydwfaZA/TFv0iBdkZgD9HaEEGfL69qNsfMsg9aLZRgxGMneNBLFxp/jMMBOsReLGeDai9mF900huSYwyYd+a55RZYagnBp67rZMSDbvO3drJUIq7SbB7LkajqnWGE4Po8qxdCY0GG+biWLzA3UTjBSHeTpSvqgoa4yV6XiadKYmuUlwb8cLCacSDFNMgOcF8+KDB96TyR65Cx2IZxZoE0I0IhOwro8SYD0grEcYsQ7SNePecuuCSHxWarQOtpsE9HZ8AOghpTjNMAIdC7+i4lCLq7o7XTSaxHExLAgxrQ4OUHobbsqzbapbkk+KlhrNVYFJRFeGCH0NmiT2UeVU++HKWx44UZThfBQpR1oWl91fOqmOAk76LM+ym+ClVVz9ITtWka22mWBy355cXGHlKUJ8XSdKihW/vBTcUd5SL6hXEbwZzF5wz518q2LKWZVpjeQN0N6MFuJ9SBX1DK2otz/fZ47ML1MsdKXJGMfijRnWORevRLgz/oWalDHFBjBnyQMPnxZO4CVinu+ecq6mgDZ2MMj7+Bkm2tQFkxFuAx0X3Na4rgmIZxSB5b4NDvVxGAQsu+WLRDJ2w1bsue5eN3Yj1pG419lTwcz7E3cijZMNmolnLDz35/h51oRDQDMFQxDG+gZT/Gjfiu+MnSVcLdSIyGSjgHqE0P8QA8huZ8/31l6SJ5beFG0Xsqk2mdRLTQn/1ccLQR/YvcY4xxQDjBl/ZPzggTku4/E2y0NhOJbnKn7Mu9TSPlp7mmDXa7cA8j4kw47KD29ivkxgaqO9oQ9xTjl8xnAu007bGNfIiW8cOwcmNvDd6JHIo+tO2L2T+skr/Bj4V6QLtNbZVV3I/5MXCck+KhVCNi3dn4vC8UB+x5Tnipjdj2EQ1vlVW4lhw08bOMTNcL7spidZJzPIrXhjopGtWo4HuMFesTyofZMPioHypzUZgY0iBIgyBrj2XNdnTw5n5RGG8qmtWXkmo+BYTPtOnxMmhgmqh+hkxjgl7QOH+Nt9LHp/YiH5WUzkOJPcloI8IFKLnDT2Msjy/wx9QJVZOyKdqNB+xW/lvogPjnvDxJeIu7KXkmj/jLQGrxN1aOOrRPz3V5b8FoeBbsqgl5ISIJ5JoFplzc7LOGBy1pvRzp5lab58GixXkSq0lci3dDGBe3XE8JwQWlkaI0uClP/f89kj87de0EW4upAtNT+nKjAkq1cZHyxsRVW7B9g20R0sQ/HgnpMymnkk7vSjBHdVO8sJikwhejtCyPOA/I8BZp6fvOShCWidjIhGUMkbW5G2g/t8N6e6yTkWDNWhbhCbwvV2pJBrWkxFaaz9DNGM7DrMdX47vV1oOxgI78zqFaMZOnuc1UpVpn9nWZNu/reVGGOEy+FBjCfkLWNmOX8vbpDVViWEUmIag18x6iPGWi6maImuCczwMt4YZTQZtGPEDJ9xZ7UWP0AppllpI3INJneC2fquGV+xElUlY7AuIWfCeAd5MkHM8i17TrSeRE1A9tjkeAW6AHLsBd8ygovA8EJcV/kFzWbQWwwKsju3Ozt7jJddJ0pSyVGNXiggfmkW1z1+T3gYRRp8YTvRayy900PEnsM6CmMv0fgOQED8msvvHC2/Z54vnp7G/NYExK+x/M7RRR/Yo/jKMj3i9BGEgKttZmBbjgdyO7Sa2+EU2UlKFW5jYVzFV//Nsr3hLnOPkoR7d2nClGjwjm6mhIbflm9UFcZmCNMyHTc/1dxld+mqivOmwaDMy3wwkFzaotfvIyb3OzxF97thR+gSuXuf0IiLXC+4D6vgltfELW3h6DK3Tw5XD4Aprolb8ytKjxBzy+DJLsyw40GJXGzrbkWFkRULGBcQ8t7X+CBhcRIfbJp+kdcZv47rLgInih/C5NpJHspTmxWk2/q8GeW3RWmjEvHN9T58v2LIKuWDAVFu5v453SOXJs1dr+8zsj8JemPRnbm3LxG7dKIq0lphd4LFOwYHGD60O048QonvmbhhL3+k4ovvPeZKXpX1Oa2UADZzgQ4lwCeXl2cfmR+pvoTaSsCamU/ZR0nsfavJvW81uV2Y5f0UhnEdRjvGBDJ7zh/abVhiclKivWLJsfiBydFK3LGVeIxXaRKlCWR8RzcTYG+8CRB/mvjZAr9eBKptNvQg5HFZ/KE9Bv/SyTLoY2Dgq81EN66V7UNMdGc1hEuYF+JBLXX+iiowAehyXIDfPvE7Q47vcVYL59IJXo4C94Yl4t9vJLqlL0FOyy0dpvxz5O5NeUtfotxoyidoKT8Pln7qMg3TQEIEkzPdZYL3c0d2dybOjeZ8hJ3z/RyS3Z2Jc6M5xzu71NjmfOFGJjfB9Z1dfYlyozcJ4J1daixzI+U7+xLlRlOOd3Z5tfZ0Ye5qM7Fr9HYYvPPKTdqIBuCajCimTV2dpPhXHqbRhxcNw0BCBBtNMN754NHjqtUUa8TEstGZfIjXFNN1G8s6MbFsNMt453aXXtDGsk5MLBt98APeud6l89zKskZMLBvNMt4Zn7rn5TzYZ2eM0ovINprsmSVko930RWw3Fhgd4I82Z6ZYswio70A8G83zBHvc+Yiv4ubYc1VKJBu92eUQO8nXzosfOm4zzKAD8Ww0zyP8nkaDbdbKiWajaZ7hp/lXlrTBXBETyyazPLdgDrhYOr7DdxBd60RcG8013rngmcd8V3gTGpqhiBg2ep/sIeIlwtBlfomrzm/Wd3gzoN+tKCTh3IzzFDfOepsMRYSwyQdbjdEi3ByRo1AcquIbQ9ye8Q27j+V6XpN7DOWEs9E4T/H6yJpla1qoxgEt3vUQYV6PfD98yk9P0RhhfQcC2mygkS6JOFHEAnfxzYugMa5LCGGjEZ6hik5UzjYTGF9zL147x1nf3+JfS9lVJG++UgR6d8/un8tSHTssBD2hw1nsYnwPuIlqs6keDPBSHTk8Zsdi4OJp8w+p57tnPFxX3IGS7Z0dTXBP3p5xXNFnVOY7s7/eMpbre+fBfZjxfhv+6cVecp6wdZVu0Nx9a60ZnAp0f9a32mhP0KNcNJZtVZw1IkKavOuO+SGJPJBzszxY8Z1lO1wj1IjN8DjKUUJ/Y0r7qRDjrEGYsKVDVLrHrfjpof/IqvY1Y1jTXuW5QWwC2/oRQ85nxPnIBs7vxY1XnAtPCek1iIlzKuhsFudZnl32t8drt5aAVxUQ24jKy2AMXbMK1nm9mBMm5uhCUtz0Em2t0JiVGNbI9dju5ZgpcqZPWPDie3Fyyrm6vlgTEMuGswyOTJmiY/lOrhTWp4+g2aC1w7cmWettLLODkqjmVweBLpKk3cV3/yYNEm/NPjixLo1a04MwR3KaWx8/5Cfs3kn9RLjQrhoR0ckIbBxgz8fowa42qVhDCUGNI7x3OEQO9ZP43exMPPRLJ6oiDdsJaCSHuM2QA+3Ffznx+jRYeQFbpFEU8oQpMevGDoQ4DsTRx/gEk548JvZkvb4/WjleECdldE/ZL7OrHwGPA/jhDP+UstgQI+74icdjWJa3JiS0kZwPh31S+ci4d/9SLDZ6nC1F9xfFiDd1IMRxID7G7q5wFvnOkhWJIrDqgl5KcOOAG1epUw3cMscvN87XTvLQkEvS2olQR3Jk4iFy1I/D6KVYlNQUZ9BLKcnE9K2QfezrlcstuDLerUCtk5G9xmGv+xZETT4H3ve0yfNukhPgOAAfj3BvY2dxseIjT0m8uvvKlrWqlBqRCXQ3jRVuaT+kbcDWIX7D7hsILyQEOK6S2HYQfi/LX6sxk6KBeEaVJji2g+c4O7ILGGulkbhGlSk4sshOA6yrbUQ1rlwqO6h212uF6PKaaEa1GonvOI6DbDPkDfueepzJxcXtxslKY233JJAZUx1eN1xYLn5OWymRVbCsPPpNmbQchHxp5sRJnOwkuzrnmg6GnHGnjBcyPiHGsU0l84fOc2DP13JbQgZ6gfDps2ypAl4TdH+tXT9GAPfA7kKtUxugVlryw5aUnEC92Bw35X0QR3UGOj7MHde9Fi/T9Z3P8vOZtte34W+LWnJJk9wczNURQyeFluBxVXvdSXkD3MQ0qgWcAdapJbtLV+eBl3ji2//O0rO3M02NsDbZbOhjWHBFfxugHkxpAorTvIuxrgvwA8bcWCYFxuJvFeNel5gD+WaA0Cen+PgcqWX/lSV/pIy/lCeQyfoPl6GbFh5M1qehQ83It/QzzNC33hVo72dk71GGZpKXSPSRy523oQyzxJvl0OIaropWms3hXTdKaP6HNFvtY+U7rxgrXvxqZdm8oV5adttuGuJgoJDxAVlxZEujSVEsNn/yWenY7KWeUf5BbdNs2mzu0f3FpJahQ+/l7VaUXol9VxaVZtYwD9pu45p5h0ITbPy7s44tMjO2C/gbFqd+bfebRkSw44N9PLDVuh9/bTPvhZSQR+jD921F/jRetyBfSAl5hMHHQ7zInwcue97Snl1qPPdKu3mEl2OEcB8S3Mgi67vZ1vktVQHRjWs2OrMLb52PUhUQ3rj2YeDEu/yQwS39U/E5i5dr4ugNYoOC6JXRQsiHVu/HmOOHezsDEy362WUhMMpyvznS2NwSxF73yd1pkK7zbJb8s3IW8qbFtGXO7bhgwcO53WVqbUI5vvDipM7zppmgxgF1/9AOqqsN9V0V23bz5o1vTTYyD2Q0sgjwP+VpbOeu+FPv3mNcT3tTJ0KfFu3NRf88eNwH/uZuhD+2BXxLXBsmPt2GnwOwXxQ0E96oCu/P7GD7u0zX+ByzuGbN6xIiHFXVfZzOy9qJtnvg5KdLJ4oEZMdhcO+t4HpPTWhQ2KUyUhgaH1D1Ldxgr1hyLg+NgNnisN0ok/3mQKMy12MrqM5P2NRgrQqIayxcz+ZWcN3ohehkb0a3F9xzJxZ3d5mknFUh10iI9fdfCxpaAbucdGlMeLWZDDie+oio1u1vF/lxlAfH4reUZyanaoWJTUP3Z4u14cATJexODOwPkbMrzG52IQ8W0ZjkmswEu/xOTKOaLc5Rcp1PArdrktl5EHnjNQ8jxsXvgQuSDX26f4JEfdSA8zmVAsKW291Iuj4uohEZZcCJ7NbMqrFFaJ/Bs2N1MoIbD9zo7TYrwh2yxnItb6TSTlDTCk2HiX5gvnCat4FsljyE7m+Lk3D5QT5uEMquS43CeztYyDcljMwsw7sZbcIa01koQ/RcP3En0hRKBs1ENBaipzZY6iO+yuaFOltdkxHbSNge4rfWLF46EfstBrsNlFbimY6z7zLPKz+8c/yrtVesQm4uNQlQGpl5CVD6kUPeZxQkQYm7zGzKQIdFSswpUQLHAtfUx1bnieCMfSyEaVkm58HST122MdYf8m28WaOMU1873FnXTxzR9jCIc93gob1+O+gNPXNkbhH3d4BqzdZ2RWaUD/5+tGMrqDaxzdTLqxY7XxeTkcdl5AcT26x8yXQ936QiIPuO0b4PB7bZ91zUYuF1HcjG47LxY+ts/JbqmpVXRWTnURanGloE/FruccgPCTx9TpgYoxgnRL+1k0HbIX6yCpgaaJ9ZZ/CXju/wNrOv6UDGH6Pxnw3s9HaueCm8+youGxwfTS9SA5Rb46xTg9PnKOR17rfNBDrKoP2hTQtVWZG3rClLcoxrBeCAjJjHV3SlP0IJvCxFkTFe1qTIApSCvgriGpFB0cpihDC9ZkCZBlWep0h4zopxZkBnn2qbnNVWgzAuBwY5nlM5IXxWeUtxkQfTuF9fz7MRjsfbEo3teNixDWAvBFt+7jjrA4h1OSGOpiDFFDniEmVXWzW8LiGscWzZP7TBbB/5/sYm1w+kqkmJbTTx7QlyvJ9DXoO62kYoIymhjN1Oa90OrcdBsQ9TYx+DEXKIZb2Uv7zk4Si5YE5cK6UCRGSbcdjmKc5FdDHedRhkXOdLbkdBucGtCrZOZpCp3owSLiFOrbbVg+HcGqjlGrKW6FJAOBuP82iEHedr7sVr58uXa2/5rUozbCeYjYd5gt7hkJ6yvBEVjitNhLDpCA/7h9gR/s/VTRXf4pLQNR/dCXZ0z+P67oBqG0FsPMQD9BB/+XIqPAY1MbTaRhAbD/Fohh3iHNdFwj3VGsN2gtl4mMcjO2C+CMOY1VneNBPK5qOM37nQ+BbkWmBC2BLXom6ICWAUAE+m6Bc8nGT58Dlw2b0XMGWjSV1CQBsPNNLD86pOxSXjK8U13rYQwMYDPEe/5PE7U057LC4JXfPRRR+bOEo+OLGnnBJWaSKEzUd4jB/hepy42kYQmw/xBD/EtfhwpYkQNh9h9HGJLzdM/B4lIFFpIoRNR3jU72NH+FN4+hw5gcJwtY0gNh9iG1wJuAlPs/mOEDYXYfRblL7UZ3RfaEKHCOEB+qjEMTDBx2R/scCLf0UuKwt07SQPSn0VtZVANh7kOfoJ3a8s+eg8Cqzq9cA1IkLafKTxp2DepmLot+HnoCgDsvGQoYBwNh3ncR+9q9FEM8GMD2b0tvnSebljTURrhYS1+Vjjzzj2lt9Og3Qtet75yhp1XUJAGw/0AH2ZldPnrGSbTJXn2S/7nb0ok8PGDoS3+XhPrQjf3bB7bW1ZrZCwNh7rIXqrnRWt/yRu4XF5z5Vy9orEqBqzb4w0slr24+HUCrLzgoWLb150W4cbColvPHyPB5bx/Vsb378R38j4nuAMYufI5hcZ5flfSJf60okuQ5f58Ynciu0lIBK4s+Ob0f/+7ji4C1ADRtaXyUdacW4f+m9YnPrJ3jqg606agEcTppa8ByLnxQ8d9zbMga5SrxEZ5ekQ47sORTkcWmjur2QBpX2cHV1HUgBcCjC1UAH2QJ+gRwz9yBLXpmD5+E5J1ao2GrSS9C5Yozm0cDS3yY6fPidMjEyMbmun47otb+xG9hyVPR9bErRhkmc3vuZhxHjyondjWjsR+HSmp4Hg38lSqQKzW/H9sZPdfj38OzuSAqBSgJkl09fscUqeH9lOHdinL6kBqkWrwaEdavA9ZfzlxnnSg6+XEuqoUB/3bfH12TJNWCPsTXLCHRXus4Fdll1GJ912867pQtBjgn7Yt2RVlqfBcbheO4HbaOZbuhD0qKC3JYJfbahtDdEKaZGKDscxFvEmuglsTDU+LQlDrlhyEa4u2CPzq1yDZnJMMDkm4xFObzzLYs/rwMhPSu2XssEgA10OBwJ8aHmFORvYPREGZ1XsN1MYrgqIZdNZHk+Rw5ztLVXAvWTJQ+jW9p829DFo+9HbIo5sD+qkP0NOuvCYP4XB0Urcpy3CR3wVA7e6uZNRTvZPoN1Q73oy6tuI+q/yD73ltcOd9U7kYWdCHwf6s7mN6J+wiAUuC5Yvf4rf5jq13PXX/RUpA47d1ocj5MrwK0tuWCL+Vbl+fxXVsG+S07zV8HnrFGnFJMXOb9EFplwVkLXGYa0nI/xIn/mpaPuLO1EkmFOprskIbBRgz5BmkgNbLau5aG11VUBII0F6bkPYXLHIDZvjdvQj4LEE0GdD7AH0iIdrL2bHju/fiT9XqnbVRUQ2ClM+H46RY53I2Ae/zgm+8L4pHopWSGjjQHuE3WLH6V3MlHTYbQtBjANi9JG++6r3/ElyXOFZKyS0kaCNs8bQ19gNlxnavy1OwmUMoyJqq0FrMeXAVJQHh3avxQxGyCl2XPfCC77dhhLbKsg1gVGG+W1pRrVvcoic6BVLTljE2TLL+VgkGWNq3ForJ75x8I1zXnidl9YHad9Fqz7fuyI06ZyJzUChUz2kSLXwq1HSXX7I8L5Jg8RbMzhbBM0GudaV0UGmJ+RdI6e5vFBKii+M3NNOHDfuZ8fPMcIaDcRzk12eI95kU54QHm/3A2+aahuCFYlpmdXVkULA+1YDjjM2XT7v8yBKc6OttFThrgkMYhsOE6A9mxDa6NA+YfdO6idyM++R7zkxy613vbkKuV5qEOnaUUPcLT/IByXu2Q5e585nxUqjusJoXLS6OhyI75QSri1A+AMPn2LGVZKVRgIazykjAwuIvl2oET1iGBfDE8QMJ+w4FE/xOSk2mitt6h7zmsgg97k+WMj5zG7fGWcqSJp4fnwgk/972WI443F1C4xm64txtls/RJgMMqBkEMsAl0sx1zrMgYBgx1hkwSrYw6zijaPUIa62EeIYvfI+YsZXLMmW7Y6yux2XyazVNpDHCkUGpfk1DRky37eeeSO38DquE4mH04uiVfbcGedhYbiXYfDIeHLCPfGfU9muHESvlXbJmDcOTUV3StZ6hIzctRM1UFuXELEU9esAsl7cQGxNQMCaudQyxEBs/taPxT0tqA39bHdWdkTSbbj47qvsasVdJlgZIKCYXNwZQoYLRxaeUQCaiVnaR9shaO9lauVteBz66bpWnFcrJICNdR1mfYQEfw7iNIpCnjD3k/ARHtmJkziQ5NZO3Vngfn+e0WxYmY4QshyEfC2+82/5CELFA65LyA4b60gczlGz63DuvOjh3YiIXmPp7Q9R0xuka3mWlp7fipAINpbgQR81wS446LYuIXbNDULgtr6y4It4aOtID7AiJoqNpXg0sIPi5O8dHOcdiGRzSZ6gJ7kZYWLXaHbHI/TstthfsryG0ztDTe86DFhDFG0jInqNpXeCm97ndcPyRSEgco0ldzpGSG4S/harZwFuW4hVc0uDY7SykcNjdr368JKo1a9gO3Fr7D6Kw0PM3oEk1DlqXCVWxUSxuRQjTvOtWV/YTtway20f9erEBy/Rm10vIW7N5haFvRX/rdSfvw7jRNyW+CjvVS9Er+nQ3YTefGyA3KHVmbxgEWKKCdrjMAjYxjzouVX7ELoGoTsd4LW3t+K7YmcHu6ATwWtSLUAcWZAlveyZLdOE/ZEy/nLjPFWZ1Yi67OS+IauYvNvB4Rghr4LHhXxSa3DIUoOYuDWP26GRdnbFkl7kO8l9yNfZ4/XD1YrxjF3xscpqcdklNpt/vcrnZDy3HtA5NjyfHK74rOU1AUqnC/yLhIqG6+K6qMKeXMU3LE795MIL0me1DHtd1p3Z1Y6hQYKnVs+zRjOU9IrrEFYnDePOm9n3IBVVSekhSlqz1JgTL054WMuY2TYTuUZXisbpJogxhP6jBt6agPA1OUwwmOK1vFcRCxaLiz/ztfuaBa6LCWWTUR4hRvnCu2shuSYlkE0GedJHCXLsBF7ixUwPsl5KIJsM8hQnyMdivGlSWN1FxJbevbe8dpKH+NrhzlqJT+zTl0JsZhaDnOOMWiwbkVUTz9t6kd022W7P52iXPpQ5X77UAVdAGrqQlTbSSg8HQ6wrIXpHuiYgW2x0pSec+N6LW537DufBRbh0ascONnYgnI3eLHSIHGc9wwSu6eAOxljdiA9eIH7MrcPF57OQH6eci99S9gKuxe7OhLnJmI9w2mcvLi/Pg/vwhAnLzFz1rLeGDoSz0ThPsVrtKq7ARkMRIWwywmaWS30twpdsHXp/qza5pQshbTLSSBe4d7rHVYz29qmrf0TYm4z9FOcU0vXipcPd2tHfsJ3gNRje8RytG3IcrtdO4F6lSZQmwDTXZASxwRBPDtEG8Y748uGMh+vPGbwqxDUZQWwyxAOsIboL7y6O/f6zGperthK4RoOLZM+/F3zLC1KID0pFiuK62zv+818P8ZzR9AwFnAmLk16aeH588OjJi+NQPL3npEhczj7L/3DvLk3U+Zpe2uG0t5axArwnA8uLrk3ww33vLAWySm33SlOnbfK7g6y100vOioN5jdt0PRxYYaxjQVPRBAw1kJCRRmCkkZRsaYX6modLYYs0UNclBDUCqGdD/FB/Ks4yyHKUb1Jfib9phYQ2ArTnI2vs9akYfrPNBlKCG8He1lEfG9xfrQmGfG0F+9DyUMgYO9g4AiHvATG6MIgNRhpZEISMc1sIZIodaHwBEAK6LfwxwA401uAHYd0W+hhaYqcRBj4I7LZTc0YYwV4EThQ/hMmCcS87dJf/8rV6Nm9xvB4s8dUkN2kKqR06hJ4O8e0PbOT+IlzpgS8FRDo+0uc2kn67jk48rmV9KyLa8ZVynFlEe8K9dbbbsObJ1CXEOr4Ebjste/g58J6bfXcgJ+7xbc0d28j9r17yMb278IJveu6BnLhHuJvXSnsfH/ue+GWLRPyLt9xZMr3Z13YjLcCnBTZFLDlbh4+s3GUbq+fS1UREO76DQq20+XmBqDNBgvTjtfa+3oXox0e/latTl96Kiwd5661FZ2cd6f19bS/SAXw6YGWU5+TuM/e13G8kxDo61mdDG1m/EeOtFRPUS4l5fMxPbWX+OHRZedJNI/qwE2kAOg2Y923UgCOeyBMkhezaCbylVgE0fYh/fPxPrIzre+uGSL63ptg90ly0Q5vCmRFnkcPZYvnA1s5ZyMtuVerb+pACIFQAm6I5T9yJ/vKShz/SUPxBFfu6hGDHB7uZ27WXWR5B9szjgzVbh/zlIN8zf+kEL1l7sWNKbhK5DF2wBxC2d2eX1H4jAyBn+eP27pBSozNTcxH+ktsvngaXWcNtybHSomQYQMGb2ejyHyw53lz/KMUNg4MoT+h47TkWk9zGs/xcbFkFQAMJEU05AgYQzRxXXtywOPUTkAVWExHTCKaJA/RQuyxhy+Q6jMWQfJYLL5ijHDDR1ocwRzBBPESGeTGbUknHMVFsHiEEu2/1hHGGbMKoRXohfobDvfAqkqZE8Ug0IgIbRRGksQ1kw8Yq2jpZ592Qd+MaWXHREbZ55F3q+S6gG7RV4daIOs92fYgQbaqbKxNMkJG9YgHjG6P2ORb9b1gU8qQ4HLZBqp4S29Kp5P70P7e/3JweHd+KgfTb2ZfHXQ6F6zfoT38O+m33ACrBiEoGWKYBycdk7d+ytVzFhqcjQxHRji6hEF/w8Mj3t+/5uFznUVvBUk9daELIsDZQiPeYwoYzZHxvH/iJxzO2lZYq1zWBEbEVOEDA9KHdKSZDZHEV9WUtn3pemkXjnW+Fzc652qfzNrxl9NCUD2nzGzJL7jqJc+fELEM9ZkkaVUxfIauS3tKl86BXxgrBpkObpZvSxwy3y8MdbDf3ILSNLrE7wsz1k5c8fAqv0iRKFZ8EthPDRqfBDjAzvGJJxfsMg3tvBWKAOvGbEe0F99yJxd1dJilnVbY1EqL8HZc00VAuviaIney+YtuAoxkaIHlg99HMEyzhEWGnvCU2fJVBQRM8JXBRgOutenG2Qx0dvbWRQYRntPsRA8Lbba5HgXvDhPsZ4N3JWxsidCgOCWoMUH9PGUe3IV0ZFAS3Tw6F0eCyATtYp37iFW/dngyr9dhz/uSyWhte4OU4lySVGJfXPy3yJg+NFZ99xnfDu//AVKRHM8rnGKPAughIPYl/fSWQyYPJjpechfyvou2GOeI5V4PKDfIOBpf1QwQwTyn3rm/+lsYmmuMkjDRVFUAzsWuuIR5iYpezhL8U9RPEJ7VqQtHQbVjLEUBSaWUDFajsmS3ThC0SFuWZzdWGKrawvdv0gmFBiA/JVcAE8Tpcfus5rhMlhbcgG47ya2UWpzYbsujcPFCINZV97I9s4frMWSah6lnopUQ5xgTPwRyVu5wGZobdlN8PQaUU+yGq8FpJqRiCMK7sinsrTzzCRQL2uTbJOz7hI4b1lvZwhNHURgKeRB5hqp4IUGkkXI3EFVcQuMTViyGr2xYC1UhQByhBXbC1Ez2EXGFVaexoCsQ7IYsl/2EAtm2Y6sty9j31OOt5QS95YL2157o+K3IEXPZs5jRs96BUmMfDGc3NUOAcZfllvby9561lXZ64F38XX8zK3C5B7y+bRLXkJWLHD2yp1HpWGjvqTrxypBB4WvKY4li4ezXx4v3JePIpzA5yVtb06hJiH2lVrjFi9tcvggQbjH3TQAHvA3JuhkMreUdr6on8vfPocFh6aaRd+YbvZXsyenK44jnzcl2453t3Eokcl4OYMdfMqeuPDRRwP6L80cEUxXz2R7nPMxnO0iBgfv3YgG17R61+57TA3MyQ4dzqF0DkLb/dOIF4BIv0LmbqgecaGSkEbndoYLU25Gbs9FH8a3H9tbBtJy3A/lqYTKxSBMMXtH5kmBB72tyLY896EQqRX/YSheKmmQ53+4Bg2sGUFq5QYFzWI+glzp14OobXW2gZDSyyQKtPcxwAB4+9R4f3YrbMfmgh2hriFctyZ+PbMFteOg/A+RlN8o463zvGC+00hd6nKDzsNIjTSK66CAf0jodPsfA2mVw1ymwcC9J1sSqTTzAdX403FtcdZfo1g4P+NDkiQwsAD9hTsfiIj29lbBBvst848GbPjhye6ZNE3TCgyzG3HtkRCs/6Tny1DG65LGHZna3YrC3CsbjReTnJY2CU65KOmud9Bgohn9AaDgq7XNRmvA99VxBQ5K4abqR3jglm4pLFxmGxiwcfhIl4+OJn9OI46YnntBT4BPjs9v7DhV41Bf8wZ55HYZyIuxPbkHzeMlaYhUtWHnX+eSv1aFPQiX+Ls9DR5JO0Ois01cRRr0o8ZzHANZOPrEgg8sQQVg9JDEB2mbjh7Np58UPHVQ7QhYKueuZ7DhWiTvVXcKSJ74965PC4mG3+IfspieEaGQGPrTbs2DLi2bP4PcukgXm9lKjHvS8OP/X3fho/SJ49pkw/YTuRjs13H1lG+qNg+f5Fg3pNQKxj29nQRxhfXKdJ6vj+S489L4Wx9h5ZL4zkDUcdX3/VqOF6KkVshlPSBHQxd9KJf+YJze3SCekrOMuleIZcPEkzI/Q/PljIP53QNkZY2nQHES67d1I/sYD97Ugh+FTtwkLw2TpKXizAvhwnhJ52+VsI/fb9rx4PZ4nT03g43HhIRyBOLVQHe3SgEXyKieKo9iJY8P1tvZ+71PPdEo6vsfEbRvYfHQz6k2XHAXjlNS6D9cYj3ToeuJmPvHWM3vqKBRKAkGcVJOJeEodOhsFyw1J88EfKUraFK4P98uWPNFQPD600dfigsDcZP0yb/7H4DZYDxiakGFvFyHQgVk1xqSE6GamKTarSH6DWlSB0hS8RP/eWhUu8Weg1fHK7e4iQc1rLnaJGfR0G4rdEYU/ewdx9dqIIKfS7Bwvxp+nC1A5Lz+I1dksPhghRp+p6U7TxS4xRy9ZYJaXg4IA5YM/J17gHy78c9Idfti/zcMH4I+PH4k6EgTxQo7cU4w7XV2kSpUmPs9NnWUHgxONsmRxsviwWf+UtheHMrpzIyy3jV7krN2zYs1UTvJnKZHPae2fJqnqjNv7Q7PdfuYMg6jqntTEcW2P+JXV8cGTVvqoebltIAUkB99qGeYhbAw+3NMWtLAXhTUFTnSM5GxYKIe6mYOj5//yfmzBMLrLrqvKpraUCnv7n9peb06PjWzHgfrsSjsXdGM7++78G/el7bmn4mfcKnjlBs6k+6dteDD0wx8217SNTS8CU1zZrWHl3oH5RXJr0az+C5Hcd/H+e+/8yLynXtCI6xhYCCm957XBnHasHxejlNmti/T5CnaQDDEakkz+sk6+PuZAWkhbqtHBGWvjDWngtf2JF+cpr0jnSudbwCnJ3dLYvTGWo7jxws2BdT/zLzTObBNm87/1uE1jhO6QVPtK4V6JUROsSxJHN97xpUANpTYE08JUwAU8qsSwW8zNuKNRSqskxIi3951qKOjpDeklhGkP1ElG8hrSQivK/uRpOvsSeHPjrwoB25MG8xb0BCtWndfk+6ZOWGYx5Lv/8bkD9oQ1npD96YuzOY3nL+wZ1jnI1h6Rze+sc5kgIadnP25JHWtamZXjiGqRT7+ot4laqUSs8QXhsdQDjbe4OVCrKLOmTTlkUxHiL+wF1iGrFkg5RIOP97xzUO8rJGpHeUTCDNI3yNzqmaXgCGqRXtJXmnyRGzVvr3gTs6deyduF+mT6g+E1iSf2ud7+NMFeKlqZHpJj/UDFxVvIiVaS0xTfWxenri8PRS/JfuI1QMynwOSTF/IeKifMlSar481+SyB3W0Wt3jDTVT7Wk7uU73S9YbJa80z7p3d4coax/+S53COoZbV4jPdufIsvrYL7zvYS6SfvgxqSb/0g3UVdcIG38ydo4J238R9qIqM4C6R4t6L+l8g2r+SC69a/GjBA7T956w/sFk2cOaYmeVG1fVUO5zEDKRWdo/ah2zfdfoWorGW7nW+29bh48pph2541ICX9ICVG+70jt6OX3JnrXVn2xzWmyciX9XW4WVDnyN/ukcfaeIfkOtwfO6OakYaRhdIrkv3wj4XuP8jZHpJV0jiTpIe1wN1kP8ayYk9bRcvkb5qqMf3wjDC02/JR7CFNYqMzmkFTyn6gkzh19pIS0ne8ttXDyowdAWbuh793uGFQ+ipT2SfdeQRLKTX3vdI+grs1I10jXXsGR5Rv73v1uwroStC5Pfug/1U/Um/tII2mlwjiNRLTBj/SPyhG+rQIODtuWwF5d33Iz+0lwzRDf8TZBlaNdtX3SuNehVET3Mp275mGkTAg3DaXWXd38+svRr7/++HKEgMPxgqrSVVq6rnbbewUV78eWIe5T/x/p3dJ3cs3tlNJNSeleo3Q4FyEM0D4qq2SxBoLpS/76qwVE6yFQu1+A9bsGVXFm9YtwSC/Cf66G9qxSGKShdOI6aamipZjXKkgv/51pJAVv3sKLpSAO+bD/RAtn5MS+xVwSy8IhvQz/nf1OA3oZ0mmf/+5NhFpJ+d4jUko66ZPUkBJr3lUPv8QPDmfuVm2SwrMrlaa8fjOV+TmuJBgX3OROh7z3J3ZxvWLJxySJjkOXqRF+pZkox0X55NAuyiVmV5G8+UpcDjQbGJ17F9KxxNGmuLOitD4K3O4PfRadnKw7stVVC33zT2GwC/2GLkQ/Mvrn9tF/GrhRKO8sQL7a/macR+J2it/qlM+75L3WTtz/1K2GuGtBjXccILSks8ze427B0tx0tjWpmc3nmJFiUej1B7d/91vL8oGCtVRh9F+6i6Dq04yW+oakllRllBSR6oy+tyYO9q/nTpVG3/+ewfqHVAG/T/pH1Ubf7S5BfaPqTaRvVHG0W/cT6igdv0s+KVUdJa2kuqP4tBJR5VHSQdoi8dZKOH1N/K/t/D07FzLe7/bBlUXayTsiRfxBRUS5dEGq9xM30ePYaeLFcSra+5NRf9aL/fCpJwfs+VmyY+/OWxWUHcR8eSCeAnvOcjMvX/LXVVWBqm0d3nHyQyOGa3Z9qkVo/PaTEoT5bDLpyQwnaSpjL2E9l4k7zTMgAPcrlpzcHWf/EthVWG3uaOb96wcMsae5zxCV1Z+L/xMkLHvCoWBiDGIcvTBcA+gX4oYfS9PzFxdTZEFmhXydzADjv8/AIfx27zkcjnAZ/b3Ij8UdP6sYn5J62N51g//TaEdV+HyOydYPZoNBv7dO/cQTo+1FPHz0XMZ7ef8YgF9a2RL48vqngX4cipsT+n7+Rtkb9deMEhJPieo4/Poom4UK7za4F5O5Mg2g54YsDpJewJjbE8R6bi/l/sGXOGFRnDF/+hyxZcLcU85DxcepCTrs4PzY4EF4Z2j3mTNj49WgtCmOf8Diu9Tz3Z74yiC+D/ma8SwAKlGIb2VjGfuoIq+XdtDN2TlSgPaUrLz5bk31oUuP1hVW7emBcSYsGkvSKPfd5SfFaS8bOo5xw4ggyOO3A3nJmexjYr0nTCx/SRPPl4sw4oFLlBapl7A8qrglGghqgGvk3ea9fdSA+smQqBd++sx27E+498j4ketEiRqP3KvzmymEF9xzJxZPYpmkXFnl1UhISX7yruu+TVqyYkm+/Jq3lZQd8RXIim/tRq8KVPGcQ4wq4LlnIb8uInsZ+0pLlfaawAi+4QAB2GOawk6twPpe/CJvFfzOXhrwbuxAmOOw32P0Hsxp8Khx8s8EBnGzW78RG+iu5AOGvsqIPPb/6g2m1uC+DKOXa84iHi7FM2TKFnKdjEDHU6J+Yg3lTBCaisd36ay85XG4XoOAZZOcaMezV+zQVh9mkWWRNzsxWznhjiruOJhYSvyJkzh3Tsyama/2IOpRUT8aWk79SX8393kfIh/VrHXUt4Z8uc+pf+mt8q1CiyX3oto+KJ2ciMez73U2sgZ3l4ft3k1jBwIeTxC+b88MNuIscrhwU3Swa4UEOqLVJltDNSd3n2/OW7z3UkywY3LcR/1Dqxz3u8/crxUtKNqIbDw1oUZj67A+4+H6zHce1X17eimhjgf1qT0WnLPvqcfl5Z8O95w7tXiZXkqo40F9jh/1Syfh3rPGP88FzQ76Vm4g8ZtRQ+hpg5/MlsHozAjHZPP4z4P7MC+pl3FwGbqpatphe0eLD+w1SpjiO7C6zgBIFJjiZbvaeCZu6CfJtuqpa+VGmPN34xyV/3Joix2vNl5z9uixpzPx9k05i5uQ13Qz4FB70oQf82is1ISz0HcZv3bE9zbZfaUHWX40vM9t5D3P7m3jXe1BvKM5oWhip6cjiwq08a72IN7x7PAY2Aj8cVZhsdGlr4iNrTZD+O+13cPOma08T5WJBxwvkozCJquv6Ue2H89JcEN7nft2x55ARwX6dGwj6JcsacS8lBHkaLZ2jOz05H2vjfOKmFDHs4upbynq4u930F7pQcDjKQVpzTQ1KVs+OvHtS8TcxXcl771JTrDj2bJnjXX34pPsNPtQPU4cNBPatBu1y2h/j1jvKeTfisKn+VHcl+KxyX+ydkZ3RWAE2MroINITOmfv0BaiF4nDkzrPm2aiGcHyvz00P6SJGz4FGqArEmKa1ji7CXV5OGhcOtLVY2LKuuQXzh3zgWfd2s/Y1f7q7YAqMCYnBWMWo8vuvaC67e6S8RVz84Zs5V7Jb9FLjdmPBEYLGe9bvRdphnArUg3vfGX+2PH9O/FPVNGuSwhrDFiDEi9IuT6pNFxFsrNitxvERDgKwgc2EC4ne/GZkwW0z5QZZ11CXGPgeti3getqg1JYFLQbEUV5F55RbYXDmC2bvEQsLipYfGNFWOQocI+WS/HwuHiEn7mfux2Orxa22Ku7Mea8vBGwjsv8zez4K8u4UJ2L9y5dlB1Ed3QvnuGmsKgTeIn3N7sQlvBTur5jXD3HTi82p2wRHDGEnVbo8R4HUKdddr9hkbBKMMFq20psI4qCY8+ruvadIA8VllfHoXiyzwrfOpmRVbmK0UJHfWh3QGWIvCrXhnHY2LiHs5AZl0X4pnyj2v4wtcWOi8bT58gJXOYqwr+85KFcu89rQ8Ot/K/5M9IMNCGaPmlG8nDD1mHC/ojYvjqh/AFpAxZtmB/aog3xQ5j67uKbF1XKtyiRm6YOKMq7kAY0zQb6Y1tU4C71fLdhyquTkZnHdIqpZVOCpZ/GMhFGng1zGjzW/ByNnHhHM/0dzxDCvnxgy2+XXhwLrK6V3HatpIp8YwcjmG8aOAB/NCdvBmOBl2XmivcyF6XYoJS7K1nB0bonrxUa68XXRg/N/SG5N//Vm1jKfZWsRv6rnUgPUOtBH+M2prz9yfGSszDXg+JzlfpKkxFODRwUTEaYkTMzRsuyywRjRYKw+KRmBhcNBlFcDgcyTDur+6jN8cYWQ0NsoBXW4DulakQI8eXCWMmWy9BlB3LgqXIy6XG1pcp1TWBMSljriKEbPbN7VxLC3LAdwC+bgF82Ad9pi/4TYMdk4af4LXzgern8lPNi/nhT6VFFHrabauJrQ4aujd17T8f4rbwG+luHr5jiqm9bCHSUoE+tBP0YNC4CJ4ofwiS7iFWffldPUgzaBIJHM2Qqb5X/8poox0n5mOx/xarvY/lJG9Bqw2BA2iAaP+Qr6G3KUOlCukBVO1CrQ5sekALgnRlPLYn055VPPzKnzCHTtGui/lBsbOwfjB9qwaH1KwAzS9Z4b9g94+KPPMc/yrrLGk3VJV9tB80KcGM/oxeEm24PXDKb2z2jtuSt0awsyz2VZbmnshj3QnlfRUGV/DZC/2qRO5PO70/XUfKy3YlVNNQ2YFXaDaRfHSqknXLlUMFeffS9/nQwHvdigXLPyToUeZM58Vn04z/nCVMPE4Ht3SZ+3/EC7Odj2nSCbdfhLhSibGfVgfiFcmL5Rcq+FLK80ki9XakzohebrR7t9wQqzYjyqjEpjPiqpYCt8k64lTenmmdUXHd/ggzHoqI7OZzYvYKGKmtizZKH0I0P0ihmPDkIhIV7FCZNMOotKzB/zsTH0v1VI6U1Qffx3mvIwFzP7N4R0EcV8lFe5F7Qi1nkyDMZequH4mWe/82XdS8Je0HVw78ORbtMGBoci8tVyD0WL/64OLnTeP2tfQ1ydfa6Q/AdQfWm0G3e3QOKL+vtlho82wteNXDo59vtLM0tfm/0LsNgFZ582PX+KLrt+Qap9Eb1DqncLfguGdC7BNs6wt5w9CUc/aoKfRZee6YUR9c8zGisK462DxJ12dwRqCZU+8dGl6sCRaBVk0H2FmlTkm0PTCqim5X0SUUsVBEQmO9/ScIvQXWZop+EgWZ5omw2XiuabgCcq1AlgBGpxpc+UI2+XjX6aFWjr1ENSu2wXDXWtbfGWv/WWCN9a6yb3hqU44dKNQTOArSeLDXre8vkQBabTSQi2dHPvce4txbM+JXFQfG3TuQl4hf+rUzGYXu3NeK144YrhKQGc7vVwInlerI0qP7vTEl8rUveTBXebdGD1OGNy2sYrg9+uFpJILLHX6H+IlwVZdazP6xirxG92WLfu7wC9GOEZNOKHpoVvT2h/l+Dn4X1u5lzQtu2LKfsSS+5FyUVsFcsOfL9zeFZt6JPlrsHzwVu7tRtJ14zaLgGQJEcXEvJTZxv+D3x4khQ90nS3XD4O+hCjJtf0hfVjn45yjAWoMYH4d1XJqZjX2SfEydxyv3Ia/GH8voI7D9W2rsNdvsoga8y7ZMdtxTxDw2IfyDE0SFuoxm/8OJGU67IiHVU+yFtZv1DC+tk19GxPh4iZd0XzNpi1WtjhZxTXbm+tZjjMeiE+e498YeYOE8D75lF4fKht457rnhUibdmtWo/9fVO2N5twttHCSOKM8qclzV+UKXOs+eEiV8ua9e47N4L2GnZkGOe/dmm7djx/TvxTyrEN3fpNvytQ4f2nU7wxbVi9Drur7L5XAv12w7EPCafxibms1y+VlPf3KP7uYxE/usCkQNrya8b+yY5UY9tE4dN9l6MLPXbffuWLuTnYArFW8x93dw3diDmETE/mVMc50/POWH3jqB9j4iO2pl0AdPRRwPbYzt7aYKuK+kBpt2rA+vjPXpF2KcvzYaxRfwPDy0PAu2jDO/6UiBV6Igq9K17M/zKAsa95WteEPv9CSkHNuUYWK8cO18X+/wBKQa6lAn7ciZeoxn7/wXNsjGpxcQmtfieMv7yGq3Y+w9IKVDtcpxapBRe8iyrjnsB5LyqCK2dCH5MeXa46qT9WOKF/m2wV2dSBkzKYFXunTbZYi9VIJcIffa1TS6RMOw3GeDxayYLr/srUg9M6jHpI1WP3NBnWpEXoJfTAO0UoUFsDOebkUK86RgWtFOCLL6Drm6yZoCQ6andlWXHmCrL7sMzgpLJRPUuqqe4Tve9Z1xIPMc/ytriXsySwoFGf4bcj4wdHgREZa1QOeWvhwLTyXE/MnaoEFQYCJVCrPzwzvGv1l4uqyQ+yEmobK8nOFQl3Ua+Pjro7dCRPriOznW598h4z3GdSDy8+OBLmnh+fLAOl9/KxiLrbfntKL9Wc9uU5jej2wvuuROLu7xMUs6qnGsk/4T4/cYPtWBAWjC1XAvOnGUS8pcGZahISScsqg6Ha+m2AYSIh4+eW6jESrjEWbeC/Pi6kIJzVpo7oVGQyn2ByjGkLcaYFMOL41SI++LfPjz4snYS7j1n2nBTOVK5qgCwvfuRz4YhwtPi+v9NByEiCX62QA0DISraOikBjiO8P0BI+KDfH05626WdnvRs5cGYvnfHxS+slHm+DNWCWOW1MXjvPVbI/Zi4t5j7E8Yiybrw05+VOW5NQJqAWxMGQ7s1QUxdr8Rkj4uJnTYDrUne7UD/v6MTqArkHmKc0A7G4ynyCS0YIiR7SBNabBPa0WDaRw41GCKEekRQWwA15igNAW7bbLU/GE5n2H0RdYiQ6gGZbSxQbzOrfltkO/UEpBx3CplmoBBwSo7so6pC7oerlYCpEj7BtMUJjg7SbPlOkENM9nonyQg2NxHP9jjVvOIj9/rTwXjcW3vPzO05+WywdrTtf84Tto7rR9tu27u+e2PPAcMNG0PKY5T1jnHtYtrBAtjMkwm/FMLqfqaqQLOvCYoN15AddwUqDiXF41WadS/orcNgFbp3vXtHDCZY9Z7EnLTnJL21E+V//WXdS0LR8VJ2PPlQfZlch0IuJ7GDY3G5CrnH4qKb5hWzo7dBavWD9w2evD6mdxK2A6hfhQm0xLWd52v9zvN1YtyL6EdvBVSZkfVvI5PV5d57ljs14oNVHkJk+farYta72XBVXL8Z3p+Db0H4pMy1q00F5MehGHno+/n2lSbMdUNQIR3MKY1mYvAke/OEWZCu4wNJo8GYKoOAoJI1HWIA1XUSJ5KZu6bDWhsIBJY23E0xABsvHd/hF16cmE5sfSQQ2SnZWAzI3vnhynRYq2OAmFKYb4wB02yObTqnyiAgqFQh2mRQH5gfydoKd6nnu/metGoFiUUaRSFPmKsrN7G7Z+cW5+FwIcwzu9fiJwbHsuokX4Zu6rOzkK+dRN1drLYTpWZROkdF6R+y4PGxGKt4wPyDbL59iZTE6+YeRK5Zm3wHqMiVe3LTpHG7LhD9ZBf336MV19lAqIgNQpfdpEHirVlmR8U86N5bVcFt7tH5+mlE886l2iEqmp+ceP1B3OUVCwpk6zy39SGizV/XxTVju+PhU1z4uDmnSmp0g5g4Np7jOT7LfCYe8G34wYnZZAQtMpSRb2xkouQhOmhPhaPQ7iC39yJTjADrGS6sxa9kJ0l8w57lAoXCcl1EltjIc+0xhIS3qdo9mbt98Jv4n2PfyyAuPlfhrTR1NgzcPCQI8dzqwPAUIb48DXrb3a5GJT7sMyQV4OEh1djoDwYIEiEC9pQ/7PKDufjqhgKxpYMk+3ipvWViyOJxaQ5R0og660W8H8c6/+GVOze7Uxdmjtf6fpMBM8X+blo6PGEj+7tfDQyT9/PHfCndQhkKO1ix5CJcXbBH5peljLILUMFo09Y5g9s8GBXb0dDu6RpiYE/YvRd4sPBKTUDompqChhTdyjXIQ9NZ3A45C+8NLt69lubCu2Z8xT685L5t/llxbrdNHQd2OxAA64g2Bs+RwHriJM5F6JQH0f4W3imrEPllp/0BZQRgAjYiTxYhpNtLZb+a0krI0ia1f9uFrRYzzsCtNlymSer4/svp89JPY++RXUW180b27d/1+Rq4EdCbOLR7dXiEmPhsj5DL3NNH0QJ3vmmFxLLJ8QdM0d46zJLTY2GE7xz1QOOagCA2GuIBYohBGwinNZ2/0N2Q2rugjCp90uhDVnfhnISL70pMeNNA6JofZOvPEKPrxWWaziKRYB1x7iiR4sYOhLb5aA+wBDpiweYyOQ3SdZFL+S3DNW9SsyqhpOMcKyODCL9hMV9zTxMYYFkGuWHfUxYnH53A9Ysos9qkHpUKJZ2e79XGBiLOY7une5MZXobFm/hWfF2cnzekiTA3dui4aX4nplHN+2ZT1GCfJ8872W7sQ3gbX+a6P8SLtxdfyvlTshT3cfVB/vc8cNmzOjls7EJwGw/3YIAZ7j/FN7vZaVWnnIdcxVojJKDNB3qCF+hlGDwynrRQ3dyD0DYe7RGW9RX5neWFTFGTRwnm+feu3B7CTtbr+2seRoJkJU6tl74Z2cehWiJoc/2DTDcNE2bk0xkdQ/Rgw8a8bJtEuQp4e683A/09gn8EuxWnte9He1Zj6uTy8kyeoKWU3oQCMt4olmfGmJBm0me+kRmjEqaDO2GCM6qP5d08U3a0Vpo6vTTTMi7gaP/gQUxYFmlGBle/2PXAnSjyX8DU8JdNdQye9bsVd+8vL3k4fnD8b7V9sG19um3JX3EroELQabrDPmLznjzw8KmCwvOSZcs3xbaC4ura4c46VjcV1ETGvQJaxg61wPLDogaI3wutGtAkVFJhW/oY9Vp4d31Ate4/QPxWiDhLkpdr8Tk54qt0Lf4mr0CqE1R1oUlulB40jB7qAJ2BPUWsAvnJlglz86TwjH7QVgVfIzLOH6oPGSA/s3t2PEbsBYnXfprHebJPVbQ3DcYBXQ4KWu4BBXmQYnx195UtkzOP+e4iXYk/3HjyWkkV88YOxmHfdBOgNZ+RGlgV6xRaoBNUlaBJjiC8WXsLjOkoT8xz2HYdqNX5ycxlrFeIXZ1JO1DuHR1bqx3ngQDdZVfBYun4DtdrRVMn0gaceTuH1qrD6TpKXhbicS6bnaaGPqQMdGopemW4WnvJPgpR9iOlQKkUaLZ4v4lS5Ff7qMW2JykGSsWYTUgxtrj/6od3jr/vO0PtTQqCs3be3FoFKXYPbqDPQkv6KUZ7V1INlKoxPbQ4CvUoRRves+XcplhUW1dSDZSqMZ/Z/tYo09Na3xe1TqQOKLcpHFrvRJ0HUZrsdqA03UglcJZDmdqoEqlq9y/FE5XfVtGG5h6kCDiLp9jrKsnaOh5n7gZ2L47FX+nfELs6k3qgVI/J0Eb1kJU7pSskz4T6JLUAVPWEMoIfZRJgv297hKm09hL21viStiOpBU61mJFa5LTvjrvqe5JioFSM4dRaxcj4vg3DC4evWOPmCU0XUgWUqjCx13VaiBufb4NonVA3dyOVQKkSM3t3TQirf+kELznuv3qPrCFVvKUfKQVGpRj37UwAdLcJGduNyEq9mJYupAooVWE8tlQVsu1ycasqNHUhVUCpCnauOgjOr9ZyLtCmCQ09SBFQKsK0b6kibMrLNWtCUxdSBZyqYGUSnxi9PH5d2dhQ1YMmOSkBSiWYTa2dI0Rp0jY/qItJBTCqwKRv5dwgjsQvunbE11bAVxoJd5S4D+yMCj06nu/c+aw4MluTqd3ShVQBpSoMRzaqwtfQC+SpOtecRWHsweKsDWJSAZwqMLM0HVtfmbgmIOxRYj/GXI71iHPnZVtlfntZJV1tNa7wtjJGWG17bHW17Rn2atufA8WYfwqDbUsV8ZrAOMrrw4W2fEioW4Q6aNPsuje7IOo7oI6qDAv6+Srg/d6XhyQ1mHetkJjHtmF4bBnza8ZXrGkTpLJMtbsnaQO29Vrb3gBp4H1P2XEYLJ1ELauithPpyEifDS0jfcWSDyxOFqK/botXg5i4x3YUztw+7o/D9Z0XMFdmHlywYKUmJTR2IPbp4Bvz4c8upNu+WBbYVcCvCwl6OuDGuFNit4tRm8Tia4eLv6/irhEZeh5s07rU3OpgPSh+NUXNeeW6fvKxucuuxHdbaUPEfOcHT1bs+PZaseFqs3F8q8OEzsqh1XyPEeO92fq3aboV9yojvUgDzgVV1msCA5NoGkYNDbvdWQZ9S8nXi9QksqYepAtIdWFqpy7cpZ7v7laIHd2MCt68s0ZoYzhLzmQfE6uxTVFnFLcrRrZbNp8b1rQByEgF0KrAuG+7CtTmwxoRKQBaBZhYrwDZtgy9AmxEpABoFaDft9QL4lmL6BDDGUFdQvwjXchFXVkh9+CzclCVBa5a+SjQbOgCVzlMCPnU6tgP7tCP8E62dG8va3tmzWVbGSNEe0RrW5ZFNVmcZKxHoimBbovSiMJjyYcLsR9QwjFip2Vby6OWh6aTKJkMTR3My2louAkwu6Fvd/YOpjeAF3jJgUwfDlZewM4D8aSCJdtkHCutMOO4Juy29W8cqor3qH9IVW8wWXrxVUHsZLf2IE08X/TMwmYX4fLbsfh5yTUP1168gR62A+x14m6D/4obAFRhSAWgcB3EK75qKd/0t/l/PzI/Ynzr4OdcXAoulA5VDWjp0nktaB465J5i9LWpLk7yBfQnL4Jtb9lIfJO8++5905gh7XZHdHAdndvMufBdGhnXyYw052/ENq6y9aj4fomElD1HIU+YeyB3vLqL735GeHlRBaokXCczwII3jhZyPrM72dg2xHVoE9KIN8EiZnrtfGNZwx8p4y9nzjIJuZIa1tih4y7KO5OObLqJ64yFNuC9WGfG1VZCG4v/jatqB3jy1w531hnU2acqz5sGo1AuBwQ5ntA8EjHGi29elK/2iw/K4n5xbZxfXYwIYmx3XuLIBoS9GEK8bTHKFL8pwqiqu6OaGn6Nw+Cah0kobt9BzLgnvvlv9ptozaZ729XJhSduh3fvyeqO4iWtVLjWybpvs/ccOkxQsbuwwMhO+jcy5RjWamO3jftPZR3V/HGOlncv/kv8Zla4Ldln1W/ZNBnE9nZQkGVKIR9MrbLdVbO9adbab0VquCGvcU9r8LOBtdxn28g2FXu18Ne7kAbgy6O11/Rv0F6wRKsAsAPhj2/L/9w2/POV6HMZl1l6ifYN0NKFVABj1ZexdS8Bx3XPg6Wfusy9YX522roSuGySE//oXgHTmW3wh2svr5CiIK+2Euj4lqcmdvo6p887fR1tF1IBhL7OYDi0dsK7qaxSK5bR0oW0AN2LYDImFagXu27rQ0qA71j6ASlBrdpvSxdSAXQqMOvbpgJefOM8ZaloTDzhWM1qqIkIeXybPkb2If/b4urTcRg8Mp54dz5I5dEICXt82FsX4xS8eq54jJuIzlnIPwcuu5fH0FdVYGdHUgd06tC3zvcXJj5hz0k9Q78mQJCe/0bIo8nMH1iH+6JsLvBWj6mvywh6dNAP8bo8K5Z8cJLlw7lbVhArLkHtsEqrQU6MMjoIdZ+iNrZgnZ089jt7iRdJBhs8lEwVEeCYFmlR1ebgzlPvu3xJy0/Z21qeJnbpRGUJyOUDW3478hNQ0ldp7TbfO4YIIM+Sbi3POhtbRfhNrTk7UrKKe0uX7nvnP4V/NJV9B1axf+m5rs+eHM4E4tk5kkzcFxlxrPk1e3QlXcBVTvJwbLcygGp7TXLCHhn2qHKR2XPCxC8Xv/4gXzg6LRsy6EFblXeNqOOH9bUNFUB+SNX5RkgxF2bNf8ms3Ob5x3m6gXiq4hkeBe6x4/tZD/nhTvzbarrNjn7GaEHDnYCqQKuuM9tUQSdQ9hg2yAl9bOjjyjXeh/0swH36zJZpwkq7XmW/SW7A4aw/iX8srv5kahv7+brLkRQXmJfis4pJUjcg7upN7wSEy1yTud2zg4z3PWYH9X6kDuhmB33rXhPiToQxOxZDDtcnTuJc8/D55YwJ1pX3Q3s30gR8JdkmmFXhyPdvWJz6CVCHowZhPWV5d0/zZhH6uwKVY2j5ooGNetEkrEWSGvqY9YJ4Tz1AVcNhiFQXHr3YSzI3IecgXzUOXeb/KSWhkiIH242y+5qRQs7tXiSe2IR4RnHd1wHNBDgmwGc2AQ4blT24Gpkxfsu7YY6r5pR1xvwTixPdmVhaIRl2VJ5L3zrLngNdM+rbZrLnqE6dxbp0tWLb0EOxQbzcZAvbwW5bndgY6PXDhtzTGZ8DrD47z2zd58Tz45L3Y3EPUmG966XCtUJjWFeHChmf0Q7zsSWMi+vQf2QnLGKBy4KlxxTKG8TEOWVlGm7Lz3i4zmLnrUZd6fVm1P+MCSqR307+1BYLXybP5Fzr0mq2ErLrSOie9y2iW8B7Gqy8gC08l+lPOGntRdRjSRs7HNuK/dXai2s5Me29CHss2E+wZsJcMr5i7jYP6sKLi2wYjeCT8NOVzJiWPkatNTXcBagIA0oksF0FduFP6KNMCh6g3l/YnCq/bZN1Zmr58XWxeUnxe2QCj+2Gf2Qd+1pJLRfe/ET4d2Mf1UqVhfxz9okxN75kisMDmol1fDH7iXWsFyEc95qHEePJy0VGZT3GU+9A/OPbII5q91+U3vne8qA4fCrk1TOr1D1OSmO3udYMCpa9pIDlyB6M/9eAQEacPmMRyEMCGfPKqUUkj4hkzIuhqOaI2dK9mCMtl+IpyXpgcpvCZ+4fBe5R5P3OXsrsxmobSGmEoo7PDPcZssr9cHJI3E+Rc/+ROS7jH+SxZ8VBCkrLVZTAMHiT3IBVoN3DBxownti9CjSxm/5G7In3nby/snhqV5AfqCm+U3TIM85DHh94Qebw9oTL6+T3updJMiU4z4UnG9mpFFW1obmHkWqx+6ZARZlRWhh+Jdm2VJTjaNNY0wqNyGR10AwfqsHUajWY2qEGqcwRP4hZ0uMs4S/Onc8yTRAtN2VDVQ1gu3Ez49ZxQxWgkh19jLMEMdh1GBwkL5G4yKtLZ5KM/L+85CEz8crMWG01x/K3DBXAPrX7xBFk+7pfR/pR4LZlR+7sSPqATx9miPUhf/uvWJIdEnLDvqcsTq6dFz903HJ5QCMCqwQNPcxwifa7E1AnKKNsbINaZGQ54pY/slvxA2Inu/vnG91okgMFaetmppa03BioKlT2bIheVdZO/C1zIjLF2FxV1UBpNBD66hAh4jQ97tvwNshc/0vx1MRfy6nAhRd825S31MhgicuGLma+ARpuBlQNOsQc2cE7OhyCkK/FL/ibXYSrfPOJ0lLVg5rAQPrhcAHzM0opwj85kP9b2v5fveRjencexyn7zGFVwLrQQOKL0ULQ++TaowfdD1cl58XbHgBeaTWQ7Hx40GuhZOj+zBqyvfhGDFO8y5UzlKuNxDUdpWMq19k8TQt3VUKE43FJDq0hfBkGj4xD0622Etl4Nn8PLbLdWay5ZrerrUQ2nngJZrKLTMMn9leY+u5RFHG29MQDPL//nzA9lm2LB4ez8+A+zNjfp2NVK/btb5S+vO6mQY2iI777+BUqb+0FYdK7l7/x4M4LxO+8dfiKJfFfTnweiL8W3CT+y7UXBCxPW9jZq6pbe3U2UbF+6ObBvcO0uDWxUM2SBxazi3DpZNuCPzqP7ANjwYI5fPlQ6Fh7l6qC7e6JQrt23jP4BqOlhaGFqvV9m4h87ASi/QM7k4JMqZqEVXVq64NCkVruEFQhWoa2UYUCRyZl/sqCbJuXexWcePf3jIt/8tp3kvuQr/MEjZ3dlKyNvXqjULC97h90BCkB0EZH8E78j8/4Rye+ddaRYMTNNgjlxjmM8mTYXZ2U2dYefXFMtnbfOahilEY+tXGuFYa+4LNdxXZ1UuZbe/TFMePafeegwzggFbNQxRzXvcn/7Db8H3HfP1QDYfmpCW09lHMUdnVEoVm7bhh8c9FewTGplUatZHJwPs0I+Qdxp74t0pX4YngC7Y5upFJ2rm/ZGNt4CJ9uwzPvOfdiPoVJFvr6xJ6Tr7lKtXWo6tSufiiUasfdgjpFWRg4VSqXy7UX//SZLdOyqrnSUlWOmsCgqib6wULU7T70czBCzPkNW4cJU0BXm6qk1yXGoV4bL2R9aDXrSJOhG1n/mCTRcSZV6jorrcQ4Mns+nSCGPOe2Uq3tVz+8c3wZzLx2Am/50cmWEqq4N/cwDn0wegh+32rwRyObuD8Og4AtE+bmbVXgNSIiHRPpk4FNpOcfF0lxtkJJOWgmwlERPrWK8MKX/d1T0xdhOzGO6kQJu/yVSoPirIB2YhwT43OrGLei8N87Uo8qA3Y2twl9L75xnmpVXtVWAhxVctzhoU2Ay9sgnr+Oco2IUMeFOmY3Jq/FUeSLyF7i+a2jakWdHI3bUqSprqPpYZQKNN4DqAwjcmzsVAVXPMYzHq5bdKGlCykD5V12XxvWocv8AyeK/Jczj/lufM3D53xTDWxU8vw1sm4D3zhQlfDRgHwfXPXq8wefPfMbdp+RXV6ci/FXqYbt3Q9M1gYHaO6P7U7+Qg6yF5eXagim2mqCWX5zgKlgsQEOx9FK3JiVeFrx1t/YttXcDVVkjLehjBI6G1ShpT/H6k77qehSLhLJTTcnTuJcO+Kr1MUhKDLHjy5HCKmmbeSDQ2uo/hwzfsTVM540IqKaihSbQHXluh7w2DQTzQiWeCZW2Oirp+B39gLNc6WVWEbgRePa0pk/9GuHO3mtwuwTjNYpjaaE6soxwTDHhOJ0WOH14uyzGqHbNJlgfd8WWioXZgi4S87E46rBC5oJ4MpdMdJ36CP1gy/lx+2kLruszek2rW/G8Tt7EMrQoCdMx76MBuhpzhqPshseX2TUVaDWColtHHl4Q/Rse/Gf4ge4m0WzTxJrxXPWy40JYhDdzTGMGXq878vUs4jx5KVmvBvEBDeCrFHUfkl8FLjFnpLnhIkxiXEBz1vXRe+NN/U0z4tpuC1QPSipejC2Ujt4GCa1l4DSaJbpJ973DXjPreQ969gwZzV5tkrc75tBMrKS+zQ42tsP2qcvaQhaDZlhfDNsUqBFa1qkprgsTlcO16UPakRG+EH1YcIFJyqx3x9Ywne+IPg5kP+G6u7UJUQ3nuVUlFFMLeDyk1oYIjUoO5aMtaWLqdsHv+JhGn14we+ObAcKGadzi1HWc9Azjtgl+SmEm+uUDCfWQF58VvY7bJsIa4olmsH05iN+96Q6VMg5nfqOPGKi5fxYTsnOgxbcNT2IekwrpFOLqEfsmP8kys11zcd9i0DfXCmZX9VGwhtVRXx8bOelUt31+v42/G2RLW7LJPTce4GtiuOiE5qykt88ariET5tCJ2ihZ/dO6idZ5dTiTM248NrrAtVn18vfjH6ZaOItnRKAUgVg85vpgf5GQFWg2oVTrKrwNb4NTy4vz1T7X2utKoFWaJb9140aQk9eDyr7LwcZxl7CMmN34LhuuT0pd+i314pLrzZ326lvHSIogD+mWkNzxHhztg4fWfH4vaIwLWxUNmtoZEbRrhkxRJ7cmCFi5PPI2bHSWAlKqoJ6aLIuNwr/htFDFRhRpBJbNti+arB2Ilkp8TbM9icpxl8jIvhx5ogd2oi+PLn22YsTgaCmhCgUEfoo0R/1cU9nr+6+smUCXH5NO5je6sSmTXM1Q4cKQKdh9VGbfmf5AKe7oE1x+esis6x+bbiQd6pUgyvdjLPvKYuT4n1/zb147QgA1l5czbxR2s+cZRJyzVS3qVe3VaD9DoDo/fCQJrr/1cNVTH2XCghSU3YbFk1V7OsSQp1OwOg6515cZxy0gVrsUGQG5fVxQsLJeUcVuGechzw+yJ96UUxFNuVHZMBW5agMnbD7R2a0DBigfvhjxhzL+RmqHZ+iw/xYDEWMT3rcWfnfLKNLz35z1yaFaP8LI7Wk9X6BKe98/t909Awu1cmTtaIMiF+5Ez38cSGzdrcKoxdVFaS5R7edo/3uAHx7kKM0Q+go7VSDFUt+D8Kn3DJeiqcpv0td5NLKSQVQ1iDGogMP3urBF/+fbD9luG+ubhdVykHzm8H9OfgmlafKd7XpBxHXDw7QPCKaR7bArEWZQCbPpLMgZ+/kDOLb8BsLqgBvGoyBtxwMBJfy5EeTOWJ0hW98LG/kWcgXL0HiPP8un4DqPOs7ENrmoz3H4l7ks6R8wbA6zfvLSx6OQ/Ewn3N3I0NZyYXZtnQ6RLjfACHiM6tjguA0mil6ujNZ0XDLxE0pD/hlCUh5392TtAGZNowHlmmD8FxunKd2PWjr03EH52fqAKpt3X3LfB7B+E4lIA2wKV9sbJkG3ItnkK+r5ydqHzu+r57XqpcT/7QNEMsr4DxwmXrOh9JIqCPd9jezDPU4kdh59y9N2QCNHUgFcKrA5NBWFbgI86J558GZBEynBPUupAY402IOh5apQWuP+rbAlo6kEmi3CPYnqLTCLSt0e/EJKM+9bTECZ1dbjHtE5+X0sQKbbXGoU6s0E7pUctIQD4TFuRuyDpffZEBRlq9Qqo6BdgxORj5mCD6VErYWfDjvrLYR8IidlCkuL4XFjHvi+/5mN87TdpE041xpqcJeExiQU9MyUkD5D9ZYwpJOM7IH8CYhOM6vsY8ZTvt7g48rpm4T/eJmbxNjVOhrImIdXe2Zvj2sr1hyxFe3LxHcP11pJcLRncB9aBXhi6XjO1wDuSogztFxPkPM+Q2LUz+pOex/ytqPDY76RmYg6tvhQs6p1nv/0BLOT7YS9yYfocJ6k9y4OMxb0450T5MVFn0jaQ6/bOVk2XF5MCNLeC9LP7O71POT03WUvOTi/KwLXVH3lq6kBdjytqa4khkf8+qerFr88yqS9zpXh6u1l7SUQW0QG+DmtA8com93idNBH9UG7l3Ml/ITFrFsm1IhBCcbNPYxwuj/DP5RZbH3Z1YZ/ha5Tg8aupEqYFSF4dgqVVix5MRz/ydML5kTgMi9KiDcMeI+mtuG+5GfPdjEe6wtx6oSAh4j8JOJbcBfhi7zr7IV2A8vv7MXQL1O/Gbomz3HxVXA3S4fX1afqeGuNJJ9x4j5fGAV5lxGaLgmVKnMZNt7kSJgTLA8xJavICORxbItLLq0bTFkUaoYC8SWDjTAtQIlC6HmDQW4CVuWLSq/QGAExsroIMoTQnmKmeVfN5dXaRKlijnWyQxYNn0HnrGskk4PMbO8vYRVrMki05HunaV4kd1GufF/4XvLHGXQVuVZIzLAKNcHCesC2G2Z+7jiHfc8XJ+Kb/RYEcbbXiuBPLXZCOOsDg1a5zFtsEAWr2DRsR8G7IivymzzSos6+wMCQ4IY6gAh0HQQWB870Ut5tfiuVP2vthHHOAIZExs4lgvgrg7mqoCIxnFE46EtvoZmpzKUENM4mMaVuOqHq3yTTj0vW5OD3eEARj4QyOvU6qDFECWqwltYAe9hZYyBfUtMqchsV1F9crzkLOQfnGT5kDFbbaiyC9uNYBiMDsCcnVhDBWRR+b1Lb+34v8UX3rfNAQ3VNnBSAxQZ4vmqg4QmmqjG5fi2lFnbXTDW8HKxe5ddo5OnLIe+ylc7/NWepATI/BlrtIAFjfWSNSLiHBnnc1s49+Ijzp2XD+n9PeN1F14jJNaRJekNbWE94izi4VI8u3r9NZ2MSMdF+mxsH+nZquN50AZ8rQtxjy0vCtfyuzxvcOEVJ26eeLFz5zO3bFQqJ2tkBqxgVsYHc6/HdtcOHOHl+DRoxFgjIooNXoxHbI1XLNERDJqNcDDenF9Uk0bTXeniXFQxPPFc+V8h/8b4L19lUkneBI98Bc0dJbhhVHBhnkrQT1DgG7MkjS5f4u9+sXJTXqqrNNXWToOrjAdC+4bzOHMrxhu/xUULbsIcfiLIqbFbExC++TEpCQ9fjNzaMkTB74oFjIvHcx6chb4r3rG576s2qg5wXdZpljUjhESTF2x8Gfeq3Vos/rjYlDCVF8dhcO+tYPVSVfJmDHvBPXeEWUuXScpZFWWN5B9Y52KUkGXKuzY+RqxleXtZd4nLVgN8iven1lyXeDDFA+51GCfibsRbdsuWGr5VQfcJrgwMQjwniHHN6xSIyxmcjmOdjFA2fo6HxCBXIr4Zycfba80eWb20k8t0uuFBkodWr9CNUQKMZ2XjTaFFNYmbIAmvJbfi/ZcXnS9jEtsWEJJQBR2PqqkDgwRTydDBACnBvxYB1W2zxoto7dRhZ+J9uEZTzHmA1ipDXHVrHmSfMeXQm87yly+JeMLxly+NGeRCrG6E1e557TDL+w5RpXvYp0N8xmjgdtkuvLn8hbfci5SDq6qNncd71yAB4IcE+AQN4MlLJETZ/1aYToPb2FWA3rR0nmbNiADAlHjcG89wEyw80EV6d+KpZWbUViIZhSnGRrKE1T0Wv198rbh7AoAS6jK4UOJcXv9kkMVvS8RnP0+/ew3KTUMDVA/JwVB36E2NhzoNHpwoeukFopW5vZAjorpxbNBYU3YcNqyL031R4VwbE8SYKgFgw5gz8e0uIobVAUGAqej+EBnAyzAI2DK54sdZ6iIikhtGBpAekGsxRob01zgMeuIRi2cnuOpFRbokIrR3jBBOCglxbG6HtwrEtyMiWh0QBJjKBWAD2FmJ+7HC5XDUxgRdDfKesWHsenHiibuLiGI4JGiL+wQxMoj/t/i6IHay24sIZN2woEWmo1TG6OIZaZCgimJUxgPxpXgyNlscOIn3yHpF/gKi5ev6sGBsmWzxEN3S9fKBLb8xd7F0fIefB1GKKimjdXwQb8rcRxeEW0chRwU0GBGc+lHKHDaE48xwXYgpPyKK64OCtpj2aWMD+c4PV/nT9r07Ln4ODpR1w4KTQFocGaKFGRnEdXjJpRijhffOCxAa4s2oIMrkVGCzwyseptGHF0SmGIwITvAIYeS5cGtZGx5vIpwyPAg3BeBGCOFGBnMTvLTShy4Dbpkt7WIKH8MhQQ+ZUoewuRfiX+Ns6SDLHNKMCtpjWqxGlzj0IDAVNGHKHQJDgvaYPGJsEYt7cYvPPI5qOa82JmiL/3/23m27bZxZF32VOea63Wx1ks5p3jmWnbjbTtyW0/nX2mMPD4iEJMQ8BQBlq9fLb5xIghQlUbJki2BddIcskBDx+SNYKNQB3OrdUytCzPEVihdOaRX1QdXnY0je4toiLyX+vUMUtodT96mAxZ1rygQTfx2f3+BQrYROHXOsXzO6OrXBw8KdeVn+vaZUr+1V8qlBY/STeGxU4XchOPrch61GWM+8DPZld5IhLhNgY0YMltBK5vz8vINk3y43xiuY21+/d5n67Jf4YezNESVoHGIvJBGx1JgAS1jEcFm9KtVySwdfhrWjr78KkCbmjzcuvwlkKv6A9qSfoof4dEbCSr7yqrSLnK+Os85yMHq/6hXLHxDhV+KvJzr5Fo94IPGx6L6iGXjvoKLzqj8qfs3Rz139fp3L3yvwZ339/rXLk72K9BNarb3hqWpkDxFHSxXrc2EXJ/flkdbJvsdQmg6XsX/rJN3v7mY4TDFVJdVQTDj5F5/NxT26xn1VVOH9UkunyL923PUXAHagXjlP/ohIKR6O9SZUflbZibKFnWW7PdA60cH50E2LJaY0oWygQfUilHosS2VGjlK5+Y/N9P8cbVHmHcdXJ/punl3OVG12ZtN1jGN/FiF6zwa/MkwXnpjkJgmNUOzjAcM48AKhmiuCj8QZDm5QLKC3uV6XHzntW4+4XiH0Q68p/84d9X0Lzst16WddqzyhNumXGoD1LrJeZ9bqHe3lmWT4GLFahfOq/Oh1+GemvVM1SP/40A/qSwCI9jX8TV1Y2iqX7JTdJ33TaOvkfwf2yv/y3r5+22v+L2L/kzyrvAO2EN6DHoQvvXvf55eAZvGn4i77RVhqgJehBy/D+1f9eBmWJD3Qi1aPuf4ivAft6L+8Vx/gVdB/vZE/w1HFo6EuhxejRy/GH6/hxVARWdWvhCWC12Hr1yEQT0aTRSfd3N7Al+J/AjzBlOJgaUG91AAvR2/8P+FL0Z8FNrwYW7wYb9+5+GKECWdeMvGoyWvABuOMhAGmXU/a0HKMdaJDfYEPLnoRzbIp9pha+9rH1pyfCv7xEfm3srNcEXZprt803jrtIar93UcXp/fNvJ/iJdZbIuC8y5x//851zustJOyQMtM8ujq3IZDxretqjK2nP4hBVKbwQtDVCXy1hg7ZW52ftW1qXyUBDm1qF4Lu+DYfktiu+DQ7lGSkBavd00Vgwl5jO/zYJ2VEcvl/vQZ29yYJWtdVbeZTknKZcH2CspB7AmL8qKh8TQmL0Km61CZ0XX6UqsiqYVUZ/Me7V73WO7ruTr+avEJCYnz2yLEYTBLXNvjrTUe6UDwsiZ3K5fHKWSZPMS+4Kj/q+JHX7NVNzcDorjO661syUqn8zkko/tiII2W4+GQpyhOCq6lUC8GRUnfteOr8BcX4D7fpG9Utc1HdMvdk+u5THQbywuRrsZdmMScRHuZtNTe/pTbgtAMT8u9d5DQKUCr+Ol5IxjJ1rfy768RYOqohieeY8iEl4p8zKa8EODS2HpN6sW50NQZD9ov37vE3QukK7i63AG9BmTga4hK2grdLDUDbrrpCv3KEtvpQ50vkwfJ+RkV4PJsZ60ZSJevbfjtPvH7nHlFvyyKEy4RtbATido+4790j7iUZj36Ff8vYOllDzaZtQxOQtnvpN1+5SlprWl2mba0RiNs54n784B5xtSuOZuiJvnLZU2epGcjbQQfhThYV35q952KKTejiUy3J8eYrgdPd4/QHt2ZkL04CvIHY7UjdEULnA66Zzj7ujdVbphw7Tq/K7k/VeTmd1YS9Svz7dtTOr+zEfN1UZ+dtvz2GX3czVKnhj6x3h6XbZLEVh/3wdpHi+j6cJT7y3YzKmGrTMmQx+ug0cxHFwWkSZlEsycoaSNxwBfC5y6HQr90k9BTzFURebgECd9mj5w83CUziCaYlUSv+EctNQOEu6xQfHKbwt/FP7PNGClebgMKdjp176yaHv8f4MRUsxYHk6ZKr2ormo7ZM7J/JzliTX792xOy2vLy7SR5qyzkjgXm3y/OuM64Uy4w9odMaY40EGNtlxr5/7daO3QMeL+1s/MDjdnt2jRd2YdtOj7q2rfE77Np1UH3gzDPZmZj6CytGMKwmDKnVKnbXhTahm9qOh8Mthlel8YcP73qtBXfSoNaKxGQNickaEh+DovFsNHYqXvmNC1ye4TDFJmguiUgljiM/P2aqls9fZehHKBbixmR7bvA8RaH2yrQFNlvr8uPVEmpDqk+tr0BDcI60kxWknawg7TFOtQehrVvl+VzgrlT4tDeOLu6uwj2rskqw53LT8c68y2Oraw2/93ryfe8qgflqAvPVBD7GWfhQFIal2bHx+Fr8iSPMTUq04qxi7rWFxzvt2iOpqQ0f//h/IMG1U0RNm4iaNhH1GKfX/VPVKQ33nSsKgp1t0jqva7aW+Li12lWZJT98hHA3FzbOTsXz8rpWWxfa7G1qO14KNwyvxuP372Bl1vWJt5HE/hoS+2tIfIzaw8FoDIl+j43LP2QRT60/6EObt6XkeKfcYgB1+0G/V2QfXCDnZxxjSvzqwqwutAnb1Ha81G0YXn034k2vSfzOWRJP15B4uobEx6gtHIzGLmkLb5zQfK8wnyWBrpmsDitFkwvJ8U65xQDqDP3Y76R9jpEzWiJntETOY5xK90xPlybQt05otMPEP02iSPyW4ml5anO1Kj3eybQymLqB4D24fzlG1qCRrEEjWY9xcj0AXZ3aFPvgNGer1eKBta6w9qPbrH0DrHXRGvC706y9RdNm2poGYC7YsY6JuZyS6CxK+eKSxNVMeMstwF0wIRwTdycC53NCGf+axAVTqwXfV1wATO5uSlJXmXyJ1hO5qR143N3MpK8d5DFhjfStiYG13S3Z6uLqbYr5RRzUjLsVITC2u4x1Yj/iVG7uaI9xeXTBcVRxFbeFR+wjbkZRZyn4K7pG0FUhDQ1tQNeOpcH93S2++mv46q/h61FGL+yVsWA2ODbW/oUXyaRIWFec2ZStCI93brVHUvf4+gD+M24R9R4vvi0RtSI85kl1/1R1KmOzE14I15REhJM5LjhbkdQSNFcbjjhrR21U9cDytzDRdj6IEYfhX3J6Gy2icaJT1dVklbDG5aYjjm9cGls90PENENhFAj+sJvDDagIfo+5wKAq7VR3KiYSh4m+qs9tKTthZbc35EWez1Y9e121/h7gwZ0g5qZFyUiPlUWar3SctwRHx2Lj5VVCRidalTJ9NDTZ3V7Uf7wS7Yqj15dhryI/kLKnjvMFmckV4zFPxQQnsVEyOG/mXMzG4whKmzuoeBxXhESdWtEZSZ2u/txneOkrUurm2IgSido+or1+7x1TexFTexNSjTGC/d646tTr74Chf6yoAb1IBgK+dS+bpxPx6QilajFKKkU6DZJ3bnK2Jj1cfqI6n7s/1Gva9XCMsaiYsaibsMU6zh6CsU/tcTtS0yWvIFbqBLWiq5nj8a6/akOobDmCWdY+0kxWknawg7TFXc9wrbZ1aiTmxh3v2mCZUByrqQ5uvpeR4p9diAHWVoN92rXeOkTNKgizEyxSty495St0zVZ3a2Xrjyv5s8A8KM1y4GujTuoNBKT1ut4JiMHXDFtQgd42scSNZ40ayHqsTwZ7p6pR5wImVlmLEBPmassVZfe9gqeF4Z1l7RPU11ltIXOAoYVf4Hq5qB/pCIoNj4C/ZwF+ygb/HqDfsn8GQ2ODYWKzUQruisy2wCVyXH+/EWxtSPe5rf7sKUNT5iHgrjfEnjGFan3mXGoC53dQa3DEtFLthxdmSFez4N2/tkdSNCr+DDcwtosZNRI2biHq0BrC9UtWpDQYn+Mq4ZAuZLBRfR/nZt1SiXKmv0NR2vNOsPa66QvAO9nHdom1xZvO1IjzmaXb/VIVsG8fGVz15XhLxF0NhoR4sSZfn21rj8U64TSOsKw3vIYKxB0Re2vJtbgUqd9io8NFdLjNbuqxQWA3HrFQcjsNOedw6EUv2PbZdxYszm7sV4fHOvPZI6qowOIg5RtSsiahZ3JFohv1T1akgXSf4ek2TFFO+MAmW9Uk1t3IpO+a0ysUw6irAO8iZ6BRJ0waSpg0kPcYZde80daog7kdngsgLBaA4W8p4cPyaqj2SevANZPl2jKgqqcFSloNO5DfYK0Wd2ldwKJ7xnCZRNRXtclhjQ9Oxh+CaYdW5+xG2bx2j7SeBsSAOW2btcguQtov7Be8dnWyD5ok2AL52W4f93UG+6tOTMJSS5aQcVgNwtouKgYtzrJ2Mo07bprbjT9axV+46Vfj+jYP8jZt1hLhZRwDWdo+1Tsy6p4lYZklELT+Ymsymb0PT8aoMy2OrsxjKivaBwA3BuauvADp3OFK35tX13nVK/yB8djrD/v2GeXrV5UD2rs7dbtRu2I7pZ48cxwFrz/XaDcD2zgZQ/N4/tt/SDLenun018LyzljxnVXJ/9ZrSX72mPEazyKE47JRtxIn5+tv4J/Z5QeHytJ4jcrnleKfgyqDq3pZvwMHCWdI2ExbICilNj4asSSNZk0ayHqNqcAC6OuXJ7kbe6KgoJFF4VmpZo9Nl2XTEmXej5mISH/4AfcAhuuYulctsXW4Bsnat+PQHByfXoHliDYCn4Kx2LDy9Us5oy0Sty4GpXYsR/sMxpkYrmBqtYOpRptjfL1fdypfnGmHjZhUgblYBgK4do6sTGutfuIwWNsc2Vy3R8SoA5RjqNH0PDpIuEfR+maD3ywQ9xol03xR1aibt5EQa4HE2VX/bjJNQ0ZPiKJnji9G3oXE+zUm61HBMVF0aSJWh795AffM3jhCUoZhw8i++xYxfJtNKlvymNqBpp2j6vts0FYDiR8VTJTstfPhzitbEx8nOfBR1ekJqxQ9vXOEnQxM8aizdUG8AjnZMF33zzhWSTvHSN94SATG7lvXrrSvEFI+DaJ2aFSGQs2sr+C6pnr9NCZ9l48FDQu8nYfLABsynJOVsgDKeeH6YMOzpa7yAMD9jTJYN++2nXOJnlVqj5vQI+Lr7oKp0BjK/eusElwPMsc+9n8mYeYIAgqmKwLmhvdg8NefPTOHTRICQhKEOWt9M4sbRVJkL6/93HYoez//U+R9YR+zLGcrjaPpbJLmqZZ8Jv0XTiq5Qkx/R9Lt6OFWy7rEK6Za5Do6Ir13KDD7DYSo3c8Yh+hcPxEIqX2PV1ldHwsemx63prWDV7yz9RL8xCzLf1LBbxP6tlEwSGlXzxDQ0vfg2/uqh1DTRfmdFfO8IO0/W0PME+AkBfC/Mz+JMctEm51LD0X3W985Np5bxv7tG0BO2iqFFC1C0SxR9/UdnKZoS45InD+ozpy07OkaaJ6+REfyZ37vBxaVJsiIENnbl691d21CA5S+aj3d+UnNjKmRHR0jr6aukBE52d8XDxN/B1xZLfXhJWMVwWZUeHSmL56/Nkx+Ak+5wUmefWWZlKQdedmdp093VN8XidwIT0CEPq5EcueToyFg8d42MsNHz6k2HyZhixA0Z5WGVjLnkCMlonrtGRoh2e/3aBTJyEuGK/2YhACp2ZwP8bYdtPv59HrN+hdJayLqRHNlWonnmGg0hDWjHGSgP6utpW3aENsf98RB2DI+PjMsL6aoUCNmZmJ/OEjJCqc4uV/02H+eHWT9slX7g3NNt4ol/6x9lS3R0U+D+KOjUBPjaBR4uf48rQuAi2G0Oy8V7vGB5/ixWS551nDYb88S1XFkwH77qLAezmPzKtE+EPrR5WEqOjonFc9eCDX+Hrefu2rFRPNVUvFOHNhVLyfEZss1j19bJUK7tjQNMXCIi8LB7KmJ3P88zFAehZqI+rPt0V6VHx8ni+aukhD0+hyi55NpdEwMpIfD/0KT0k9g3LhD6sFYJ2D9Sf5ziuatUhD2WDvuGTULEOY4VGR9odaMlPz86IpYPXWUiaI8fnCCiOba5aImAjhCB9bx8PF/m4/kyH49kI3q/bHSmNGR3P9ERpsa+o44qe4C54Pj2/8xD1+w7kBnyfYd3ozklOvvunT6u2LxL0RFuRpsnr7ER9l9eOUHHZTYCGbto+u6utphEhHctlMA8c42Gr8FnsdsMlAd1r0VbdnQT4j55CKEEx0fGZdfFqhQICaEEB/cc4yRkA75IMRvI2komaYQ+rCS7LSRH9rVuHEHNn+xVr7/dXQxElWMRfz+5tTYhU+1gexKgVPytzsTPVeqC1eVHQ9DlQdR4+QZ46QAvdY0Aw8JT1bBcUGGpeW9fdxJPKGICSJ9nFNtsbWh5OdY6Vl6hk0po/qeVFV74MRdcan7gmnsFuPp0eQZVFdyt+fOTPP+WSmTZ8vRZbz1CjuYDqs2Wr2G2/C/v/e9uMFVIMo6bWLrU0kuGdtU76A8n6ImC4OyR41gWHzxPaFR1oGxuBZp2yLP3tSs0HeIJykL+LeNDQmskXWoDinZpWeSGToofsS++52dMKZ42Q5dbgJ9dCvJ+5wQ/x3VajnvNxg7bkd58cIKQYTIdcUT50ny51ADTZYfY+Ycb7JziBl2zIgRWdil6wiVWnss//xItcynwskt1Gd67wstrmkg3JGkwkn83ViNoUzMwtUv51rpskE/DbEpiNuDMv1aHZkkkEwLcLlI8xBMSkyUb/coLjpC5TUOsbX9C6ZFOhpevJ7GYWzVBUxwHOPYX18i/F519lRyuzsFrrwNKd9U+9dEBTlOchsjHPwifWdy+0dJIPIFN5Zr46Lz31g2qxt8/wJ/PSeaiNA0XFk8rakVj4xHPvwfjMUQjHxeX42REAnw2EU/FmcXmBrnN5xXNR8zo5oHWOA3ZmF69dmKCZkk4x9eIz2xO37Jlx2tbdsRaRcN4atTtd4aSP9xlrS1e5m9z69HHDRye2U5Nyh8coLf4i4aePlHHFsUvExScIn9WsV5UhEc7Na8cVc2c3O9V33u3+XsuTsUtlRRnpQi422nufnSfu/q0IWKhsRH43Gk+u65MaDe/iyhNqHSQEH/O5UixeusR2y0OS2rHHCXfOj5ZM8wvYulUIefikzhYsYm94TJguwvG51duUz2Jb7RtoJL7yBYCjZ2IBfrddR5LQ0aVxLkEGOzEjslbBxksr0kRn9km6Aa7c8dYbI2qZmSGBLKvXGfxz6S6h52fA38hz00X+JsiyipzcCEABkNRti4weIwYjmtOyrYMeAypbjtB5IDQOo8tEdAYigl3gsaxzPAUkn9x1bXTEgKVoTjIMVN5wkwmHsI4q1fMrko7RuVJQ1Ldj70n8hu3eRzKP1idxhUhsBgCR46dxU0kBg67NhP/7jaJKUaBWNPVeVwTA5VdoPIfvaByA42Bwq5Q+IP7FJbZrpqmY1sOZHaAzH+8dp/MIYnvm8hsy4HMLpD5nfNkDqXZtYHMFTmQ2QUfC8cXff4sSoI6kytCoLELNHZ+wSe5uzwj21IgsgtEdly5iO4bTHAVIdDYBRq7br2ImizJEdDYLRq/c31LJFrmMBDYJQI7bnjL4iazW1UKRHaByI4v8B4Q92f1miAVIdDYBRq/c30+biRyTQxUdoHKH3owIy/NxkBfVzw2f3ffZbPurgnkdYW8rs69Pl2kPNG2CRQLjL9/vxhW7BMVacfIXIyuRmgogPOmL3yW+TeXbG5LLcBriAvpCq91bskviM2Ws3LmUuCzQ6XLe6B71Nlc5/HRJ0reP4tdSZb82tUdkXE2mWDqsQiFoSLxJyU4zXHPuVwTd4rStTHWiN3vgjnve0NsxiXDbhPN5KqRo97SMc3jEAR3yq/o1Zu+sFzm977BKLjCfJYElSm8oQl47lzm+z8+9IXqWnCdhAt5yTDB7GvCLyQs9arBm6+EF8GtCf/jx768BUKNxJR/F5B+OKEULSrVhhvagOmO+Zq+6RnTxcCmMQ4aeG61AMsdY3nP5vOvWTSuLlLrcmC4Wwx/1TOGS0JNmyhuNQDHHQsreN8vjn+SD8mWKV7KgeFuMfzN234xfKRM58sML+XAcMcialxlOJ6LX9ZesJeEcRxXlRNb1qndz2JcNS5/6Hf1Y/dZfCYPzyLCa6WP63Jgc+fZ7KoNMONEaxspTSLCyKRi3q4IO6ZnmJHVKlS8hppBrjNZdE+xb3aXi6JBthCY7AaT37pOZXFBin1e9TEpREBjN0oGuapbcL7QLGZIHFZIXEg6xmE9pBqFX8FM7CiDA+yTCIWWUW6oJTaZLVGnFnr1wdXWe+9hvdcRRt/luN7JqK+EsbsQxdNMXmjHytxeXd5iMdqaEvz9618lSz8cYM61RDlNyyeuku7jc9l/xZ/WZl3R0kC8/16GtELC//5f5+cfP/z++39vYuLrV28+riajaV3BRzspgp5JnoeOO/NQdri4SxNS9RO9yWJOInwmW4GEW5CwhmeNga9ffXx3/mYjA9+/Ws0/1eYK+zhm/A7nJMvJdyuk51ScPCT0Hti3BfuqeNbI98fpyfnbzdPfmw9vVrNPN3aPfv+f+qn4nomz//f//neJWIr8e3GR0MRCIvofMOoPqJ78BvK3B5jShN7gOMCSN4Nv459iVX9OcBgoPdM6l8hyRKeY79LxuSwyzDkO9Iax6rwm++8632WWYP2fInsiftOg89vvchsAB1N8xxepXstFaUK19viAyXRW/pUiRO+T+V0h/d28WfGEBDhWOP3+2wf950zCTK1lVFIy/bKod/s5EUUBSsXr5Y2x3Ljx2C/BCfxG/ZB46LnQmcUTqr7+QWGGAbatOlaYdRk9NUKpPk/E6zNIaSKBGehAJjWu0yKmqRmlagd3IRkraYrkN0kwTm8qilu/0dsZTR66STD5rWCDCEcJXQzupNFPLDURR2PENEwM8yy9Uu3yizw0batwk481VdCFCQpO1ek5VXlZdH/LYgBO9BqRKRV0NNNXFKE4YIPheEiTVFsy1CFAtRqq64zNDFTyEKBa36vVB6Gq64qkY/D9yjBdeGK2jj38iP2MJ1TxQ6iKvvyciaGEYv5P9EhvtfQ0F65Ab1OnRH9zxReB4VGK4osAUNsONdkl7hxslbcKv8b5KyX0KV2dxZh+G8DJV4RMz15Cn1C35qqE80DskIJTrDBF93lOty6jI5Yo8nuFJQc8/ZoQGaM345oOYm2PH41ThFjU42u0kNrSCiq17y2lhEXob3nJhbkCoFzu3ptKf1Yk5ivvp+7ldnSqf/haIahPVK+2ALDcCsv8AHBsgaO6kfmUpFxuAU5QFnKv7MgV+PLNcRQOKBZLbnF4JRASI/UYlitujr3pzEPqIn3PXeTxxIu9qySeJsNPVhLF/1wnov0H4bPXp+J0mlCCmbmsjZ5sPUz+PbOeaeDPsH9/MTmLUuMwYQu6a2W6u9Ow3ikdRa6wJNR3d+aLLeRm3TUc6297frbZEmB4K1cWeuVvXoKaFLDrwwq3ipd8GtE0E4qiXBtI8SYVuo8f68OD5thXeU+A9eTzK7UXvUjw6kQZREmcUJyKT20WhhpIlKZ6RQ9v65GC6qyOfVBA3X3b873S4JVWyF55M87NxsKrL+LwRm/R44t4kqzAKKBkLrrIu9KasexN7RzqvtQlJ/qKMynuIU7t96XFnafi4aL4VhK2x1CZPgCeZnhCMhYsAoie9LJFKD3pnIH98C9Z72GRG1WYMx+FGPBp6EM8IkHBGLBp6CPGSQzANJGGrfhgwXQzBVi2UnF6D00r1eamc/6Hz6La9BuW9Z/unmOz5gvVb2TWTsX9hqZhKlbGL+2opNHi2gjWd+uX6QPgabfqBJw2f8IAow2rUABo07ceEFq7KgV4VsAD+LRVGV2CaI0vSZ6gLndHBDeIF8KtB35Lu2HmuuuSZ6KX644IbBAm03xz9AozZrLArCbXyo5sjG4yxs8KR4fGlm7CuPRqyQcKRmI6H2ckDC4KxpSnt2wFoJx56ioZvSO7+kHFOlkjpg8BoqUueVOXw/FZnEXMOPuqY5lvHeBr16Ub8NXfpu+xuFE6eqhxFWct30V56Sct0NGc5XmvcXFjjrJcJNWrIG2UJgbJhFqWnnuWtl7qA6C7Hg2czjrvHghKdzVd5s9whDyZbox5MlYQ0yK1yo2MSRPfPHWJTKPCivQqy02rQojX9N/Uca1HBzIdMEznYtAzLMfOysQEN1h3ckkiwpnMVPNFX7JjMHaRNYj8iysnOhVRIu575IBpq/4nKh+aeNUzHWhX/sLQSADIrYBkOQ91JhNxBgDubCj4B4UkUCwszQXfUnkOc2abHGs/WRIXycIAuOYkMozTTH5stFFQ9n3iczLHJkXPFxV3DAiuQdBOw6PfZ8JUinakgATsNkyGlQSSGsDc7gqwbfMR1tiVMXRCD5QcVB8P2auVjLjLpr+6mTM/KGxR4liZoyz27MV8agsAxB2NqAAiGPKPgoiA4W48bNpkAQC3AFD2F6gUeiWKpazjOyinSRwQnfKq2EepyXq/y7Q/jLq+42TluPK0cX91Dqzcf/furpLFWMWtxzFWedbWOJjV0qVqh7JTisXjc4JM3tSMktvEEnZzm2RCHnkm7hyYiQhvsfmh1xD5jRfxeVK8gHVhR70U6/7y1rka5k0ShmNxU+GI0/MEJvvAq2WE/EQWmxAvYJGHAiBbGRgOWLWNiAakVruhA1QboXI8H8w+oXIwL8wzfv0AJ8fzxDyHWgAAOZ035vDaEsDjdh6ZQ37QAjwRC2AcWBn0h0YEaPUl5cMBFEqACVJAHErBBKx6nBLiMAonINXbFBGHsNEBTn1PGVGpri29mq9pwhMxFulSSFBI/sV/CqnxKcjj+kfikUMyITi4llEibPfyiQH2SYRCj4n/aZ+IoZYApFv5gXyWAuIzsXpkcqu67HiSl1kHNFu7dgGau6NZlDP5XtSFlhXpQtvhBlDcB4qRFACKT0TRPMYwbwNA2wZUqN/BjxzH0n4pi7WLu4KzQiD9X03N9uUGgHkrmNW7PjiX8+YNnqge85ML0TGgubFEZen6Z5e89C3nSNmsemf3JAVEt+Lnxt+RsC6J3Ul/FiMZkOfpE8i195LA9SDZ3o6gOZyDZDmzBUfTSkXzHCW9eXiV+PdWQot2yTLqXYreVMOtkANg7QB7IHym9cG/AbrtoesqaKvsVsWsLdP7lM1iMSEVXlbkWMiRzIVbmseKn/lsIg3M30P1XZMBsjt9dnuA7I5D3oKnQRTpxd3w6upcJ8gA0DZ1DaDtwLRlE3feJfFzGaC4/UaBCyha4XpSlfFmKA5CfI1i4m9aaDTlrKnfbp33GBvZV0Ao9gWdFqfyyXRiGhJPMB1WG3oOk84Aab+1ZZ7HzqoWgBAgdGQTNU80HkwCIm41O2TL4l4hZW8iXOljvauljx1ZLuYh+JbtdIjjRUisuhGrFSMcTwUv8tyTJdiqH8QYpvwrnndfL38aWE3vnAUOgLUJrBTxmUlux2e3yXXCyCO8f41JX+MsVOlezI4m5qehoNZXFMGEtTZLro0UQLfxjQS4NjFtqTtljy3dZioJcAJpgZXQXaE07fsXYBsA9VgBvTbdcWknzTNc2Zu+Ug6gNdn5ALSNoA1yt3+VRk6vkJIgC/G5SuAPEK3dpKs4reQngFl7Rx/AbHvMbrQSDKradllby7SqQgLArc2NDMBtxzhjFAqCa4pRNDY+Gtb5bTJSD9fF+lbPiuEDYlHJuh/iTEImVgYdNV6XPqBFEtYoCznx7Ppog7ks7OP5GeNJ5CUZTzM+kLZtcEc+PkgdclR+NjidLxjesJPCKYoZUlmovQjF4mraJCvdTqXDaSVJ8La5hsWTC1xVX8k94LgJx35WXnsZoN0sxvYCWLpfn+1FQHW3ZNuLTazOVXF7uU/UU35SGtlK+ZUWA/IHR94rKz9cxEp7tv4MF2L0av6+xHMcdjcZUWf/JNbf4jRMGA7gb/CSf4MzVbVSHNyK7sTqEv4aL/nXMB8J+CO85B/ha8LPkyyGielF/woy7SAOPtmJB+Hv8AJ/h5H4Kd75j0NjVoixWBXpbBAhGVNksq6A0f8FgOtBDpIdQXPdgD/QxSbxazxI1Vi8OlkGWBYH9jhLUF4CgtNEp0P9O8OZCkXVAj1hLv7OEo7hHT5aiB17218EXufnhdw9MsYPqiBtcdBy3tR/lUkW+zpd3eBOm0IFVkJBukKcEg2VLQCobKhIcJ7Qa5rMSZ78syLpGFh2XKLMHoTigA2G4yFNUlOFXh62DpC14vU6V4Foz1D4M+zff49Zlspx4EDmhhUkedQqzsrWfoMmrtBhwlZWIS24Rnx2EacZ7y9A2gPmTK1lT01XerIWPQxN0XGYfzQmky4GDOwZDbn5ru6TB120UxyMHYT1HA6zA07ie53GQhz0CQxx7hX+P7KH3iLRhyQnABAAdGQz71x7cGJjklAJun4QPpNqnP591e/my/oEpH2ziXEhHkMTzPWiCpGTqVi6K5ik9ifdKeQ6K01IzPsNFBZLTYrzRcLZI8nLFKSIMlzSqYO5BveNVFmjTd/5FeOAnSfiZ3unMy6jMwnR9KxE6JriOcEP57m03+CkVMwztRm8JnOkIohVsAelabhQGcXPatk0uIrHO4mDUxSG6gp5IMsmsm1ddQOM09MwibHMh2oM1JbEtWzbKpF2nv1AV5NavaUkiWtc733ESKydmn2UEq4KpfQanNXdKGOicYgVR+edrSa3f6h+AlS7RAvniV1OplOKp3LqE1OTQ3kR9kQrwOqpvPqMOUDVjlYAVWtWqbldJtYAsDbzCsDaglnwBrYjFeC0nk/zKUDVklIAVVtWnSZZXJvXAbG15ALEWnQjLWRy0+c2uTDbP8O8wtQShN9UAhvAcIv3FCBrflGBdged7ACytm+qRkqukACt9Wjp0pkoXpzEwQ3mGY1L7AC31S8m4LYT35T1/oRO4bVcSy+AqT2bbvCEwUzfjlKAVStefaZJln5awK7QRlYBUltyClBqwydAqQ2XrtFCujYDWG0oBWC1YdZF7IdZgBuWNwDcWpYBcE9j3Pc0AOB2YRwAty3jrtAjbE+24xhA1Z5VJAaoWrIKoGrNKtkBGAI3Mgpgas2m3LYMBpsWnAKw2jELVtdtKAUoteHSCIfY57CS3pZdgNtT+Abr6N34BrhtzbcsguVPS4oBVG1Z1fAegkdSC4oBbttHrxd5EOSBxOmTLFDc1VJaB49gB7i26kZ58Kpu1BGg1EgqQKlNN5/zuuxWOriaDJBr5BcgtyvnTO73IhqSTpUV8c/RMPEBskayAWRPZdkV5rMEAGvPMQBsd4Z9SoIFgLYlywC0Vkx7oCiV9QUw6LQtKAZobZlpD6w6bRPtAVLruykCqsr+ChHg1sgwwG03vmmDtOpnLE2HYKDeQDQAbEuGGc+UEjHVm5ECZs1lSQGzrXmmfQZM6MK3iFjvqBHCS7qScADeYZgnzwC5XWgHyO3KuZGPQkT1BYDgLtwDBJ/MQcBud/YBduu70aVTitgcVce6Fq+jZYBfI/dcxa9aj+5zPn7bv0BXcmosnJmjpW3g1S6uaeJjxqo9GWGPQGoq+KfqrJ3F839QmOGy8louce0V3Lgy37aeURa7W9Fod7AGHDPR20SgI58GhYMYRQIyTz50SHw+kP1xj8SeHD7z5syLZOf6RkAWou0Og9lPwGxXnvXZ/2+f3AMc98zH+paO6lMLhY4nlEG+ABx32BrrPo7sV+hrFxgsMKTIx1IBkS+WGjmJA/z4m9Q4dGlKHR+b+Pe34lKhrXxRS4mVyjTjNJN9q4LOqmNxm+55GiZjpJd6fogR/azOl7oFKLeCkmEOQK4DsqJ849d4EItufzJPF7734oR7kySLg8EdmyGKg0HxO/IAgNyyb4mbbOvyx3owIY88o3LMymp+SRgfRIjEanjyYOdNcEpYhPSJKcpdCgCrClb5AeCU19lmPiUplxW2JyhTloL8leswPMul2eX85M1QHIT4GsXE34RQkwmvfrt13nN80uKWm4zxLiKyypxGcah0Jamje6/ev3771ovIIw48pE3/lh1Nf/n+c8FxxLY02t3pP4L9YwOhSvj3F5OzKOUL3b8l6Bi6nHljHXCt+fJt/NNs3amRlacSvBXY1fvQcR16l0cdAiaDfPlo5u9OriUPgYsV8a866W4GgEOg84MSboDRh92bu9U4zhMaIa3a6cNW3y55d2mmFlf3bvQyy49auFqfMS24RnymIlF6zIhJcWNvANDaiB54ZKMQsV7hgOMpibHakBaacY6I9a7Ygp5PG8XZD8Jnct7oHR7S0KXukwdnlCa055RIqbhCn18mKMDBFWZM3NnrOWSOQiLTnal+8pNuLpbl8GgWcxKJ1WpC8QBL0t/gWGiWJJ4OTihFi9LfqTzdbJXa2K2KVyy7VaeA4hbdagpzHIw4zX2sajLAU3aLApTK3Ykx5vIf9isUS6Q3espL4rlYRInnU11115HvpUhY9thR7LT1M0RcaoIDlPHZgM2SBzWkkThYDU/1zruQjJU0RRRFmOfJJcSt3+jtjOqeOoRNo5/w3Z2yfN7dlc1flMmZlvuHAqqzR+xnHI1DDNuvB0ayN+7cdZuXncEliQhvaSqTvotBYW0rzgCM//mfuN9guGNitjcHr/Sx3mXRxyPMs7QwCra0JfFErwOZdOFAYkGkQVoW9wwr+34NxZlaL55eXmgdoirrMTqaR8a7SMlztbsmA4waMHqQ+zqF6DLx7yckxADVRqhGyj2m90CFhPECE/1trIq6vnTD8ZzQJJaeiIYVOrG3OuztKq6NF9SXqhfURoWAidV/eXdxBsiU8cafCf+SjS8Yy/B3ql2yH5IsDP53kl2Se3ybaFqefMUP6iLArpim4nszOcX3vURFnHvFfCQ76jIklhWxNHhInMxXR+CTpovBT5bEntBnuDIqemnC+FQ6xRaWECYee7Ohsnj9bsV9lpuwsZHgUgwwbtYYmFQyrk0fxvaG6FA8Zy4EFDeSEUB8EojNP3F3Z0w8Qm54Oxxrf+f8rOvarFJEI73brnlzg8192/r/3ErrseXscptbk3uFjwksMZv5+ZaW7FNRNaUJTwQgxms+1W6Yak+LAZfEUQ0TB3BqFUsJ0YUviWPPIoePAMmpC4HDR4CjEwHYDT4g+mMQYCb0OpVv6AY9iK9JFpoQKqulwbvEqG0DP4lSEmLxicrE51goKiQMPX2ijuU1AfZJhEKPif9pTIda4lqGCrnPeIVSM5FJkZEM8YTEJN8RgXRb+4MMkm4dmJINarYVocPEHMG/4rl71Vt3B65J57aAAuDipyR7c7oA+h6x+wnYPZV3YqWnXuTb5MK80sMomuRgqjrDBaI6ZRTguvX7DDDu+moDPZ9hygQY9/KWFyXNZK+A39Y0BPyexr/PNMnSTwtAbmvmAXK7ck5XJaBTgG5r0gF0kAz92UkHyEFi9BfiIaB5EG72tujSARnaG0zrA7djEeVQVZ7DP0fDxP+UBItd9vXc2XU6PFYu7dHtEa2eb39WUpb/yjBdiJEy+RtsfT5061u6KRP66m51WiUWob/lJRfmii4n25UObnpInmFtlPEMheHCw49+mDEyx16S6my7Egnk+zhU2olncrNACvVjBtexnOvPDKy7SdpVB1OTt1iNQgkqidHOHsVXiiiHufBcTKSZCXnYhYf6I6+6PyN81j0viD3jVXYXSA0dW93ZAlcSWimfIma9hzoZlS3xlERnuCqERSbHbdNcscpn5azoeknqQgyP0vQGU224Lx3S4aP8vJg59q3dD14Of0LXqyQFTwaxLF/B2aPnG8bAG3pcUPZESd4LjD15ny0DS6TMM2yQpdKFdxAjLpcXAseI+JZV5btqPpV1YtoFly2XoNHyB0T4uVFXzLEjSN5ZgdUyoH+UEY6tV6+pYcutgDxfQEMKAadIeUgofwKUwEpgZQ9YyYdXV+f5NoQ8BvC2KyggYbN8sAHC7V5l4N+W/NP9pogyfBbPywzuFQmAuLlYik7nYHvdpDq1tk76quOiAcg2bMzN37ZdXNYhGiKO9FNWrOSrLwO4VyW5zDUciT9NWIp9PvqlI+srEkBwc240gHCnz/fKn9BbWXk+dtW5OrbfcwB1S1BNIkTVz0U8SXIdqRCeJxLtbpZ6O3ZsrymeE/xgb+ECwPsEuKs1G7uBK0wK+8KW55IvSMVhBqAfbI9stSexRm3oX64BxojBCuAQ4J6TED5iB0G2k98xe0Uk1Zw80fk/8vjim5Xq3EiuZT0FtpV5is+MVYrPbpPrhJFHx/zMixoT5F9sKJTSJMWUE5lgtfA/RzGiix2dziu/YZ/kFr9CoNzRO5rq9iIm3CS2nbZNsVWtES+u7tHYmV2UymxD5FwTi+0Y+/w26e739Emc8KXzxfeYZal8cBxIGK5p8rjQAK1q7e2bMykqafdk+IWub94caX/WZTqNv01zU88IIhPeajVAHHTUSXpPbwhhfRt/92v5bDd612r27E58VU+dn1IsnoATZN6AvLrCbWK0i4R2sM7sdsDkV8vIeZnUGnuqLqH+RMjl9A912gsMxLdQnMtViodSoqqs67cjmZK4rwgYj2orxvhESOVr44vj4Kq44+T6oo8Y8eQexx4Tc4WQFm/NrZSOtLAXqJgNUu3+lKhUkl5hHAnk4j2SqzjVrjNNdtN2vzM04uMSpbw4IXHuikM6G523DRbOBoHuBgI2RlbxLwwZhgxv9zGD0EI3XjP9nyvLk76ny0aop6Gg7s59+wJZc9FUZ8szwAUd2rtjKA7GyeMgoESsI/M8GyyvZxdjznxkqhkuRxmuu7ssPBkJDfK2e2XW/EraJ5WhKdBlkdRoT/RgR7lh+pomc/F7dH0BprIXdQSQlDWp4mQkLj6bTLDP2bUSqr4b5B2DjbPc0dKEMIsH+WR5XlrnK+aeeg8/ynmrq1aNrf16rhCn5PEqCbJwRZWzcYj+xWJVK68zM5Y8BGxKbDA1S3t11Gtk2nabmlks31uozHX5FHeJxtiVQnncOM3p+f2iyBLwqTj9lha5Q7eIXKz2OxyfxVmkQTXHl4RxwHBt9J27GDZUvdRGWmVSutLVlOX+rh3+dSpHydqnmtL9jtQzSC19FBIT6FSTuZP8x9cbQN/oqUIT0ti8NHY9SDi1O26uJ6pZkw1cGSSKZjbQYjkjWTtWpXA9jMtLNK0CddVu83zQQRGFZ0AWCio8F2dVrv+zRzV6PQVbAsB0J0yXtB9ZlsaSnYaIsWHin2pHccfSwZrM/yZhq8mtEifcmyRZHAzGRHrP3ypY2Q/ELmJxNxXaQLi4JkItMNbPTVdtmz623cOhILjRt90m/1sM/ZP9GNovfd0V8Jc8mr+kCr0wDvUoFvJPQrcRDeqZVjXC3+9o/n58hhm+THykrCBf0Bx/wjgeYUT9mXmy9Zd0fQ8gS0MsDf96B0CeXXActbT/b9hB6C0uTu2LyFywkVj/Ek+HD3kPhM+8vJ50sRcNxpyXBtDZTMR7A89ds44dmFuawYbj6ywMZbAow3QuZ6TCGwLJwm7/4tHflyPVdFGUstyQCKlIX6g7N0Z/eQiQrc0dpcK/r0bi9jIaXJ0Cbs0vKsC2R7pxoa8OxfMBdOugK3u/uzO2a3EsBhAQvRt/W6RsD7D8kIzxVRedOxon9CstHOI0THTUc0XSi+j6gwLTjxDzg0IortCJUyxLapm56iJOMw5wOROuf1BslrP4FuQq08ravqMAnCMh/gdFJyBUBTovrJANEk8wHVYbADN3ciY88zwVJigY2VKAC+ACuA4NV78z1u8RVrsrc719LwBTsg2L9SAtUpyePZLc/NDUAMC1AE5VOynfQhmhAbjZWRXEpFeby2oygKsG13kRe1uentMk0l2Kx7wInPHZkdr5DY7FkpjE04F8t8oIiPO4X/vjVYsxE5CIj/6/+AY9XOcJVq18rkV7uzjUCQlDT5+oY3lNgH0SodATGkW+86YlPcZvc5zNqo7tPitNHUNzY5U5yxLxOT/7R+un4ieKBXebBHfSxdSc5yYz2zXxPKGnGaXi75BfBVg2d52imPg5hD8Qi7po93gBtIh0Doyu5TmAtQmsm4xxgGqLrpV680V/kXM/7H/Eseh0iDkSX5PbxA4EBVzbdW17QiuHXLa0f9fwM4DszsiqVe7fZRtgukXXFAvlhcyFWqg3la9Hl6oz9UurGrsexPTTMnIWu6E4xD7f6K3lGSd7tcJGTCwMTVGBlPBCY+8rNoZc+ZKk2g9iYgXCv+I57id/mgzsFiaAEcQD7xG4voT7rswhpOUPyPjLy4PdkhFpeSA+hQvjDCmOHAnjLQQ50arZlTfOYp8r9xdngI7jRej3gdWqnlREuQx6ieVSlJVORRdqrHLH4SxvBfBagKfoVsmUCvhtjR+Qr3VPuJKmwRYBYjX1DBDblmORyqnkTcq82Orb4GCqpUNipqY0GzO5hf/dPCjAV+3JmDM8buUsUQDmWUv0dmBnEax7LFxTEhFO5mVOgIqk9/kS9oOPQ34hFa8ZcyJdqFQiLKuOwzCKJte6+u+itZE1RP8u8pu0z64lcCd/408mxguJQl8CsB5kB90SLHdzR0ww92dmn0KXnBFXyygAnSpaufcMjejPZLy7+5q0/eR1ISPCyGTRJ6S2cqrKzzvonrwfkJqshv5MaO3XYcb+YwKm89NeIrTUC8CzHp4QozhLT5E/M3k4LQFAZPfyf4gO8LXOASC7/hwKQ+NXI3csKBthDgDZABV+wRqgDpYmPRBA4oIviM1ykOQxAKPWtMm0YA6igMmSv4P6Tg0JQLMMTX7/dxoCOlV0kjmmqrxknmncpUTr0zAZo/BbZPxZytMyxca2TotZ7I7b4j7hWnYFilEkQPPkY4fE56rGh7SIeMq84s2Zp3L86xsB2622V4Iomuj4vqurcx2PAICtM1wCYFsyrPL9lL3kjpQAWSvv005DtiKum5VB7SxCnylKZ39f3iZ/jsroh+am9UDme8UmGleuEvWv2Tbzv+Rj3+BfmfhalD+39gqAfj/Qmx36teA3XNM1+NUrX9sJUuYKqa6UYeZn8fxC2p4nyG9VqVUmKI/xI//J8gzlZXWJOzZDFAflLhPvYP3xPeJWdpXbicS/gAfg4RIe9cmhiAPjdJEmxHwCyp1j8Gt4AeCcrZXxZNBcL31qYaU1Kk9POzlZsBckmAkIY4wDT6Xx8zIaim85x6lW/88eU+xzHGxWwKwfM5FT+BH7GcejojNb4EJmreH4TI8oLweuz/qbPf6pgPQ4a/z+uORO+vOnYKKnIJU5QfUmE5Lq+0uX8IYmoJKrSc/394I5lLj76W8Y5AjeGU63cgO3TKN5QqeZLNHMCtEtxWbcOtGUbujlhubzoAf7m89H1GWrdJyF4a22F4muvo1/ivXVWZxF3c0GcGgo+xI6dZB3fTlHbJB/ZwhTGcSG8K3ZFkGdifhPdknucyiHtgzg3KJ8uf60nBMcBjd4YuDMTwHJbQrB13+FokWZdqY8BVC3edt15k47FapcuNiJtFRGeAao7k5VrQapl95Si9Q5wPpUWMspwDoHWHeHdeSjENESVuu803lnZbRmsY/IShOq9s2WgS3s08LkiK6GvlTbto3BqgRgAYKrEWwywEUo/QsvmNnxVMcA4XYQqmwuJz9GX4Um+pOZtC46msv+oc2XAfBtgW/8sbEuryHguE10zGGRYqW5CfB+Et64API2+VQAbJyRmpocURo4FY8pvuO3+l/tQ69N9gtpCvUrDSvxZZwqZUOlYJfGU9mv/jntfp3/1T6rs6VOO5wDSa0lC7IUZ73PDfU0XLpu2FQFGmS+j9jDZj9du1hhOsd0EJEgCPEDooXrFschjjCn2r/jBrMs5EV+TbYCNfYrlNs/WM5vnv5J8S7KkeQ1YUxxK/IvrpyYtXoXk10/D7KrfiVMptJh1S4ef+LLfGeXyXQKLH0Slg+EzwDMDWBWdRkde1AWgpFb76o3geAlnuMQMGxn2xCX5JABfk95ocV/XljAqNaJgOXuWE6NEgQz4k4IMhLfa10HpTyTFsuRkACMO8OYiMEzoY8DjE+B8ZyEHAMbd4Axt1cIwGQdIOPAbOwJp7kQIN0CUmMAKwKAhToujTdql7frydA37l+hNA0XteqBZfQiVdfJfTO1zz1D4X2hyYB31kEwfNJvyvChhgaAfV+wr9lUbm4C6J8BejXpuIZ/GVYuTR4yDED0MZgJ6BdCkZoqE0gBOUvRQ3w6I9pHZj3Ixe7Srbi7odxMKXaTvHVPGF1RUfzGtdAwYg6OdseCpa5Hw3Ew4jSP66jJAFXwrzsWNEfZVNzI8y36xhZAuOwcBSiV+3ZjzOU/7FcolghvTBRdPLe8HWAC3Y2cZbcuISgrmFzThCdiLNJEQFTk2Z9C+rdc4Wt9aEkMQYSHAg9iCJ+NpptCCAk7iRdfhQgwfAKGwzFA+EQIZUcAIoQDPwuS2kE1B7SWtBYx0R3/iufOWJ/3CmGTD7wFGUDYWgtaG13tUGD1s2PnWmT6MwHYk8D0Q6PZtK7mM5o8WNsfjz5OC7vPqkbAewu8i738wRUWdwXl5v4lMVseTQ2A8U4YU+VA8b3QmWRV04xj7VY7EkP8FhFWuFYAwPsHuDD7AcCQLeSFgLyW8TEGRXUMELaHUBfXxo86He1gdG9qiRImDwHJpyMJOG69Aij6uEEP13n0m/4CVSTuVLdPiX+/RXX7ftUYOCxgjtUW2ANYPaopIAYShnIXNSWh3NKXDnmeoYwhCpT+OB4Una0Dsl8E3X2Bc9+b4JXOvvTKGtDw1QaHneImb8Z5ruYOX30RJ0qnYD0HI79TAnKiLztHMixn0U9gHhJ6j2nl3h9K1GlwVm8+qj21lErVWhx7EY4SGXhEEx+zwrfInN5gsSII2BM2OINE5vm6QtyfuVIF/P+YJZ+64FSWemFZ1DaTnLhAVYI5mZaO7ZYEMHKsUHpl5TsTvxDKXymP1DCLs9tRq43wsh9VLUsHWSb3OO4zRGs76zZO+UcrJGP2K9QBy+rQe8Bj68t1ScajX+EPPF7+dG3hH5nF5BGniXgnI+bJnW6FZekNqdMMd1qx3C+QK3td6rHa3SfEnKvufSWN9WfKPGoyfVqCLcuhF51+NrFfdirrmgxwbLGwdhBHisXtnIgvo8e4tF5XF9EnGZ/lukNL/7IJ80oFpNvKxyb1X0zuyItQWiSVFOdX6rShiuZMpYOUBYGV+WKQhpnoXOBFwtDTJ+pYXmPcezxl8NBdawnA2Gb1xMTHZKJyZnhl4ofvTH04hLC7UfOHQdIuT8YLD2XAi/bYMfkwyPXBH/nlOMfQRO0n6+BpMlkAfr0KRz0k8xyPRl2yofkhRnGWniJ/pkdlC7Y3xIlLb5KEq7uHpIMTmxpPvtapLHx6UQR9PwiIK0Yqpa1lB9ICmej/Ik4z3nNmdLKk+dNB+JybHOxbk/5NE7XiFbKiQnFW1FgoJH2dQwoERpkvdxlNwaslgKrNMOP+T3EmM5fJKbeXmMi6JOpOedDRtf1ePzqE9RMFqyaWKm6VK/AVSU9RmesQP2y8wORjTeWsIddM+mdVz5sv6+W7pQs32NskxiFGT786pW8PkMnvyZMvSqhowlLs85HZ3qxIegCJbWzWrxpg0oIm7Fc4JLQnOssSHj+k/1uea1of9wgG/ZrEqZhfMzrHOoJohuIgxF9TNlKy3sHBxDOHeIjHSRabj3FV1A1EmPgzjpPHQUDJHFPPmKlNxiCcxL8VfsfL/uzr7i1zB0fJvUr62zGG2N8J39R+GlxpoakFpRMFVES9MEY+GzSdtMYdGJ3Or56fjT3dXFY/F33Mc1j3uxFFGeAQc3yF4gVE6r4gbD2I190JMuejdifkkWdUTmRJPE0GEhB4B58HJsfeuZ0hcv0dW+N2fkKnLK8XxGrVzrfw3K84jlzEfpgF+CuKMMDV+AYCXLuzSwVKiP4Ar3b0Ary249e3iHDAqh23AKv2vNI5FQGtdswCtCBW8tCEAwj3x0ITLJi/vqJXlfn0z9Ew8QG79fQD7HbnnfJBL6uuqtPuFg98RtI5BlxDJBGnKGZIJbnwIhSLq2mTLK9Yn8t/UBVhtHVYm08XKU90xWEUB0n0/fvFEMBsAHObwHJAdY8UFV37ecKvB8JnKo/vKEXxSRyczTtr3Xx5YJsD+ClWxTdOWBmZDgDvCLDTceoHAbOvoevPzMwHPBbfLMSl65FOYRf7GMBsAeZyxUE1dbLK7q1VuaiYV7+pAkYMQN4Asuo85+bgLiRjlepfZjcCHNtPo4zTLBI/qViofuhE3DfHt1qb+qK0WQD0Kd8lwi6kFClcAcrtJtKGWhthMgUU97JeavNzlsp/EasAO+u3L8TI1cxxKbSs0K3MVEf/57B+9DRMGA4A/5fC/+wR+2rIt6K7JOPwl3ipv8SF+QCfii8DYVzgsYA/xkv9Ma50I/wBXuoP8DXh50kWw5fhxf4CN0kY4uCT+BX4G7zU32Akfop3+MtcXVQadIpoKB0WaOXVObcEZY2gjYvVFMXEz7fpfyAWAVSbobrJGL+WZ4BTi35D0VxNAHUpJD8QjUk8ZSfstnu+SEcBZHnaze/LPozl25ji4ywMb4vU2gzz0xAx1l1/zOfGz/RuAwdIrkOyySzsEnpyfDIAW6piugJPNUTUah9EC1lW5u5O5j8eI1YkShQr9hibNfwkaRfCrXJF89OybIYO5qbkNrGErnnLTUiI7cScmpuSNkx0gostMJ3StqF1V3/EszjT28DyAFDdEdWfgOozcFW5e97gSekKWpEAzntiL+D8PHzuYRjHi3EasH4+Xk/DZIxCGWupFcHiVKdvBZz3xGnA+Xn4LO0KVyg1VUqkyEiGeEJiogYIWO+H00uZcJwBfHWm0a8pK9/YLTzQ5HcLkdhsyVQkAM9F/DWNLskE+ws/xF+S5L5Aqd7Qd7AitBjji/gz4QVMVVGfAKrebMzzI56n0A3Qgo1ILCc5ynhnkwseDJ8wQcE3eiEnaRSSf/P0jeqC/sIkb/ZRKrN96QxdCeOzZKpi2E61vN/gMMGPjJnsZUkgs24ryaWYfbK069pVXcnR45bP5411VDTLazhEhK3SnTgrrlbdSX0rkIqRxjw/A7CawLIi0LUvSTUivfMOPGPR42zAMNXTLv1NCXRYZxZ/kifyedjWbjp2fcuie1ne02xwGUkn60g8F466U/V/q3S7aB1lhGPAbTvc2CL2VYcA3Ir0vePirsEvGTLvpZgqvxXx8CaLgdq4tX4LQG3ZaZT4957c6Dab3NqELCPmb5KHrlZMLIIuxUf1J/YFn2bJgxrgSBz0qgDt3qHobPG7FgqBnl0siRqxStNxo2+x9la2UjuEgqF843Cc9yq9jMVC8ld4qsUA6BMBVfox4Lkjnv3JTfM8ePYvJc2R4XqDHuBDxSHTz8Ew7GuCn+fhof0rcnniRSosK1edwoWsmHuFUoB1Z1jL/XDbfSihN3hKGKcLgLbNjj81aOk0IOYEAN0zV0nsRThKpO1HF4bOdVXR3Q32Exr8hQHfA+BrTjXGDBDeGWEqVvtCdVU/pn4Az1GYIY5PKKwB9girFqifAVgbYDVVf70x5vIf9iskHL+xgpWYtKTLPv8R/MSAYbvEX2J6xDoS70YRUMyfAwUgQLmHt3zNTq1Y57uyWXt02AKwTwF2XgThale7BLOROGUT8SMhzAZ7A9bsBpcxzx2uIF1uet/dmTz94jjVXuTKB00NWR9uwFJdo3o1NTVvMeNWJ0tSwG0ZN8HDKmSFANBaZQU176eJo9C9/CB8Jk12+slU95sv62YdXJ1eQC+n9YxY1pvWY71KgmxDTEm1lzvjnqzCU66U7Dbvsi7sGGh1z8Zrmgg+8kXuPKtOtgqVUB+CP9mFSq4wIUU8yZK8R0jV7x0mvtknV3eXpz3GxB2f2n2i8gOH4V/y10aLaJzoBUJN1md0KMm1XH3YYa3AzJ8xpwlLsc9HZjl4UUpIPA3xDWZCbVwBkN3hlT5WnZjjLn/RJ1mskv+gMP8eM8yzVIaHspOJ+NufxXO9fkYyXuhffCl0xa9ZNBZk2TaD/CkKwxEx2J3FaBziIJcBhu0w1IqRcgK5woyJi6V2aWdMEF3d4ki6SGKV6k6uLpkj8FKsnaJl/XGxIvcYTpF8A73pzNNJRwd3EeKUPOo0kdblbRTT5T+kXhtdlV3aAgB1N1DtH1Su7hm3Ia5IOoYxU+kgPRmazzwZZyltkWoPXfQyFydCI00TJiY8NTvcGLFZmTY1rYB44w/5iOERjkV/ZE6MHqAnD9m9jES7Tf7Ci6siMbAD8WjygaS37ECpM8OxzOyl/UD0May4lgI7JXUs60h5utmQVF57TpOoSDexLO4rQNh89m1bkFAFOurB+RRMXPfMfAI2zntc7g0b2ZcsjKbulQddfJHqa+1i2lyTkKd+z9mjfGi9ilKHPcSg6zaKZyr9socwhDL6oJelNHbG2TYa8SLrebfRbPpYTZgV961XGENCLyZfE372SBjfJjl3iriOAJYHt8m1WA49dvSLV25HTsijTB7DBmOa3OPYw48oSkPs5cGrESKxSehE4r3lZLMFAGEbCPMDgG+DRZL5lKSc5R4YHokD/OgKakVsuZio58THtxIxY3bVZhp1uFWFZClNC1tsHnz/jd7K+D5HbC/G8LQ0DzXIW30QGI6Da7s2UmfzuD0LXPl999NKN/fddMNf9kL2c+PoNU0eFwMf+TNstjWJUa1qsvWfARlmbypvn8r79Kstj1zJiRHgEJspa6gO+50iZB9wdCpNCBOT5Th5HASUzMUyxoRImEpq6XTT9z4PqRCXVm7RM5NMjjgVj3Gir3IZkXV3FS5wLBJqQgcd1ZbZLmZA//57zLJUPgoOpOOimnP1HLuqdYtFXkji+7x+2j3gVelfnHulBio3WToM1sYVl9wA1u446qj1F9tHRSinj1LCVVxHr8FZyhJffrTEHSdTMVdPdVhmh6vE7R2rn4DVfnj1GXOAqh2tAKrWrFKVrFxMl3wIXgFYWzAL3sB2pAKc1vNpPgWoWlIKoGrLqtMki2vzOiC2llyAWAuO4UdturhNLowRYxhFk2YIv2UcMNzuPQXImrsB2h10sgPI2rypOpocxYuTOLjBPKOxxg3WS+upBrjtxDdVivuETuG1XEsvgKk9m27whMm3DrDaTCnAqhWvPtMkSz8tYJ9jI6sAqS05BSi14ROg1IZL12ghA8UArDaUArDaMOsi9sMswA3LGwBuLcsAuKcx7nsaAHC7MA6A25ZxV+gRNtzacQygas8qEgNULVkFULVmlewADIEbGQUwtWZTblsGg00LTgFY7ZgFq+s2lAKU2nBphEPsc1hJb8suwO0pfIN19G58A9y25lsWwfKnJcUAqrasangPwSOpBcUAt9Z8K7pRfuSmWIA4UoskgKqxG4CqNavkMlv1Ig+6W43luZgFcG3FLlOeHdsFIWoyQK6xG0BuV86ZYntFpB+dqvn/z9Ew8QGyxm4Asqey7ArzWQKAtecYALY7wz4lwQJA25JlAForpj1QlHazTOVLUAzQ2tJqAfadtkYLQGolp0onARlaVfZXiAC31d0AblvzTZumVT+q6AuYqjd0A4BtyTDjo1IipnozUsCsucQIYLY1z7T3gAli+BYR6x01QnhJV3YD4B2GefIMkNuFdoDcrpwb+ShEVF8ACO7CPUDwyRwE7HZnH2C3nne6tkURpaOqRNYid7QM8GvsxmH8atX47vRQdaFwz7f8DXQxZMvbYE2FuRYVlV1iWaU4442uDJb7yjagFETRRJcKSeI5NsWSA8RRJJl0FmfRbTLyZzhC8rjnYK2a24I8Uefw6ur8i9qFAaQa+wOk2nJKuVQRn0l3vot4kpR+VsTPZQBdY38A3c6s0x9LpcgO8TibXsSEE1k1CsknLbXchkZAdHV0ASB6II6Kr0gJoelSlo4rNGzAby0jAb8n4fcZ878zTBenSZSSENMfiEUCuizEJaorLgBwN4F7g39lhOJrxGcWR0shILje0KLy35vlcuaeG9ieCAdw7cYuaQ5QfYFdYHN/ANYWzMqdvkq3w4oE4FvfH8D3JPb1MLxt3wwECJ/Mwh64XO+bdQDZbu7q1R1JgGurDdzew1Xbsh2LB5zJAbDBLJtij6mtQ72exxSwa+12TQmLkNWnLTgNEWOA4AYnbNcQjMhUKlBqlPmO/JTE+PTywiwt5dkZpQldgRkxdSVNvUl1vecnUYTigA0oDhEnc/KvMq5dxNejS9WZ6nxVY88xVL8+x59IjOjCAGVJeo5OimLim/eZ8Wt51jtEzDxF9YTmafO27C7OwlDqqNp1i2E9J3Uwq90BMcLyJnFogQNoVd8xAxYgtKKHOcEPQhcVX7gQ/yOPL76pXiqSrutSdTc0+Vdn4nIcyBnmCqXrXzypAiSx6mJIlO9o/jW7x4tPXfuKoQCl4g3xQjJmv0I1Kn3oxWLlYamCl2Q8+hWe6MvPkS+QXKxf66hVzmCSxRqkcJDF5BGniT/zIubJxJFyAtOXqR/yVfZlrXMCjKv73NDdJ8S6Notx5plFr343/8IL+S6qgZrjFSDV77Ry+am7u5vbb3+Y/KCEGzj0YSdn8OoHPEuvFvmrUJ62UgKY/Zk06zlr/pEOPePuvUJ7Bsk4uJ9SLB5KetlpiDJKbhNL2F2QSiucfBo2+MmS2JuQUIBA4qkXSaTUt0mNO0IkPohtBQDc0tgF4K3qk/mUpELjCvAEZSH3SBzgR4cwMyteMTVRPMCPHMdMBm6JRQsj2rHwBjMx8NJu/o9s2bCQXu5a/0XwoxwpDgaje5KqLgmTh67gpz5/Qsn0fRyqvWYZJPedhidxcJISoWAUOd4t2RaL7FRx7jphfEqN2Yaw64pwiOeAZnteNvyIMfmQeI5CEsg1FdJP7eHCGH2hG4dFWxdN0XWVVq7Zg39QmOFiCa9PW6rE6lp7nWALeo5N15cLtkErV4Wxzi+EH7GfcTwS50bzf9qKQfaHrJ46zJprRAVR8j98cdb7ZffTcOnou2Ryo4rvjgrE0B4J1hpZ/Wm/pUXgfIlE/c40zMRbwwZCtw09faKO5TUmd+ED4v6sL7iMQ/QvFir6OMnEr+v4cXPiOgT5+sQngzQbh4TpQJVJiLjQ5ftFADPoPgHQvD2AX+NBLBZzP5nxfvLihHsT8UIEg1dv7qIkFqpvmgjpCNM5pjI0LInF/czzM8aTSOek9Cg+Uwu2IaHY54Pix5i4i/hiHtIm9ZToVfXPYlMLYF+C/eNa2GP88Lkw1eSwX8SBAl5urm3CngP2q7F/vz3lAfv9YP/mjolhCc1kFfGTUxv+OLkxfwCYXNqD/LE9vysAw3S+85TydvcpBYB/AvCvfy+BZ/AVfUbk326YyX2Yx588q7xaryRWv5Uwr+wR+vfbIA8f0c2Y2y59SZ6eVB70DYdNaUjlyAr7Zv9Qatrm7Cdf6mZuu5ZWd4BYSn46ysZmMyePq4rROMSNmVN3MHTjRyLm9tEi9gGfJnxoBNgsYZPmCZ1+JiTuATYrMhKnVGDFS98S4w2mjrro0FDbYMZxcF3Ef43ysxXIiHPBEsQnCY3U7UJwbc5zPxMdUnerbj5P6GlGqfiO51f1CKxaGKekyg2Wz0/iqfXROysbAJwSnAjd29DIdUaIOe5cXSaVvFyH/WjvSCu7eUWyajIqOzDOlOX9EiNbeGFA7RhGv6QHpZxXYk+7ySRUx5wk08EE+SgodquzVSit68JOSC9rk/uczPFlMp12zkOE/Qp9XSsWU08PWXy85W/o16j0u9U+kMo19cJcsQK5TX3KSRtx84/eNVaHdt+dr2BQBNf/Ix0WxaT8W2HpFF0LMuGzeL75BTXv8624ZfktL6X9hsv0Vt6qfSDViSPJMsSYi4y9UkOynOClfEtTSK23vIfe4rQ+PYbsM4+vBbRa9wY4rXj7ZLiHZNttkmtXBb2amwDFht4cRZGJKWecPA44FU8TTwcJx+FIhjtqe2R+tuFTWKyo70IyHkSYMdmsDRbY/FgP4BBqJ6eZ1ERVVQVryXNRbbEiy2otjiSIWFkGW8WWaeE1TVJM+TaBUTPEvj3E+Y1mH98WAXytaloUc6KuFN3B3C3PidxPp5Cr7z9dYT5LtHFZH7bctxom/qledusyW8VpT/EwZZ+qMS91YU+xWRMI1EM03A342hWRrodNlt8KvT1ZszZRjIJQrvEzPvngsTSUfg+5vUkMU9bxvZTxyU91b7pjM0RxUHo5yoOOpoOKWJ65SedTYbneHKH0VPQXxWvS+ASUiFu8vK9aoj/9wVKXmPRPXdwGbYh1lzWLxF/8i/JEo2b9ZYt2NKGn+YxN/sWVk7xGbmcz7e8FPqMxGkNe3pvsWeUmSWnCE4GMsaUzgZysvIf/FI1ieZwmcZczJu0JvJU5OdWr+YPw2ScZ63pRbBCJhV8pAe4tc69cryAmOMe/4jnu8RzXZE+wgAGg2r6QtiG1Wka0zOK94RoAtw24f8mHMr02Q7t0BQDbBtgiSXgzqtVmgLQNpN/1Y61la8M1fQe3IVOV9hgTSo3MZjfgM5o8GOcCOXs++jgtdhBWNQKqa1LeoTQNF8r356wQWs6MJ7JZKZZl87nJwwy4rsH1Cou7ghK0S2JsEE0NgGQdSblSvDYLRbl1rdc2QeGTrE8Bt7W4EabMhyZjojoGxKyuZCLDywTlhufyFFCyutKKjuXbfqUdGqQRwq40ufYKQHQJUcv0dYMedMJZVjeKFS3u+JgOpdv3RTxJwCf3cHiZ7qx75QSXnzmWK9e03+AoEROQCRcwb6gt2tpmKKtuFDsB2iQm9eHRr/A0lzLAEgw6Lwr2BiWwsr+iFnrlPFK0Aa4bs+vbn+TCZYMBljtydPc854DtDth+wXJdY7vZVCSA6w7d64+bURvkVYyjSLtGy9inc5pEOtH3bd7WUaW08Ge36wWouHtTGFAetqsFJHq0NmLpFBCpIEJYR9WcPaOiX62QxPfqTnnQQ0yWsjN0HJBVJYsoFtNrACWyXgiyHhTF2hou18tgrQkVOU0ywwV11DrfnY9YkQgFpYR3dzG0L3DWRxudExwGJ3TqYrjRjjD9BJh2ZdMIS7d5AGktlwCkDd2I90yDJQ+6G4hzYE4BXLuxy6Qpx/aucU0GyDUSDZDblXP1wGd9nsdKAWBLVHMGsCaLkkDDpA+VvikVy3Bz0xbWKsJMasxPJJZpLFAY4uBzmIzFwcJY99Zc4Qgd5QMFo1+hzgUtaROYTUcBwKeqbLdM4tVfGI7P4izSX2Fz3FmPymdF8yeg+ZzcVGGk3xlmSgSAPpmeAOjTGBqhVPZVrI0vYrf0omfkJkB5MFY6p66/IC07juUafwy9CWE2jZNpPmDjhr6nEMnV0ZEdd02sb5ZxTZrC2TiLb1m76vYqE5h/j4Nr3V6mB7OE/QTK6sYEVOiKHfRHQu8xVSWzjOichABSBSSJiMkOBAhVETLTP76Iz5PCt68udNO9T0/A2sVOW0SVKUWab1S8+q6ZQsYyuNDQTaZaUrUqkM9xcJM8MMByt6wrDE2UC/qIy0huMlkAkFsByTD1JioNr1dm7RLrX3quhA6HRzwN0ohMldNdrhozAG4rLkLim+OFHSKonh3yniXLeVmwe5tG52VUNKfyve0fwt6lzDsUCzcmQ7DjK5fyIZSNgPAOsWu2rTTPpGMmT5PFv5Jkp9oEiD8d8XqGlMs8qGdFG2C+c4Tm0o8AxPuG+DLxUVhxpKpIANmdkW0Vvdy9HdFtNNDd6pwH2CcRCj2xRAhDk/hGSTqa+j8k49W5/8XQwjWZ//M+xpjLf0Q/hOM3TX39g8IM9xChlplHFTydBWopGhnHc0KTOFJDnyUPusa3OOhnGP8+4ehsDP/q+CnjfZeXj1RnN/plkUkTVTGx1nGitHajXuJF0eQ2aeoTMGyLYSqkGCDcLU7EKBi6ginzUao2KwG9dkEjTqBXL8OlytdOkK8/+8XZBccRFMHbI0qNZdJ6jYiMUFZ+oKqH4qz3uFRK3Xa0yO3+UXG3gOLTsel6KcUWlQaoyg/93c5zIB3WMo4DlTuDtdYqT5E/MzXs5BFAtUtFuwil38Y/sc+VnYABiOu2T2tgAYCbWbjcdSQ193wfVa2j/xwpbV4qDtbq2pJ2A1SG4mCcPA7GiBHf2C4HZRKunqeJOyA6Hc8I91RkXE/+1hiFEMtVxqmYnzgV+IiBQzrGlwavB4kZnwCcu2/ppvrTcssCcfNPGTg0oUn0CTH87o/vNNyxtHWta9mrOlTxqBf6SkBzdzR5UumzQzDacRTlW0xT3y5Lk4ZyeR6PxOoxQqz15plMzadusQpJacE14jMVTg9orUCrONPeJ3wGSBVIBYSKdWRCF1alKBJPMB1WGwCyAjKmrrfzzEm/z5EtBbQALUDroGhpYw5PzD0SHKEOG0P2sri3qNk9XeljvY+ojwEXq5YG4xqVosJzVdTNNaUCaYBf40Gq1nueWVRHGc9kVkUPP/phxsgce4nOpqNjzaLU7CKCceN48HTM3nF4LHthqGzY61BVOE+mU4qnYpZjZWXOUrbTHgoqbi8Pdef5GcC4HYx+kZTYz5MSA3zt4ZvSJEs/mVKI+tgd26/aO5+QkCsPey9NGBcDh42Ho8GwB/sPT8fP3W9w3ZeK5ZmbdHREftYqS6WjeQf2ApHbeQX2ApGDbn216cjXtQfY4Ly2DyU6FnMzPovnq94wZcJW3Znp51bcYlm8l6Q9BqvpXdNmSZlTUu006SCGR06Rzy3bZBe/egeCzb1NqL2+j6av83LXVx8CJjKKlgT5ojo/6fgH7S+8SCZFsEZx1nvn/afh0vUvvP6oyKUFZp7c5sJUr/dlL0KLG1zEVzhK6EJ+d9iNkZo4B93yNQlWobWxdx8xPJIOx5zMiTEnar8K+XvSBfg2EX+SK5SmzpSrEyAV0Y0y6bi18pLyLSNDa73lPfQWp6oKYNZzxRdB9hlFE0Brg20FWNXu7ZPhEpJtt8mF4V1Br+YmQLGBba6juHFO0ima2EU8SYr8X6VoBZoTzP2ZsViZjudFTjwSI7oQiu4/iHZwnXMYwKq9Gh1EI1Wkfr+xpYBa+17/sbIZSSA/1xqcyQJG0YO3HE4Zy6Wmyfwpc0pcm0bBpzSJGYY0Ycu+PjqTsikFKw1+ZqVtp11vaRvbqWAqgJf7XJnMnmH3ckzuDRhx7hV5tmRvgMq6LOhxFoZl1TYm3rEQMdadmN1nhMokjLcxAtDW7XM4BJS19y6t0N918Huexso2qE5kSD0kp1vnBMF8FCIqCz2D780LwtYDd5udIHPey1U7Ck+y2Jc3onBAGMtE86s/Xr9/NbiLEKfk0SSADtXUf7V6a2BVn3d5oYWJWHhdlV3agm7Aly/yxiH6Fw8mAhGO9fr4gaK0eUGorxW/6KPcHVUedowvOsRYaNOxh816S38CqSplpv41nz3xIbuIT8Qff45HKVr1gq3q0NI9bHcIpXGc0yQyRXcAvvUdGrf+qiFD9md5OzmQXjTIjcpSkWTicp2u8Kr+Mq7Ru4ZEz1PGYniPF5+6ntjv7FE+gHxbqthoeb/y15WhMMj3caiK03pGJRCjhJxOL4mbs2FXT8XMXcWzTWz2ZT02exsv5obtDMsjtTgD2Fz3rDwGyHR3ndvYeQHoUiqu0OeyZxyYQlld/hJEypkuX/8Kxf4kDLWDnfSIZ7m6X5Xuvq04MVnwH4noZrSI/Z5j16Zjo5tg3cl3ybgbLMdt3ucVrYDsxo7Lm4eEmhT7lgQQbNNxeX/eaSnpfkSzHuYpCsMRMZ75Q8LQOMRBLtxikykV31v9KREHt8l1wrpiVmxjvx6HyRT2SF4EsB7sjmwJVl+Wp61c46YNbnE7uCrSDrsprgm1Zph6E2WT9kqj/nchPVfCdZ4EASVzcXdearHmfqE/F+qSE31Fh4vfPT9yhAF2PUwbcBjM3M4jsFFBKBxWlXfOiV9uvdVkW4aiFLtbMgDji7IEAHR8u43BrkFXrSBRZIWBfarnwMep6iO7YNM/h6e7wkM1S6VVZZQRLtMJ5G6qllTFS/dYazgYeH1QHw4Gnu24XSxUTRbiIZlM7KzE8hzQ24jecDykSarVB3UImLXATMdhGTNufgbItUDuOmMzA5s8BMy26F7nIMtd18r64kZV6WjWsRcEVFxedGOHFZd9JxLpbqbaOmZcy7JDgOtTceW55Ati0iE4GP0KXSnnKu1wN1isyWT+Sp0K+nucB+Vph98kLiVb1cTNl4mP0oFJloZFaqEM0O3afS1msszU3RBMCQhv2f0JnWayBB4rRLcUawW0ucmRidWq6KziQIw/3rRungE7xdMB66dt4skMW/m51vIHRLSRVR4AZq0xOzeTqDnucI6BuqnKZGmyrVVG1Nqh2JrB6BSgsaERSwv//nvMslSOCwcylcA1TR5Nes5VrQBif2rFHvSFnHQxDfUB0elfiqsD0Etu66v75UEXV1EHxqcHNYgPOmkRBqRyOLfck8FxNr/cAd4qtwswA2AAWAdn8rkpg2LvlUp1U67/9POo/jdf1mdg3S0EvldoTF6nmGVUJTIcI4bPVKSyDlpWDacoFvSKhXJ6m+QXAYCtAEwRZbh8I/Ps34BcER4qEwzUZraarOtZZ0xtnjjh3iTJ4sBjjHs4FK8TNcmuSldelkT5hI7CEGJJjwJOZ/MhHQjKnrirSwTHArUQUy/AHKvtIR2kBW/1MQPp7Pu8dxCde5PriXtoFucpPFqt0PSMqQPLzU5Ant4H+8hIHMuCOkOKVboapZZ90aJVxQh/hVJTxBI5T/dOYiYfWoMo3dciLCus/4srJ3lW+w5aBfYO4qYOBTah2i6wuzzNhYBerxLxPjt+TECl67WLgy46Jaz0ZdRluvL2y8RHYWULuCLZ2p1PfU1SKue7QT4zFhLV/99SelEKAdc2uApexgxpnUd8gsXVtEmWvwC5/EqLO55YWtVs0d9OeXTBcdQym/RnqSMT/zr/BqtO6sLeonOF+SwJTJI8edhbJGSu8qAo3V2c9RYP8cUTywhTRjs/6S0a7pas3x2Trufpr49HaSRMWxWKiaAu7D1f9omSG5Ue1pjhzmUhths8US66apwVyZZZmUoHMXGH6OMkDJMH/ZnqbDm7w4P300XwlncZZRV1szlr0kGO0ATnA25o6oVXwcrcv9qJXrlZmnzvOvDUOPEUCUkT/16akNnqjMC7/kThyb/iiq5b6rMyrMMb0+RBZvkrbfUxfvD8covCh02jF0bR2R2j/SLYo41f+SSBx36FZoPDbCiV2V1DMhat0r9FjHnAMA4gT+CxAersa30wMN19w+vLr3MT71ss42wBmFf3ilMVIECmD6aSfaDjXDFM45A3Ubm85PxNOIaCmEeBnetOoE/CzXXFf9ncWPDisylGZpsuajLIL39A0H4CaDszzaii7IROWZGkzwhzGaC4iXp9QLH+NZTjyjO6sZpSuuumzUXsh1ng5G7NU+H6CXA9lV26agmdAl7t6AV4bcevbxHhgFU7bgFW7Xk1UvF4gFY7ZgFae9aDAcLV/QGET2ahicfLX1/Rq3Jj+nM0THzAbn1/gN3uvCvd5tSGgjpV6AFw6/tzC7jl3M55gJtqMOFCeHX2JsapSmivSgaY0ABp676otlhW8FpLH2Hrc17txrJS/cyjvTsUPc6bvTtoPcmTvY8XzJ282LuhoedhjUJkQxKxvoPSy+Tgu79Ty+k/i2moTPAmJuc56Z5H056hcjNv+u549ClP+j4+Wg7lRd/nfONkumEACAB6OR0IElTvAGQPElLvAoUp3Uc8hibYJNRA5GSKY64YI1cd4plO5Zo+TUjM+w3Uhkzd1QaAqk85uZ+AlNQbmXXnxTROKP6BaEziKZNz9nmIpr1TL/uTrXzNTtlSzIgqqBmwPOvREE9ITPKtjNVbShJ9s0XiIyZ4ZUKKU8JV8kXAbRvcshiQ24Dc8v5SjCKBnydHEBKfD+QOpgxT8SQWzJszL5JOj9YmFsC8maDN7mt5uo8LNe48x3Ip6WQCuRfA9Cdgeiie9smP69mI6jyo1uvIMM/S64TxqehIp9a3JU9LKK83aDtabukgUImnmgtunlIsHo0TFBZA5ee3yXdKAKqVUGWU3CaWsOMpBP5BYVbJjmALep9gYR/oOJeDsv4dnJAQl81scKpWW8oZRjKBnYt2azquNctWBlrHMaL9E9B+QW6XXsJFf4Du3rjsCrorPYB/pdh7SOi9+fTo6iUmCWgVtHo9pzTMhCbN5F8n9PSJOpbXyL6NxTaJCCOThSNVXsJkOpgg5RJTYVwsOseXyXS6dZkX1aPy+LM6FD2dK1n39ID9I9dyFSf6uMRzHPYer4ZEwOKSHB7Aqm2Poboxx2sKb+LaHhmJ7/OicrKjkTgHwNoANqRJmpJ4Coi1RUyodLKKYSch26hyniaZMRSro35v9T4JnPXZHlQopaNZV3aE6SfABLlDDsglAGmDpWNdCDnAtVXEPcAFeWj2RjRAblfOfct4JYuFPnfBSn0gqjkGmBrc3Z0yP9/dDcaiw5n8wWKlh6myforfWZb8pi4vN+Y3G7zyyGH9al7E50mxJ1sXApyb4Wz5S7KoiRcgjkzfOhFEZ51pqm+n3jkpRGVNNhQEoxilbJZwmdZhhKQX17+b8v1YK/YkIroneQBItf+omOQ1YuyFDwXg2C6gEDjXzh3HzvgGUDX1jdUWnJdvMekyFoJwKZUFhcrfYba2nNAbPCWM0wUAurpvajDSe3jmBGDcaroTrbbPiDj9XGWkLQEUV6N4LVpwcK3bc+QqQkBv7SdXBcGexXPlFFqGxeYSQG91waQYP/KfzDN1k+KEexOxtg4Gd2yGKA4GxQ/JAwByo5XB6rlWK+pP5sxkaFYLymtQxdrISuMs3zjGZ7noLxIHvdpdtYOsTy8vtK3q8qJ3aTGfNvbOZyzcZfhOZUx72t+/+8m/nkQA80PG9dKFHBUmLdCII54xO1GQlvQ3a/C+gOlxDuF9QdiTjML7fxXdyS+8D2x6nFh3X9RyM3fsvtDpUybZ/U9WDuWV3d9sFeZe32H3nL33CI20Z6ch4vKDpj3iAZdep5UFuACuLszfkML4ybD2IKHx04FplbX3FMWCWrFQRW+TjvqovQx8jmby3RduPchWa7YQ5QMFo1+hSumpsiAGf0uHUDXkT1XZt1T+GutrBqS9I7Zqq7P6C8PxWZxFeZJpdXxJGAc0W26SA5rPw03lR/6dYaZEAOiT6QmAPo2hEUpVPqncEu5MQq3n5yZAeTBWOhdB94K0BCw3YFnJIuUnFKtfEOvER71Zr5K6yh9UPxChe1z2f64TwHQP2Tz4Q4Ood9yTdKEdJX8gFt1oQNbnxytvVkcdg6FqyVP3zvEnEiPDJTFofZZnc2igkI4QYSY0JMCP+Z06exuTrgs9hGWCuT8z4TOqGxzPqzcr13DaU3iWNrpkuIE5r3Zyq24+T+hpRql4NfOreghak+Hdn0VJcB1m7D/Gzyo/hXfOdxScjUFPGig5s7Bvc0yp+G14DQ+M5CoNX1w3vLo6z8GUxwBZU8cm0rQw2kuwomgCwG0T+ANc6/EWP4AH4PXqExFhcYPGTXdsCwDCpo4/V2JDuxoN+iJgXcTXNPExY4DaFqj9yZL4JvUBs7WYmfWulRauIgHQVhtAxNeSIp9fUzwn+OEcI57ldd6amwDMrbNY2CYA1tGUFseAI0DXAjri64gHeQBArQFKeh4aF2pEYxKbNMkNcoCxRcca1Ql5rMx2Or60JgQ8W+NZGJBVf58W/2Aq07JUjcvVNkB3G3T1NquB7jyhVfV73QWAc2uc1Zxa/IAV9irdSygRAKOwMkPAZ35PADc1dLyQsNzBVB46aoDFWe8LLD8NF1cDC8o0yGwQRNHkNimd26zzXbMs5weaS+YEoGuTxN8F6HR67Tztu6dTE44RI34+/kQ7EFpp5T8hhu2sgrviZ/exlKoQcNyNh4DhBj9X5lOSio4DPEFZyL3SZ7HL0NU+hrIIIx9iP0SCMvlyqy5s+WEdJr7MFpQTrDwFjHqglO0TJbUosmGyBYCTY6psrbaMVsN8WTWpzOgcIRKD+vBciLmiKOwRLXdVAuVpJP/6OMQRzktLFGe9SHi6LwzcS8y5L2RmiM3KSLvTywsJyBchBDykKz1NfmKf9xiPzifS3P802s38j+2d9T/r42KQG+FJUUz8/JWRkZeAzwp8CJPwXMtzgGcZnpuMcQBnbWdY3vnFKnuHgsBsDQ8xR2KOuk1U71eYse5VfXpGJFUeFr23fqoqyFgp1P4u27qe61fvoahKstcJ49Pct7IiafcVTOI5pvyUYvFsnCDzOfTL89vkOyWA1WqsMkpuE0vYMaxMTeEQxR42Sed1kuNkKv+bGpvXpTpcgdO6PvA8N26ILs7m3Vuz7wOgKpF0rFE5TcmpK+/jUuAV9hChhqQn4pIckC6jU/3bl7axlR/C3E4mfkYgKf2T8wJ0PQ9zPgR2/Yp3fhb2ORP43PRe6Q1wrVSo/aHPenl8lQRZiEv4rkxCppEyY8vqh6wwSW7xCusfehA/UOYzqvwiQLoNpPqnEGNCj/PU5oTqyyPMU1nQ9epLNZe/dCEdR0nX0kihAKXi1ffSqaW8Fl7eVtWvr4iTuUowvezYV8+slYaZmDakQ34YevpEHctrUsRn5WqrY2htzLkiOPmN3WCWhfySxNnj7jhJohsv2iQijEwW/cJqxafJUhQfEI17isk6VXqCfBTgviO0XI2n08RZcjPBYfiXvGO0iMaJnihqsj47rMg5Y6r9drTZVIxV3epFKPXMN610NfjP5tVmEbNzK26yXDEqko7uj5XvCaZz4uPb5B7H/z9777bdNo4tar/MvmV5V/c69F53tmVXXG0nbktJVv83HhAJSbBJgAFA2aqn/zEB8CCJOlp2QmL2GF0hJ0lQ+AyAwMQ8nCU0pT6NycAeboa0XMpjysZWar7wJDMPysoG4YsczaR46Yee8FLEz1IQb826LEKt6kfR6rhe1Q8xE/ZqAxycJWaCnUNy3TOwf0JDu49D1TMLuzdh6rVp3Sb7QzKdSjqFoQttXH8atQDsXI8hFmSHTJjSjMdoc/7zoAXQHY8A1vfeGPm91cjP32HLy62im1W74Qxm3Owvu862xjJr1W+5Z3tTXH8zL9K09v01C4fLlChVhhJHtm9hW+pGGlCR8rGU2wI99Y+s3xybFGbINA+S9OzR++pb+QthEGne61nt8fahdHtxCU2JM9u2R/0i5nWHw4Jpep8StzarzhrhhA+n1ywaUsE2dZVWeG1G1e62weXveOV3rs5mxZRGznCq3GXDieNP5tfrOeQp2PV3OrlpnxI2Gqj0/7hhzx5ub2LeGKk0/LPp1CThitjBL8oIN3fLNllEq2/7qL565y520cz73cEWpohoYurMpw14X4302goDhtbc4NDVwgTRQCK5H2nsAoyY1uPKZFzBTy39ffyOIPuLLp2UIRc6mEDhROi2mHSw+IzkzhXzPM8Rzzoe+El2ez9lGfOBXx+87BZEOMbvtSC2Fowri+FGFtIg4bUYNzwpwa/L6V3QfMzormUBA74ztoEizmOwFDXzLPgYOn9FBNWmHGLqBqTE8kJELb49jpMZ4ztMZ5OmJpHmry4jb4CtSs1NJuLnUuiWj0Zw7s4P1AVteEMuxZyVYbzA5cLe5l+h7v3V7i7Ol7JhZyKhKUyf0sUdHKpznrhv3dWrplyx0vl3+y0H5uCG5b9QoMizhhckSb6MIZqIOTWjoWa0cuBelSP2k2L3YBcl7vIcMZ8Oc0ziGV1p2SsyxH1C3DaE1eWSsBHbavkCgn8D+NW3rrwB2b6ZrZuQuHjefw5t2dVO6ZoUeZ+I95MaCfCzXea9Ju1V/JgNIV8KnjL+PKJZDp6NFhJEwTvKC1zSFHwk2V/URRa8H97WWpRNF3uymHHVExwaT8R4pChodzWNprPIbba4Zx5/j7SIeON79b+gOFffmZ79DcKsqOP2u5vvPzNTj/j5ZnKV5X7i1xQg8HcALnjC3PW6xV+uCHvggl6rbqwLXRW3wJ49uOEWxpFqerBZHRvbQag5TlcPNr5+bWUiw30Z5kZKEeFxyWVmjUBzVMUkp5AOGOntZ/PST3pPjSzRLFbncqqccVlpOc0g0IZTaW1J/7T0aaF/o2ecvuon5W1nIi50NBEFT84e1YxImtSW2XCAELc27aQMRAQN2+2+ILGt5SKxQ9vYerk2MIMVljJEeGC5PUHYGNZza1kQeQRZoQuSpouIvsZpodicljmhXC90do9orfvLEe2Z/e5H0OyvRW/T+LHSfN054YDOXQS26jSITCXvhMQqrRoB2GBN0tjs2XQV4fUz68u7dzwwbyNIpY705GMug6b0yps1Vcly1i8hOGsrafuYN+QuabmOByOU+yEdNTF6J2SdT7PzTlwSJs3SSshFI6M84xMqB8sXkFYfchR92HiUCpIMm1IEhaAQ1GlBrZpGzJ1fiTM0KU8Qk5tqljy8VsB+1GBmWU+YlrBtvi1EoM1C/M3NB0NH4loY5aqQdlNzTBS9emXK+8i1XUBkW5HZsPV1n+ugnv69iFl3wpWnr/j8s+ANN6dg56brwGamnJRemXG9gCdNk0qFcgDdpa/cuVORcUqHmubYNb3/kvmKrnwcV2QIqgJlE6DUjOzptRSZK8/8wJsE21WNq4GlhtYQIirvQpjlENurIlOZkZuHl4QdT7QwEPGli2jhTESq036nV1CmoYzFK8TSAS/us3rvcn3vc/VeoWk6hPju9v7qrH8VD8oo4X3AdNy24A1Q+msi0BYTwlXnZvlK6Sbglfi7w0tE5rcBagdvmooxcZbecUqJ/MOeL8WdQHK7yJnnkNsR3BRyOzoQTIu8o5mThrpImLPddIfmv5NJEFZPJ0fQSfuTE1HovA3AyVtDN3exD8FwVNLUhBlgXXSFf18sT4LxEHoMPFQCsq+b09+eXBZuOMZmsdws+o9l7SGvn8unzajv9+40JA5rD3XdWYEpVRj57//1H7//I1KpeIlcV3DLlDGblqHHofa1HuFu4Sb06E7z6zDtrUPNe/IMMgPaxFTwmkmFKdB+IrUAcqAdQyywDtlMKT4jeb6wUaAjM+eECPZ8GmUL9SOt+Snzm9+SVty2Rtrl3OLvynBDluk7KMCHiiByYH6hlSC87Q0Q2R3Drr38x0e/VjVy30oHYzeklmddnudlNBOyjEJ6R/jinCcPpvlIXuNzY/+dSIp0rxgwvkwfWswXbWWjsshVYR/DuP3+33/7z/+MFMmoD+Hms+A1g7fdaJphjLxfHW5v4+G1zh4LbsfUiBspTSIhcbXy8+kFsGp5C7kg1Qlvamp7JRD6J/y0B/qjMOW259Ndu6MngaLKFVuj130pdF7oAY1T4uaGBziFVXsYcDAS90KxVyQVTJLwD4HW3+zf7907EVkbskP2aGO5yLVoTL4/ETXDxrYp4iKkaSoD1cKGbuODCnIEt7lIBHcUuGohYYNSgguiLfZCihdF5Z9DJHcgOUR2MLIRItsdqH1poV+eILfDFCTIbVd7gzomQ9gk8Qd10PyRlyC8TUUivDfAc0sum7yRkqz8NjTOEd3R6CDBmg0J0JOUwy4dPMmdN8V5nm8H5uNUlZnSoAS7MZxLoYXBYUvh4JiSsr9sCo97f+UbSQukVlGzSpJcUvNf/5aGxJb6L5De1EJElzWsV5wSiUxsGxtqsElgkwUy8oy0JFy5bdsoI9zcLdtkbipXy++cOEyMe+3XfHNB5cwvq3dr+pWE/gBq9n5TggZXxLPHlI3t1wC+jwGDOcSzN1RC6zsETDWCnoXdrVbz0TpApoCAsWx6vgwk4gLAVR80282cCEEtgYJ/PSfTvm64G5mGOeEIqvl8QvJyJu72286dBCk1noffAq+MUpYxbxr44GW3IOq44d5SRnBapRJ3ycjP09TUtUhX05Cfb7h4TyTJMO37L4179aWtb2y9gtRPQv2OmqeSurxb5u3t2i4g85MwnzPFtFU3uZJd9PQVYR/ieA7GQ0pdmFJ3GG66tVOg6E8CrONp9DMZ0SlaR4/S6uyLo83H0j/nJs8UHva50PpjJa9oSmP94B16LkXB0f3+l+AXgEvL29j116llNaz21Sv8AFsrd7hnOO6t4bwD5NHR8ORruzZZnJ/dXd6XesDGN2lPfX3K+LPL5mUOQoBgzqNqr8uqwDpMwKs3o+R35w0ETripWVFHqYhJGiU+jY/y9VP6FuRldp+Na00b8LbM/s04bWSibAq6bn+0alE6YSmtL6sz69lS7YI69XElO9CM0PU2OwYN6LiY3nCmGVjX1HGGN11EzIcafiHmD2zNpZeJPXtwuikYYawiG6Ee13YR6klb6gtRWc3zD6q/G0EdpwVhHuh78UdpsttIB7siQ65HuwEh11O3160aKFs6Yj21Yq+7WFt22UAF/kB5YqOmnZ1LSRbXjKZOKVyfbgBZLtPGVMM/6kfKNP27V07zOZWqnJxa83qEdkCxllgf2K2qRP1vQRX8z2IWgNr9cF69jh9lK3d5e+Pi1t3ebCDhHDXUSjRvlzn7M6UJTS4YJ5JRZfNn95ZDPxM7HVpvb9QnycuFcC3BHwf5d+90Nqtjqt6bFFZv+7t3O2/VcX2+D3tnu2veqw2zk/R0/5LOGgDtSWA5tZKNk5wL5ufDsM9aSfyCH84DoZGbtaf+mic2NrdS5g4XtHJN3Hse35raC3fcT/2Ftelu8xtuu7B9zQkWid6jNCbKFO6HlZjkTNuQC4hQHhiPnJMMEhpAVVIWa7uPBivTyK50o7mKnA9OHfwceR/Ae69XfeXrb6llyPiNjM/l1Pqjq0o0kpR6bWrbJSQuD3XPdjsj9lH/Bf/O9Ky5H3cJQBWifWNj/jJ+orGu9wMa58j2dGyHxdQ8WBk/tV5B3ifhXe9ENc6R7RvZDmOSElmzbZwj27eyrYaA1RbceqXraVpzuzkV+UVYVuiCpOkioq9xWig2p5FwMVkst2bkCNx5/ZWI9jaN8PvR7O+u7a44OSon3GeqkNbW28bI+Sfb6B+yqUC3saXOZjKC8dRtenClCdcj8UmOWOcidnwYurJAlvjMPlLZom4SJLY/MQiHRTuHbJsv0dzNZejVa2542Uh76bVZfheSqmM/Dk616hwCzcK9e459J+a1VBwM+8u+XLWkJ8Gkq4jjGcnrxFhwdGfmz6ZP1bXdO6KhnXP/qW7M79VswvxHt0WODPcJpO88XMZXvMiUD8ZgjzsbCujdCT71nuBK7OOxKXHWDK79m5WUO88XcAI/SGHA7p8J1JVq/xvVpkDeucC2cPNpSu5E/NzNqIu/CstGa+xm2NifD9LMdag0jdEWivQ2mYWPq6fKtQmVduVrfv26pPFG5PuW1mmuDgumu2otVJkHvgjDw1w239qZeHGaZHNwUOh5kOYQChGYV8bkX+RoJl1JfVD5ew8CbwjkExT4psKFjiai4AkksPG+3yPxb1O6dStYjCxJVaa02XzHXoscMO9s+Ak2zNv+KKWNJWPbhZ78TZx5kN1kuU6LUr9s8Hymrxp87++Jnh1qTnBJ0nRoOnZZVnmOzPYLlew0FPdSvC58HHjVVF0sXegG01ILX39Mtmjvl7uqimc0I1d2lPDGx6qKSki6aY5cusbmTkmVu2FmqJN6N6KFSyLZ3DxUPryS6sUtie0tft3RRfuz48hUT6WEm09ATFLa5mc8AQuQkbg0vyfjoJcICg6npfUtUll7Cpk0n0Iox4QxyEh+3jkH0LdB8SH4EMSOL0+ARMyPYiQZI42tH98QG4YyYyiy2DL7CBBEysbYKnYNFl+5KnKoCU0+E8h8BsoGnLEjm10zd4SzYQbvdNBu09Ei006DEp7qxM/kEcimGT2SaZvZI5W1jzYiWZ/pI5OVpxDI6pQFibSshfoEZWf0XrehBb+vSltjay4ytm+GG0ghm8DE1j5YnSGpHaQ4ktpICrBcOEFl0OzPu5ZHymIoTbgi54O3JQrqjKY5UIhFljMzDc7TYsq4gjDbaeRO7DHcM/E2XZQkCZPDBY8RziocpYlGMktkcqK9KSWTvHv5vz8EzZNgXYtWsWzC4x3w4TdUYb/yVJDk/2P5hkF4QnU882akpcWetXs6nzYMrmpJ172gIaM1AIs0GadVlGWGMdB/DrXeetu/jViv46AfmXcBA+isDffOorvKQJ1RQ2hozTjdPOiuIdgW0GW52JxwFpcjP6Sy6uIi+INJMQWg7uEcQW0D9VAojZj2LNaOY5/cVLZ0yPBRcAdUE7PiHolmMEFkurtY62ZWW7kLruogGP+qr+GYt2ex0mZVn7O/KHhj3PD74W0dVGzTxU6D3egocSumt3TuMmju5Gh/wZw6lyoPqyHpGKGNLhNjmLW6xnDlZmVTprR3gTcwjnfBYKrzThgfRs38LLOCcN48EintpiSeOz1E1S7Xq8N1GeXnt0p5Zt5jVub0is+HnORqJvSBq60nJfi9FFoYXGdVbKo/jdR+T+s3VdeQ7V7u8hWvB/Jy3/BZRp47eW5ep/VjAfIB0DYX3AgWhhB3Z/Yxd7hZduWmnTIzXs5NTRJ3ocyS24MNYYzu9YsR7HF0r7Z4eobHH0x/KsY3ShX0q0zLTrcs3TcbGex9+fOyoGYQjGshLwspDfHyri7vWzTy3TDgpM5+/9t//ud/nz1mREvmth4e7Ipe8DuR0ANz6DxWURfMWHtXF9kUdCvKwlSSfBYlNIetBh4z31d956N/wOXwLD0+lE63TD0+Bk2XDRrKqE0DOi6mN3wi3DeqPAsqV/BbGSxPPF2wPydw2ti80MG3jk5nFD5tA6nOICdVGVopQCq9ybl8ul7S7fzLb+HQn1zMh1HoZV7mwxCsmUbW/cHc+iCEviRmvBww2bHYcEWW+2opDBG3XzDveZUYy1kLuCi1dbqsgyOFF4rKaGLzcET1nuZXI722wg47Hr0PyoxNYWlUKbMUAju67dVrI2X46c90ThHdjilAA1U30SkzNo/F68r2t2o6Tq5/CLY9VO9DZuKZjmjn9MdvCgPzRtWMtTfrsrI4o5mQi1KpazrgnRWMqg2zpuTgIeqFjqvppzPIgJ+NuDYVaHd1VopckSG9jQWajwEZE+W2thMp8rqwgb+E9Pajp6guEN8h+Eqlf11GwyVq00XkubHARuNj0hs6NyS9nOdK6+sU/XD2dnbTEATW/u7gb2+dNtLr/py7mfWXqpIzIMa3YLxPSUxnooOhDX4CyHBVJUdgDFdNcto2F4yK5AhsvVSPbDfFTuguY2wJOZVGcjXQwiHKgYTGLCNpZL4Saeq3KKwkaIK70yBtLtpal7VfRKZbmW4h2gueze9kIysZWGKrOheZPd3jS9so4c6Kza+4SepyGsKuBd5pCWdmc/CZoSklstatt13YM/DX1StUyvlx2UNktFbmd8nKFMLusC9xP1415aBxh4W7oZBcVQKwSK8dlVcufN5lfxz57IfwRrtPb4uyR4huf3Qp+WtxL4WZw2g3PWwKECR9S/rBLJuMxJ9DMKVPYWhw85VVKUI+OPxP/Srn0vu1abhzaWbihabJNWTZUr1Z042J9hkffQBbqCeJTUUfxMvhmezBqTfKvVfv6kQafHsfzJfMEKYIELVWR8ILS1d16vZVJ58X/6QLdQfFd9Qu81vTtfhbw7U4GFePtxHor6PHqVpGp908joew6tdupz9VuvXqLHguqbm87AlzayTfieTmM6TO1chMKXFk6Y2H0Ls1nJlNFg9tp4shRk7TZHrjPvVuraQ+xTHF6cfd+a0gCU26Gcvy9I2mD/F2SiqmRuY8g6UMydkZKbwV9Lk52BZ6csPzWjxTHkFAHiO1BcFGzQikQyfsgX3cmCjWMLJ31kN3IilSerhRnFsTrBjarQq7HnO9DFry/8z/Iq3iqFYERkJk3vShDKI+FBm9TIlS3yXJcyox8P8vg7S3WQHeEWevUwZs+ohEcd1O3GgGXxQjYbE5Tu6qJ87vb/ATs9wWbUSwqEyAV7cUTILygcB6O9IdDSuI1Ce1CZfd9zgjcSwKvj2lVdC98P2h9awnnghYgImIXGAMgEVT63vlk8OaQcyuwiPwd3MFNjZ2b9zFQXVtx7IWGqN/byMCOS/StI75qSBUrJn+9ckK5GfS9W9qYkXOx3NucwNAtqdsw4e8u5Y03nleCbtrS9GVP0DVASJJtVxA2r+yBzyUgo6uvKtAYLDmPkuFQeCtadN0bG4GpEGZa5wMSBW02gfPgo3Vq1caF9o32vZL2I76E53wxG2pD3H63oCkV3EL112MYOUWDTeF4Xt7IL+Y8EvBOY31SHQ7dscG03synUo6NVDBJbPwy/2EqmJKJFiensupOsqmv7Vgp5P+yqGM3rjsfBzIqRRFfrFAlG9HWR0izNO2y5aikeXRDbPbNFedNm20HBZXTtK2iqvCPR1AQYGSgG6w8iRNylCESMip8k2lLpygSpnkz5FSHx2JV/c3Cm6mteaDlgxjkhJp/R5wS+0XIRjA/tpb6fXfhMcbIwKlXDBexfu7rCSuevY8KI3i+5Dpr2PY+/CaETWjtaf47Q1g+mSESGkjpXspnmiskdKaKpYpnxzygvEbrjRJU5r8kYqxOVh4zfWWO5Bmo805jeWlMBdeXZGpID59rpciL+SFvD5sdLMZDK743Aa0rXMalJKeZGOu1i82Ho+NGfNAfe7RZdGBKa2XkklVhYDOorOmMh9B7wnpnbjtmefP01S8OH0i4juw8fUf35NKRGyr++dwIGK1ngFnS/y4mCjGp35vOWfaxo9CQu2ECo6MtiSQ5ySDaFrwW1MWa5v0BhRkkVW/RXMVud0l+yACPfA78Ifb1IRtNxzFdo/7iOug1mU/uAYWstrdtDrParPZtP/ueZNpH/KCCx1NIFC5GeEhzZ5PMkOTL3zAJhMKCrL7ZjK43bcdadW94+eRJHlwj43Ev03lLxgncjGy7/EbENvuwL/lL/S3tAkvvAUk4UZ+Qa/hgv1Rmy7iX/AX+gvqGVX0VsQ2jLr6ROb0glI+pETGM+r+jttv6Wi6UkgpZUaTmKS0LWvpBFa1I3FpSs74lk/RpuIqBWhCY/Mh+qon/+gYqGVt5cwUnsIL6iMXq608Aztnu3DYS/lZF5fDfryzNIKwEGFDaunLfSFVdpRMleEM7JHTI8GRzZVUune1sFlOnrzqkOoS/dhbzt0dXfRmeTOk9QJi54hgfkCktCx1JGZ0kiT2Zg3XUmSX1W1DexeCawdnd2cQlitgTDX8Y55gmv697TOakfxcBssn+R2ZHDjvChuO+X2MJGMEs1oAp6WeH6ls+FghlmqImSKT1QJSNsa2cvCIu7z8xyEG6exP58b8Iqsxu6VzmuISYcsS4UG84BIBmew3JocMZstwEzCWrXObgLm0jL1uF6iZP83pTINWlvoxGNnsoa5BSDs+WAhom/oG6WwtAPFsVucgmzY2CGeveWEf+TSq5w5/W0lzdMvGwx+p3w6/JrEWcnEnNrqnrWUf4PRVP6nIOfU1TIYe1YxImtQxGXT30h69F8Qt5W4t8qJ7IQI/HKFpggndUW6n7Yfss3P6pdB54T1MneSzqbhLWqbKhlKDm9E0h7hEschyZqbpeVpMGVdnE5amkTuxx9SHV/YJA0XGFJssup4ixbQDU01fd+miNGEunl+CXW/T8pyCW+9zgtS4rOEi8VnGoqzQBQTmiOhrnBbKzMIikVvLYoukDgmPffdXhNrbTv2uQAPp7Q030zJJ49/+/t//OHvMiJbM1fWBum1R8M860HXVp2E1/Bind3WRTUE38JVNIWZneTFOmZqVbmu3EM/VZitgVTSo4yOR01caEy/pehj7R7MKsNK8DNZZhav7Ikcz6TZ6wsue8S5cupkN4qAE8rfVqY3+qvailBPO4rKvficqQ0zbMT0USt/DWccYWedFu/0VUZ8vxqkixPSMzssJ0K2YXs39R7sFyqZCoN8SM/zPZAROPq7HQeQ6rkfikxyxzrksvysu8FVhfHrGktoHY2ia2E2ClLZTGhkZDRPTnjMkU0oXDfROgqjF3RBmoJ5Il/EsrSAymgm5KFcPVltzZ0WjUk+9IttnWbJcaP3sgDlfxCVJN+lN2KsuzJNmhlBkpsaEcdTJfAymnmlZjkbUX73JrqmhYn814oEOfeitI+aYhjhkuKjLujEfxmlXM1Zs0gkpqoscRtthwXRTN9R2ATfAP57n+itsMN07piBw370Uc5aUmovWK8j3QL7m9qqcGz4RpdaiErpx8466NJDI9sRsEey7gIU6TnE0ODnYawHprSBVB7I9NVscCt5I9d5Mb9eoghCpHkh1uaTGKtMmoamXUzdefdbddJy/IuS2C0j3PekuxQRD1G9CfcXnzt5CilrY7QTnvxzbZSnCfU+4468PNx0jm7EpWJ2tZM68c9IBnde293FKibyXIsvNt/zJhavbwLJZaGUGMBhfWXWi00JWZ8hrA69mmbD/U50ise3EHqjplk1mVoDUlgttDGuXIn6WgsSzekyrRIhtT2zaFDcwPw3J7SZ3Nxz+67ZubPYUcS3tUSKttzeusksisR3EFqU/aX2KuDZ2R6R1XOOquiMS2699IbD9mti9UHoqfe5zWXAbz6EUIrf9uC1JENqm3onM3trQylENuR3U1hDb9uZWF/r46CNYmGPzuxPmNLmjKv9oQsECdNwpB88tTnYzomZU1XuuAqDt7eoJJZg7Gg5a1dl3pmedtd/YYgyNqZM/ilCfMv0+YerkX63RBZU6+QlTJ/9KratPqZOfMHXyPvPWPZSAu6dbLlrkpaTmV2lGPKRCspFoCDsaQ2K82w9rQnU8i1yMAPtMYgpOBXFOxuVJf+vfz+AhB1fc9aUZ4UlK76vgDo3zkFrAJ7NetU/BQRcDgBxd+zquB1Ndjezxxj6QMv5sn4OD/lbdnEdViCEXgzWIem+whfMxI7wtXLcjah1PoQ8WgW+ncF+kqUcAhwHW34erc4fB1X9IaTkQwGEY9a98skqT9G8uz9KQTGi5bmy5FFjj8Bskza/FsihMHgOap2KxbBcNklBpdNxE/FQc2GSyBMKch0miFybwp2MBKQ9WaIAoTB5DTXShmjicpL80ylsvb2/srebfMP70QVS4vHVAx8W0ipZQnfW/4tc2MJe92x32v8p/uO0mN6iXJ/2v9g1n7u8MB/2vbhbnZ3eX9+5TFef9r/BQFwlz45c7xCr3scrFkva3Pu1/1Uc0pRnV0i3dq7P+V9xHKHR/Z5hvu08XbHV/kTCaM2vSddm4IRQowMAFYauQuNP+A/hm/uhJ2RbKkwCq7dS5rtbuuOsWVHrFguqGlxkX7dE1o2mytwFtwdmPgl4svMWnO0FCa2XZiT+LFZgsVgs/LyxliG3NNA+xHdXaGmZaeU7NR/qZ5aVhJKLaYPyJqPYtq9RimLmPpq96SbPhZYhvs8lyX/EtJVOJhaQ+vZZbTJgJQ7WPbu0G76hS5mnw3Lot7as2XNtAOgHF6UryWZfERSHAfQAe9NqMqGfrru7nzv4MSe9Des2kEPykIveWJwjKx0muZkIPzczGLq/lb0/mJRyU5HCKbfpd2vQSX/syJH4w8TZLYXDSYvpTMb6BXLhfZVq5bi1JEfDJmzT8txewtXLZ5an08yfzQwY0Tom0OZSdWnZZtoHfakkDEYP2sgydXJ8iIbm07r4vs+o2192VEGk1SrpwgqoUf46MfEnfJSvbkTvsdCwLCF5hrtDk3l2vIlo0hXt9LqWz77p/dlsK9WlfPo3wmXugZn0mIUHrMCam4XwjaeGYNc4P/fgtF+zMSTRNhlqWIR1WZEjUFUxcQoBoTDX8o36kpj/+veHyW+94lKUgtr0LrovsJD27nemcnV3KSYhF1NjzXJNuolUX5FOr1GVk5Jk2hWW+lY5/LK99tJRL4n2kmoI9P5O2zTTnEk0B8un8NGKTcrgSrOV2/VP9UV77ksNr1F7zij+WCqzOENc2rYXNEXvF5/UYviRBeLv2S6blNkYzt1ZThAj3LBoRHo+wXESt5ltvkXd3cruUKHA5l10t2duOx89owYvVRkByc70sm4zEw8qloJG1jHh6cHd3XbkBm+MwAS1/T51qOqocugCNaU2IafNwiO1o47yMvmpJYn0v6ZzRl2tKdFHGGm6/hOhau2BjDV6dIar+BhZ+l87Yx0XS+4CSRuo62XciOePexKBFHhQ0H/Ictq1zltKzPC3MSKXOJixNI3dij+Ge3HS9uo2FPGVYUjyvJKxuS2IdPKuyGLd2vuHXolKqrgo7xqrcwEl+d4r636MXIZ993Qa/P1BVpFrBl+vSlJpxiGW7aQ2d2BzRUVmkjxsL0wfY1nAlNtNIdzHk4yl57b95ZmdYUBxsmCtEVpaFmLZjStnYtCpEdZJOmJH8vHORij+u8yEeX1aeEk61iklKkdMWTuanMpKMkdEWRpyW2WUQUHsjUhs+cEioHI6miOeoKRIiOmRq9CBeENXmqRHi2f3JR0a7vmhIaOeQjYg2DNlWCed2DXw2JqeMQy3cUlmI6bDVLfLa/5OHrPZc7SKofecISGqv1S9i2oEJOR069ewTqk2Zmh/LAJ5gYFJ6z9gq2+Om49Vu360DnMAQ3e6SvQnDsGBgfODj2TWFzuisD5nsvX00fXWGUSNRevk17YAvRcH1+XQq6ZRo+qXQeaHLzLvhprj/cHR9StX+fvDWezUnmUEYQSVSFuszGCV0xHgEOFQ0V1EGHhPuwa6TXjZxfHy0lXp8XE6Ma2Slq435Y4BRaBnZ6sAcq13NsPoRlBTlSZ2IuDpDUgcFo3oRRZr8WxS37JnahOZmJDj/TF/sTcgyhDTY8OXwJrWrlo/qrGlMW41GV5VV5ObL27/A6+/jRZpaiy7fnfVlSpQqP0dI9HCi/n1NlMj2MLZtfb9PPHc5AA3cEvdWiOcifyhSek1YWshNM0Rln4wmLDXzPsgLQWXTf40r8yj0ceezVp0itDZocOhKvYZLVa6NhixIcIc4zlRhIHMpMqbYZNGTuAFVGO17soBGUatnrHe6l4a+Cj4drMBXve/ZDLfkbbCxBG0R3Z2rvDOzJ2R2bDsLKZPDe7Y95Hji9ug0sStlOuG9FGbyo3Eas0+hfeW4M/rml/ETjV16lmExNQ9WYYtbr7wt1Gddjiu8EU207UpHs+XV2kQbuOBrDpn/fOD6Wqm4fu3aLDxGYq+8im0Ft5bZz3wBXoXjA7ZwoaOJKHhiJtagW5WfiBqRzHRamoDhw5W97VLkC9+/t9/0tpwC/qe90O+gLT/Pc0ljBp7zk3+L4hJkwxmR9V72PjfiH/Hn/BHXftpMvIzENXt17/ks9DWIP5vJypObUW+7Af+Kv8hf8QdkYfIvIdzIL6j9M9mftOki/vV+kb+enlFFb0VscymoT2ROLyjlQ0pkPKPub7j9lr7Nh6epGJP0S8Z80JfqdA+7qwAVe2/Bhaq9d2yKa4vcpLQ/gtiOn6wqH4FtKxaBvUV9DKX0UQ962jbWB2R2jmd9vCL6SuPCVM9vo07PVJlxztAxZdLh5ixz24qh8zII262YXs37E4UcflAy/JFWB1WKK3Ns024cFwi/Kteq3wbjK15kqtbHeQFC3K9chPgeLdEf3zKFvfnYhogMj2N4UyXsrk8vn7Avv5XhlcqQ4RsZjrAZHoIQykvqxPArMuzUp6SJ3fuUNEe9MCOtkiUNizimSjV3UDdfPsDse2LTqPoJT3mC5EJNleCUxvRvFLbtVUai1a54xkVCzfLjNaIqc52ytBLICOPH2rSsBbzvfrT7n4WyPECMuzE6j8tYsty8wwc+iFg1bewwPRixpi6Je+QQLpv7PD56hwNz3Lh3VKK7I4sxvbfuBZsGxYzBQy7o1J07do+6YwS2R/6KnWkwutphM5oJuahDYzhz2TsrXatz+0VMT/pTcD4hzjfgDChN28/r6D3JpvjT22I/snb+vBES2+ER7bD3q+f3bomtr6lLGDAXFWBJ0jvHmlV9gXsC1H93JLceMWpAJ4yznZ4gvY849vHseu0SfDp6aKL5cQ3Vz35KK+5l8zCiFJX6M51THCj3/YA3mCHD/dvhdrvOKmphL53c3wXjE2I8YWs8PrImIj6mwyPRE/R9bLQfO7wi0VMPAzZywQOdKCgbUb6lcSLKk7XKP6Qo8osFQnxLe0SIJ2iJtqxzOUWKb2mKSPEUbbHPYeg+rCkixDe0xDIWxY2tuwv73pTQpIPhh3+BxolcT95egw6i+J4NFsG+d4vdIxYBQj20tSLUd2iplTGxm+DbzeSVSX9cuVsh3kPbbM/wKsKTsXg9S2xyzMgn0lTLnhMqE88UbIcCduj5GFAdd9c5IaT+OuOsuTLRV5LlPl97XUN0oPswXL11kjsSVb8d4WrbpReiMrdEsjNPCAJqs2U90ClTWi72MoD6bgpZesqWuCbtGKimO5/LXuTCo34vkTWFd1TPRKIOthc7T1/Ioml05wSIajVFqrkPSuti7vIPoMNU1dsQTrt7j6Qp0WzO/qKQcPyG3w9v64yBmy4izL6kKj4hmk1FXd7e2JLcWeDtp1nUnNGXMpnuNzi++dJIp+sl3Q3SXvvEj02BM3ihqW0xpZHL+dg8/s3eUif8GHo3hX28430mRPldyGcqf3sC/Y4TQZZI5LcnP4DllGMI7683hWZwmypdj8+wTLERysKMWHm+OFM/UqZpNCeSkXFKo5RlTNe6nIRCOzJvVmVDCjXSxRaNPGS9rS+XCZzB2kGZQuiFFC9m8VP3TJuffvNNx24MQPhS/4kuMmR8EsZPyPjD23EAe9y/aOvuH3m/Q2E+a2PzpXNB8O2hm/DrZKsH/vI2R+Q+bnb5Xa2tB/aWc3dHF1dFbyNUPj2mGv5xs4m/Ow9xwQ0ZVSZttJ4kaZFx2K9VQUJKfkcwu55GOId3rYzk53KKXQqBSJv0hWoVE78riGTKpzNY4iZjpLL0NKdlQBdEUjYUteFjFPKwMkUge05ZAoay11TlQbzgVAWB7PogB0tly9cnVCZbB9tQobQMti4ztd/+A07aqafC1Uv5QRfB7FonIqFtnyeks3HdiGg2f8GRzYZ1JIJZA4Nkdk/++gTH1AmsdylYokZakhisee0W64o3B1ND6+SRbLRlVVoWUJBLZwOlmOJcMc7ltopOZM9G5irj0082wU2o1PYuyF7r5ua3VpFNk1h66DUiXVRWA062AdJqAd+lWWq4fW932Hc7jHbDC7Rx+aXYPiHbD2u31gH+6tXW3ylgGoIue1M2wvI7dxnBoa4QjV/RnEDbiaaziNib3DOPv0daRL83AP/vV4NXgZvh+b0Uk50Ws2uv9uk9mr/gLJ7R+PlmcpXl2rkeNgWI/F2QC54wd732orpcEXbaM3bVf8zOrN2M0PtrJsk3p2cdUE0MoZGwtT425/AIrMsbaYfteTdbr88M2WhENoUkxBOL6lQdW5yw1zMYN5JTyGmgVHZ00FyKOUvK5snUkuHlvb94S8Y0DZvfpnL+dO4XthR/3JNZ0FKoySFNaVzFJw83DdRb2ISSPecoRoFlx3lLO8Ll75vBBbG2tVU081BzDgq5yAzCZ1o8U7MOMAyM1CniQGKmoZeSmvdpZrrgJor1HbaE1fg4jRKGcLmjxGq3TiI1m7DYVCjysQxK/01TMtTwis+HnORqJvYIylWO+zGQe1KCm9mVFgbQmRnVmP06/mmk/yooxMKpon6V15DmBufbitADebk3y9uMajudRYKhpYM+Pa4Akj9/QBt7wja2dxtrhmfqaticd8HUjA1T9cDB+L5I3T6sO0RSdaHXViNon3WHCKcu9JuZEiSmPdmny5PuxiJZmlxCqGYYbV3IpRuuNDEvKcfdZemB81b3Cayuu+WTK9GtARqCvu0GumXmDY/TIqFV9PUL2Mn3QvCmtVNQFXrC73djh+m+P6qRrr0jKee6MHPrpJnTT6H3hPTe3vYaivI8pzwZPrO8D3mEPrABIsITtsIyR2pPEgH+lGaIDE/SDn1hiPD4ZogI39wKoWjkd3wTRH5va3/Le8BI8PAWiASPaIMhW8e/Y8PsPdYWzap1wltKQWUqCD5osQHjNdTmHbXl9H63bifvf0IjBicv0tRGBfSb5/oyJUp1dlj4dUH739EkjMhPgrzNlrCnmLfFoNeScNVw8/DJPSnhGL+/vYk+UJ5Qyfj07FxOre+vqkQjSWm932hTIYBoGWVpJe6zRJzlaTFlXIEjWRq5E3sM9yQ0ZhlJI9POyy1sJ0Gi4TjNvju2Ta9xe2JW//ZA3cZEeXKT5dgGD9sV3+815g3tl5D2+9C2AwYiPznyL+Mns/Izk7HCcW6c94SrGx7JdCrp1Ex3zFRIiiK/WPjsPaqYEgkusga4OmrkbRQdi4LrTQUjy4OKrg77xbOe5lujlrP/0zq3x9TXPwFcz5JgnxBaKOmwa1wJkxTUFItLeMO0/u7CwWD54iZ09qKzGKITSBDqi7LDWS1AYi3EUkESd++1FFkVpmVdjPQ2B02ArSCX+bEOB+IELs1xXmB33YJvrVBw5eATKlsKRIbtDF3m0eaeD3ThYVOK+BAf4jt+ZeYU/HPv+NKci33JoVi3/Qe7ugdtc/XUs+ED0KFjwwdxRn1iV3BLKwHNDRI+mPA7bbf3QB8pyUv0A6JswJENtwFN7A68ImQdCfI89XuK+4EvrQzaY1E0w1AsXUKkO0p2GihqI6HS5Awsk5KhD3XOVHnaMYytvux3TjhgE7cd2zgPIuDhu0Hpn0LjA9rPpIsRAz6oCVVnEB8X2hBicpjArdU+DAddnDJ8QMdiCsEsWWamjD87LYs5CBOLOYfMYRoGXZ/PJXgmIejlEBWi6tRYrYUDo4AMYdyv7tbFiGxfZDCHdBsUAxYotmYx/u7mkwjFtaSY5LqQdKgTUbiR6rIpQUz1vuDjo/fEMMeIba/WlTKl3XOVJnpZ1NEsiVVGVThwNvgPD+f/frz7Mrh6vPp8fnF7NdgAKbG5MKKypBXXPeey00yX0eVkkm/AtCn38UpO8Qm4l4zEpflxGe9g4KETkqqKQEQ7MtoioF2ZbZHQJkJjquEf9SNlmv69DVZG8vPO7ZOckFDyO1I5+DsWOh7zCxlJxohm/+968E1GlanGEcwes5zQqTRS0yOZvQaYr1wVuTOR+WxW63M6IJrgAgJBHb+QQFL7LCicqaUzLLL8tNMIBa4K8gsLpLPXAgMx7VxoIKLtRSCfHQsPBLRtloR0tk6NEM+udVqfCK3vjc4IT1J6NSdpAduqZiKcCuVq6y595fSVxoUm45QONc3VAQYi5p5Lt5ELpiBXthy/u9h+qetxhFcjqFgLfFtfe2TD0O3tZVpw9qOgPphQeYKE1qI226DJLFbgl3PDJ6KOpMziUobY1spCbEe1tr7mGnqHFoaoMNj+x7S0/uPzCbpLB1KotJbmh/owFLkUc/MaORJfNE2HC6Vptp1hS4GN/qqUmed+pvOuZvI7Ha62eW0DTz9wbQzh3/Se/+rKeqBmIqp07WHv5VawT0qM3idm+Nk4e5t+4YPA9j3JgvqRwjKTQjVdbIOIcQXvcDV2DtL+H+/ScUEU/a//+CrTDcx2lZmXcSHYX3TpxI3HDYGNsYBEd5apZiSn7r+uQcJRF+GVeevLBBzQ/6RQOY11FQ6jKQk9XuG78HKjHFM2Ls6f6sb8QM0mzE9wWuRhQltXoO5RTvei4LiAbfRvBpNS5it69vv/+8d//ZdZrIJ+MheKaRolNE6Jz8oDOOrwxwbaYFxHP8aY3b8G056F8/4Ynv2N9L0pNuOjG9dcRO47oiVzVb2jBlHiBHusSzYWbCbORQ5JtoaF+RM1XtB2oSdMC85eaS7iWZSpCCLkWa1EHd3SRW7ap3u3KDZiuci1U99LwhORff16Mwge3CH5yjpMsKzmOCVmYZXVvekxqzpQDaUcyGJ2lhfjlKmZ86xKidaU97HGy3f7ioZVaUlz6led7jCoKsOAoTq6WKkCJ5FCz85SMS3d/G/tIVpivAuxPgQ1c9MEtTR7TUVsFvFc6TIp55Y0NxOqzTfXlbKeT/2SxDPavZgub4WyFsvMCO79eYnmgnEiFyP78LWQl4WUZmpS3tX1XvWYsvHZrBkK0W6qch1KGM53INL5yJJrTPIiVdT0NjAZtDW7sodBhPp9Rxjd/BKdFEj3w2q+EUevwmlujDVv5m0uX0BehWfaOz7WhL1CBCwIrM6UhiwjyTh6IZKbQ0grwqcCHG9A1+S19VZVHwS6Q3QiUFy3AVk63xp+n/44qO/QW+rfv+jyp20VnZ7BHovADTOu6qPqo9U4D4yHV8hXAQvN3VdunVkZ1S+LwhxIrHmfXXM3C2q7ECCf3iwBTzOudnuh8xYGvczPiFSQyq/yKbY/aE6duPd4yifqPSC7bFz5At847TdNmsYsnf0Yt6cN9Jp/713rjcZ9e+FCRxNR8ORMC5EyPv1E1IhkZqVM3ZaYve1S5Atvubv9pkMzGrb+tBf6XRRpcp7nksbMrLtuJv8WxSXIhjMiadWg97kR/4g/54+49tNm4mUkrtmre89noa9B/NmM1E/e5X7LDfhX/EX+itYW37+EcCO/oPbPZH/Spov41/tF/np6RhW9FbGL/P+JzOkFpXxIiTQzJ/c33H5LR4OibIiFx0xZtp63dE7TkVgzfT9EZ5wTPSv9eRTt+s4M5XMmBQcPnLOEptSnbhnYwzA3M0+NpLMr/e1O/NV8+w6y2J/Hdd6RFdmBUQKSLHNZUAZ3d9efbMdEdPt5QfQF3bqJdCqmU9jmdOmka9PoWzFd9U443FjfyV8IA2Mmt+Bwx92ApwhPxuJ1Jd2NqoODvagNRl/bngQozmMhE88UPBa62ZSqrfKxaUNnwGCXBVyIflvvQKlnnljHEuq9b9W6eUZCY5aR9E91y56pnwINmrLjJ9++6Mgw86asvuDeRHB5UoJHuRRamOrYGnLYdk7ZX/RPc+neX/lG0oIqBPkuIIMPI3QKdiHEFFpX0PgATGcj96+bhP9WTaacfdGdiJ+XbtiIUGlZwELUai8i86uhfPfaaSrGxP1x4pQS+Yc9XysWmR7HVFGNRPcieuBLvEVMh6m2jWz01baie0nnjL5cG34wWbS1bb90wKhpFY1XfG6H21r1WEr6ph1ZWjiUJ6hEOimmJ8R0QGsyk2YamW5MuWpo6lyMneTaXIT4aHcQ/xXx7YnP1RTZYdzv9xnZkNtx7a0qzHba6rI6u5DixSzWoMc25ogNKdI8gKaNqrnCspIhyYNIgngNZSlEloewtFYl1ufJeiysUl2+DFcV8j2A7xUvslWolQxJHkDSbpKvkKxkSPJQkqoNJbbKQ1m6zTxY0ChTCG2fMm2+CVkfz3o7ZKSLGVneY5XZb35tMTwSpip/6IE73uGXsxxFCKRVIPzKZPSLHM3MONj5RIOUq0LaBINjougVBOdQtcIe5K6YUvuwcwPA+b+V5uLO5csNc4SbdsVprEeifB/i2x+f/UoguI0WzC4J6KWkNhY+8bYOhWQj0RAiuLZCIZ7vUMTPVJe7ne7sWoqsfFV3IWoVjQuWJqWh6LmUZDHMTYdyjiWN8w3EVksAZcKFE7iPcX0ePJvvkmmPxR12eq+8jmDVCLtTWh1o8ZVD1HU9Czh4z0fyqs7AJa0sp6PD+XgPe1ybB8cFlBMkcWlxYEyu1o7r4n4T6Zcj15sq30wUfk84ixvZwe15aC2h8+F6TtgXuunBd+jw6Nfrl7c39lbzb78r3Lw9yEpXMWQGY784dmqd8ixIEi43gFdwlWdBkrgvSs8QexgoA589xh0GyWAgRe4ZwGGQDIaUloMjHAbI4M4Jmx+KZVG4TAY0T8WiicRJQiYyX8YxD5gFm0yWYJjzcGk8UOXV4k1B0DwgVuMKERCFy2SoiS5UE4mThEOkChBTbhf5SJVDMqFVZtf1Sx0D5PK95ynhEfUZ2bx2dtrMIm+34m7F9LqKRN9Cb1tZdF6aeZhSrubdi7RwSlB7bpCbYmywtIBJtfi1mltKMF2mtMljNwOzzzOS5+nCWoC6jYDqdH9Obvy6JGk6ZJrWGfXcOdJqKa3K530vxevijCTJl/ETBbdhkVOpmXcmbpEjzr1wemCLEmN5jvh244shF+ZKS1yRIcY9MJZuNA3hsn9N4wIC3V7a+XQq6dRgU3WRtQzpbS/tmtE0UXULXBUivx380qJcVDTOkdrG0nxouCybjMSfQ1sOuGfYotekvQikNTYlzs4Ss0yPMhvf4DcrcSk6Cn4BJ/CDDg8+ZtdwuQQT+qXyqz8T6AbuSI4Yd5Rq/xvVhh7m6rDo6grlZ4JTCx7bApHc8khYW3COq6dKLQWVViVhfr0P2WgjkjXehVT3LTUT8XMERS/F5vls0NMEBkMEeBTAr4rKB/GieoRvdeRK6IRKSZOqnx39JTasmA2RGakfZQxBL/EJJxDh5rbng4+7XR8jGNiY5OdOivA2tD8tCVfExrM3YwI3d8s2We00gGjDHhP3C5Q1Et+YYvpG02w7N5+HyJrQgj7QGdHCEeIJJC7liUH1LZXJegqvKhCi07A8UFWk+mo5POI5XKllAPUgNxb15YUvbXgsixAl7iX9clzD2WT6SXwD3H36OaQlzcR8tSmvCpHwQYkv69fcUfNUUpd2y8q1TcuF/uTUofllKjgFdn5105BgIpjTkFudl/qi3KLSZVQr0tQGx7RFOVsciOHY3VD8p2bW62w5J4MVXHqct7esTVvL1mzhgU68r3Z5ishas7LYDJr0FWpHExt7Jxl6fTVT5SmyO5QdktteHNFVKkCi8UP5hsyJHQ/C6bLtVqJ6a4IkyZCTXM2EhmBEQ8KZZn/tSDvV1ECLjLmS4ABJHZqPGupeBR9DjvtN2bDN7RfHzi9JEdWx1gV16OtmcGEhH+iUKS0XCHRz2dIzcl9cf4IYDxruzNVm+HVz+sdyi2xKkGLgCR1P25V9cfRv9IzTV/2kIue3GnGho4koeHL2qGZEmjVZHR2TKvzI7J4DNkpeyUY/Ut3uzi17CBDE74FyMymBvLTwYdULU2WuzVrNpgT2sZ9bLgQSrvcD0e35qqqYSjSS1A2alnz79Z64rTuXdXWWFNLZhtehyb3kwHAIZYHcMJM+yKkt78Z8pqZdaa7l/tY4JX/Rs5zl/iNqDoYLHu8RYKM2y3989KWZY/N7EgbvJumIlpHg1TPLe2KjVS34vxQ6L3TdiazjlRM2TVmCNjd6F3ybPsP1Bpl54p4sIBJ1dx3hPoTcE5I7Abkzpz+15XJKE1XlzOoYQPUjhapQGJ8i9/nTZKq8HiWhr7aK9sKIbNTM71fKC9OzfzVL6uYMr/4Iuo2tMUTJsQuMMePEa0i2R4ze3maby4m19QVy28htKTUZMlspSsWS5TApphNSpDqq+2U/UC1vCVY+ZA/k5X45cVr7JTQFey+Wwe5yvxCmr4W8INp7mzYFhxrQ2fW9OrMZFSDxjC3kpurDZuVQSzoG0PswRnnu0syYfxvj0r1QemoKbDjetXBbLcNlYlPl4t8nZiuNC0KFkxJOtYpJStsgTcACbCQuza/LOBjmBIyKU28dgYw2N6cpEjpqNEJEOxEx83usptYGCh2J7pkInhLSmGr4xyyzmaZ/b8wHmh8355/exZRLp0SV/I54DpgCIKd2TuYnMpKMkdE+cyQEtKERKTNiI6HdU0jEs31yhHza+aRsjD0Mdxk+BlhfthdOB6u/+wqrBmpDDSZSt2CaRqwfs63gmnRPcze49cIJKic4f46cGqVZs94mqKYASfXOgHKLr1XpnXzDS3OOJclb7IZMGedpKl5oAsD7YATzTvCegoQ3YSltunBA1Ap1bYSNIECVbANKCMvW0HK6vwGESLSe+PD0SAx9TqkiQ4JHOGNCAbY8JHjk/BYJvrUNes8Peim4pq+66SpXypDrES2zr1y9m9Kk4LEznz9jShXm8u//1/zv7DEjZjro1lIP1G2Hgf3qPk5fjTIfyyAJE8bpXV1kU9A9fNW6M5eUcaVL26s78iTkHePiEM/CRJKXC+GxuOO+GCEN7b3Q+4Ypi/0qY1m2F6iZ+b0p/Ob6yBkelWejISJrKRK5HcetHLSSUuPmDrs8zmc0E7IMKHpH+KJ2u3WqMjO4F+lew7svyg/tvkQrG5VFrgo7qqVsbsT6Yz/Om+PB2PoTkPHmlZfdBCjTJKzaUzpr3WZc/y5vF7wR1RZjkxXjnIzk53IaNiVvZ4JkDrUyRUTLxSCevY1vkU3TpgTh7GmRjGSWLCWQzoHjcefttD9g6EFGB0yeH8QLTp6RzOEjEeLZMgQFD2frNz54OoH40Jx2hEZCQXvSvMNHDTGF6U9z8gkAQgrRq+ZUhBARDdO3phnOEmKWEZ6os8H40h26DcHybC/DCLBFaSTq6pwq7Z2BuNCpyISdQTpm+ygcYNdZaylMIZTVpuLf3ni+o2ic4cUkJdOr+mNy9ZpTySBsJEmvy0tvyyypqL5MiVId9ET4GFw+jliTE4LbYR7aJ1jWdHYpsmQ1al3e3tSJEnx269ubTQ0MfoibRHvPTzAyu7TS0rx4WRoqKF+Ofcjc7+8MkESznyKNspxvJGVVAMzypA+ToDsnfKBmtHQL0IYg3KXVabDEMxo/f+WqyF1W1QHR5F6KVxcReONVBFgCNHc4j8tGZ3UCyAtU+cUirL4u509DxmXUajqmVQ0LOp37MabrzVn3Qha8I7Z+6kJOwyZhksZayEVjMs34hMrB8gUk1msd0nuNT5DpZdiUIiyEhbDeD5bTIc39ys4HxbIjOMTxr2cJtvTdt4UKtVmQv735KGIpWxphkSIT6lPKEXY+pdyp4GDqbn7fJawOc8G4RmglNGoWy5JCLxsTRa9eWZnHsO0CYtuJzWXbrAatGz4RSK2iVm9NNJ+/4vPPgkNKUUlizeY06LnsOrYc8uOufC9XZAhrCRbEXVA1J3t6LUXmSjQ/8ibpZiK+iPIp47Tc3/SJBk3HgUzKVNYpq8DeezlTlc8ksXnPtKXohhJamYL0ZzrvaojF9wDXNt9tgOoFuOXAG2M2jdwCCGN47GxyG40QmgGC/wklPdAfhanmVRWbw0rtqc0up4I1Dvn5KHtoOPJhUAMwKtkewc+mXS6DzvqZ75LoLQF8q0L6EoL23eg9Ib0Tt73+xT/+0MbXVXyb8gNrFd/bQ59xnicphZoNINYmg0JXcJVRLMdFlvu5uYNjPkqhojC/YRY4g5id5cU4ZSpUEL9NmZ4V47MXIZ8nZoBQVbxXUmgRxalQNHL3RAlTcaHA2V399hQkrdWCDIFutZujpuQPRXMq3nrlyEVOKqblF+rCPKMliSmCfANIpu4JZzEyROXFT2uLoWoujifad7VFc9ekNuefsFddmILOXKgYCIWSW2i/xbVB3hWf7+UYY+bzyz4xlQBZrUWbSX5vNNHB731bSQ9pSmN9w+O0SOiXjDkdv01n5oUw2u+jnYW9wjJEKlGMT72zaExypu1mDbLbOz8GJ5khGEEdUhbrM0isBmkMI6ChormKbJYm9yCC3ruRrinOIAuWc4i+u7v+ZJcsSG9vvRnSe0vba+zg5znlyfCZ5R2MVvozGyAiPGErLDdezuW0j5sGH9IMkeFJ2qEvDBEe3wwR4ZtbIRSN/I5vgsjvbe3PvQcJHt8CkeARbTCk3LEf2DB7jPUHxO+00acj+krjwtTaVjkVU9A9N+MQnFsvklsxndJNKv5tpaX2QVtYXUa3E1XGQtIzp86z7crpm+HoJsvT/bNT2nKsfvCMvroYK6sF9iTTs+0sLFZmkaXAi6sOcMQgRsqX8ZPpw6UaYJfWlf6NnnHTQJ+Ut56PuNDRRBQ8OXtUMyINxqp83VmD93eCGIRG9b2IPSGx49rYernlJ5TFpQwRbm10vUW47MmkJeGK2G019IrajM5b+dqWUSWxF0o3s9hnhPENtCZUxzNvKuyGNPMyCL3hLAz8SU/WCmauYC1QRuLG26IMygHccLk0Ewd9Pp1KOjUN4kuhTSct15+Hbp73bkf349D1cDv8HeCh4UG5iHJDu2dOb/i1SBO/zlwVHjhXKR93i/+lEp0Ioa23dYS2BdquwKHVGQRpgsihCKuE5SMNVHEtMmoecLDcaNYUILZlM1vzAYIgMPeSzhl9uTYTXjCzdBGJWi8hwE3tzn6wK2PU6gw/BW3fTw16kRIUHGO72tKumpPC0GFtnl5gm9rYpszVe3OFJvfueklpSdhdXLWjgHXqhRdWW05U2lji5j1nitIkSoh2U6qhOaPJg+ljIjt226/p5bLm9oI8D+ZZHiDLPVkuafd8KhyztE/oa9cRgppSFjaZktX0QkXdRvPITEsZn7pdFVvNL3mLs3JVkvqRwseUwogYOfKmcPi1rvXlsI0KUcnYX3TpxGWO6bBRxOYGOCumtIwsBvqg8uvyIpmmOBr+JIChDH/Hw+vzeLdtETBvy960v09tDl7x5aTvO1FZF0O+fhAhpgBQF+MIfBAgcOdGPDuKsw7yborinZmS5Js5Nr91QDUxy7uRsKXfUaW6t/j6UJZ2znZlhZd2Z7AR+/tf9TUc03YUJ2lq5tJzM7N1ucfuh7d1wIZNFzuanX5MNfzj4gX83eJYFrl1lk7qyUILz8Tmn4/KQlfiXzgDL3vLubsDiW0pzfzSuRsBaw15WmTcxp5BaHV8CgS1C1TKxuYxhHWirpiR/LxzWU8/sgsioKo08OGgWsUkpUhqKynzYxlJxkhpKyVOS0s/RLSpIakNHztkVA9LUwR05JQJIR02VXoQLwhr21QJAe0zAUBKu79uyGiPwRshbSytkQHRcdNOXYd6upVBHEEduu5FYod8/pDW3utgRLX/jAFZ7bkuRlA7QSGpwyejfYK1PYwPyfN0YcOAqnspXhdlgNol4d5ezQPmnHOlK+eZLi4WiGuvkst8cLbE8qSMqoT8dpbsbBi86aQt5hOBxE++G7dd6B7Z1QTlX/PEhvKwplZ1ovIl8QFek4kkLxfCmZz6Y2S0woipy0JK0xAvGL9xIUdo8kcqxuZg4Q0tt9zR/d4M7lXbDOLvCl1ATa9e47RQ5qu53YshoeNi6vOol+bOcUqJvBVThbTaE9SVme4mLE0jd2KP4R46N8W6Qe8KDq8yBlMiRHlgvqtm0TeQNhDChlifnfZsUC33IPM3MPd2oRt5r1xH1ntOl2AMEcqsjuxcyKx+EnNgRhe9KO25y3NEehxSF2DtcknYiLy2fAEhHwdZ0kzMqW+qrMz6vCJEuCcegBulI9eWdUeeEg2+z2ePKRufPSnBr818DdFtQXekQzQy3LlQtbH3iEWJ9A774jiEZfplBHfYp9p+TB6oWc9L03/Pckm1XtyD1uVcTm1X955uLRcQ8r6QXzXlYC+jnFb1PE0fqCpSfVVdqLWrLRcR9JGgnWtmC+SVCwj4cMB3ENMwqRneMh+0uu0CAt4TMONMw7ucP7HVSZtqlH5ly1KEuidUmNyblaYWhtaZMl86G1b4TyO144BP7r4qRrwH7erZcfUODtU599v4bUPvxluQ96l5F/wciZ+CuCQvLmwXHNnBAZJZ3EF2YLfajWc0fj5PcfPmAKbUEFXaq2DdC8wgnTFFGxrYJfm1WSELHJj3T9vltDJn69oZU8KSEJHuj7TK/NJM3HIr4mebLKHZhE2hq3IE/eaQfpbq9JbOaYo0dzfbBi7Edzi+B/eZ8oZoLvrYkggh7qujvTSFDJmuxsbyHAnuS7CMxtUs2xdl37nlOkLeF/ILYfpayAui45mLCdoQ9CT/X/V1nTXiAxpCd1TPRPLncCDiC5Eswk4v9v6s+pRP7IS0MIHYdrQTltL6sjqzCp7KesEnjSxlmKb953J9Qq4f0l5tAW4DCo6Q4RFtExnuyfDwwPJ9Atqa5XkkvjHF9I2m2d5ToUtiQLkcF3CEeNqKCymR+3Gg+pTxftk2VVE5ZzEdiWdqesxMvDg36ZmLt7NXFk+7qHXbr3KKPBo8mOq4O0r9AYJqTqWzyp2RPF+cQZgYAp7yStcp6hXVRT4gmuz+uJX53zTknV/WvtcSRFeVnTEohDbY2SfuhdLTMp+ppkQOzA8shYhvc8tDesfRay/78dGrY4zct9TB2EVvK896ErxgxaBZz6R4abjHvMbUaoWd0215dg8p19AT8ldj3qKcd4u0ZtoaSEfe1KVsvQOBv80/wBqdtTXytgsI+22wK0eLSjSS1C2XrWah/TpSfzfq0kpgtdpB0M0JapWPaTC+L1Kn8XOHQSwrT4zCGn9+5arIoR40gYlaw5N809WwoZk7hlZL2vhoO4FL/pUXGjuY62A2Q3PANNzMz1HImkgyFToUm2vKlgOT3KtXGhdayDoN1dqlcIGtpiK0fMzPm9a04CzsQQe05vY5OOjiJP7EPBImqfU5aDQVxidUDpYvhD4OpYw/2yfhICQY5jyqdydMCcGSWO88bhe8qZtJBUmGTSkCQkAI6FSrKBst1Z3fGk406WZm73ec9IWQf/rkH3ctXJtS0OWI4elwrYtDB7XifmFnhrD4ApWPe3+bl0bLbSGBbD58546dwZw7DhWF3+4C19HKf98mlPapDtbkYYOiXBWSQg8aE0WvXlnpB5ATqWjds8DMLHBSdcKMz34EvzatKQnuU7eOhinH4yrLdRkgviEJG46dXK58yVZkCEjfcC2FymmsabI6M1+/FjYwFwLYD0EsXQoM3JCGDUmRdUQrssAB5YyXSxK/jegk3TSEWHN9tB6OsWS5bng3GiznaQqGuMOCaQoTwEvYZ96QjGKckr/o2TNdqDLZU9cazRuWW+5Ci23SIbZ+3DTJevqtqL5MiVKfSUYR5DFGk02CiHQvpG2v6RPGViNmO/qdsSm3wZdKe+iMMH6yeEJNASJrQ1YeIK6VUtx3ucplF9V5sTpPad1bD35QMvyROrfWwfiKF94axx0fFPDeDnl/qhvzQzWbMD9/a5H3ZBbn9hYEB51dlEU8ygSfimQcTQhLIbTFi/k4RERHGcnd049ZpIW58Q5uHFw05rf/Cx4wCr4mf7s0p1MhGVX+tgPjajyWK7H61zlzxptJrQRpCrruQEjimKY21sJZwhQZe9/vgTs+KGUISHMwOKa6jHNiHv0iR2Cq3Mdmy3ikKNRY02hqGquLgthsrLsa6fBft87RCJtoZ9ELnjB3vd45vVwRdu1PYGfhznxHkMRNyq+lyKrYELdr4spCuY1nXZ6fGTTMx5YkCKosr7lQamzcOFhXr1DR/sw2/epQSFzS/DxqAaxqjiHWu4XN42MsEpHRx0f4QAqlHlPCp8VaLmlFeDIWr1XUbKFpOgTHa1vv6myt0n83P+7v/2H+v1el+Vw806Mr/d9rlbbWyJImb611ItmcyogkJIfprFvxVf7nmfnRoG0OsfLDvlbe9/FxkeWRM5TzO3AF72lVp5LksyihOThy8rjMReq/EfQPuNzTqgueLiKSpuIlynme/fYEU6wMJmlfFZXn07bhvCftG4Kz9bxhx+wsL8YpU7MqxjuBAQw8wJj+RNQsjIqbv7BLnhdMdcOo6AN5uXfT1NDqq4IZscKqcFDNOdS2PGjMNMOpu9UQBFn1SybjIiUyzL+7O/0ik5Zd215W+i8qxZfCdPa2xCB9/TN/pi8DOv9GJaSQDKnWN3U8xdBqf1mYcrlr6NdC2n89AxVSE7AVD7D135HXutY3PJY066++qLX6650/SAzNnh8egPM0LUc9P9mhybWQAY2Ar/qOcSGHurSWCqLeQ5rNqQRduW3/F5LwUCZ8/jiYP/WV2wcLTW8OewVhKWkmKdGaBjKFszbYilq7vlBqDLaQitrPVSAtmqXmrxyeFsYfhzV8MTV8Znluyg2iui8SvFzF/fP0TxXKEGbrHJqmwW0ehDTDJpJexUItlKYZWJmpe6IgQXBAe2WBranc4qI1ElEv6ztMzafZhyKE5Alh1FpRnjRrHo7lGSygw6jtH0x/Ksah9WcfWb6XVa6cIdSPFILTUFg5Rz8KKheRJlNnGl57Q9gLI9K7Me1ADOC8/C9EUaK4o+bhpPdAvLtENKYa/jF8zILl740oLz5UJZ9TqQfWxaLdOzQoHhnJkYVngSBkmYo4bBRukFBlQrdvJC0oYoChgsY27hjC8DCIeeul+SUZb496HBwXOxtHHhUP+8qaCAKxr/wyfqKxRiAA5Cunry4KL/DAT245vD60hC0KkcO5nAbIYVnkFLc62RDoIUgcF1Y0/NctSJyb6ZAim3U2d1QTxLKGxSqEemg4eQo2I0m4In00UDqSjt8Id4yc/NwVgHzWWo+NMVYnf0c6m1vPNbFpSxFTHS9xqSmFMeFJfkc1/TqDsFTz6/UPuvJBqeB99ZPfo5nWLsDd4PdP5tAsa3LBFe3z1v5uCOSll1GE9iEg+FeuijimSk2KdLlRBInjDwgOx2JHItTBoZGZJLCa51RCyHczJNjle4AEzIfRtv0w1lcbPwrBaG82EghIR9PCwIc1siQC0cTsRyEQjYKHEfTuezuDwHbcN0BQN8Mvg7aE5eG0gaGWjE8DbgPwms9FNqYycAjhmJu0QwjQxKQdRBhmJRvrHoApST1JfBHy2SfyG/zuFGg2C5WbGkBGUhUkjHunQrj5EppSscEgGFOiDd3huz0JUIfQQiFIPUJzPPBraEcjOF3CLhJh6ROWgYSmZ19qBWHWGiKLygmJQ/kmcMgimjKlo1TEJI0SosmYKJ+KCS7cgnxQivuKxecndIm3IllwzTLqkhW5/0Y2+2qZM9S+9IL2L0jKUUDUgscIw8NwVmwudWphXn4n4ueezyoOx2OH2VxCru4vue5h4PKj2DwUnMN6ZFiw/mquDwFirgbLgtVd5LelpHl2pIVfHmSfycxwWqYGtURgfHW2ggGPsq1UAljZb2OiqGQkZX9h/1lrKTDLX8q1CllHH8QLEqmIfKZK0wTWPSEyARxRRvIcO4/DAmvlJyV4lEuhham3BcKFzOwQA3Fw7/0VGy4F8VgrjBGZTmnS6wAyR7UX5LLExYw0zkYB+06JJKHV/AUGl74b/R+JJuh+VK+TiTJE9Gc6D231s4yBqQGlOdi9xfrqR0HSkGEk4p90oe56mA3zwK4xoDHLwm4LRF0Uk0nYg4NpCEQH/pW4YNOb/hr97MfAWQSHzECRiZ1TOgNxNlkECMPMl6KJqRWfRtbr3NkJK2vvYoS9tvs4FIukeibFy7mq+SCajWgeyAu2ngYiSOMIJ5ciocikbDY88bEt+pmP5I1kLgVXWhIW4lwllotcC5eayB4GjQA8OpGCJNwU+vXrzSA8DGPQYDSDYl2KzDymaRLehiXwcLlOcvO813k501WrA71PSUxnIk1CXOBsA/OH29UNcVYmyUu0ZSfKTFebm5fh7jPs4BToHoP6kUZVniWX2BiI6OGP9NKJkcn//A/J83RRI6FSIZX/+Z9xwdIEG8pKQ4FElAEzMcs6WPK5aF5SzM3vkSPxRdN0aJPuhk2kSt03zAk/58nVPMhG8kLHMJHT8K3xnnhxgB/fhgn42dzMQhKiy2gGPhDet0qKdBp0EkHV0JyqyeKhSLHlNNk4DVuwasctZMLWVDfBMB5lNBOwnJYCgs82vthw+kBjIROFkLZB+sKp44SYtmFyhvbYovZAdUf4AkFtA5UwpRmP9cUCAbW3JGKeC9IO6iA8QyNI6a1pTQiqFZQpzo1E/6SBd7Wmq5SNq2TO7+xpoGYg2+CYUq4ZTZMrriWjCuE04Vgtsm8+SKZJxsZulGTxxYcyRTordBBLKxY71iCVFSqBbmVuo1Jt84KPwMg8ETYeZ0rRjEACkOzGxIN75FKYi68aMW3A1AhwhIzWGVk8GU2Y6W44HG2AxNRVlusFollHQxSuzTeRCdXBaR82qJDfxAZny5vZ/CkYv3o1AgXZBCCIPmrhN3cyrUk8u5yxNJGUj8Q9Mf9oRNWCis5JajvdDWfaxypDTls4fcnBijt4a5cNHQ/Uh96uMPDu5mxcIsupYfTS65yhR5KBvlWYVViPc+O8qc2MaAaWiHT4I0U+LXyuJZmGacm8FY7zkgjaH2uPxvNAXrBfraIB49UH+qNgkl65wTn4Cc8ao3LUgbVYvzNhHwkonhX8GclsImN3k8MGMy1dYl1QoMpD9oFOmdIS6TTpfBYvAbsQbwHztWAJkmkjc4lkNrWZFMlsGGYIFzfIppXNvRRJEWuEY+FUEZAj9cNFKqgkwa+otrDBBecuPGiNsQ2QS54NWeSD9FMv0wlFGeHmbtkms8AaqYe+S2tmh7z25DXUQbrnHEnrzomR1zZeLucimLWKQt9MBnRiSkuQ2QZmjXCU6y0tUKeeN6H7LPS1KHiC7A5nd5kKRZHcEeQeRJrS5MK8BekdTs9MQ6T2nwzkdzi/q1ca2x+LDI9maL0EOEkhHDRT2tRkgRj3xHjDbXSbJk3zm+1e8i2d07TXIDl91U8qygQXkuYiehHymUiYgkR5Whi6Zr2f0NffnpxLsgsUO2DIo8njmqX99dA+hIjDcW/FvR164E1TO9a46l5agR1KfJgsevWaU8nA7IKk12ZFWcgee/Bv4ZETqWhTOpyRHisEt5B4bErKr3WIIMYQoR9hbOgfJYxg+0lGnim2jkbrGNAJKVJtvihC6gAoJK6+DQxLknAIjKhqoVBLwyBhlnc4v9rIoykIt/7N1hA6i2E8o+VHJFwKd2zqvB9V6CTAAMNlUQibwzdGX7AxkHFKg6dwxYsseAgQPNG/IOB5g6ZcBfWVSAVJXGWvpchAb2153K6Jb3he6HCBrIuRBZuO1Bf5pwqXhN1HBH/le6Jn6oZ7KuJ8bH9QCG2E8rn3MaiVVVd83u/N5vXqmyr3OZz3eoXNv1hbrG3namsKoRwiRqlIaSFLFwbYsIaqnxd61uuv+476X9bXh3C55/ZC3lAoMi9IlUXBizQFHYnznHPBwWGBGIJzzy4aiurLlCj1mWSho/hcnmHbcEAGY0Bim0fgJCAnOLJwLM75AlEoH5LadZHgMZT9I3gQvnMEx8FaWqvSvMXe9ZU/c/HCIXYXVc7g38W7cHIrCCIk05to7bgH0XFdZ32usX3J7c4w4mnHs+V6qMhs5SGA3gXR8eymWj3PiKol2J64fig2jU/VlVAxpaJKBxlGRvF9SIDLqZYkDp4FU/eEsxgxwDhxK6YIohowkcb/mF80pxLbBbQLG5k/YBJNpTRqqVvmYP9sXSv+E9fVe5Laegdi47pKwbNl4dhyD6JzqyA70du8SKov9xWY+pHGLvcOlZGd/Uexy5G6sjnN1JBkedrf+Ft7k7DXep5IliQkBw65uY9qFZPUGSs0zi0LCFY07nuoon1h3NvzIZzbiSEY+IfOpOffm30xWO9hS6Ln+qYj+koj1k/wVHzIlorNuXsQubRzuTbNRvQ358cmPG4y29TGDCSb9zzI5x4wMpIHDALmo96hypRIv+rJP4JFUDCu/9HrbEk7EYwXur9xGDbVPqHuBY340QMvCg2F+zKAR6XL7AiJiEei/5kA9uRhvhU9zh27b6Ow6T4HPso6wvAwEIQB0ecWUeVoimY0zSF3iqHwpASPZB57daedQz5QlQuuwgJR5aq6lyKmaiXRohf23HDvCDC9XnTsz8N0mSLVnwhPUoo41vpNUEQqoW8O3tRsWYhEpP3K9H6FYn4HI8kYVVgbQISlvtoAAQkwFSgDf2wh3MHxYBzMPuoODgHtkW0i4faAPI9A9sUOYRHIXtgmJOb+S5KTMUuZZv1XfG/CYF+EIGBO/SKZBjstTn1mMMn4NFQcdi/sTiTULc9DwrCu+A9nE2Q7hwA2QLYDeBAvAQMIa/dnLxDBQ+hzS4BfGI3Nm2bwSyJNlTZC81/nujQTRZp8zSGlxZCT3JxrFSYKc7dXW9Oeb/Ps5AApXq5Z2uO15l4IBkxSWF72eEGxk8NFea3XGSa3Y5AFL0eGYAFU7SBMArlZRmu3igyrE4yJYnHpYSjcd/E3e5PlckGq7IH2lp67WIKvnOB2Ium9LSGLBWgYUmeEnGWTkXhYuRQ4lNxIKTJZYjIuWJrckfxaSE8mHCCxGVK4D6tBcqbBSTvM6hc8RAADZlXTRC4shGe6uFiEU/uU/LW4lyKnUrv6NwXhYLgk8cy5udmjK65luLUPp+IFZz8KerHww587Caf6ImNuPQEHfa22WSlRn/zSLyKg6o+P9vjx0Rw500A4btw7Ktdad2QxNosKg6i/JuhvZTSMqfmAMoF82vnAbNssXbH9bGo/VGszC1XIp53PvaRzRl98Zm+ktIlSrfnBFrXfiD3UPVYjvxWSkZnX5M526Wb5BmTWzszrl5DWXrTIRFN5nqZld8TxagOoMZ0ISZHUblKK6iLHCfl2SJoSmYgXjpy2c5pYsws4xX63A9WUVowGTCKlnZQUYtqIKSPPdovO/YSLVMTPiGrDhJPyhMrlFXKwg1Tj+lkulJ6a3/EjNTckXgNV+ekE4pNxCLDSMHcbrRs+EcjKsFrsaldIypNSIZNS8YxmJJqAuWaUCpL4GAxA6itEhnebzozTsAlM2Ct8uO6JngXeFOBC0ucU9Js4wOEDTYmmydDeYm2cKyjrlxBQBQhsmFKKrWYJyoRxL3sQQocIpq0fBd6BVpHkLiRWry2eNvFwqWkoV+bLC57IFkh9GhoO+7q5OYnNNHVoODDN5szbBbpAvtBuIK/YSPyTLu5InvfXJ2snpUuRmSU2c1DUgxc7M7rWS0hqnZQzuoNUwsHSueF3NBNysQ6nvPJZJBTxbMQzkhTxbMYTxBhUOtdz6m1bgw5u2EYhrMiGbQSCCupXAVgJMfHVTG/zXEizXvxMzPzObjOFEIZnE5DgkjJsAsEh+Aj4fj2SEJK27MbAi4zK/uag3x9EEkBUnt0UwKxRaZLliKJCof9CGDqAwF37UcDG8JgJTvHT+fiapaFC0OJP1f8I0Ztq79faFyEkvtvZDS6YDpVBGJFNN64pg4rquZtC2ASCagNw4KJdPzyc//vx7svg6vHq8/nF7dUgPAb3VEITuPkSRsTvdQCfzUEw+UPaq/9dBQ4goLwpLSOA9UkHDIGkS9kDQSBZUraR+KR1jg2iiaHnjSJO2ZmKJcu1OsslZVxpkqY+wNCTkHeM93dPcq/K3xMdzwIkQF+1NG1/SDPCNYu/ueXDPZH9De27hYaNbHxHlTI3nvPk6pXpm0lzz1ok1CPqMx3v8lia+fz25DKUwnEI1bbxaL0+MV+4iD7ficr6H5y2DcEsE8n/hlVnSfOUxPSaSaVve+wcZkdCMze64T4S4wOd9nxoW6pupSrvs+PbWq0HdEKKFDxAJ2x6w/NCB1N1OAimskQpsDut4jjcSzE3P0X2HcCwGF+KzMxn3WBuvtoc1F+mvWsz2w209oFV+3Oe3bh5fa/NbTfU/iaD5UqINR9QLj4LPSwXbCEyqE/7XvEBHRdTiF/h//b+rO/Vvry9cX5+tzd9r+o3Mz0H+19b3/Kk75W+tvv2tsrusO8VHtGUZlT7HCjVWd+rPWZuR2JmhuqU3vCEmfl5QcKYspRJBC2BvmcUbK00RGEqTPFcOxVjAIplO6Q3LJQCqfJQFwlzkxR3aP47mQRU675noNj4hw6owuaWrzK1OTAD0KYyzvQZ+MVHL5Jp7/MOvu7f7WkQ1Z/6r1niAgQsfcmTXoc42onBzdsDaAh5SjQYmZ6RODbzduBwRq3G0XK4CkL52AYhYaqiMHDH4WAo9OwsFVO/vrkkaTo2N8MsIFQGt3AUauV7neanvfJqJl5c3c1BcH93Ueiy1Yv+by9X1X8R8lmZyzTQP39epCrkz7+rf8hf/seUja1Bla39J3Ngt925DotA5kxIlTeq8uWHjACyZAS0GlpH8GX8RGP9jaQFLWmoIIyvlpk8KcFBNWCZQKgCSyRgBg90zuah9YwlAhc2ud49kSrkdvAlh7eqsAiANCeSZFRTHybRPPpFjmYypGmzFPBtOHNBrp3KxB4GRyDQZZOvfUJT6v/+A3sYDAFF5ZzFdGR+Lw+4GyxhCLMvLCEIt0NQPmdS8MysnAPuD00KYXaHJoHgekNGuDmHukckZ2caxoRIaSGN1Ae7MxI1EqZbmB+mGUlV8EzimsVI2GEUmcAiy6IYOmFgQGBXxgXFMgdBGJduApCGsAu7qfJ2CzqIrdgWAlFsbWwbyaSgM8BAGYPpzl31xPl9750qXOIxSOfifICr5HTuNIzqNzJzXBGZLs5jSER3nZJpECOkg2DjnXzNwanGRz2pw6AsiYPGkZFn6r1JA3GsczjAQaHpmVCa+XoWNHGhtILyXthOpgXItRQZhA26E0kRgEXsUXxuRUzSe1dUn8OX7wFJ0h8Fk9QnTAM4YcBQLMtTOqBjUZh3+6zKTVEYGOIZjZ9zwfxMVRb8spK4xmLPg4Sh5WIkHihJwI4YeoZLJhwIC/vHj0Sh80JHOfFrugQ2TjPGqWscX+zlEPxvtlIxDw3tKwZMIggPAnoMJJgb2tCHIS31Yjdpt6qPyvO2IQuov6ySgFX/Fwkho5gNhNbEEiiShCzUkHEf/i+oBV+e19FUYLaeBxFOxdWd52YSahpBoXyUaJF8ztXQSm6FeC7ycDjEJNeF9Cb8c5h0OkFAmrFVDPdC6ZmYehBBM2i2iIDGhkLO6cIHl1MhTZ/Waz+0Z/3OKrMfA9sXgkQAC/HULDxvuFmBTkgc5lDgQjdVzSFIBm47dUgmtGwTZvL0usD2QBc3WZ6G2SZEmtJYX1OagOd/kAyslgGmCeHoF1YImIEhCXimZCMDBVx/VYwzpkOfKEHKkACCILTWnanvTM8YhxykE3DzCsWORGS59icJpfnVq6Y+OjNTw5zGbMLiIDxfdwOJU8EpMlliAqeXwOVcSrJAHsosLv4A8xGRU6lDBOKTFDkX2V5nM90Cwdrn1RaKQRlqNjAwNWDyypyXH9nyNEAWmmbgLGVuUkLqO5HQ1HWS+rT31u5xfnZ3eV8ZDIWxY9ms9V3c+825x0fTxrV6fDx7LPetYV0ZxS6rkfMOtaJA8hyVUVfPvkPmVh+A96H/SSo31t2usP9V0CLM6vvjYOpu5j/mObNs0sMfLnntkiRgDupHaiZEIShdt0AA1StY+yVGEEQo7q0sIN6aXS30GQMYgHoKQkZaWSxJlk3cljXJqI1NapvFHcmDJXFdpOniXwVJ2YTR5HO/tZLbUQzu7q4/Wc1CsAgmwbcG6dKaR+4Rt3rOIRqfz3c+ckUhlRYqYFT/lT9z8cJDA2STn1DQ0YLzmqoCbVyVon+yXmsh9oYy92kLl+AgGN+dlqhgd1oHtJRRB9vPKh6X6xjZrLCpTkdiWEwm7BWhgEVWoyvBVM8sgwKc+7ahYVU3Qi5NLjfw0pYxpv/hmvdvOhsQIZvNbKwzbv+9SPbmlIH2nvHpnyrY5gNEJCfpSFiXCnM0KHUU1pLYLDvPp1NJp+YD5vz8Q1RWbKHUfgkBNZsRfNhNNwvuu2X3zKuQCBR8E0LsPS0YXEjpO8IX5zx5oLqQHMlYMj4QHJJpkLnhcVokFDk4Dth5NqLB3rOOpqW5uJkcbMkGTaaltSAZS+ZLxnCqUi18cAiBdWDdNYLn8YcURX6xwB4yn2InqebvRYYwqiU/4wij1n+8Iox2naJNRotMUM+6Zfpl20jwU3I/5ziXU4XzL8finiwglCj2lLKnYONo0viD4iBawRjGJCUSkVB9zWiamJ6C01JwVC5p4LhhcWC7oBo/q42B4oFOFOq8zBPBT8BNSzhPU/HifNnCbg9gqcmT4TPLQ2wWlaDaLgkhA8oeKJqZtkbqj/La/8/emzW3rTMLu3/lq13n4lx8iuMhk+9syU68lh17WUqyh9rlgkhIQgwCDADa1jp//mDgKFKDk6wh7H6r3hURpAY8bjQajUY3bCj+wMBQJinjVJ1mjMeAD5x4mWCRdhZnWfVhIj8zzcyFoQnysDzyxqIN3vAx7ohwV/k+1w4cB0wE4QjNsCqnPKJiyZnufTq2XXlM3cQSrpFGsV5xeUjyk9OnRFMEc9xsQiAhXbY7JQMwOUkHjuLYuAvfP5kTJrQpNK1GPH7vKbTaHzFiCpkE10jQsc4nci4VzNQdHWRiymmxnd/voqCdRBJffHwwkyohploKh5rk574VkbSQAHYOtOn4g9B1OkBPQLfJsFUyiGRWO94cyIB00O/5pWDpMvBX+QTtapj7bU6YYPLsWuFkfEjdG1rOnlwLQjFFOu+qJex2wURD4vhGUZJMeShFWrueyFDivO9ZTreqGTrN5mUlb78sqrROx02YqB6JTjyWTFN9Znv0xTbkugc4ES8o76lxRCBP2iWQmNrP9e7K10cn2mEBDsQlla6ULQ4XHjuhAOqyzOuv2N+fT0Cu8EhzDyQ0QANj8u2OQMVvfvyRURWK9Zw224AuojciWmlDNqtsQuF1iIuBJpsLEdOnalT5SxxQDTDVJVgixYsQ32Qv7GsvL9BFpQGmUjb9Lh6zw+gZTc9EloTo2vAaeTR56EumDUIpoNQbkEpBhdpXE/lJAHQ1rYfyzVlyn5zrCbSwJMSfVtDlnJznpYSZELcbi0+lBvS4/VoicJOCrUWCQ6eLitOvEMVkMg5RT3s+kUleFjaD54Tr4FBmd1FzDVo0ghKtTFcfh5AfnFMypcoskU3OBu6EswWJP5KNTPJ1DtBjyCUPr0JC7E5e0KHWAJbKwpfWrCw1ahYy/m08ktGpjJeIpYUFkfhzMCQFunW6TkSsyebnGxSSAgrVEUnpbxqec63EMedySrjLjx3EpLyEuRQuubilrycCceuipBBqeOTFCEohyTeKfaMz2m6IIolGSA1I0xVIiKctQ+4KBWiTABWEkE1besItlJ9N8lMxQjoNOn5pHWLAymKJGjmtkSKfbBVlaftIu1bFzelXe4mg2qBgHk7bQqYq+eWX6HDnMrev5IkUG0x+qodXRrsE4sMX8sPj4HcMKhj58gqJNImMmZjzoENAT9QVFkESGoONAVonJyecl0KiEcrxk1SIojbN4Fgpd5G+MLM4MZeUaLhGax5d6pmEh/OWEZ0xdyAe8A7KWjZ+O18jofWErs2CKiS0VYaCnwo5NTiloazHRAY6YJlEMknyLCXBt3Aiin0nZFJj4nwtCKQoanB3d8Oie+RxfOzsO5mhaDjTXwN3W9dY3N2dMWeeIIvj40BibBRD2ah4XEqpcYp1QwVHSoniiqo5CoUl8TtdIobj4xODarNigSqz0BO3NJIqRhTHxx/l2VNKBLJwYoHKokDht6dcCUKNNKxgTLLUZekFmQmkCwjy6Bgut3SGu3c1KH6rO/i7fG1XuKqkXnQwHH1yQa+xLo6q495CG9GUmGjBxHyiiNAk8iWSEFMLExPGPmrxPFAktZGUz1t1Sx6RTZc+olFmKNLZKDk+tyQCagNSmXCnve0yEiWoE9BK4eEhJ1qPZAT9iHyLUwsS7GwkngnIEkvrOIwop3NiKPKo5b0qoIQsJIjGqduPUpzM56rGxR1pQTbdbHwZWhb5k7zIqJvRiKZ2zW5/6fJzKGsMMfN6B6z31NxSkynhzGOgCem7ZajCgjwcj3Oe2bYviqQp4HiFFRGBWgdlnUXTEBJcS9bwpEomTNMh4XxKAEePVkRcZ67VTeByye5xEB0f62yqqUEQx7O6IgGd2fSrjmXkmfjkg7ATrVQwSBxfMnE/kY4J8nDmiF3jKBr5pY2LhRFwMxDehPNNK56WvBXuCbBxzVlbXMCea4rQD105KcsmsGQa8TDtCBmwXOx6htj1nnNFnnBGdF7so90MltD7cIcOpTD0yeQepkYbWDZVueLBNORlCuIjIZ+tXAclXy0jlxYXt8V6g3S6h5L3XxMOHIwraeAsmRMfTVaVOai1gSU0Y5xWt/Xe0Ee8lpG/+tzeD6kkFPWTVuO2u4vsCnYh3sM5Z7T9EHqq5KOmaoXg+oeQY86xGxySapMKKV1WQFWNyKnOqQsTUlqvvzYrLiS3Czn/eJUUvNoBxFlzGztvyYb3QI/DaBlpvnnVNCsbkVM3p/wIFyXJFCGVkHzh8xVZKtuQUilKRLcWQ0UbUuqk1HVOAFF1C1Qg1Os6aSQmqaFqkGj9jXs49nNl7qqyP+OBKjNSzP5z5tpBYkhICh0B9P4zDZKA/W5BvTN2oH2wRjEeLuwP8DEcl/TBLtiVTPodzLErGvpk3FHpcbSgCXFYhuVjCCgk9VWaIpQOKCeZWVhzg4XYqJ6vrnclM2NKmx5nmuvkYOcZ55gqdO3QfnHS6zMeu1BozjiQSZyoOeTu38pHsN2fSZUQMyKGTlhCEQN0BLCkwL8KMbDu1R8uZwrpsdd4K4FaOiaIDIIf05M4CY8hBffYuRUJqZYQYZwoRZYuiKDfNWOYsGukzCX28SaxhxDk4KJ5x0Pptwf7eSw670BCc1Ik8ovsGvsD5SlVHkzPHQ7PQUHFnAk6Ton4nYl4Iq8N5cUV8rFKtt2OWI6PY6ZTl1H0rBQfpOIGU4woVL6JBCCPwHOA6IXMeHwxF1L1fLxYe1UQrmsreTO0n+z8/ba5CF8prifyk2KgYWSKTWStETSMmBgyJZq6LYCJtDrESMsCNJI0h2CFJOwbhfLeMJh8IToJO8zB1LiUJM41qn1j/Y590i6GM45g2mAStwgk7jeCYXNDBItu6ZzZKXoZamOutsKA8Wi7Hc59czkl3FUIBUjhfRH4WD8CLxXEzv+mpbhNI9AMLoQ1LSKqNTAK2i5R/ejPy0nnVxA7ryF33j6blxiA0Xv/JQ/0lAmSWwP2+XDV51x22yA0WqBC0GTmttAQREKWUzqU6XIiJ0kKgwKX83m+bLIvwfX5kSgBrtP2GyS4TtM+n+ZY22tfawqUPr/OTJEkMG/5KGMaPGP6lGgKnEZogQrBHTdIb6mLLn+griAxDBBe+d3SVCpTnLbIUpd69r9ZCpZAftK+ugGWRELu6xzsyjjl1NAYLBBF7cSpgQiEyxJg79D4JtwvUwfUG2GgSEsH0W2mDSDvWNVxpgF3vdwig9Z1+5zr+xmcRVJuG97czxvWsfokYpcjjMaQMdhLILsCtTiBfEMgBJ1cynmvD5/ujsGn2tfAOfhT+27jOKS/iO2XAycSEZGHY03kKA9ag47ELygRRghkVDJFFHmiGBoRUNvNC/sruPsl1StPorxykpH0uRL5M3mMvyGJcDUZIwh/BQ2DryQSKoHZXy7gdt/HJtmOn0s1XgpDnvp9FrHhivWT5yDKZ0+7OvU7NexPv1dzIW7Gl95Fka9Vu2/CROV3eivjoyizkgnuilLSJC2nXEDbXrsxCnZ7ODLwmXAW+9NsKEurnPwi+I/qHmBCCbVvCBKTV2qsNSCXiku9ASYS+3QYLp9rKZ1WGxFNicaFo75HPHU8+kLMZFNufBNiybHk2xahGSYVa+blpx6D4768vCGKJBqh5FBGjMyF1IZFcIIBt2CpLhGH88DYRk6drAAKBdjCxL7ZAflClGBijtqkg8mJnvS4mvSzyDwGJBPZ75Tvz2Ligos8FZg0HoJfJQQX5k4WyA6EBo/iAqw9H7JW5qkJ8iv0xK1ng0RyIuUVwlg5zTzxn6WRS5E/3Y8ZuDxGSTIrlIh7DVuFlDTc66urc5gg/MmXkKMxeOtJHOce1xE1hLnshF5OrqjWYA6BrFIK6qNmyp/XGiB711pg6g2IpOZMChID2J3U4jKSkU8cCyb56VYizntUUEEkDSEJw8edzkR121K37twWmIOq9QLO9rLMXhfMl7DycfFN+vrB/gL7I5FMYeZWLcjEM/lIaUwLexehtAUFkYSAlHuWXoiYPiGPhrcaFcoKmBnj9nngWOzX2RvT4IP0SexDVI577Sl13wLMajUKzlq7zWS9mx4AzI2WwjORp6VQ1ao6rd4CzCpV9qFSaGq+8a4byKnNaaVtyInWyKnNyT59rZgdfYQ39qE+E57hAFw3AMuzOdfTrzQyyKnNSbCIhnAiNlsCBjRjT42B5eEYVxzYuYPqt5x59QB93HXiWm2EbXzWvGany5VDKl33YNDKxUcPZpnwVbcJrx0WnJD5nMbjpTYUUtKsAIXpYWY/XDjp8IWVOKdxqK7Dl3mw44YnIKGq6ky4ukNnTzTKaqu6jluQ4Pgj7+RGajO331qWzaw3Io5G44g+gCLiDhyffBm7DN5f9W0mDEuoN2pUfZ7a/hgsaGaRYzGLibSiw55A9p9LYZ8x4QS7M2FuFJ0hC8sCHAeiNVXmI33IyyLUroHNMCIPjC1OLVU+iGY7LHv2QnxMk0s2o9Ey4vSDlPf59Nu+AQlMrMjjqXzKc8Q/Xboyq1TMoaSPaUPIX0MbHFY1GGL/+KocFWULJBQhlrMqIvihuoaMYYEYHAb/asQImDJq3RhSmBjcSl0mTNNLdk/LtXvZAglFtEhkfMMz/Z/BYVpeQoJAn4wikbFLrQdGH88pMVnh1Om+BQmOkXlGsKZh0W5GKBUU5yUOa7QRQzB2QZJxw1JeJJeb5E+VD2l4Do4T/kiWuubhCA2gXBwsCmt39wLaOs222omFPQQD5Do1cALbC2NUXz8Ka3elVviX+eqk3gQJRqhHcM44vRBF/cvc9qhUJZjDZvl+vj8yleja+akE1AgR8jGEU8lHiN12O4PakCT1RWsoRASKipgqaL1n2ucT+k1f2J9g2IyVzsxWOyQsmWDfMppnincvwYUXFDGSVSQBrKjJjSgaUZIQubhDXsx8yKYXWmf0k+LlIclGKyLxFwBXHN00HmXG4/+SmXP9TuTQh4yefKSP/iFIeBKS/k5zl0T+Glj4sH9RLw/I1MXsozRnT0wbuDAeFTPUrU3BEvAnNFJfZPZccmuS6wsBzLO7yuOjXZvRGGkEGm50AKegaCIf6FmSmqXFoGHNnMspvRDOuCjC0ZpNkGAUKSdCNHweqcjMwp2bDF/lAQFOHPwsTrnTo/4UUmpR+rz1Me9XR3Itctsfg7fnMCFTHuhonsE5w9yN4Ly6BugzWKVRuwa1P0mNT6PxkST5wKg1gAqYI5xfi1x3nuiliM4F2P4XF9dinEUR1cCM/jRkAPGO9tJtVm+DhaM8exKi35KUAMp61YJwCspocIWri/p0oFa7MmEhWse9gNHxiDMXvLWgpffrRkmn9D7YRqgIhpcX7tgyLASuHEUej3Av5KPIc2QABOBeAPJgub67PRH7s3WkWGpWUhFZheDMQUgZ0rYhad0AhaXMEpcvFPIiNa001s3biGhe9zqg4HRRuc4MGM9uDqVedoPOSMbNpZT3WXqbcXpOGM8URR6WB7wZea1kUG1fQ0Xxvri6yB8E5chu8wjRTUVRNLMAtDfWhlFeObeVo4EgchBhlBAOFYhPtRSuLyWJaQzRLK3xsFojDpfnSiZjJuYcUFjgNh4jpuxiV6ol4nA4nGBcK/BQWkq1MEHgSok70ob2eXG2D9cr1UgZcnaj5IP9PYUiATy7lHXREUkNST5eINUtdhyqMOvg9ILYc/s0xG4zDWxaiAubsVZRxn/dqHkDDhFdpQB5CtEGbj06rreC82i1mfBVJggDYSCMVRhp2JsPPKDtC7RxlBZmdeAhN7gBTbkWQHT/SegsTaUyNHYsLIWnZZ4VdM3dvgKKk2QW2EjxQFUQlLio+3cmsqTIYOhe95aCYrbzAxKT1MrLID8IYKkkMs/b516chNsIwd4+J732de7G4orNlT/RefJIFAVOZsqck8+z8au4Wzpn2qhl373AuwCJZLocL5Op5NrvJ/X6sOEuQB4VSf2RIugQxhAZKG+Kh7ME95B7b78JXPfdT9fVNDG09zNXP/k8L2iKQHIgfuKcEYATBXUcQmSffyS3rHrtHN4BBtNwcBQc0nkFIc9XFhaqAQVQBglJQfe/GAlAuz+2a09q4Mo+6P4zDbz7E64h9T3Md+X5uppz+iNxRTWci9qduIOJY8YojydyaL85EXAxCBcqw9mf9I4oRZbQIYgsoaq/dR93xRD3uJrCrgzK0hoIIgdh/kQUCY4LywC8ICRSUPCT5VPCYSIw8jfdX3/z5r7nXrTTpelv7rYdB8Bpf7NZbSaQkPSkv4HmW9aN/myBKzc2AWsMVAwg9x/Q3z8NJwzGJh5y1uMSm93dnigiNPF7zBC7fzP/I6Nq2ed0zus6XvvLA+u6z3R/M+955OpOne95XGbiY1GpBxDiUkPmsPz1mJos7XXymy0Aen5qbEvvIXS7OKYwZ4IOLy9CRJW/6vV24TYEK22wFMEOQKBi0FQx7/+4IaK/W2V1CkXPgfzRq7jS2zTKj2To1M6BFFbvP2lv/DExBzkPfCE6aem9K2oWMtbIIm+EOyuuRQIWBLyJMQSb+xyQF8LYd6c0MkUWpio/ZPseHDg6ZUIUp/lCTtnQAgcBZ9qUJ151XgKn3gQHBctzSvgSwEVUbtUCB0QtMBdUlduNJD7mGRPOZSZiuBhG05tMLy7mQio7uSphDXDtUoOeczKHSyV3yH2kNNbn0n4FeBR2VUrNmXj4KIU/8ug2ah4Qy4g+IJSaMhkpmYIdNS4dKDFkSjTNS+OMyaysKdRxCw6aYI2XVmiwRZptYBb264mstMGG8UWxWtPYlypDGTl+7MCCglI1XcrofsY4RVFZEZUCDBwmmWBP4RhumVnRX/nqGPlsbCch++sMIxyQZ0Q7R/rVUn/juS+1uASLwFCiRvJRAKPgPcZVolFduZFrjcBxFKnxXHvICTfkRGsUktDoU5D2u7Bul/agccgN9kSjzAXu0bjnxabXyEW1fIsruag1Io5GIzgjYzz+47KwvvxFv2slbMVQXYJFUNpasCgQNtBkRvOtSMJO5nbd4UeDO+Dkzru4tOapZMJAhRJTY82Ik4AG2viQYi5rKsJdgkXAhI9ggQ2h1JOwKAj5mB/9foTX6TL/y0SOgJwIaQLIq1CC6rtfJLg6irWltb9EBD4TP8z1EysDOce5k7IK7Qy1rvtdLGkXIo0WBFGJhj9FDhqIdnkmY3t5JtxpekCOqCjTRiZD19egTbWFI+bvFaUCPIVblIT5Kc8osFXVjdRmrnLrotECGUSxwkQWduGRCT9pwmMRyUyYK7eNp09EPCmPZA5dO3I47mgHBMUXuqFjE8sshNEM6y2AwpyFtr0uwobOnpg2+VqVKE2r7fELMZNI5TjcGBIxlEJYu9z7s/xDCOd4nEWu5PGV/X/+eSgtrRuIxZ8amF7KCFg0+HpVq6gxbLbse0HsNhJFE/lA8xOLpZu01QrMgB/K6F5JEi2qZV3ZBBpFsbCDSIO0x8lKGxwYs+IUb1668imliiVUGMIBHvBdoXGj6AOjjwjijCi+PPEmKUAYqZJJas6lKrcZP5KkPLXZaLzODKhDRc9AAwfKgoiY07MHwjN3ANxaqdx+jocSbn0SISrcbTuNDU3hHhXoOk4CAcbdnaF2zXJ3F2yz3FbXRip6Jh5gEbi7W1BuzQ73OvXJnkMEeC0djf2voU8GuZRcuCTxOXtyflY48fLdbOxviZn7XsIntHAExFRHik3pFTGKPSGcBhx9z1LASHDDogIzCzrEroq/cWboIN7Pdc2LqFI24Kakkgp1rkUm5oN4OnjMk18NEhduHU9rU7d/hYg2IcoD9iFAisI5T71Xz4zVSpUFisRoOi4OxIaXEOVgRB9WMoPBpJByuWyCcC3AxoPLg1ZLiQas9y6lZC27JMRxMDbEZI1UgaEFnCRwXkoC5yA1IpvNGvrQXoPmYN906zeu44n/hBuiSEINVR+AHH2ujY88aUg+RAClEOmwoiV/oCt2tGuCSKMuFs0mYOPjLOTXycdHfgWBgduZLvaaPrvXF9cewod6i9ecGjKORgtkECH/I4I4jjgl4pLOjHRVpPvLgvp6ONqzYCKmT4VtFQrl6BtiFrD6fubDRsf2g06ZIIpR7UNHe50ItptECKB1edhp3GABAYP2KZH1Xiqd41obkq9Ag4Z0WXDPe5wFdycSTkVmad9R6G/cWZLU5e8cfHNn+waWgvsxq+Ml7In5438X+RNQoaTFYpz9SRsXRbxGnyM1fgwO0xMyn9P4M+nx+eofRTSmnEbuV13ZjvT3BMcPY5LKjJgKqBBSFyT7acMF4zHqpA2Q6g1IaBuhfqex/nmcep1daBsmvSApDf/1YKzQIIpi3oI9gto8el1p9Pk4xixJOS1tQAQTwPhXoJcNnURATzMz6dKC5/+EQ73ylGj6+uiT4gilgBJe1l03fWUzoyZaDIJ/L2yTLhIZ3/BM/2fw6pWXYAj4Q2dlTImUZkiiBbXrZpgEYPfe5Ttw56Z6rB43AHC7nb7eX589+hv6H1KhuM5fzPqdP6gFIc4F/79ZCDn2D/hiIjpLwFKoXYNj4AH4jd9loRV/k1OYGIoLmL13VoHkfrn9QE+Jgklh6oeCHQJ6IsOwcNExGjIMFxziaNBCQVC4I+QzVbrH3qit/Q9Dos9ZXDYjeJ8vnUKs1PI6dd+v4U4YNRZ9jiLcDKLQiygTpQkVUMBk4FIIutXlRPrhARNCQpZTOpTpciInCdBlVQrKw8rlvLQSAK0eqAhn+d305yqQnYmHXm/PrQVQWoeegAJlDtQYhN5P5CcNTwQI5+FISYCgxxTOFpt94APJcxnkr+FsL4ZTAt7cqR8bgGX/uPPpSj4tfUnq2o7zB6mNgLRiboPwhU8+St/631JARpEpdiFyFIAxFC3OZPp0e4Eklr2uZN/iUM/I6Ldm7Sv7pioRf3HRVyLulJ3KfIJ999kD+81GkcgEKeFySsIJvPf+5WTB9BdmFjf++NlF873QEdn35ZTsXSbmH3yGT+hUNFLpoOIsUwWIS8SZZTKwcwtVxEg1UHTOLKqlB1Nc5Hsb+TO3eWtfmYRo0dQ+NQjp96XyNEwQCP8vVUWpzwtx4rfExykRUIlo2/dcqShGOPvT0/id9TfJ0M5EHAhvvw2lV0GRfbLnW0DPZwOehGEJ9dlFJvKDmrD+OgO26lZr9Q+qWExBHy/icuJBKGE/melUalcTZuJnor7XMHwmHvt2V8EA2WxjA5VJFMIYZTDhcjN/WDRCpRLynzWYhAyBSCQ3VcaRTCnCcKdvrVpNmKaX7B4sEBZXWxden17EiEL7hR9cEjKs7ILt6nb3irUw0CVf2OHUews1cEucosCLIQLsSqdAIrKEKhZVI+dCGDqHN9sWPHQtPYxVIz3OMrSNRJyFYqgVjVHeAo0Il3MW7ZE0nMM7SVPYAOxVrxNZbKEQk9TkFmjIwHoSWhDHOXErV5SLY0XNQsnHMRHM2Bkk7nUB8t2x6JwH4qhpj6EUIiSPGhtljfdba309IZxHRVLUJzUYOMvUYEwUEZpEcI1R96XuowecJSwvk3ybt126JpA6VlP1QNXegpKYKl0tXBpktAvm/BAeQUDNlR2iaaFxLgDEsvuQcvGfIzojGTdQYYV/woaNf4kcPkghkUXd7kciFRF3INHZK1appFJoCpRIwuKY00eiaBEQayinCS1CXy0eq1XPngwVGuI2zo6Y/Pw09HcmxY0wOSGwZwK7VhPnyDol8S21X9Lfels/SND++56a37QUUFWYD+7ao06Lh4ptT/5gg1fr/vScuBfyEeJq3f1/wOkD5dVgu5TzS9cCEUcUytsUE384tmCBzEE6txo4Hu3aCTqPWXD6Nj3k9lcARsJ9zz0RwHJRpcgvVOi5bwIOo6gCmtMw4KXDWWHIIrA4V2Se9PjA/o4YEmrfWbDQwGFMrLUBenxoJu6L4q/OsBjba9gcSGoyF3sAnsRIyTRFEG5oJKnUzODgOGfc1YiEKxP0ocgBZI3Msweg1kRFoUwu4B3xMY1PjFFsmhmqga7XSRxC5mM6zebAGXwDGhldZ2C/TwJH8EiUAI6A9jkCrZWw6Guo5xgnycz33hWf0PZxGk9sZ65ICpbEecb58o/MTpkzRuM+F+XYimJ0dXUOLJHXKoIZeGmg1mxUgvCJdEct3atRAccXt8qEOZnPFZ0TQ68zk2YGKTUodd9CQHUxshOO82NoaFQaOWZCWXaIo6cDw9DvE10RsTwR8S01mRJIxpP5lMZIZoXMhYh4FlPkEDjg4FmLBkdPR93ytrgES86tBUGT6ZAWJOPJXCcMTZVy4QOexHsls/R0iRLxMEehKO3VLEEY5RKXCYRRrfefEEa3D80ntEYm6FfcYG6EpOfQTdDc5jhRc432V2BxQ5auUC6OlGKkoHDUabynqERLGOOIcKIQiSsJR3lsRwqapTKmvKCBesPjQLmgBqfVmqK4pTPtbE/wNMAb4FYSTjiXjyFoDLY8kDSlIh7fsxSiWJQNnkWopxoydPymy0JUPc/m/0NsYEMJGV1kkjJO1WnGeAwgB8c6NF4mWKSdCXohZjKcgpSfmWbmwtAEeRRlVVlUtMEbPsYF51alziul4tqB44CIwH/dA61LQp7bvdWOaAKaGRNxY+QwhWhMteb17x0mMVDbhNZ4hA2oEY046XdNmWcwGVGx5Ez3O3X3M3hMnd0KU8N20Mj9I/H4G7/NhCtjdko0RTDePgn5pq1SiRmOHIek3oRAjh8VM/TcLoYBHsTswMH0F6KTMzFngo6zNJXKULRKjo8fCGcuPtmdpDqZE1cispiUNeLxYRGh1f4Ia9wjEysyVLHZMjdnmaK9rlj0DC6KppxENF/0QNzK6IDiFshBVG6Iq5KBq5+KzVCmy9ywhb2vUYcSVVCc9YJIwiEiwb5lkFVLSLbu18cuL7+ddpw+qRbNtUbAaEoPdmAShtGIGOLDcGCCUYHCReJs/lBUJLScPbkWhJJbL/WWEI0BEw2J4xtFSTLlIalT7XoifxuDnJS2koGsc10KwAtX5telSKzqx6+7CRNVJJMkByMojXWZLAyw5LynxleVL6JWnIfKTtRZPrz8M2segEnN/X7tE2tNpJugQthc7RoylrB3ZIdZczMpNEADY/J9o0DF7yL5keTBnDbbgK69NyJaaZsgnRadUJoQop38HMkZfkXR2YDnTCew8VyImD5VZPwldG3TxQT8OOqCAnn0FC9CaLe9sK+9YQPdnGmAqdStbYE9gEbTM5ElYckUXiOPJg99ybRBKAWUegNSaVD57KJmLuwvNC6nt0JEbUQX4gEhbYBE7auJ/CQAeoTXQ/F1Nj5pqmELS0LSyr2ZF9Nwuc2H7ifOEUuZjhdoCqu1ROAmll2LBIdOFxWnXyGKyWQc4qr2fHLAPAovg7c/0sGhzJio5hq0aAQlWlmyPnYqj2FVMqXKLJFNzgbuhLMFiU9zhEzydQ7Q1D4lj4WvgFbZJNQsZPzbeCSjUxkvEUsLCyLxR/hICjR+Y52IWOPEa1YUkgIK1RFJ6W8anhupxDHnckq4qyYSxKS8hLnoK7m4RZ4nAnGzp6QQKp7lpZtKITkNPmrf6MyTG6IIPI/jFkjTFUiIpy1D7goFaJMAFYSQTVt6wi2Un03yUzFCOg06iXNMhTDUsydDhXZxP8hpjRT5VP0oS9tH2rUqbk6/2ksE1QYF8+joFjJVgVS/RIc7l7kdFE+k2ErxUz1VYIH4jXpPxL+C7RuvYOTLKyTSJDJmYs6DDgE9UVdYBEloDDbaZZ2cnHBeColGKMdPUiGK2jSDY6XcRfrCzOLEXFKi4RqttQwEwX49EYVvE5nUmDh7HoEUVVbu7m5YdI88jo+dDpEZioZF8Z/Xt4jBzrIauIeoxuLu7syOD8Br/BqLQGJsFEPZqHhcSqnR0nBDBUdKUzKQhLW2iIkWn0RMZ0zQGInYYXJF1RwVhiXxO10ihuPjE3NKNIsQhUOB1kXFAi2LQmXe0kgqnD0sio/y7CklAlmEEYKez3yEoN4sUAxRJDwHv4fm8uZrpOGKApsP5IGJOfAYlrrOmGSpy30OMldJFxDk0eRxRZZTilBWHBosunfnbuyTAPPjdzq7nvxmq3PyKG3tdGrX9ahgixn4ls4waqEGxYf4fMw4H3KiUUwKImFXenzP0glCaUP5DS6UVgH28I48fZhPYqJHzr3ODOQpehdM4UwNwmrDSsmSSxJPZECEYDql6Nrt6uFg24YJAbUB5WiGU0TSlJnqhGMlNjjZl5CowxPrIkEZDq02oqkLMWBiPlFEaBL5it6IqYWJCWMftXgeKJLaSMpnK74lj8imSx/RKDMU6WyUHF+ZAgG1AalMuMxnRMQoQZ2A6g2wPWQb0SCVWhH5Szm/pA/w6oCXULx3J2xZQayHvo7DiHI6J4Yij1rC5wJKSEqKaJwC+SjFyXyualxchgtk083mvXsji3xiL2TUzWhEUyrcL136kkoEtlengvWemltqMiXcCgFoRb9uGaqwIA/H45xntu2LImkK+CTRiohArcy8zqJpCAkup2t4UiUTpumQcD4lgA/6V0RcZ67VTeByye5xEB0f62yqqUEQx7O6IgFd0uOrjmXkmfhaBLDzrlYwSBxfMnE/kY4J8nDmiF3jKBr5pY07fSPgFiS4CdFDK56WvBUsleKFx3KbCcMS2NWSGkCKC6SBext1c6QImteVH7tsAkumcZKgfbYALBe75CUZ96UtTzgjOi+E2m4GS8g7q91JpdykRRChSIeSj5oq5JHzmEAHYehQCkOfTO6mb7SBZWO/kmtfbXowDbnudd27hlxaXJwZd4N0OulIv99FOHAwriKqM2tPfABuVSW11tZXQiQmqaFqkKZzT8Z+qsyFw/6IB6rMSDH7z5lrBwghISlsAEwD7H8QfXcGJmcgufcq+qC+iRx/40BJ5Dqhz8FIWwjMfCEMObRfnfQ6OGILh09CZ6mrzUXjj8QdYRkRQwDzEFIlhLM/6d1USg4eAlGKLMFT8Flp+ptIdGcOcY9jnneG4HabtCFJiiQKEuZPZMESHBoOAopCIgXFOfMpgWo9Gfmb7m+o6JbOp0RpejM/XRqqoY8BB4GcALagczcDCoMThv4WiVtFYP+txd7cSG3m9ptPwlOwIQylEDTq81GC3TjUEqVAA5En+vgjz2gBtPu252NDDE16HJdnrwcpJ2Zm5wDPgMv5nCqPwb6E2O1HogSYftuGm/y6OKN6nafKvGQiewILwl5LDbb3fok0YtooCZaB/94H6BS8JFynVIzHl5/DogE2i0s2RRTHmrjTxpoiiuOhTFJrLQa5GKc0YjOXIMQstM8SAncSidaCAW1eNXRpv1Nu72JloQY5njERh1FyIS5l1O+EOc+gAXlYnDJB1HLi33wu1TCz3yzKp8CSYbq4vBAzOep3Zeld5KSOAzkEDlc0kexP2HKxWX9cuHzgPT6NsZVQzHREVNzrUPNdxCRPyHydmR4fJd4FxImKFudKJp9Ej7M07DC9WstLa74Px/HLmbgP2x32BZheG6rNIBxJe2Duon4CNn/t/lFsmhlAKnIjlxmJLIslwsiFxP6Kvp+Sfh6TGyUjqjUyqTH5mEcXea/GbcYpYqmJytkTM4DF5SvOPDtQATzvfMVZZwsRnHO+4oyzs5jgfGPGgqR6Ic2YKubDntWLr/Uo6DwKFNQ+5TMRXco5slnDZpKkI6aQToOOteYS72vFYbVJdOQnwZ4Q0QZE75n5kE1dNmpEtE6KdMg4NTb2EyeKRBRJNUgpmsgHWvi9UY7WyFHYQTxnnDqNhJS6KV2xuUsWOSnyDKA4rQE1mn5SHOF0w7nNtIG1F/0dgIYypkV4HHLq5nSijIuytfduiOhvOqAftpFYglZRk02qaEoUHUcLmpBzqYrHEFMD06Mi6RdmFn9k0vQ9tfzegvKUKr3nM/mG7Po+Q2d+Tn5cpOW7UfLB/jAFDseVjDNOz51aMeA674+Hu9MvdomgTl1z/+tldWCwD15n5uzJUKF7X3+xo//CmmV5hSMvBEP3k+bgMDwSndgls+2FyGkABTEN5TVqsqBBCoPznEzkKdH09RFIAGe2D6gYrMXIDB0ZfUufnLUEpP+zTESh4sPAGdZ7v7n9aM5CJaLwGggJQR8DguJFKLpDE7f6oOf9ju3ZiUVy73RlzxG4JaYK2tCtPS/l3Kf49wCKC9gIoNQw38ihdg2IQkLtU6fLoA3Ca0C9d/UMLiWJ8wRUv8kp3M5Xl7CUQL0IbKsq7FVmMsL58uwp4plmD/Q67XWOgB0ReZ9LTOOzB9sCwPe0lYfjMLSCMrVvBM5ipQ04DdPnQlI7MmC6WHONjWJi3uus1x1MtO11ZM5EluTl5u49iNAEiMMt/ZbZlecHImKeGx3NJtgs7LtqmY/hGRrdSC7ME1JpUmH6ymlYEy2sMj11/15YY+wJOpTPhLPYxyj1OqBrNxx5dQW4TCKpaHHhlra+0G/IQONzV42SZHajZGohLRGLC85eaQw7aA4T4nGbq25baXR1dX7JtIFGxNcKvnVLfme/702tYOSHgi2DcwEch1ko+VjTtE8R9WZK7irJr/qdk/ZnoFp3EzizVFFjlnZVLVxN5swVxQhlu7tuAGcVAgINjYOnwWNaaQNOyI6vLChv/wo4jevpVxqZc1fve5zN7RtLZdR5BzgtkqZ8ubKk8LC6biCrDaxa+0pe0DSC2wbuQlhgMb0W44hwohDYNmBnSWqWY8pDYTnk9R28rhNmkNnzmIUrpPY8au+5nBKO8raF3CdxL+SjKNn5yRNV2/a588HdKrH5BQBi21HaiiU2AtsR2IVIM4NDcxuyrCleV1Tr/MuQ1hoBc/tdzP6akhnT2r4LxWwDOLeV7gaki9b72ONM+z9zpizkyzFD4XomNLQudvWaZXQi5aX7fMS1DdfYfmPwlaHS3xGZFa4rIpaB2nv2QNELtJFZXK2QKs+/RlxrcXmfrEZcO+K6TpzmQlq70Sp3thHXVlzc5WijTbcYstqgt+x6CMVqKyqdcmb6nIr0h2XpgTBOprw4HYg+nI24vkomXCa3G0VTqRkGVmz02mD0SQ7JHxurwpeqSxQe53NvyM1HKaoW5NPis9KGhFqEZtzFTKIUbWLkE2as8xWjOdkGlgn2LXPp+SKCEQ5tPK56uEuAa59Hz+YmSkOZTJmgsVuUXFIxx6VJNyd/4TSSEymM9XYR3ZUBWfpJboiClahiFzq1a+BkQqRxTW6qa/Arstw3WzZNFA2QchdIuIGY1mHqvoW81vHyp3AR2ndA887uoNSR1HZSqN53BAUtmdMzQSnfYh/QqKPqpy1Xz1iib5ssKzDVJXTbu9z8aK3euu5Ao+WyNruUe2dizgS9ENoQ+2vK1X+jFRobU2UN2wvFpSJFiXGF7O6H0j55o2TCNK2SPzfbAfKK3JCbhH8/+MTxITPwUpCERY0bSCdtpO0DTMb+cr0XSmzQeM95G+Pxt5A0qbi4EIYqQTiyabNBJhUTlxrVN/gKZzAqdDwLENMoNp6Kz6YV0rW7V8BpjO9ZGqxi+wJZpPlYgUjjq5bCWrBG2k7vMf3F1cDKcfjXoHnooqTsb7bVzzEhwLXVjJQ2UApJsYrdU0S1AVV1kogaBNUGFZbkF0nKme07ytQGVMVBq5jGt5QTkCcWduEkExZcykhn7YA7e8IBt7sSL7d3QPqYvw8VzJ3m72MFcgt1F1RM35JHv76nhirU552IfhtffxyGag9sylE9dUB6CCeraidjpfokQh2IGIG1gVl5MvTJwExZvwugcdGckwLNyB1b8FWI4vIUQ7hEKhUVHzH1O11qmFnoFXkcfHPDx73y48jFRF2RtNhGjRY0uj/hBt4G6lY0t61mH3mHnFY4XbE45vSRKGqJ+ZC7RtlJ5LWNF8BtReoqGbtsPHov2INnRUOtVljZBpiOP2HmpaikEarQMKuy7Rg7EbErgOyfKCoha+TV5tV1Azm1OXnj6eyJRpmhAEtr78wpeHRP3O0cWXH7PBMgnbvP11oeHGqtTVImk1RqOsy0kYmrjGjXOU/Lc2q5Qcd1wvkt1Rk3K8hO1twEWghwR2rrbgLm9cA0M35QBijBeHeVST+7OwCTRGxh47GAH2adaFYbkU+H6Hyk2rjkIihAawQoAAKMxp2uKq7yLYDy1NVKO2BKyovNJ3f4qpa5J7ULuhhmhM4GNv6XPNARTd3hRxExinQ2SM65kok3gRBSCalYowVQCKYBxhIJ52HH9meCjXt7DqQiTz1kPXTlMjzG1Sr0kul8+dVx46PVR8hqN1bQ3R/rPUZVm9uSQ07rfEToINqFlKIfKY31FcUR18Unn/TiGyVTqszykizhBaCk2ZSzaC+Pksyzh5ZXSANpIA2k0aFh/VLBqtcosuspt53q/GKfFD8R8UnKfqfLYu1eb0NKex8oiak6dRGheShWoyWvIoOgtoFCQiFfmt5joQjBwOohEr54QMtE4HmFglF5D2Zm+bXwqpYatJOyEWk1aIVcapqagaJGLV3Zq/xcm7ktGqDSssuJRIo8I0kIo/F3PCBX8gpoZZDn4bGmAvjFfZNYGHPFiZJb+i2j2tyQJZekeeameQupBWo+/ZxLBflAJ1VWyOq40rr7yM/yS4i+rw6+lVfIJsiWV1l5tQOnwi6ZuG+UX1m5h9wsNyFV4o9PXsp5cMQ1WpARD3ZWIUjvmfmQTS+0zqhdSiMei4fLeUEHarnVTViYvs20sYMJqbSoeLWMaJpoopBCArGsSoy3dhBLvvp/pF9kxuOTNFU0Yi532+y/ZDZ0beMFUfRCzKQHt8uDiNQhDa0DIc1gJjMR702ZIGo58Z+rvxB9Iey7LUXDlzdMCJonFNj2FNLtpGsWVLsiACGD3gfyQE8pFWNKVLTI0W5+BLl2cv1W+XOGRNj2U3rubnii624iy06WgjhfxHsqvOc1vhYjNrO/zH7kDSdmZtdKYdG09THk261h7X84VR+InpAktcRi730M8inTZZ6xZfNDyLZbv0rJXTGMjWy3PYRsO9mSOL4Nb5tIa02p07oNUGSJXf8EUv1Oqs4FE7SsVKdcRvdV9Slk2sl0IR8n8pw9hSH9URo/3X+kT+ZrQLrpAbBMw31nefKQ+SLfjG60AKdzSxPpMhjX8DSbkM8qnw/GpEN/FzibAKG26fyeyynhzva4IYJFH4g3+ZBSk9JQCkEju8IIbYiniSc/MmWIQTSraHI19DsDvNZfN6pqDcimyQY3z3fC5BOkww7HWEPGHexhnCIefz/saeWLNPeUNiRJ6/t+Ad2kuIW81vFyeeRd8gHgwBKXeyEcrAsJGXw+uOp0Zq0RJhoP4JbOPJLiwhW6Qhx22iouAQ+bk/lc0bnVJvW8d2UbZH3CM/tIYQY6j6DPN0nMAqHUoHzSVEHMENANpXaNQHIpuX4UruAETB4rBaLhzrwVCKZB1spexRASZgNG4VWFT55WqU6QudQ6cfjGE38CSINMB9JJhbnilywuDdSPJKEIxoKZFQtduPljVrm4A5y5Q64jb9PaRxDbGmxKSoOCtYmQfxC19UZGmTjB4dcGV3pcbGuWr51iqrM5UcBX2F1kgu38SbjPADvWOsG4V+B5zJXM0tMlDqItbHAYrUWTvwbPpHyJg2lXOkOngy8EQuqEhDpnA5zyCiaXEO8QJ8lsIn8b+yWCc/CEwbXaChoRnZGMGx/XkAcL66JQbOsGZFBf9USOrq7Om7LUaoWGKJToYIZ6QXEnjwrPYXF6q7gGTkbRRD7QHAajRY2cZiNwRmFGHzYaa1N98way6maVkNRtkk+k9x6iSK3B5AubMW2YmEOMKWjr7evpVxqZFQXV0Q5doEi0WFXjK23QCKmQozMfazeK6cRVU06Yri/UGu3nJDISXhT7NlIPhGd0IvMmqHSYbpNZaQMXzh9OpQcG+UZXmdm71Yp0zFAKbVTmtMznUM7C/phuZOsfBcoxLHhTj+i9Iunij0vnL6nodd9CWt207Of9LuSjqJ//A8RqYX8Kdz+nehXyZRRXkzHSqGiAZOFHj+cwsT9fAGfgawPb3p9LNV4KQ56AHTYPGjXYyKuHpuu1yT0kjWBaYPy9vGFCk5QX4eHUUATWAcx+1C15RFS7oUJOO3CaWZ0dVhkh9H5IOEdMXeJ0IWJYh9x2ZWNXpUzM2WwJdOXwbE5FhuMLcc44kmqT2vgEOF5xESzD9AhWpEyr/5/zeooAIVBNFfOVeqwJWJk0IQ9jvQXR1NGsu4mUmpTs11SGMsKpw7GfcqLmE9c75NLkMo4IJwrRPIa6mS2V89ltlCKaEs2ouuNKjaZSaMTTKTnlHcRT4inCEeg0Y9ycJalZhtsh9gccqYewDUzru8R5DXvP6zphBu5W8W6MivsjmlLv4MlvIqg1oDruI6sVVvaDRiz+L5ldUSKQTpvOCbdWZKiihHjaePwxjWtvV58uf6dLZLTCyO1aIJkuMsrNYqpj5ofo8YhpmVgC5N6N2y8ODTkFY83kvAU6jPfl5XVm0gy8cFSX4EiM/We6vbgxZ1HAsdIGjsnMp1o3qjg7UrsGOJHQdMiloC67Qa5Jay3I4zhyV+NvHFEEFM5yj5FHY6jA9IUX9eyhukqK/tthMQfX+UfCzLlUp8REC0+h3gBQN0QsIfw3fcnuy4CWehs4Ihs2VzFq4fsIXQjvWeRIqiJlfxfo6I4NaJg+UYosT7OZ/RGog5pwUkVTJSOqNdAN1p3YeLv2QgBF5M4LjFkeoDlimkw5jYtG2DTOBMIoYbjDgnBA5IHuoRam+iLVPVUvvlblMYHE/Rda1GTp1VJ/47ndVlxCJWAoUSP5KGBBmFNBFTF2qjyXPKZF0oFmIzCRGI//uCw3/d3F0P2iOVQK1SUsAjdSm7miuoJQtADmUGhJcChqNkKeP6C8huNF7kYB0XzyJ9m1CaE+1dn2ogUwh/e58VA1QxsfXbKxygQAjLs7Y7ur7+72mDB0rnzU296CpOlyzygiNPG5DfbcU/luFIzA3E1gvmopBjPmInGZmA/SfJqtIGmpoAuPXZ8xQwcPRDHnyxlwljBTEXLHJpPU/kQNZEbayIrNBeF1+UnJoxguGI+RTJOM2wbOExtci7GJZWZQGdWVUeI8I6iJ6jLkT9paBaRr+scvmkbEELBw7u4WlKdUuXZNBDPsT3r2YN+Tr6UbTUjJtifMtdLRNGThL67AssnTo4avGCQkHegsTa3CqYbZf4KCM7XfvHC/TO99y6haDqzgzKRKiP1Be5rSeBBbjROCpO0VjW+JsN+KjLoZOfWcL1RBHL/9LkjuyoGaEk2RUcEoeLu8mnrhH6wmfYS0BdJSRKfuCkFtBqUycVq+C2EVsFotOAC/B1XI2DGOFjQhSGwnYs4zieK1G6yYhp+Fmn5nZKjvLbJFNqcD7bVS/XUNU6rsGnHM/qSIaB0il/4NAXlALh9VEdH0qGCEOD4Lik9oAgCKjhRLTVmueMBETJ9alZxAg7AtTNCzJ0OFdj8AMgtf3DMHASe7tdMbn4rMzsSrhtOarpgxCmLHcAuGBIjK3IIhP1IwKu71lQiJSWqo2+Cbuq1PRybsTORxb+KBKjNSzP7T60SOmzkkJAXPgGmYCMLLsO9k4n5bUpu7P6lC2iBjuGTT8Tf+h3N2uOAsyBBqEgETQ1heBRgn4UkEkYPIi5if9nhvdS2TgbBG4xYwgKAEO9ItN0tzika8z/UbdoZA7LcN7S9IhMOh4fIIZV2Rg/+qigRwECG9BWwQnwR9Si0FGjsO0NZfbbV5Kx9B9/9EzeEZVI902rKnvtApDJPK6EG+raU9E59tTFO/8HI6wZNZbQQNgwGFkQfcewYyYQZKv88zUdaR9p2vN4CFMAMIwY32sLAKMafec9lsg4zCwERRptELRkTfc1Ju7n4Krfu+olFtd7d2DQXBUAptVpXBaiNoGBFQGF9c5GAYF+EllI7743EsaurG1UbQMOZAYVxRs5BxCCH1LwF2PAHV8ZGMhjJJinRG1SVQADECQAAIIFxOyBwoA6NY4gueXzLR303ZLRBc1ddzprT5KEUJAzCLS4IofEAsdAL28QsRA5ohhpzosLfiX10YmgDtOkSnUUkgAkrgd7qUs3KLtbyC2f17urwG1f0b5bKQsgdaImi0gHGXUs5/F/JRjJfJVIZ91pU2yCgeYaIoU8X3OSPv2k7PAHX6I0motndbO+tdN8BDEcUNMFvNWcqrGdJfQVomdHQfknHQ7L7B7oMSfl/TdZwqSsIWWu0aKgICD0ERhVmOg3oDWAgzgBDOnlxC71CU1b8E2PFExhmnsLrvrOHY12cuFwbhEigAAQ6AP5Mys8ue6mSOu4JkDK1BAHBx3CTBAJPwOqAeiF1vAAvBmUQnWlMFzWMUl9ZheQWz+wJa97Vx9bbYbJnn1cqvel5HczOF8gpK98Of/dIdOSC8HAutVsRRtoKyobt56HorFBSfRN2VUl7B7H4Grfs3SqbWOFzmMRfhAmTnU2Cd9970UvDLK5jd91sJsDyo50omzdgCiH7kksIpE7Gd/DVoCH7lCJpAuDzh3LUAZVDfVgGMQcAbDENplaD7ltqiaKUNUZRt8LJ87EjkCzOL4YJG9ygw6/D4GjmxRkDrAE1URqHTiWCq3iovr6dQXULa4l4LASgACQ7ARVIGOpVL9NAGkECxPAcLwC/Nwfb+yi9JwXY/gd19AU/2f6fL+mFoYEeh6weh+9z1mE6zue+0/exwxlXRRD7Qi/H1iBhI/dZE2KXOn3RCtbmUc93/rtfrB9u2oaIg/uJVtzWZ0XHfA5O6Om6fgSbiEadE9bDTL+bMLLLp3qNU9zMuH3VZGptkRg4iLjUdhGcGMdNRpl21Ff3ia6gD3DMaeYWIvSknf9I921iIe6/7aVylyjjLY/DHSxH52pUzqZLe7Q5s6vkJ3K6XVw4BxH6f6L53PGX5msS9GIPqbf//uNZkkZnIhbq46HWPNeU0CvNzeHnJtIHV47DD0Os+KxpJFeeOBfey571N7Ro67617CaW3hiW9y6C8Oh9F94Uz9IqkMPrqXvReLTd6C0AlJyQNW1o9l+Kin/bf3stwra8AJPieLnWxO9PvWScT7FtWngz7lvV7SWDX8vPQ2Tv/Ekhn+9/XBRFxnk01vOy9+6LV4/67MOzXRflyILzsdW9nnBhDQx7YR9VzU6re2fw1mP6eA+hvQlU+F/lXPTeVjWJhT/guvIbSXQC9lQkzULw0ZV/di96vcBu9BbDGdXFpes/9WO2TxeQbB+FlT3seySRl3FuSMzYPS/yTmKSGqjNh1BJQtyMfjJd3fuhv9Lz3Kgv2Vn+Dkoqe+mDj2l/ZHzrsZ3a4DV23LZmh0LpN4tifvHVBeOdSJcRA6vqIzkjGzXVmRkyB6Th9opEV9TPtBzqYbk9B9ZbL+dg+Z2D9je0DwAZz6HEPC6Ft7PKNkm7F5aYuJQjv+3yd8mzOhDsZFt34l7lCc458dxzMzmNMMAiWSzcJ+3DAkFJXIjla3oSjF+6MMBAgiqacRNRlCqmBuQ2tSf/KRj+PA0lTvqzBgDJMhBzb7z2bzayy1DUeHe1g5MN+ywO9IWZRBzLRIJwaWyjUm0HxmDHOB+HCv64xuZQkHpJoQRGFtTK5fQuCOC8vYfiLdkASXIchJ4XFY6hCJpqaC+HWKU5ETkQMz0zfAEeK2zDbIAop3CQDlIN7JrUGR90AQRTHx18lGJt8I4eUKI0C4dw9RFMBx6GxkUXMFKJY5Et5lRDO/oQMY6bzjS2mje5xLPczWHBtiEEUoYoVktC5eUViqzoRRg0GgnAg3AYiikVBgzNxjzRyGtyZGkjDO7kWiYwRRRAMZ4AjC3+Q4R4n1UIsEkRRokAO4aA4TqcFi0diogWAYK2dxAJhNOUCMbiVOmAKkVqmRhY5GOynf/p0MUIeFQ+37w58IqkxCVvuH4heIA/HAziJaTazXzbQCeGhgsCpbxhyojViqbBon2F/IgMeJFORccEpt5TEV9QsZIxCU0MTGm4kX7pHRpLqj9JcJCmHFFu9Eymrbagyn5gwb096WET+Z7ARms0FjZHMKpmPWTJFldzmciEMnSOYNphTmQmcqNpcQhUhwFzogzvlEwL4mTZUgB49NRpn7uVZwowBTaQss5YqmTDdv3pb3wUjpqmiUf+qrn0XDPtASiPItr0xy0BCE/sSMIiYRszOsLVpdhRafkEm1GWuukslC8vWCogmIp7KJ1fQKLLGQ61WXUL+4VD0d+/+mq5OiWbRQH/jzFAI/Y0Ve7DWIglpvEJ1WUGleLEwJoXX9dRqBmp0RPLMyPD+7o8a4F89nQPs9ByCJk+lNnP76b3W5Xk51WmWpAMqrJlCdb97OlckXQziIrkL63t/p/YbFv3uYrSg0X0hvQNp1ZWy39rPPpdloN3vG/g/rvsdA0O1JeH+2/N+R5yVRaBTRe0iyxTLqH53ulhiqkyEvzaEP7Q1Nqb5ufb+9zTPim3/toNQVuWGCBYB6fzdnRfqu7u9GXsymbO7psr+YjGgT8RtjQ/SkKZvz7GACyXJuGEDbee8hAxmjNumB8JZPIgybWQykJlJMxCQEmZtOUOBKIl6b2uKYuwF4czbPkOZJFZvaJgk4KjMOoAODaEpjQczZXVBqpi2WiKk3g/twT05+OqMJ3fTt774irw28zJ6QHXSYIYytoWZvmepHpS7gPEg/3ArfFLUUdaeQUn8aVQR5XYlaG1Lo8jAfjrqw2fqQ0C6MPcseV6F64HLyFrdIJwPXd13vnEwrhf7UDU65i76y44eYN2mIks0kKV3o+MxMSRV8mkJsfNuN5soF/MIsfdTLucQ+51IMZeAOl541meZ8Nl1CfcOdkie9joGQR9D/4sXMLrftIZDbUqXlSYeSmvoKNt9MBts63BkYkHSdDmw1qBbeUoFnId3vBMDnoOikVQxcAj2JwgamWs19CfpgdNw3ii3PWWoOztUxVLBpsLmQirookHmVhLmOERi5nwokQGO4f+xtpXQxFve4KeQTEAXB0EMe6CDcAHd3PaRjTQeezfMhUgz8EsQ5msCQadQ88vBBuFddB4BZ1NF1BJRoDRYBFMmQAvDXMksPV3iIrS+CE2W+htHJNCtbBJ5Oxu6DVGEEOGyK1rYXrtD6rAxzJiIz5kCb1PGlFNDr4iAPn2mLLqHvtCyshCZW8q9nhyC9s+Uhw1d9JvRAzkbqByMO0DMeEwVcC6LbE7zszlFKhgkUhJBGQFF5MWcmUU23XuU6n7G5aMuo0djO79GZvBVTvXAyIHKxC8dce3+yHcewxqRsMtOqw1cbl+qBt8yqpYDQ+YhojZPLlHMKSEN+5WM7ofSPv70z2YMe/fqrwESxkh+ZN/9/Q1LQjx6bTNokBBhn1ZdbRUwh2rkc5SchBQlCGwzMG0/3kyqJ/rJKz+y0FDCVDy88GZdBeNMPLh0uGpGIgodxMT1pI8MGurXJaSj7kiLU66bNfAk5K774OMie0kmP8wg1SAEf67ISXn7gz9bW1Mi9oPOnmiUGTLlFCKavLAnHWRm9nagU85MTYQkd8vGS3dsBuGswvHja2zsP8m5kslwkYl73ddZe4VMqqyZ/CmNnYahWtunKjDtew7PRAJBY60SNmMRI3yQhkP8BRj79VbUqJ2ixoKkeiENECRh8q6ZbpaLYX9ScBhCXou9EZ1m8wsxk12ygTCOI06JgCoc51IlxKBk6L3P4VgCRRaWBVXafhWOEU9jeHmxaojZpj57TCpLNd/w13uhqEmIMPUOyQHTA3+Ux2M58bfdYnjs715oP5589CWSqpMi3aSAQSqbqpFF4rjQMDfELMa52aaAkQnJufwex3tqvhCdXMk447V56Yrc00p+XPVmDXGcbQeVtEEhoxVGQ5m4sE/3ez6ShCKfLhmyFzVOcITIGUTvXQOL9Ima6+bCiTmlcz116UV76wX/ISq3dIZQPJQZozxGFsEf5Y+hoGw0ZANxFDjiJOknCuZ2EgXhupaDtlptMz1kYFwv21D43XUXaPBAgTKpb6eakK65ImHkJ8Ge3CIRPAn7IrSBo9HIXA1s02sdk5gpa3ZKtRyu7IG5F6PmTVBg8hCw0qX7sMHZD1JyVgHZ942sIQKOT3eWX5U2dEzKSUQvRFC8GhCHq9A6og/NrSF1o2SSmgvhVr19jY7sRjKa3mScu2g5TdVDI2S0iDv443Lsb13EvfWwdcRqM6HdLwEcr/1MKC55+CnR9PXRJ8URyPFxSpSmf7jHLsJTIKFYClZruMP4f9Lca50qmVJlWD0UOSIudwMS2kDIqhpi3zhEUjvJ0mfCM3qipkhqPamQJuM6Dc49hLUR1uOCKnruvL0oWttpaebq931xzJDURlLFeepzPxgR1vZBOOQk0yhWm0m5GhZhHxdBbQQVEpuPHC4/EdqfiMQ2mw0Z544XYto8Bfo8IihO2zhJFVN1ukRKm1c1mdJoo2+B5N+JjLabUH8gqJ0sKOS0qwE1LmY70Mhm/kBa/g86x7eCgeEkd1UzVebg+OWFz0ThAqQ8mTmXU8Jh5qJoxRd+xRM268lgPPsPUQETpPsV49l3ZwEsnv0rxrM/C0dv49nzlJVhtk1oItVyLzc9GlmQb3zJ93CuDAyIuxDUrjJx5Rsm5WZNvQVx2Bb3+kbJiGqNPFwSLHdxS3XGDQI5Dllfb6TWbMppuHlJyT00MrlmbcKBrFo7gYwjKohi8jrt+0Hl3ZmsNkKD4k+3rzBZaYOGJDdfc6H45LIG3lJXIi9P07nmLmJqYjIfTMInNEm5fQjgVH3CeTWGdGHPNVuhYam6PmIhRX+jBfYQ8olE/MMdiqa6CQ2S2yecEk3zoA+TpTWZye+BZhIriUiaSB6ZWXyU15npd+Kr7SDs+2r6o79He7t4dBZBB7kotOLAIugM2LwoEQQbROWFPhHxrZ1PFfTh4eMpoDKgB3Qvybhh+egYuLlzQJ9CJoD85CX7t1Tn+7uI5HPpo51C5jyvJvZImDmX6kvedktJvIRLQxuZgtmYqEFQ1ORV0P0rUH2nvj4NHRuaBodGvQEUiURG9wMSqqMF1Wgb+l8t7XkgzonPKARLPWQC5lRZdDxPBXSt2JxZA2JsQHh/O0D42kMurTTI3jMNtutja0WnCzsGYPRe0W8ZU3TAxMAs6CBhccxpPWMLKG2Y+sXjII+EY4nbENMD/Y0zUxzycDBqyfdsB4cLGt0jn04+oSLGR3mmlFQaMqRkaTGhDD0fD0QRcr83duMqPy0UySS1E7IqbPUBZ1PHK7Dc05TGwDT19xIK/tPzTAjKkdQmUimL7m+JsF88zqaaGqS1Xa7OHuynoY5qkIJqS5YV6u17UmlXk2BJFNsRA18cW0PdlaDiYfBA1EDTKFO2O/mtSiLsJ/hCVhPpzcELASKoyqHJhM5SZwhajTJV8tFafAPq7D0vK1RkSW4o5jkMOUcu0Z6gj7kZDQwLfSIugR5YhTrNXH0ENQgHSNyh+UooKh7afn7YDR+CkYx8F3wmeWz55I4JqGKSwxDSWCBWZAZaW3vEZSJRUqCwrPFEpFKbuf169NV8FyHQ7hq4qma39O/+0KP9HnpDllySGOE04fiMP0EN+7w/yKfJx64kXWogJLSW0IxneuHIMKqRTZPNg6UyW4KC05zAk8xk1rpbDuhTZOWEPdCBDKeJ0dj5QVa40bkBmBuGJIrs0kP5wmyAYwq2UIrpjGTcIKL1iGiSmiUC2mWkNUM7kVYnLZCILB/Oqy07nzOiAPZVg13G1oaO++kaA+GaKeH8VoweGC2JR+NztUpukek9a1dndFg2hPwA1tqWUCKIfxIzT0xXjbDhCRnbsaifBlGulkqLGwdjIoVUNJUDkXEe9BVJU6S0RoKoTqCy6Zruwc5tgj6Zr3qwuju2t394V40oGer6Di0yKVxQ1yDKtJFJyEoxUPTsyW2GhMLre1Wmd/suFllh9FckZUHavjrHtwTntvyHSC+I2x4HjvhlhVhvBCzkbY64DddNJ5wsZebAPh0f30ppLv010v05dBeUxIHtBwplP+yvp+q+a+9/WPy/Xj0EvkVGLnemkUU3rnyLRt5/HW+c7/4m0Df2FXC+b3flW1gTFyL29sTAlW1aq5cN6uW/CG9uVBg0Kv5SzCvqwuA8+A+Cxwnx7yaOM+Pru1Br/nmmBy77fjZNXOb9DIq4rPv7+eKs9ReBxcnpaCNPIYc4Pf1tPHGC+jkccYr6JwjjJPWXocVpav/dxt1KQR/flyUzd1qurmxZGtwc/rtx4w6x5fzm+ZvwKNb/atwo1pbz0XNdi+siS3CZ8XcQxoXHX0UWlyL/DuY4Cf6NsHG5clhfAHYZ0GuXgBi0+rdxRUst3nu3u0G8KSwKpfafgYwiHO9tCmPYpA9wpfF348Vlxl+CFdcY/wLgON39XaRxdbH/6vvdmGi7/ctYowlnIb/+3lBUtOP+KcZozP11bNGi+7dQx5nwb8WNtt3BpmOKz4+7wGN0fzne+jG6GyVTjYT/QsJozv1lmLtPb6Gd8TehRgPvHwKPNt7frlVwmvzb9Dca1D8VNAbY/rOw0V0a793pBbFfVkFxLxBJA4n9pA/GpEMZo7A0yUzsi+uQfBvJtIbR6g4PImoh+igFUtpK6UzEvuIwbDSvtgRsRhgG+89SRXsq3tvf33zasRmzghEV/3raKNQW88HuYVgYVfHvoYxxFX8lXYys+PdwxznxbwaOzuA3zzE98MDTvxEzJNuOaZ3Z9v3XR/tvB5rLx7x8DHFfO5iyeY5+pYzM1TJIIixI796+fj1wi18naZoZOohpxO1s7r5+hZD90NF06D8JGCT7PwspGtiRS4V2TuCBlMkKnrH9niEnWn9Rdi6BUv7seYy0/Z7zTET+N0Hic/D24GB/kGTcsJTTQarkg/01Ki/6heUa3dfPi9pnVglJqoWd5SiNBw+Es3iQKb53pw1NtSdk5z5rxdHYV63uP6pZPmYI36M61Dw1igg9kyqhyk/xjpWeuMZiroOFxamd2IrL44IqakWFmiwNOse9AsXizn4Nd/ag7bjbuBxndmIPE3dFZOUGAtoCaKSYtchPQtFlpFWjZT8nmM6h7UJYQPZ9J2quIXJi8blUN/kE7wE1WhCJQ2InLvtDxe90CRxNc1SdiYcOBXTOONUIp4ATydSu1am1oSOqNY2RTEGGWls5s/bzFZmzaCiTBCf2tYNq7J1ASKebzogYMiWaIp/NfEb7SKgg5PyD+1dsHpyH40ixFLVPSSdWEofXejypndCJsuMJ0WzRPNNPtxcIp650pp8URyKrRM6VTM45eZC4rirZKPotY8pdfiaKkSlHNWMXC0axpw5NE25ABGQfLylciJkMG8Qex5WMM5hS0wml3niecf6RJAinC86Nog+MPp5TYjIF05uzXYAkj6m6IWaBeDrwBI8F4lk7wtweBOJZg2fot9hR8XSKjgtfpoYqPbZzvJgjpLXqB9F0oLmiBsF0Kh3OkM16Nvb9iKeGxxQtH4ie2O7F428c4eRwmA4lhSSEQPk2k28pHTxKdZ8HEISI9iuqNYjzGTvyGNvPMUijoLHITCwfBUQgRYSxLnRHPXytCLi5JFMKUsHGdMZE3fN5Re1HxKEBymHGHbAEm39IOJ/aj0AkFsmo1gAmI9AOXJzBos+Jt0/OBSJxW/61BohA3K/X+d7JPc3nnhMRn0QR5f6gxyfFwxgicDdwfXTnycyiKTf8iWCG/UkvrfR8zJKpncWRTknHPX5LU0oM9KXhDSciTNPF1VAKQ58QTAFmtRHBVGDOnlLiTkw1bn5hZlGsDkLwiEZmOzC7pYk09I+UIq2cll7IjMfje5bWtp+QTk7Hn+FEjb1mkEU88yfIXQibnfYhwrEL7+j+imnNxPym4cvpvAMSUTg07odS7vcLwyocRgSrcHbhUhzSBLks9e2PhJlzGfDkr+HCiCkny9xnYV/BlopSJCBiUDQkj7iSMd1zWYGyRoTwsN6CfFp8IuTT4CNiFu77RC0e0W3tCSTURWgSPhPZdLAZrjSOBUntUtP4C43Mupg5BwWSeY40Ia1daJ2GFQbC2gUWUgqmUQgpcGm687VpRzuyCkxuqf1e+yZG+Il/3O0I1u3wzgeQ3jZ6EdLbQM/5Fy9mZ0lqlpXDMW8ARaeOZbD/5uDVq4EmCR0Q/0DuMgiIFCWG/ueFocACx7YhCvk99+5CyuU7d+8uvxd2idrtoPgZZTsj5jVRmigKSwcl1CxkrPeyVFNl9oSVpwcrQEYmLKpx+eRvD50uAmYgNMYYEwPtMqW4LLnzRT7OwnvukoGRA1FXSDfStrvl38HQXs6lYlSP/7gcTRFgE+BdUvnwwDqonilogysp5nJ0uk3g8scQZRfKfYdyv47wk9VzHuHJjZIzxlEG14MTneAOvBQitia2FVNs/87IO1E3wvYNsJzh3wltfwXaPkLbCC1pSVoCTdIESayV78sccBaZPRePYRw9HyI/eNCDxOLkNXPXvpekzBDO/qSIaiMqot3KwMkj/53C8lBwOZ87Wp5NDcmlnNdTsiMT4Ew8C5+QtQbEvvmE8zIE0x2498trjWjqoakjplNOluAym5UlwfSenH51NRPv3DMuP2vhRHf5xd31CYLpBnOKYNpgLplGqdkGB6zkcAsA5eY70cCSmkywJ5rKaDFI9CC2a1DDEtralQNo7lU1GPND6WdFQ+Di31a2gUzv8DxE115jI6AKkF+EowjtTAglaJWP/SUZRy30DEQoQzvOZJ8ZGdEZsewQ1pY5DVHtPrshq13nOSS1ltR7V+OaRShc348MZWybkkdiuxP7llG1RGC7A2PmyUXZMLEKDSFtXd2gRO28zkFUXaisHN16WhpVVje1IEx5UUm33++UFXgd5Wc58HEQCKQVzbdyBE4PNDW5BsGQ0Z/AC3a06JzLKeHXCQv3aksUp5VdOygcsc/CPyAhFbIuzl8mMrovGvNlb3Sf50tGPpv55CnHEVNV86EsA1yv+aCLXIGgSDGtM3t7/6X9Hx7y2kJkdWqDyOVgf//w9aCyEwdO1bhwYs6miqhlLbzkSgLbrXw+ohGlqcNkdc/TElltZGU/+dqqa2V/NMzVaqGZDl69eoO6uk7k6ODNPhLZQgRnLzd2Dt+8RUlprjx/G3tXKbHLBFyEVgek8GgU0tgln0/CnmiMOY+ewWj1/LO72ZX1qH4DLsFkIKxVLOYyng5mhHFnHT9avTwgZpCQFFOO/BVQwR/R1yraU5nwJ0YiqegedUk6b6mIqXLTAUlTvvxMOIs91DyvZ2E9KP+cS9XlBG+4IPz+kj70u5bqNmInap65s0i6bHJ8KmZW5ITpe3azFqQiwdsk/PuB8pTWBCnoMOciaTwACtFXLcWNkkbaHu9pKzk+6cVvtvWPsEdbwBqzJOVsxmjc/xK930+pvAcFT171xo8kr6fzqvBeNYfyWhUd539zwVjuRCUCWgPovOdZxxycu7tgWN5Vg+mWPHrFQo2vtQVuQFVIYroNipKZiCeKpXCg5AllQlHjkkMmJjoGDsG+c5xNR6ynBTjyfXa3Z6O/cQ8kvKwIBIfRJZuOv/FmYMK/e5fwf+09l2PyburGM3FrZ/vA//x/vtE9+mJuJ4lsuhdS5BSzyMC2DgyZv0i++t/lP0K4DDn2Ld2PaKtL7qZL47/g4KXrfWi7n/r+vHtnG5i+oz7N+PH/mRGuqeujjL3Jd2fcG/ffvH63f/Tm3dv9/1t8Uded8k0uK4D7TQcvD14PXu4PDg7db7F/VXtn6d72MnyrNsT3t/hW26Ro5Lx/x//HqMw12TU0tVKT+ba37n1TTsT9nWt3n/TOo/fpGMq2t+HvEdOyZfCuaFFuYelaXr7Y971ZEFV+fg7I2D+8uLNCxpLQkVdePFxOCE6frMiUb9g/aLbHbgPRg9w/eBnkotyF9H/X4i8nlf3ouyi4Ttzz/yHNIqxA0kylUnt+Rb3AgR00TBBh/s//u7+374XXonLDoAkv1CCstbl8zndMxCwKEnZw9PbV/xbtZScKzIqIufve/7G/+6V7LOIuy5t/pxfZ3O3hG3I5eM/MhMz/wz8tFzTvqO26H/qr8vwo1f2My0ddSjbJjBxE3HZ4EJ4ZxExHmfb7ti865HyXNzSk/t3+q7cNqX/74t3RryT1B6/ftMT+4E2H3O+/XpX7g4OjVcF/+eLt0arc54hacn9w8PZdt+Af7q8V/MPwBU25Xyv2Ub5D9hdL/eHPknpreXy/sMfWnIvM4KucaudYtZ/VJeFrn2oq86Ojlw2xPnhx+PZXEuvXBy2pft0h1EdvVoX6XVuk91+1VHnA0xLp1/svuyX64OU6iT44OHhxcPBDIu3We0pybs2ZnyjURz9LqBPCtkr1wrvI9J79i/3piy/ZLr8wHXZI/U5DYt+8PGgI7MsXr38p6+PwcCfrwz+23foIGrwusoFPS2L337xao4PXCexhp+lh/lEV/Gp//6cZHl7CnievMXWmdkS7JHblXkNmj7wdX5fZo19Kye6/a8nsUZfl8K4ls0ddMtuymAOftsweHK4xmNeaDf9CmT1699PMhkLGnie1M06MxdEltM1bDZl9fdTSs4e/lr3bktkua/egZe0O3uykZwOftsy+XmMZrDUM/gKJPdw7/DEta7tm/3vo/9u2Dw53kd7/OA+y9R9tMX5UxLseZ7UndpbmOe00GKrmhhSHaa8uxftvfilfRUuIDzuEuOWpeNU2br2h3JDgwKYlwUeH/7wA/7BR+/pnqVznT3yWfC6IiHmnhdC405DSVwdvV6T01cEvpWvbYvqqyz44WJXT4DxrCurhu1VBDXjaqvbwoFtSj9aatK9fHL7+2bJ6sHfwQ8r25TuvZl+2JPbg+yQ2iNl4KSL3q8LViXaXz5Lje7rUXVJca296Et6+WZHhg1/Lxn29m437ejcbt+1K8HxaQvxm/5fXtq9e/jRvsBOu54lpQtIuKa2am+bAwcvXK3sX+7+UlB61pbTYPWj6u9piWmnfupy+blkFAVFLUA9frpHUtZsXBy//habtS2/avvSm7cvvNW2vrP3a5f9KXS7v//Cbe2me8POZwpyf/eiQ59qdpkgfHqxuxx38Ug6xo/Z23NsuiW5vx73tEuiWPAc+bXk+3P83OBd+1Hpw85H975ufZT3k54+CEPtXz5Ngquadxm/9RkN+D1+v+hkOX/1SdsPRThsQ+0ct8X3dIb5h8VWX38CnJb7vXvbANfZq/6dZDl6+nierthedroRae3MLuOVLePdLSephW1KLbazm1kNbVPdfdqna1kLtXbdH4eDf4FL4YZ/YW69o/WLt4OV3Gg6/02W37eBkrjAe3OvvsR5SFt13yXOtvSnPfuMM5XmDPHtCHfJ88MvL89E7L8kvX/r/7v9seXYyV8ize/198pzSbnlOOy2J1wdvmrEMr1/s/1putJftfbb9LidEeHBFpLvcEC/b2xYBUtuZ9ur1m3/D+u4H7eGjd/YvZf978LPsYSdshS/Nvf4OT5r/wi5Brt9o+oPfrdrEr97+4ntvr3fbe+uyiQ9aNnHg05bho7f/hhiHH3YIv/E6+e1PW9KFx/9vLnDPFF4aSRV3Sm/9TjPc4e3L1XCHN7+WHt5NfF/uJL4t6Q14OqIdXv76G2/vftrGWxCv5wprSrvjyRp3GsL69tXhirC+PUT3WbUB7fG0TeD9wx54z47evfHWwk9TtUHM/FEUltBnbmVoyq2N3CW9jTtN72+IkWpsaPxS0vuqbfHud4nvq7bBu98lv62o9JxQW4Lfvnzm7vHRv1KCj7wEv/pZEhxErVi6havvWbwZ+7U6zrpjJVdvNjeS948OV0LSX/5a54s6/BJdoWdvO/wSb3bRyTmh9gGjw1f/BpE+2jv6seAdr5TfvvX/fefFu+1vO9rJP+FWbhMnbK4z4WDUyWpbewyU4lks/MqG71j9ZYJ9yzpHQePOyhBYXf8d/FJaff9wp7C1SoNXA6DLifG2PQAOuuW/B7EUP82ADuL1TGH12QbCOeGxUazbHGncWQkCOvylg4B2C7d82xLbw651X1ts33aq7Te//rrv1cF3nsvIZamthHcUW8fHNu1NM8Y7vRT1GyvniA7frniL3/5aXoqOk0SHnQc637UFtisW6OV++yzR4ds1h4nWnOjcf7t2/ff2L9mAfrm3//LHJPeV39HzYRQH3vN24Hf6Dvz+yKHfH3GhIva/PnTo0IcOHXacmnv5IyegT52cXqe17LdJmhlaayFxXOaWPve88ta8gsl1ZkbMmzj0iUb2vWfaf6hrmRYvuJyPDVGmvOMyV5dvDBdFBhl7daOkM/3d9zrwOy9oi2EZ+Os1J/xqt1ai9A5froY0/Uoj89WbnY6e7LfWtIddcfv77Qi9w5fdEXpv/vmJZLf1bE6tYzT6MXZw+H3L2f/I03ec+YQg64Za/tAw/JhnSnTKszkTes/e54Nw4V/f+JedZ6xW7zanoYOjZkTqm2Dv/jrT0FFb2g87Ny0Pjnbz4bxs+XBySO156O3+/r9jHnqz9+aHZqEjL/dHfm45OvL/9fPSkZ+Xjvy8dNR2U77ZaVRcShIPSbTw/bDandOQ7Oe8lMximlk3ZC6SVCo3MeRFjTQ1F/8/e2+33TaOdA3fS9Z3OLaJf/IwsZOZzCSdTOzuft6jXrRE2+rIopqUkniu/mMB1A+BggNRVIbImhPFIihFgnYBhapduxawM8B9LxewBc0Ws+1WVS4+gWbNl8I8gf9/KDvTZ5X13V1RndWP+XyO+3zOuCV6oHf3/RATi4z7ohKFBE6xQnKVKMTsUCUb5cofmIlC9A98tTdC+QxPqHE6gEobl9JOn9JOX6qdvlQ7fak2zFQbZqoNM9WGiVWYBTmAL15pdF7CFcTe6pVWXy3NXfp7NYb1qcin74vVQzmtjTsHgx/L+ROYxFVZ1L+Uq7cw54+t6Dn8d9Xq19lilb6sqvxp71oz9feLYrq78sv68db8V+Y5zPL9/oVXoC9V755f6884pEVPqqflqkTdxP0Ry0u0jDg2LzFMCMLJ23FMjIe5TiJuuV4n0Rsjzkz4fUwhYqG0PSptj0rbo5I9Q8T/yOsHxA6b1zQf99df3161xInmGeyXm5CwAc72xQPZwbSYND/U3L+1YTdY1CEeN3WIBJXhOVbhZk4aqyAucYgPQxwi6lyKsQXh+gpNvLgyqDo6CvcctIsvoC+OYboz0mV06pBUB8xxaf2oMIayw+YkqYtm7tCTzfQgVM7kUDTLc83+HBUNTqcBRdqTm/ECUtjQOgg+wmtA2OvH2WqF5fsGBPkdCvA7PMolE2X5LyKqADRJXJonxYpRnTRfylx4Kydd0k6QK1CRHFy5d04HX6vTC5IehW+h/RahD/hCY13oM4jQZxCpzyBSn0GkPoNI7fNI7fNI/VqpXyv1a6V+rdSvVfq1Sr9WuUxovbj0CFQ3s1qv6o0DNG/gsto82f+7AeR0Oqusp5s/Ibi8P9R8js97z+fLfPWw9bEeGgzvBsGcrg/Iv4cYLPx3aI3B7rp16JDEPnRERReUgQXkxMkZMekarRDuuUOimxIjh3JTCDHauoOarbyQx8XptIEJbWBCG5jQxim0cQo3KyT7Egm38bM/y5nu5rPMq1pfuM1rbQvwd2NZmz8XMCda6n5A+1itnlAC1/Zy1zqEtNWWxE/IW3HdNdcyXNKKmRzXMLKfoZAXKbjpSVuZ1XmDriExDKQWlH+1u95FcZLZ6Uft6cQTWQqTviMsZImXLqPWzI/LqFWemLD8oeeOYwt9NeVQZHqJz3oWRiJ1ZFXzAevZnY7ETotl8wPmpotNA9vlAfRaG/GL8hq6Tt/dNe9R+7OQ/tu61RDEVnGKKnrEkqAFnKZhxEMnqmqmx0V+wsdQO3nsIs6yoRZxBG198V0Vy3k+0f2O/Oj23WSzajObWB6X1rkICye5YudIOIkgtHI8ZSB8uT5vqi9V52Js4SSmj8msbzjpk0GYzq+5eNcdJ/duqfujXfv9H5vjZ/0c3D13df2YNLXFztKoWlYg2v5ocZCgYcu5qw1lZsiNMPlU+aKqDRJc+zCc9IT8Tb1HkUKPpxqAx/GoVvXEj3N7sJvpsjuyCMMciue0icimElQ7ipKgZgCu2oPwtGQh3pYsB/ci+m8v6zoSyuRQ9W+3a9BLvXlaFhan6b5YmatLaJG7mDx9NC3GfgGsHgh+aMaCLetr3G+hdlSF0rhwHlYNFOC0SJeiRNEVXMifoKaC/8B2Q07DvNsCsmVn9V/z2apgunFe9xLKvMPusMou0swqu8jiEulBeDtcoHxXt4ULEdiyLd26izTD6y58IRaSPBMuPAG2s4vsCGwDzQ5IdvCLAcEO8oHgmgK1Djyy1JWzzAKriaaXuvMlfLZXGozX/34HWPxU1Ov56rpwR94Xq9y5qPsy57emEKIzoktHc21cMGaaR7Z3GNi3/HLnlW8Xy/Vq1/3a/8q2+6SXjdt51/b7DmDezc/2pdmlmjfw1Gt0R61uIZJbZs1IXNVUbtCUUdSskWoqTHuLuB1DJM4+ksSzW0nveUPyEVp183ng4ARrFBD0gJ4H5DzVfDsg2aq0p1X/ls/X+tP/uii+Qay0mIIrptth4zrMV8VkDre0WszwNK+K6WU5Xz8uYGDj0llXdHPV3bXtJaOAsPeOn8qv7V8vq/shjK+AL4PTo/ZHrICWRfaj5ySqExDSiVWFkP0Uwh/J3D6sBGf7CR/bjzxH90vJuEiwkMgHdxiIHzLrSX69qmbNou4zJLPkr/Zvau2pe2VW2+9ziDFMyfG7D7USz9JQByJqsJaGFVER6So/iqDURTNHPuFHj0/JvDVULB3f7kPgKxOIAJFE/M2Q0whERAgE+Qlw2Al4yQRpIRi2DYXtPmGbSv32+sPVNgHYjJuais6mY+oyTrkPtaY3JWcPqxXaR6M7ZKfJmUVgbA7ocaULUzejIrGznLnR0voTQTVUm2lC0uXMkzUkmXcfyk6SNyQX5JhQBRzgs8b6YLuFMrqsMT1QVoNFDWSGCagME2BtkgThiQRy1Mk/GiA2x7hlY2nF28VdCR+4vZp/Nee73aXOAc5cQk9uZmjvyIZc9p/HysWvi3o9aeahvlvPux/R1D7+HTjIs4kZ2u6Y5WL757Ko4IdrvoL+yO1+qm9vz4r9rRp6RxeVx647g93tlDjbaRLXYQ5p5sRQCU+knROTQXbdTBJ+mhMsHUdoPb04hqBM4OMScIkJHCoIhK4ITBeBuSDADyXE9TvTQGM29lpDxt5sjRBHN3ERYxBvP+xMuhPWuSK/a+RaFm4uemzcDCJW3hl4zs6P8m2nBLdBvCyA24qOUZHPWJj2s6MFQBHumXIzthKXvuPk4JoXcq4NeETZLK0ATGjffO0G0/v41p/xLm9bBh9S9uLDcq9ABRfCClREFadQWZDGruMjSgTTKUeq7IWnyP7gOEV2rsYVpgAZR0hmAJ8SYVNGF6ZYNHN2MZ/Vq7N5OYF5ylc5EPJRi3jmvm4nlswWTM+iqgRjYRle6vDSKEKcd7JhmYduzNWBzHkxuiQvoYPx5gFr7wBqVxukHQzx+ey2/mt+dDROpIxYxByZ/S3yPiwUW/AJUoaO1IKkjhvTThFSiC48oJZeVDNxAhL9cWcHyiDn0zwq/ZjqR6DVMy2twrS0CtPSKixlPc8QP0syaM/q+vlW0pbL5lEd1tO0XxIoRSwtc0nNZnoQ58pTj0j4M0kgvQqMqVqF6UpgpiuBmVRDVav8GJdqD/nmzzPwrnBHyh7u2oDTLymuFrgkrGzFzYMiR2bHAPBeSSp+rWymehLk2tPxu9nt9V/z78V+jgf11+L2GUzvRi1IZ/+DtBfSKDtO8fghnQ4B6d+L25Oj+hy+nh/W+8Nd/qdUtt6piIsnhsidBiF7UyTYPRq43E8zQe7RICOHVoq3mkEnBng7S4FLthh8yX5fTj6fBOB+bGNnXsWtM6/icaXMQtXklVNtheA6QY68yqO9Jg/Ol52kbeOR0iBMK/AwrcDDtAIP0wo8TOljrmL9pEG6ua+99NbuojGKTjrMXEKTYR0T8lxuLetVXg+QN3jMq1k+vT0+rJRZWWlhAisRmZjrE1G0YbUrB4epG2auuiEuMUK4r9pL+ClexNjwiEyMgRg2g6gvAwYng82NAamNCTKU7k5zxO1GfNqgTifQY74/0LduZkZ7Z3dl90yPHWMsfaJBzQbbPQqzcxlV+pgIJPZKghRAGVIwljqHh3aGHCPJfLQN6i+t4SdwsI5LtzHglDEoimSQiGdMRZxy2zeG9m/MGrpD3dNGRhPrtKGikmuj0o2OchkkaWLY799lVLRThJw3fA0yiV/34VyfXUaUiWBg1Qw0thhUwzMIjTNotsCAR8JAS5tx0TMD8R6Ad3Xb8bzaa6jr1Y45vlf3+ubMDr0KQbr9fTNNLRUKZxvny/x2Np+tZvtpC+tiVXytZqvislwsTNeGMA131yTrvQxh+1ZnRrPe49GhN1lE4oR2N63sXMWl84sdnrCgAHMzhmcsCSke20ySmwYXiSeTIRJ/IvwUByhxIY4hihBdEAoVoXDwS2FKU+KGw0Rvx+5tXc5hhhfvii/F/E1VPrZGYCaiauzuevJQPOYw5FjKRoHRO/ByvXpofuvZRP8fe4277mZVvfpX8XScsfU/N3GeWOemyEozsVgy5hIqNxtPg7LxZobcLZBJzxYoxDPnpmzwJOFx3YVSSHWmQN3V8mUpUHdTCCamsPOnCN9QDXd46hrdf+NEVR+TXedG1HBnPNxQwSOqLBNBfFzixhyQ41TmhKvbCXJtJ/GF9ZT0iyida3bvmOiLQEdLoYwshTKyNIm50nJnCvov9CxV+wLcnDJ7F4mL05WGlYSQvpQuM0HIJiLEoZod4jwVI/POwPlM4RumIHaQQtfUlMp+3tmL94Cy7rEJruCHJhhxj0x7Vw85MB1qMouiXBztgRFmXJi9mg56HtUBh0s3KsexA45hW1kHHBXU1H0zS65CNkt8wsJeN0yKkxRKHtn0gcOhhgPDjINPxsEn4+BPcPDJOPhkHHwyDhFPDianFxUOJsfB5DhUyXDgUXMI+HDghHCW9Gzx8AKKF5fQ2bGY/tL8NF8K4A5r583dohp8zac3ZdfB22rO/5FvusztLi3Wj1D62L04bT263ZXmd25mMn9cei6v/uMOuFesmx7LRWF9nG+P8xe9zb9XLJ6nyorFx8XMJEiH8SBqJsGKuTKnV0Q7QY7Bpz75zWcKo4VZUUbEzdQlaRwCGpzQuIiZW9jDH6iaeIHvdJmOqHYieYTGFclz6T2CoJE8t62qwFRniVvPYibJjeQx5tGBIsKP+/EpcXAIznCoCeKwgHBISXFISXH4fhzcAQ5heY7ojYcpcbz89Onl//vj/Yer13+8/uXlq3evrzyFw780OO34mXDh99q5hHqeMOA4nnsX9/zO3RiqJmANDMbKW94P4JsKZvmm7JxGtU3xlIYpMnLFwqr9XSHdzTQhzmnqc069aTKpxuickkRqrQ6lxTqUVuuA2E7zqJV1lJbWUVpbRxlxHa2uo7S8jtKvTfVrU/3aVL821a9N9WtT/Vqsc/L/3NVB3NV2PejjrEpbl1VE1hGdMkRNG/NWHfoidbuhY5VE0ifKKqhPQMvPHGHD12kflyRorF/bq9T2KrW9SqOjpW1daluXab9cwYvrcvK5WA0b/jS37L+zvsW5cDOv+7nBrTkt0dT28h53gKXjAPO4HGAZRjhhiHQOR6VzhOsAS48DzD0HP+pvpEPHxwVu9jijO6d3xlTvjJneGTO9MyLN0obiAn+87/i2H+9Rz/bjveOibi8N55w2GCpW9aTB39FeKmdJZqXh4vJRCSIhQgTalM0VSUDIv65RtVOEJOKUp6Sc+0+V8hSN2Y7LQDDYpRlERxn89AyWBEbZUPwQ1F/cpapPmKC27WRa3DVuWjFFJaO6Y91wo7BFRFhc7VCQbtJBwUasrMrJLjBc/TRVsdcMMpIOJSFifvyrFmNHA7lXzJxkxIqZxxVAJNwlK23C1t8LmpOQ+sB2htzq10z1CJqrcSmgaSIlQ1h/9ITh8mNxvvccPSg4w12KurD0O9Q5i0stRyVhuWFzo3ViYEEh83aSXOcmzXwkdW9lEzmJePVxp28GNCMGYUcGaSztymmuMIP8EUPyR2HH7k/lfH7b4HcL/Y8ajNcAxu5BYXcdPzHsxt2jgzP2fSHNDWlWP3tf1HWDw6MNcdX8omgbud317maTMdtjSiP3mNAjhQySjGcO59zMj1splf73fabjUrMMjk86gMHIYJo50wI++q+ruxQ+2Hq2WKUvN1Fmg7iD8T1Efocoi4UAwqdx5Xe0Y2RR9zCXiiM5WSbCyEftNLkxqYx7krLKu8Ook+wwJLsgRzVIEFAQ1jwK/Sj1o9KPqX6EOJXUUu1Sa7VLoF01j0w/cv0o9KPUj0o/pvpRv1a3V5BEvxbZskg2eJZn1mGX35TXf2mKeev2NWf31lyezQXdluX8v5od6rsu9DpgScGtA5aIi9Cuoxq9SEkqiJQkcV33zKvGmz1TH5zJce18jZkTbexUP7K4eEkb4C89KRk8JyNFwuzedHGlNjkNbGfAaWA7Awf27SQhzemoh75OvbpDlIyvvJBoNe3mUe9jupmBbrvXPKqeLPb29FPWq/uqqN1jUTuwKxh0x/bPWq5RFd+KyXplDmqf8q+mTlFfap5dr5oZfDyk9eNkPrvYdCK+Xc/maIR5f6CbgpGpnYIRkZ2WXDYrRStABHcbt6qQIt12jlwjIr6+rd5aKJmM7tTEQXqFg/QK59lwG8fyyaQvf8/rx0/Ne7X5lclDg4j/M7XrzUF/UryBMtp3zf/QC/Btx/rzP5G2250hu3GBrcIYV07FLf7jQb4SEopWDGlcgEvrHqhTl50nrozKn//NpArncrDe2wZd/UC7XpzBp6893eI7g91yPWb3jBdxaWUlQcClIclAh8xpJgep1OMHAlcZck//NbrxDVZVOZ9Df4lhJBY5F0Mh9zGfLQ6CbT2pZstVfbGsitkCfnG0xNQZ7a64ie7Oui9nnsQEXOmeTglFC+WcZjGIiqIj8dZOj9vTlngcDH8H6VNQPPhRPrqWYeDAAeNwkOGQHOKc9y0yzf8sq/ezhTl47p59zFeThxceuO9JgRSPOah5/GZiqx/zyszNspotVm3G4uVi+rqZ1rd3+zGrZqLa1xxmPM259vLdW8xidpctyq5Tkp3G5ZEj0v8M7bOh3MAuRT1y7rJ2Kd5pwyubQ73dlehJdEeP9FRkzw4ygKr+JL8NYq+K2/U9NOPEcGsPdgORqROIVJEpFSJynhlK6XPLTggNSku0k+QGI6UnGOnNSaRjhC7pCd0tsI4H8Bv93TH0dkYskhKRFnSTuI6F1A0oUoY2OOJh7ca5S1MiaDxRqfRnQG5fmX4DquNhq9sKN98aA641ZqWDCRV20+40sgajrtcg0RJd5kbDqQgr92unCWnanXqiG9xb7sdPUu53HNFOi65zmfVsNbqBmEeRcl1VzQ9hwnp9feG3ixm6LO9dt0J1NnWUsnMZVdBDKXdZJgRblxUCbYVR6ZATJCd4kFomvoaKygttpcaX6eHgl3GguHCIeXEBp0jR9xT5qbhvMzdXxV2+nq8u9f//drFc64IbgCNiBdsMf3PafNDoaN6xgnKBvC7X1aT4WJVfZtOiOtgurlfr6Qx1tzsj3VVfGUWOvVVfGingaGxDcMw2MLqbQFhAWRLU030zT257aepb9pk3g8NOksI5Ts6OQ1k3h19e18JzpIMWD6xEA6w1j3d32jbanqOmWTsM4TvDr9UcmkpoozgY+Ovby+anzhdo3tIZtdqzZHZLUiXiCpWowMOmzNzDJqZL4vbZbScJaR/hy17+6FDJcWWZus02hxYZussqh/Q1h3YDXCY9CzI/rRcLoFBDHL/5pvDZNpe0tMjy8a0JdW8JMG8fIUy4fXpVLMpfytX1Jnq4Hdjh+fjDwk0xLx6LVfWEGY49aG0cln4+OZdRhRiVCCKLuap1AonGI/sFrp3PmacqgT4jfTq6M27fVl1bRB2P3N8aH2rqOeZaY93DgJLCyiKp6AM0KLc/oT0DNFQJ/Bjg7RX0jJr8+MDLeoJ3g6oBsOun7P/m5+szyezYoojLU2EuW59yFLqOn54gi67Lz8Wz91niwa2XnpuNELcq6YvbvTDLUbD9Q3/u+o8/Lv5Yr2bz+sJ86LOJcXE8FSjuHV0/QnDbj4gK1MKlDhKsc5vLvyUhvRHb6XHFxVJPjpL90M6IYZhu582GtOi9FJtIy8a1HhDYebVq4DKZNV9ymS9mE28v2+du7J4vk4xb5NhMxZ6Kp2gqXhL3fIk5HA45tp0j93hJfb3I/Y2miPoxOD+AeCX6ZjNRyuCqrIrXiy/Xi3xZP5SrF/3BPjGnyNqQSzxAt8a6vrRUNiMrrrB6hlCy0OoJhwYrkBYY0lm92wlyPWmZjVFc5BBMKzKstsiGc3IklPeIJR5Ao3d0ldq0Lm1HqS0uSSmGnBElfkZ0FKU4UgqnnPBGO0WITpvwJPEZf07x8AeIjRy0YDeLgJBqKK2R3aqtyxfmRb4Ycvne0FE8gHeHuw445Vlqt6CIDO+IwCcuzc3SQGlupwqOUIbTBVni64b5Yyt4jnRR0uFdlCGwvQvledCN3WAdMBPRJcMSHlfIj6WumyJQ4c0U4WSFFXkSnjIc3ipRh3Y/pskIAZ6NFOCbgJ8P3+64RZZltiyaiopxqBBxZpRwKBwfHAkKSpdu6AF2JlT0PngymA8+mE8Cn9kLZne4u1RLe6U+l1E5IsKVXcIy8U5KkWO1aQ4/q50eN6fo05+IB8l9SxVcJNf5YrZqADQAmO9m31brZrW/uK1gys+KbznM5dmyKv8sJqsLKAvCu87PFngBG7FLhqMKBCK9dkMqhlVA3aWZGrd2LfnBwA6sujwkcSP6MsKHKLvE8fy4nq9mZ7XuaH0GL6wvvoAbfTZZN67N41m5Xi3Xh+ObZJmFb5L9D+AbKSA0pc6znwHgYiQA1wWYvy4BH20ZptcTef7W7rKdUYs9bnqwxlx4nIbgWsgQ+WzKKApt4et+FJFXMph/7cLtTVU+3pQHg/0WX5Jv8RU544mwe45ERdKjGSLwiCoIu8o8iE/tph7bGcIC2T6tkmealJ9odT6unAdYrcPFsje18A/5Yjov3jb/0ZfZdJ3PD5Nt28D5vq0WuvgdSu+LCsN2d8iKXVv4JpHhWyKS8CSk9ThH8o+udCnFwc0ScmDEmtBzMS7JKQHMcwH8AIGUKrDACh4jwNNcfv2lme5/r4u1ftZC7nhmyRbfMzDsetkcG6//QrVPsBu6bgjJEssNiat/lMj6qXMKGuSGmOlx3RBv6doz+UguT1+cc1CgTwDMISkJmVKh0n61OYhK7j7qNOT+ml/Nqk1pWgOWKajiTpvRN3BONBcX01amsz54wZ8tZqsLGD37Ws1W+ILvDnfFTbh9zNQc/Xh8GrfwQAYpryG9CJVTqmNmBxPrjL2dDVd9yw4Aur9rPB2/omsAb5b1qYmeYCDGb7Hjgbb3Ehc1MA3sq+lGTLB+NgQJCgo8KsgOXNIzI2Qwpip7sFyu1JFV9tPtqmxYHoNA/DFfNM/hFzzLl7OLfL16OJvoin2UCesMd/mvxJEbjKs7X1AjDURSHFmsXeIrweUGaRb7Yi0IHZYf+LKBWQGqa4CE91uEvvx4OG0QwbcP2GjGXdHMyrjLuDR+OA8rIUPEXxEfJHXUX9sZclPujB5YiKPOxchk8gUUEwlIFQhCep47Acvbct535f1soSW7kcL4OQweC3D9O5wBaUWHuZEuSMgNlqdidSKjJpQWT5xFBCXmXYoJpnbsnj0TvAeZIOLws6cueRgV4OHcCSQwkaQ9AQ9eyg3MzrXBGIJ0PXn1TXlZFVNY55tP88JgZvP0ptRvcfiZ83GyvHh/+RFD/u5y12mhibREIZK49DOpCpNxUw4XhSGQpw6rqp0hRCnZF1tU/j7dpl3AiLxzAR9IiL4aWO8nSwTh1Xqxr9twCIKX83wFU3HR/Eq3+uoyrxoIN18bPXw6oxbNyupETyIr2+FhTrkbNMeOnW6qXuI96DmRh67myihDjCmIkg0mX59X9x+qm4eq/HoknkHTHkPx3nWL0W0XLBgvMWaaIEp5dVKaLAuhmpjpcbM+WfSnSp72LFN48Y8GS7peeDFAvXAXvn/W5QIcHAzC1lgXxoxlFoxZXN0Xk6BlGKm5YWFSm2aCXCD7ujHQZwoSRqe3Bn3WOLRR5VCFyjPRU2/tnw3EfsvnJnH5qfgCPdTgz1dF882Kj9BKF55+WBq4Dwz+R8NmQb0Qa6x7oqRO6TCNygdBpGbTEB9EZCE+SDs97onSVzjslX1oTy5jahYFMkIcsrU8I0dk7kEr02Ae8pEG9B9ugZmtzWFzuTaCnMPhPp9MirnJ6k9nNQi6YeDvDnUXfu7kfeLqLs2zoIWfOpInFImKc6QWDc/7MMHiz2FmfYXtDZ5Og+Ni4YNxZ6Tb9S9Rdhg8S2OXo8IS8ZkTBmeIBCB11vB2gtwQSUIOXcRT04l3VEDu64m/XgyN4/Xq4UIHyjEA7w908Jsyq8tIek6iOkVSloVxY0nqCL8SFSJi2U6RS45N0vTQzq+EsnPBxuaJgBMCvxZPaU9P5DKfz28bbILO8TadY8SOB9EKdGBerlcenO9GLOKgcIiDURUIJ0HLNHPaplGEI+uKXZrZcT1tpg7sRkJHuEqnfbuRvNNwGhq+9UP5FQPv3nUr0ueESOKqvGFh0HVOiRQpveHEjfR5AiQpjz/S11cb8PqhDUgPg9ti8WVWlQv4vS4MktDC9v0RSydb10HtQzgufQYpww57TpSPMRfD7lnPTI+bbOEiFgj71C2T3uqW+sc+EYanzZkPx3BnxEoYMluXQURV2StJWM9gGZIMF+46bObHBXGSHtg2mJ1TNjIUi96d+ABOJ0LxoY4EI4nTl4/FFawIK+LNHOVsigScKXWb8uF8DqXkwRDmYmQQ5uNwJTa6IX3cCMoTm4HHonKFMxGEX9eNwBImiNKqmR+kdVkSvSucqbE4EhsE93IihF6b4mVtnNqJMPMTTtsYoRPhh3A2Fi9iA+GDQxHK8iDIuYyqWEuGkeaYm+3AknZurblKPP3xDncgdPHMqOCbjsSDWDcfsG/WmaY265OKn5D16Wq1o1lnl21k5sddfymJP5imRpN1NhDuk3BmqaS20qmKnZSPhYPddB22BFPhKp1KNJaWyUN7xWSGkDIqCMux5JvrovrSfCxdjNLvLCcSuwUdj2olTrMwmVOXgI+c5YSD43Z+3LOcz5WIqCw2ScZyluvAuNeBLqVOZiN28SXUoXCqAlkSktkw0+M6xELEj2I6luNcB8UHn+kyR286i50aIYIWYoaI43FXcDrzCE6nh+Y16LlutTQqDJNxnOm+ltXnuhkuDoYvJU5VNokKvlkapn4nshBqD81cbo+nLpsnB8ckxkftEf9V/LYdQB+KyedlOcOlYZzRDnwVt8g96pzGRcBExGHaWINFwMwcAJ9xrATKSWu0c+RyiFPhiQpTbzNmepJuzEcWWkOkWlA+WKet9eJyC7pLLUqkn8MnXFVPN+WnIp8CVRPkd6+1APqLnsjXb95KpZ8tc1xDxnuXlRpRTmqE/4wFrcLtEJpi7Ym4mxxRnuQIH0PvrSMVNsBmBax9gqp+NGTXEqZQ/t98vsJYwQeNwI2u432xutb1U1ezyn6uhamflsX1pJotV6bTbl8bMXIHmgmNt4Nxxq0K2dSpkI1qh+AsSPLU9c+RAhPi9oY20+MahU/y1NuCMR2hTYACB7h0giVD2UQD88s9yG2sYV7m0w/VW+gbk88brO3fA+OAgevZYlK8mVX1qq+GhzGJQsumooHv/ZFu4NtqR5qcs7i4S27inIaojWGVsi5xCW9EmrL4FfT60pZe59X86eWkeZ/6zTy/3ymzD+DwgwnpDWXblw6TPkXvsYKHqe3ypHG1rXP5TASjgyikKXqC+TzMDSCmqM/Dla8zAfPLio1PAEHA6UmAXL+AekhBk6FErRv8vV3A7zkvph+rWf2Yd+DYOjzICLg+vzRf/X05Xbeyqv4b35WTfP7RWAloMBhp7L/Ws6podeXhrp7bBGxJl22zPKzWyxq1mCqERc1UEa7X1JqMJY/j1JcjRCv3TN3OD8JUSQ+s+EqT0RUdEDaUvNMOZD0xvFg2V/IltBxDnf/OUBfBpqXyPoKTuKgqtJ/EO8M6LjkS7+30uGW5Kjk4LK9GJg4iwLUV4NMJJnqW5OpeHpcGXluZ1Y9lvXoo79vLe1f27x7KSwLoN5hZrVFPvzPS7dckbLHsLCpPn5N+ncawUjGHYWgmB+nUlB3MbgEN31H5+qxvQvVjVU5/WdbXGlLvyvLzejkoiNfVl+IJBfH+SLc/B5Pd1VueUxJXXN/17Rm2fhMuQhKrxG3SwQQq70RE6iN7e50QcZLcKr8gRzn3MF+6hF4Ak0zXKeusm4AlQsD+KCA4JkCKXMA0Cui5o5v1CCAXC44wxsME0RpzaP2WZgBsQyO18cnX81Xnkl75jYJUPoX31RNxl08wfWLT72z72hdbiF7nd8XmDRpr/Pa06462vftt87vpV0Bvt8nqTVFMQTOiPWCYT7vfc2f3+XUbnN3Ten37OFtZH7+BTwHF+vq3+X22epgtbppLd6AB29N3Wy7v3y7uSlRbtjNkxWsT+1BPo2IEMRlU4sEcYc4ziqXzXM/NTBDCMZYHCuNnyfgCVowMdfaAU7eBWV/8Iu1dw5rAYlKFXNo0i+xnDFU5UuACYVkoRKuQS1yrkBx4ngb1+2xkCWrwBQSRQyWoXcjBZ3vMPxdtyOq49MKyauZ11T6ZFsXyNUzlFCd2WqNddTfOu02P+TmLrMlJEtacivDEjdAqLELrRJLaSXLdOEI8J3HmZWcwMcIQLUgjCUjaC2jCKAQbrO9gfb0sJg0CJlvp2sm8XBTOVUDpJYy8rKpcu1Z142/9HaKy5bKomqkbwFBAaNyjpN8dsrwdYlcE0qj2BUH6NeTkPChKxYinnupg7TiuTtAV5UhnR/DBdPT130PgeFZfzarXgD20w6w92vVymLBCTzSq0BOihRiCZSTgKl0Ph+F9CNPoc8xisG4QO3QNgWTtJnlddlxU2SZJxNUdWfbjSPAQ/Jq5cVfi+MuphBgKvxpY/ZrYI/hdNaCbN5NRX9RltXrfTMUcTwXYo91IKnE6HUcVR+U9Gx1jx06nvspMDhJC5QemA4g0JjMqXKuhcL1DWE9c1zOYs6vitvkcEzSMgt7R1Vq2+M2tvxhzy25sdaZuXJBgcUGH3pzi7GbqEwr3dpxSIwwL0sE6wXaB1hPP8BXOTHz+Y76YTdCGmPg9lihiQuLuQqXCaDauz6FCiJnt/CCiiMmB3Xu4qQvqj2lo/FRB6qV6FtXtJIWBerBY92N+WIdXqCeBn6hcaFBf5pMHdFXeH+iG9qz0bBKZ+gCyGPMQ2FKs+5+zFJvZQUJ64kBuDT9XI+s5z6B5EFNJz66WGlCvG0vSYTj97CiqgQXkq5l+l7xCgxfOaJchT+3gBYuqmRRJ+0Ga8JD2xGZ2XIo8ORDRyhypR+RbMDmYn/y5eHr1dMQ6PMnr2eIeJzrujXRX4tR2i3lcHXRkUNCNyKAGgMSp3+Y4AZ7QQ5FLxlf5ykCUicnBEouTfDlb6fIl+EzN0O55f1DP8/88bRItKBHdHe+uyyK112UR+bocFFUmSP1e6hR4eEhg6aF6n+OLXzCZDkZD34PYEUhuvhgaT9673k2HWHLLyXlcHbLdo10QDzck8EZxpWURvdAyU4NFKgBWR6C1av7z2WMBQgU6doch13OPVQqU2QXUKvoYBYZk6sjeE6R6lLk1dmaCkPYj2YEl1LStURlRLQUDOUgGEjhM8sF0BR4f727KTxb49FdpEFlgA7fr2Xz6Pl++Kat2+AjTWC9mf62LV6g7Yo1Zrogd9YiMzxR2RCRpkNIM0gACb4OWqjG02j52XR8sWLdB2KEALhb3zX921q7ZF7fFYvJgHs90VBpDszvcPTxqsnyHocfjQrRAGHpZkHuNKeq7TbTbGUJieWPIfMsLeQSmCbBzCCScCER3CETItb4woa7rLcN6aq8XWir3ej3DJBpfTIu7oqqK6SvApYbj02KyfWKAZCoV1s1d78vJ55fTfLkyjbnNsJ6GZQXSNJt+9H/Tnszu/zzWqBq05meP+bI5MJzrKyj31XOTleDhqV1HHVUdk0ROAUGkEoHITadI1yuOnl85obGfBAgbjFfSoFPbyGNefa4HQfhsZ0R+hPtusg650q5sSKI65sos7HggXf09gmXm3Uq9dorc0y6JnjxFaDZekD8228dZbvYPDN/IuNUvS9lNj3lUizdJXA0BiqXnzY1WNRqmMIP0zFKozy+JOpBCxX5MfP2ABD0BjW6CVKSF5TrBe7mqZl+Kas+HgYs3zcvqPcb2MclPP/DBP/Gifm/Q6nGoMqs/RlSIT0mQmLXjrSiEw51xt8GhQiM9yqcg6Y30iGPpKMNjHc4CbDAR1ftiUTRTWfxaF9Wn8murg2Su/dJ8ukIrqA6yzDf/g9Hce8aV8dxjBTqFsAOdcSm5szBPxi1gwHx1pM2yQDkAnKXx++p0jG4MxCpv8xUO6f0BqyOBU0Gfxh6wRxVPZQiVxW1x1M4PooknD43Xp6OTdCcyGQrJzf/V+C6gVdrAtIGCXsaPB/SkelquSrzb0d5I1y3hWdyBdx5GcnEAjTSJUU4QxcxOcNj9Ry7LxyWfCFgXAYYDEVlPIa9LDaoXuJCvGYPwYb5oPvSvv769GgDhe3GTTijxO0FEtN8ilRZBnJxnKi45FKTlLSboJdyu40KGwH8zSW5tWuJrWpd6l3RGTZRyUCtIL9JjrAA+LQF/jMA+TsCuCXTPIcDyaXYzeHAPqWlYMyVIsmr8eSR+wU7ezIr5FFi7MyNo2tw/f2pfaaQnlrq0/kP14RYa47bXOk/0e7R/byvzFzCj4JY3b1bc9Ejqfsf62hOHRy3bGe1Gf9KMWNGfNC5CMLLrEOw0nLmWF6KB2k6Qexqmntg98SsRiRPsPepCHWF1WsCNQoRWt2ihkBTXtVQUAmMUqd1QQQb39w3oPhX3s7olwv9Sft1eh+e/rmfTzoVL+8Kvc+vCL/mifNu9BLp+68lqd23gYJNtbbPF2WPx2PxGZ8uqBOVwD5n5mfsszXqr2zA7j0yzXoWFXx37y5IQ0aR2flzHj8tDDZAS0/ZrTNseHMcIfGsC5Qg69EZAtJbAr0dgLSYp67ftYaXbGomfiklZTWtDRdJXPiwKc3Hvmglgufe+zxdPe1enjX3Pmv/klbbxZd4YT9sNYvP3dYP8efGuua+V8TOv/lfxNPBG+Ne6aMxtP6GH2KXvJitKRpkVXpCGlxxPfIG6KT+FbYxOKS4XSVikzMwREipLPJzA1CvqRNLzdHipWXZBjjqZZWB+ICxMIPZNMvBOMzBYcCYINOXTDcsoFGpSKOKk4EBo2i9NENmbsMPcvwGhLf8PCjKbOYHvoC/v8ULgmn76WExnzdxs/c1/lrPF62/NTTVMJMhcbswVEyMxSiTwUeuNieb1L+vHW/M/5PVuYdh3cPPVKp88XD7M5tOqWNyUH/PmH/N7FV/yub5v1yim6lz/sCw0sBZbN/vSYLIeeEFoPtK0qM60yaPMYHe8uwwQYbHbm5NpXGo/pnTCOpmifEjqNu+lIXWgm0lyi/JT5TmZymdIkedieAGr5IIkx3jJwFemIFJKIahKE/CSYY2jELqi4FNQmD4KBk6xbjRJkOG/qfJ7+E3AZBt7yh8xizWY1YvBxqjWzYy8rO6NJi6M3rSiKtd/zXcXN+++m8qP83xSPJTzqbFPc9un/Gv7smlZNMav+3S8Nv9La7KTh/Xic/sBN0+N6tyw5rvNZ53Vf82fTXjt3dAxYMEsYRgRmSJps8mGHW+ZW1mF5AmcwsF2glzmJ6OePVx6I6ssPc/kuHQZKZzSKazYFBiglIqhdBm30GuNZft8Zz/7l7ab8/biZTlfPy6gf+DAVtOY6myqbRUzGWfUSkFYVOnmMBpVIDbNemaHFSKllLoF4hwnSqc+BV/qFaBh/FxvgyOyFr3YEEiwEwX+rhrMWhqHD77Tb1vwbfaX6+ZZfdd4u/NitwXt6f02p0Udsr2Er3+8nfxZlwuIx6zKSYnuKNgNtiYIt4oJ4irUFa6FUGxDSZ3EM0dMhCGqINwjC+IzET9/aHzFBJCOJ7AkEuCDEOjWoGWRCSf9iglcW9mmC6BX2scWinr/qM0Hv8nv74upm16wrm9zE7vXTovt9gNv/qmol83/WlhD++9zvMmZeEvjji780Zi90a6sH1fCapASl1yJkfANaHzuFhgnGFnPMbd2hlxzk2QEfKXjhB8IbKpE0qHYerPaNCjUyLbOPp2xbi7hOPhX+dez7+46vpusYERilygnUYmgcB7U88plPCHhyMSNQiQZ3upNjaFX4bGWAD6ZHIy3ut0ympPJ/i6zvyFs7xlqI2iO6Gftb41H5rEbuslqTZXp9heJi7saKCSoXHlMrM9C4hzn2xlyi3B8rd+kVyplfE0WCBBdCFQZEZBxIYh0Ss/jiflCzbG9jUNv49K7S0VVbyv0nRubU8veteNNZVXlE09auTtktd+RwjKPuNrJZSKsDNNhEKY0pM9COz9I+x1fJtnrKxF6Tse2RcBRpK9kIZoq/jKDUHL5YVXMr5/qVfGo26zNVg86+Hy9zBcvF1PTW20QyG/Khc4e80Vzd4VdOysgGuAxjGdvtnaSxN5JkqjY4zLpKUmL5naZu4/g7HHha7/2TOPcZFyMCwr1bhR0ESicJSmUBFEgWuveFRS8T8pUT6LhXtHbe4PBbVvdvaFfytWb5m2n2NjlvPni6Mgn0OWdvmpMCRu9XuXV6sb0N8TGX38rJmv445l7NnN92SwCs8bgF5On7W1vFzpyvH93Xc51LO9d8aWYe4iVP2xhOAcoBK4L+/faDeGJsGkfcZVHcYGcsrBjFlFuR9YshJC1mSSkLbxKD6wtIedEjKpCkEJYj7JssGpYJHOkLdWqjv1BNhJoHlgLL8Ysjj6LTAKBIT23OSqRJl0hd2TXdLvcbSbJ5egz5mELc29+iBB1LsaWTYXNEVJaFOKaFJFF4Iduk79Xmpfv7maGQ+huqIhFGVC1G9vbu6virvkE0wHsal03TuSdPnD5HU/fTd1Idma1RpVGfjoeLfmE9dTIIRkJKTtvZ8iNZCufBpXizzARFB9Z5gjSXwT0gggQnDQ7g0CpMUE6i4XJUEHV+RuNO19VS1WsHqry68t6d6vJsjqXP+Vft65eJ+e6TcrqS3uZWXMVXMVmC5kNcgb0Crz5pd10xUInG0viKl9BWLoErZqkLCwm6PB02zlyDSvxNYDiXvkSfhL9kuwiO8ayOBgVfGbdvY1Ajw4CawmBzZVA1pqAZ0uEGxzJejaibIaq1S/NuadNHl0VxfJ6Vc0mq9d/rfOWPfev4ql+D/Xrhkd7VUyaqZ+bJ6/Wd3cbgu1Vu9c1V2f3bxcOBRf6uEKUHv6DxmjuhqDZfS1uIeu6gt8Mszhk3CLWSatWWdDIa5UJ2vI4rE+Vcnl1+GbGDtVQ4eNTCSXDqYSWB3anAjRvCxrP/qw1lnW6djapX1b39dvFXekNBTx3YxfdCUusbSWLSxNLISyfsEYpQoQohrYzhHScEJ58a+ZXCRq+Ftn11Q5RCeKa5cM1zUfrvjSPmuhjmD7DUX1mi+V6ZUg6mggKH3B36VNxZyDcllzUk3yeV/tX279BafoEVhRiQEhoXXFbT06mkVNI06AcLdLsLXEYpO30uFJyqTi4nFGRc85GlobiRDtipCdX4cVN+dus+X5v23RTi7gN4I4OMDuwv7m+1CMX8F9gmN+73qVKJ0paVOkkLtlEhIwQ1NUeq9t1y4La+XEL52V2qGaiaUcwJg+IZz0VQTWcYK1/BUSCojohoC/hc6H9DvcGrM72TlaURkVuTpFiGczrYY7KLcWaYLgNXZgnLeoT1fLXu6pzyse2dCt9clayb9tDfTeuQQRDG+i/GAziV8Vdvp7rN345n+XNB0E7Ivru6mY4nA5cJC7sBzVedlURQxoZEbz/lo9UFpEkokh7aiIiqDrhWv56sUbDNHvXLTBbTVzIuSBxqRf0zDbwIFGRdn5cRI9BTu5Y3yTt2epTo+mEIH7THlnfwhEXQzN2Qzcuk9qtiURU1YmUBQk3u6X4yCpNHX6jmR03JMPFT7BM9ww5djF1QnCbmpHbeeGNm+wNWv22srhbf2Y9WzIjgUaVud22skNaf8Yk+5nqPLDWPRSpGKrt3D+v4TO9qsqvdVGZJzfXLwbG+WojTONHu31LB/MZszGfRcYlChJvdjBPVQjmzey4pUy+5FFUC7nsuZBbqDrhUu71T/x+CRXElhmJS8QvdfnkNA1S0cTyRcyRr21nCEmIkoN1NBk/F2JkMn4CJMCaR03ySTTLJ9HLe6KX90QTfaDEoHnsSy7X8NsKcOln23BKdw/QVUrd203hklbi09c2+SbA9nT3Xps7X87n29v0xH4rq+3fX6t8CRpFL1fvirxeDbe5eFv4evv2MqpEV6GLkfMsi6vqCaEAJdhhVwgkbpmGmN9mmlw/iqQezrZkz8loDh67JOKCiKMs0CioC830kdoadf24kNoadQWtkNoapaHdaWvUlYRC6tfqEiqh9GuVfi3W51oEMsHbnr76j6tiXty3NJ+/gwDmal1p7Z9Nc0ePDXde/L5YPZTTlqH3S7l4eX9f7Q1AJMo72ObRtGiX96arAioZoexjJ9RSbzU7Nx+5vfBmvgapsh19V99Ur+fdhaRzm2bmzjb6L8uq+fXr4jKfz2+bJQIurWBKqo9m4N3sczHw2rI5DdbeRca+o7PapNKOP6RRdWhgYfEHGhJ/IE5q28yO67aSnyH+0LPhiAWqE3qtH9Yrj9vaGekm/KSV9KDnUVVBIl5rWJRYpiEKt+30uFwN6TmIEW81BxWjq6bnWnWaa9lprnWnOYLynhX1u93LoK9Z0pv13wjN6jFzubNVmEtbj7VYrB9h/Jf8ccBt4GP+NC/zKWYn3SGrw7El0k7OZVQrv3Brn4IaiHOsst4tfJK4RjunHs0vf9WTPJdjazYllByK77ozixZsAwJb6xeZJyi63XGL/EGoRdyj5yIq5p5ExFJTbD/gbvGrlj38fo6lmSW8mkIo5QlJ89RP4DO59mHBri6IOgruXB99dFWF4KZWSR+bdGGF0JUVQpdWCF1bIUxxhdDHJlPlZMqcTJ1TW+ikXyv0awWSnwxrKwLbwft8eXlrGn/sAH0JN9kXsUpBPdC+jbbDunsmQW4whxrr6GKs96Y0g84rP6weiuq5t8aGXm9gsPdCI6gOA9N6s4d2X6s7JM4W93uVkt0btDYsDHwpvPdoGb5P+de9q4MtTNfN8XWyeruYzNfT4sPjDF2dfDd1gz2pPpnsUy5VXGFWirSqDpKnJQkJ0e1oZ8hZnTIhDqw7YSfQcibNRnwktUE7q7ojGNctwTjUZTSPugRMd2rgulUD170auG7WwHW3Bp65clEk7Az3yoRTNTbBfnfS53oE4IpcNpDeG/DGabdvvHOF27fcRW63b/bCALWYm6Vnt2h079e1At1X7b3Rh2pjatvuZXr09bdlWW3atLS3aIe8Hm492PyBLQPWWDdnqAv99qw/NXqYEYmButbPMS+cZtJtVM+C6s7aSXKDMNRbX+CN85KTFHse3SxTex761CpU336ZbXcVfbT82w523/cgBrMC+M1xhfbOSPcUyrnVuJ5wE4qPqOsxUniZYFugIM4meMbQimfHSd/Mk0vvk8TjpBM/U1ucxAoaMzjODhJtAYn2vYn2vYn2vYn2vXUVjiDa9yba9yba9ybaeoh+LdGvpfq11KgT6NdS/VqqX0v1a6l+LdWvpfq1VL+W6dcy/VpmpA30a5l+LdOv1bV0QtfSCV1Lp7Uom1ODG2tiYcZrtrCXi83OCbO4vQY7586M//jj48xkFiBfWa710P99+KQTqPVu8/vjj9czcNnhb/OXqebePX9XlkYX1blT/2/ghP+6mLbKI3Db+6IyQgnQ56z55+XqVV7PJubP3bu/XO3eeddp6Zey2YnzxbS9Q2dZ4Y7d6y7bS3p3bv77h7rNLf0j/9KcBtpNG15zs25AfVP+umh9ffv5+/zptrAvwrQBHdTQ1vSX/aYnG75kVTefs4Dy9u0n2DDsnktI/7Kez7cHNX3F/EjXn2fLG+ziPwf0Ou7n5W0+9x0/nNGfq9hd9WToISERJY8tdY+KSj1Y5G+HsEvz3w6G7Idivizw3r/dISuibZUvRhfRZkFlulS6ekQIY8L1ISRevsh9HoS3pRk5RUszcSGOA7Y+Nuv2olzzULnmoXKEhyp6Ar5YGVbBP6+vysmrcvrUHiv3rm7IRHtqys0NLyuzfW1vKepJvtQSKMNZzZ/1tJzgHWB2A3ZNDbWSQOKcRJUv5SowYcodBgAnCAcgzZDCGsrwypo08bjez8SgmBrd8VM7uLo9klA9SdsvNLJrj6+UT6fvZovPNyXc05rEVbFsftjcSOOBCtBwhqC1tS7ALiGo9NJ8ELyRPHZLV44rFZajxFVcNFjHPGSQo4RkSaUTmzGzg0imkAM1ldPxFcSLLBnMU+ribGikA8Xs7NZU36M4x27oolw5KJeRa1+FHQew0kqHauprSDSGfkRHV+zoKIZOQog0G6pip+VBGkoknH0/7i6Umh+az4+2AtAIwtC+d70Lcp367Uhg8ajOBwShvLAwwVLshOBW6bQzhCCdiQObrYjzhI+MHcZ0L0im3R2m3R3Wtx3kCwiz1w1Ci2mb/dZho/V8/vTvdT7XMNhE4q/ev3/zD31qRTyjO/clx5oFTDlM3E25mcIrj6E8e6fVXEI6bYqiihchLcMxmrBwm9YhClguq9JMj8ug4eTAk7U8BVnsyD2CKdMhUreIVOlQe8RWQ2XD2DdkyY3Z4ODcHLjz5bI5MhzvSd1vSvC8+Vv0ju4pOksTS5oiO2dR7SxSujuLwvK4mx6MnRSWDBLtJZnKUJ4Zz7iPZ+a1E05PIiIqL4g8TrdXMzh06onr1BPXqSeuU09cp564Tj1xnXriOvXEdeqJ69QT16knzowAsH6tTj1x5m5VJExU29jVVdFcq7adiq+KxdN8Vu+aplyWy6c2h/ydCp5dYrmxRNj+oFNY+9JXeV1sD/haTab536eztppm35JMoGy2Kt401tZuoLP697x+fK21fa/XSyBumNRT2+K7gCXg5X0+W9SrzRfYxBPaYlrggc1MY7MvRTW7e2q//azB/wrAoHW+l9Aq86NZHAbZdLcXnllCcBl9rmhmeaUyMr1vJAKHxq0dhqpCCm0ldY9fNPOcv+ih8TeSjm9/5cR0W9aGT2jPANw+yeOf9bbf68aWLRrI3h2ImS/zqi4um/lrUFxp5teb5vz26+Lzovy6GMBWVuATewJye0NWQTqzM5Zx6RfLoBAFcY9uiI1kbjE6fnBjyYGBuMy04ByX/qreNokcqhFgg7J9WwDEbfYs+PNYfFdFXc6/FN+rXvDfZrXAzIitYBmZbxmmYClchiAP4kZRmnrqF+iBut3ZCNmBurCjedSOIhksQoegzyB0Me3YxsZ1W7Xe0uXj8QU+q9ZnvNDu5NUtsHLQuDUyboUlCI+652VK+lZ7ZkHVnmZ+kJ6X6aFFbMkJBBLUxVFVPVwLIHAtgMClaZGij1ZaAIFrAQQuXYsJK8wxsNNHJQPAd7N65TsStbdsCV9abOBtM30rwE/VHWz7TiLDuj50x1jTJSy/Nh/I3DCs2b1dTItvXqPbH+0GO2jKLJJNXILKTAZFAt1AIAlpyNxOj8sVoMmhfSTpeTa2rUjrkXCtR8JlMtRWtAPczb6RNM8v/7QuvK4fBzYDHb/Q3Z+9tuDc0q3gIpzYovlRMQQUIpqPNg5yunUJFnI0aSfIVc1PDy3gUicQyTqWdaYrQnWH2uZR70G6IpQjFaEivDJrB7nvxOJ2N+7ZDqJZs7tv36Z2Vwc1rMd8qYW1MIuyxizlqyy1TInGFQpjtGcDCkKCehS1M+RqXlEPM9lbqC1PUAx5rC1pmSquZaq4ztVynavlive0pTY3C6miPYqyEwzoaMU1z7tCHrt0U/sebT/JVstjOLPZ/OFj8OyNWS2+KbF5z1GJHPCeLhknQfxNMz1u2skXG/Mnnc51oGFUsTEtCMcl7dubqMFVAytT9Buw1TT3Hg34w3uiSmbRD2RsG0Pm8g8YhnHuSkpjJ32n0zDDCQjNq30MBPmMXg0b3M1i5IKR40gIcOpgwLhuHol+1HQeTfVnmurPwKNsHjVdQRPbmCa2MV1dz3R1PdPV9UxX1zNdXc90dT3T1fVMV9czXV3PMv3aTJ92tBYq11qoXGuhcq2FyrUWKtdaqFxrofJEBx90KSNPkHBdfwqpKQjc8CO2Fy41rN/ni6eXi6nRNHTu+XU5feaetujQvfL8W7c3Pf/eyFs42yvyDs49UGa097Zb0sgg2VtDo82n04/Np330KN67w501SnFl5afiEvLQUZzv56dcIUW8fazTPM3Mj7tCpXIM7WOP3YZNc2auhkpR7YHtpvznNXAk9Bfcuz4Q6k380pOPtQft6iFhd+SJalfmSZh2aBaiHYp0mBK+sqEDO6ulY2wXyNmgCnItf+gqX+VGZ3hIdBe36/u3IAKVz2f/0RwhP9i993ZlcwmxV/uoFLop4o9i0EfYfshqT5ySCTM/rmZLQg88c9ERNgvnPB0U+wjmhoT/34uVify1hB7g2DU2tsbdnLCXdNOwSWIHILKockI8C9oIuAqyBoShYCbIzcMmyRicn2PNQSSDmoMHeUOaxKfir/WsKkBkxGsD7j0W6Lm1A0TG2gxqrun2bTuj2AagXMjjzAPyU6z/dFjfZ4e0gUDeR4orY3YngCwqgiUX/RpYsTSk97eZHaSB1aEOjTASvOPCczYUnhdFMa23xXEDobkyZ4O3j1AQgFIpkRu6AWRqY1uSyFdrFhI9RpKK3OHXm8lBYsfiQO4wHWNgRgdoueiZH2mPpa2IKEKj3EeeKQYdCPSQ8Wu9lVZLxuupdMetTpwq7k6cKgj4JMwzdxu8mPkJ7sUZl5sihnVTNpJGQ+IbavVvSi9bxB3uuiwZtV2WqKhXnATF3JlweqSFVCWb2XFdFp4euK6LMWKbDIXtPYwdBW34GvV+IWDz/DvVgLs7LFFckliRdWY6vkeEbCS2jgkPEcdnYVi/e1cXHrKreHxdUOYBuFeYhZ5n/PQIbycqMN89GMDz6fR6kS/rh3IFR8zrHCKN/2nlKHqhvSruZ/WqemrLncwTvMapM9ZNmEonYSoiD6GLkII+SkOkWJSH0OHjc0QkQcoSdlzD5LL61OJqQDXzlXFO2q6SNbSefLu4K73L+HM3dgtXEyuwwiMLrBDlhsdpmLyWCGK1tjOEyMgJdWAFnzjXczIo3OWF7L+QS+ggqeU1JFS2S6hZ0s32pHTPpLLfAj8D/qpR/t4wZvYufSruDHjbJnS17qOxf7X9GxyhF8PbT4jpIOF1xRO7j2NUpNY0CxLzVY7/oxDf3jm3ttPj9nH09sTI/C27yDln44rbSIhSSYRiEMhqLX+bNd/u7ap4NBLyGm8buA2/aWz1GOG/wBC/d90qHqJO8VBc8RnEzydBAqMZD6lgbScIKR7yZE6ZX3mXZONyhBTpGXbXcIKV/pWR9DwhoLVCF4bo/QFLr0Bktl5BVO5OSsP0CrgDaYo1rueuXIFA5WyErwWvv4+LMhWoY1q4waxl1jfcrlH14hmtuBb4LwYDeKtSBW/8cj7LazwO6b3LIkSm1omWRLWYp0GUgCSADakQNiRauMay2I+zCukvELaKu6A64UIO5WoYsveud7GcKLs9dFyeCUuRrlwhcMZWceWs4u38uNF1mUaP6ET1RLRWzDgdhjttmTAwYzd0YzHEJm3FFXKkYSFHGsADoE5EXeBiMYTGj+iU90R0B1EnhPbfN9qYZfPdv/kDjs4tVuJI2h2QeFRFSEL243BxrEgydVNGUuI9FGX8CJfHxdQ3sDohxr3Ltne5lolVVCdiC51nboafYrrKJHG5W9hp0uFuJZ6yOkF8TFt/hCQ7l4MfJ9OL9BhYAzVN1+8r2PsUfHgFuQcF5YoKmJSKut5KGoR8Dbs3m7D4d3s9dm83nadni/u56Sa9CbwDpqcdQQl958v5fHubntBvZbX9G/qFQTPPTVvMwSxOV1JhFrc/0A1IMj2z+xFJGllP6gwL4KCKRjxzKvuYQrKzzKWNtdPkEsc489idZM8U3J+AfSAuyDFqLAo+r4KQlAJpPQUrg85JKzjgKJB5UqDXokCuRcGsKah3VnAqUnD8V9A1QCnkKBGm3WKqAP/WYvWqmOty77YjrCkSBwP6jmhF58WmTV9bQf5LudgWkZsBOIh7B9scgu57773pqlgWi+aHnTz9ZgTLN9LL9/sfub3wZr5uwPh7Y/vLotre5Cg3dW67gm68s42Ge9tl5zKfz29z0xMYWHUfqrbbzrvZ52LgxcQQYWvvmtId75L1rEbfiVEgipnvIYMUPJB9XLr1BXh7b8p5/OGEwcrDHvcgNjCwNwc9P7TtO6x6YBZ1PTALiyzQkMgCkW41MMOrgVn8566+XKYupk547DJSKhisOyPdJJ6Qtui4iF3TMiyXIUKKwdrpcdkX3Ce371Vbom27jxE1SpOwL0tg0kuQQJJZ1q9J2nMumYFe46c0Ts3qaevsdGV/9i5tz11FK7t3nO6PbSMf86d5mU8xI+kOWQ3HM2UL70Xl0iD9BLOgcBtySEqp2288Q2MT3CdWqZ45IQ3fteXYhZ8MWlyjraLF2oC4/k4Piu81nyBEWOEAEp3eN3WJeBzVOmFBAseud7OZJNe/SVNfH2Qvp4Om54Nz8bKL7Bikg7ixAiavgvC8Ak6uguCkAh6LAn6rgu1QISKU2cGtiy7hOnKa1xMyrTc7RvcgfJuvJg+zxf1N89/UuX5V94YZTAoMfCm892i1/U/51+7V4lsxWa8K5/rmbq2K2R2q1gsolcsXU+dVVucZ/WWvysnRlXW23RvVv1agD6TzMOP33dQNCKZWmQY7V2lcpdOI0gUJaw5NQgqR2hlyrD+ThyrbsRNoMpNmmzvu9A6WDj2hFNAnFARSFfjSCs50ClLGClYzBeuigjpcRRB1JBKufd4CEgxLR9v09zcCtQ1GkcsGx3sD3gD+9o133mX7lruQ/vbNXhh0FnMTlHu9+VXq7v2aTd991d4bfag29qW5+NvRtqC8I6SpfdwB4xqbPzDbt8YsGXZpk5JJVCavhTcDqD+ChjRbc5X92glyg/9ExB/P6FkzvkXUCSMZrZw7iufOkKX9kWaWeDSJq+07d6MZNAnqHUhlSNOadoaQJLKvgxr1t63JDE9wRI0FFETudQ9RBXVmCjJ0itF+PQXcvcXAtgVg193rDOkTXv3MDR9WD0VVf/cdzHZkZYLMwfGmNIPD7SE9haS6Z8a2p2Q8R0aBSElh4UOGKAJKHiQ80k4SJijlcRu9IUR5EkFkckGP2kjgNK2g+kGBfIWCtluKgXsI2XQFvG9dwqZAA0NBQEnBqVxBvkuBlJcCSWUtGq1AsEIBxUsJeAVErRTs3UogBWJhu5Xxzl4uNk4hfNHtNXAKdw1z//jj48wkV4GjUa710Nt659D98cfrGZgu/G3+ul5VMzNmnr8rS9MWe+/OP94X1b2++K9CB0BfrnYve7naveRTMSkrHfv8pWzcxuZYqS/vbtZ+I1T261/8j5v1EkSjt13k7OcdSuNzhBfz9a8/z5Y3A3ql8IrdcH3xqiq/1kUFCtfYMuMOd9caS4I6iYysgqiuo7Epd2tHqkTdpLLAFWDYoQowZHzyRirjQwVgze+/h7TToV1HfHxYtwd/rj7ACqFlYViXNExlFymsSwXeB3gEmhnHtV5MIVOewldOEzFU30WDhS3ofPHJnRu610PrRMYBl/3WYY12gxZJJu1K6qgEebPAVsApC2uT7ZgH8+glad5e7B04UlDSThMyVP+NjW1sILcN3B3ffeO7VqAPVlvvzL9b+O+zcnhOlppEpSWmS6i/r6ThtunA9w23QRzJ8FK+LP7Cp4wO6yRZoDN9aU5mCrrvtQ//9mBXXCyzyaZxZa0YCcO8DNM9ddTFMomri/0EuqdpMjDmt0A7HdBbMiAOdHuwSzxVtuZAKiM/AKMykc7ijohEJg7vVOExNvITLOxyWJBvQXZikNfPoty7ngtqr+dxtRojYXEet8c63l3PldCj+ILuq0aKK9IjToD1E6/o5hi97YTwnSjnd+/uevRM2o33WFRRT6ThcxaksIR79I41EIZLLDGf3Iy/JnaM5sCGNQc/+H6YeQTahdcJsjXHUgOKiGrL3OIyjkV/qEI68tGwlnxUeKpwpE8v279LnGSbOC5GqiDMoeDMrpCKBTaghWwCQgb1O2LYLidfb+NFBv/7VaqD2NP9vLzN5z5mpzPa9aW4fWQQcfFhVFDXBJfPibC5lUOGMbODeFIq/kLMwc4MO4ANnRN4KObLokKrMLtDViWOsoVvZFSYFqxnvIcgyjfMLVEw8+OW4pBDAz6kWS3YyPhdwNNWkO1RkCZTkPpQSJqsJ7/rvliZ6v5/Xl+Vk1fl9KnNlO1d3ah4bIj8bZP66l6TLba3FPUkXxb/rI/p72obzJ/1tJxg5rI/YPftppa2nzBlLfEcIFQSli3jTjKZE4wTmSHdu6mvfbevyPMZYj9TI3OWwI9UUKOu0qSfs/RCw7r2MIjy6fTdbPH5poR7Wnu4KpbNr6pVMYC9tBhw2zA9pcAo4Wz/0nwQvPsOdkvHPnhqc4p4VIcJEiZU4fpHSFWndM7WHCdZEHpopCkdXVN7lQ1W02nBbGigg8zL2a1R/0Zhjt3QZcUrpyOmiBzkovchwG2JqfCGJHIEh4DjivsVtF9REG5QsOmpLBmquL9sWbOtKpH5E87NH3cXSn0OzudH2wP0KvE1DETXdMGZ1YSHx3XoRWr1WZCkBcGOCG7DqXaGXMwTJg4kpAvDPhoR6gUkRQVAXwD0RdpT0uLFNgY0bWsyNKN6PZ8//XudzzUEtDJFc/Xq/fs3/9BHVsQ9unNfcqxJwHTDpN2Um+m78hjJs3d2SafEqv6l5ySqvJsI2yaE2xU8pMNmOz0u45Qf2uZenkLh4rgjggQjlvClJRI4Yr39ItPIYSOcZ+RdNjaDI3Nz3s6Xy+bQcLwzpZMR25lG/Sf8FuuYIKm1pcTVwJAgJCO0r5urJ54hMkmKuUcFST1nBV+XKr9IJjP9v4Y9LtALcgzrVECHXQG0WgEUQgHTIoBaJSAXISAXIYBSJYGdKiFMJSFMJbEGiDRQj3xebBMO/5otWunau6IyLcg7435tzC9GnrLo3G4KCau6e/VN4739uvi8KL/ubthoRk/x1yMf5cX+T3dTXq/v7mbfjF3vvRUsA++3epiz7dtY1z1f97kx+BY3dRusBuNqFUP+We9efuyysvkq/qp79A6r7Qa3+t6R5DyqHZcTN5TNsfgDc1vfnSksve8KS7WThDTfIJ7YHFX+9nenSGUeJ7kjYcIkRJ0kZKMk1D5K8FEknAIkUJ8kROGl4D0ld66KxdN8Vq9eV1VZ+QoA24J+s/tqoZvrv+afmv9m9li8yuti3353936tZmZhab3jzVoDO/nL+3y2qFeb/30TGGzXE5DkmVVbwVzzH4Htvymrm7xqruk2lcW82PgNze1DmS304362WTemjZNQWxsnLnn6xKXWk6Amxmka1L3PTJArjSOSA1udiRPs/ke6x8Al0oKPkpOeEfT9WqubetvdGG+A1kom5quH7UZ72UxVg9ZKy+Dsb9TH28QKjq+eAPrekEXStEVwRVzmIIOIBSRENUZmLkUTj6+w5MDAeSunMKp2rXBU5GKo6iurDBHwtkkhwZ/HorsB0ro53pnJwjCO3WClUC0xcxIZh0YmYcW4rvQn0p5YuZ12BC5nzjJ+YENvkhkBphHxDSRoDkjQQpSghSghxiRF1o9vYA5v7zXg3ujv4z+16TV//9btRrB/0Tqwzez31zO3dxwyY0cbVWXctbOVdtTQoAp+i01ttg2L8Z+R2uwS/SXG4mQutVnilsXpOEicx+0kIksgZjJYHa+2jvYksTtCuFeHdJ5W7UnpQh+irm51/RhmD8i4xWpLHVabiF3yIYiqifW+SonLaktxVpuPiyCfYbUxPrJdBmTnJZyp9LeUkLySadpzlzEo02kpg7d3s3rlO/e3t2zl1nfaQVr19tfmTc0Nw1rK28W0+Oa1k/3RLpMhdZgMcVVAsp505ixEndbMjnvqUMkYiJ9HHjvgu8m052axUZttYPWdJlL6noHBrsNp/wZz8iLeuaWbmuVW+omexyUHJJEubb1bdDiM53Z63BYdvtSTl7wpT3AAOTL0BO1NJJy6pOpZ6WLAv0PYdyxgd+O2sGWvVdlglvGYL7WUCXom7451A7HEqv9i50lkIuVIt3IVxu7BRMod1mY7Q674T5od2ItDnuu08ag8JYjEwsFBgoiShKSsRIokwzylltcDTIO92hYnPtVp8bmNzu5d6L6Hufa6bV4znMVs/vBxQPfGukcLmpCoRYGQc3YaYi8sDfGa2ulxT9nJoW6TOKdybF4T2AfSt4wG20cDKiPIH7BrNPceDXdNesYgvj/QPRQISi3RbxZXRXDinp1ZWL9JiXVncs4FZoIQirMvH0HlM+2Zhtf8ZvSCHQVzqACX4AZISJdoZoCEzVIC1UZCZE1CMEI7hBJSPxJWQAnEcglnKwka6xJCCRKmSsI5TQI/SoJmjYTpkEArkLB3S9An0VMnYXuUQM2VUN8gIa4ggUIr4eeTgELJ3GM8658qMbrFGwrd9sKl0brIF08vF1PTfda559fl9Jl7Wm1k98rzb93e9Px7I2/hbKHIOzj3QA3q3ttueYWDUGpNsUU+3ar+YWuQO2wxelJq7bRJXPEJGdYa1I1oY7oEiZsrMhPkknl8IYofq0t5XEmRlNlQJUV7OLspr8t1NRlIfs+g3ET+PEl/e9Bq7KxsDe64OsQlQQB3JciQQlLq9nVWB/V19jqSjI2uXk5KOWgPxDYjc5WvctP9fUhkF7fr+7egzpHPZ//RXDM/0L33Wj2fbU2y9G9x9zNHpefTMIlJV2+G4B3NEx6/xqRUyaDIRxA3EPjbnLuhRD+TlO/cYPVPcvIrcbG6aBDOeUBnc+4WilI8vSLEgaQuOrpUvISCJCnTnnGCdjFvG925uO/gzpTTDQR5iHu1q36rx+Fd6bvj3ZiysL0aJiJXSUIVJ1XY8u647WZ+3B542c+wug/r1wzV3tXA+2teP2KA3rtuy311abkiNiQjRZwUS46Q1M2OBJX7t1OEiX4drPVC6DnLRpYggaoECV9bQpGehMIbqQYTSFoDH2R6X/zeALBd9bdZwr8XK7jccgx19QZ8Y6gekfxlDWO6ZXKRT3dH2u2rYXhTSXKM8cCc1RfwFarVmd4eJtVsuTqb1We6OgUN63zv7q6TxLm04s00iyveLMLizSRzy7aowLYM11kyk4TEnIlPPOYZXvCPIS+2cxXEXQTOs0DklMIcppcacDq9ovH2tv4N0KYTjZjAEn77AHayV/PUPP9OVdTuDivqmUlm1zHGVRzFEE0+jjFUhJNjTFRITn4zR0jkk/u2ncQvMTZ8ntH1og6xhpQMGPm8XuTL+qHU5U/XORyU/1NUA2B9L0LU2aq80H/+1u4JgsvEYqWwNPryQCzLnrkxIkKDtoR2jtxjhBQH8lJOUsbrqs4cZAGgDgCepQAur0hFT9GZ9/nnYrfQ66C/2RX+prtA3TYfFoxlm/LqWs+j+2pTAd9cbr7T3hscnErYFHQYK9IiNFBPXF/osmJol/oK6uy9xF7/bZYKDbWO4jSqnQQ5vgQRHZGjCyJBgybPBItdrZimg2XOHvJ6B7DBML5fodgN3WpY++Xsv/cSK/pKoo6+UtpTpw+rM1Ru+JUcFH6NB/4s6ek+fQ9k7g5xCoP4F1RSfSr+WhetxsT3zMH3AivTTOPONMt+yqwsCSEtmtlBUs0j2AuOS0VQEFFiSd+TtcaWBtXHvMpNYdOz2PsxNvJpHWgb9o3dLDS303MpjeuYHaZ8r3o1gPPoBPlkgiJyj7JkgP1hi6wfh/iPzel9Egx75+6uBB+3nSPO/idivD1cctw5ih/8rG+Lz2fw9WMsoK0xP8Qz8r+kuw8wGfc+kPTzjSgPYLubyUG4SFn0rhFUiNNU9nSNWnA94xwh8PsxpvKb0Y0LPU/jt9uKrVE3dqBJz0pxGWAiHNdS8PZ1iMlEFJhIXyLTpsjpb8/i7XQ2MS/vMezvLndjpTTjVlk4jUvoHklEk6CdIM1CNAnbCXIjpoodmnEwOb1Bka4u1FGHguYnolD/SkGUWH9TCiESCqLENFOOCagjemLVdfNrt3U3rxo0r6p8UpgPr90q8yd4We/K+90TbS7tleYbfSmq3bguMYdnQxlPXawu4YtAbgSzImTcYgFmcbMAEWPCSB2iZ99pT6Pd9Cfos0uzdKgExD7Kjof2Yj2fe2US7MEumhOrZIFGFkA1agcBm8OeLMIO0ajCGncgneCFC0p4ChdSb4er8SlLU5BdoZBI0Z2EKVCWKMjoUPgBKRwZKUSWadpXWfrD7Z/FRCsdNB7SWn+hXzaY7Fy9uoXr2i7gKXRF7Fx4uXjaPf+OTelvb97Q/L15N/OsfasDTe/ibvZtta6AS944WxeP+WyBC5PM0PIgrUPRzdxFxf7QLNaAsjgnWcFC3DAzO4gu1Y9OVlyWi1VVzudFNdjOQTLFh9o6AF29cdtAI19W5beng8EruN0DUbDIi9tkCHgpCSFdmNlB6OLypwAvHQV4QXqwPhi4XGVxx3jC+BJOLXIa0gaa46rMhGQ/BW7JKHC76YjxXAMY1F9I7GSWiKuCQPRTZMKYPtLVq0k8TJ+DdSzJuZI/ArwHMEUb7CajwO5jubgve6y5adxrLuvZ9yEN0cI3s/PTLrpiFMCtJ/k8r0DUuAd6nXbfcenz8H5ZIRpEKjOzg6A3/SnQy/6b6H3Q3WHb8hNvsQma7Be8G1xII2uTQIUI7D0p3N5TCHCZKz9ipgjhfvn6GfuLDSkzh8Bho9PJBUmOQ2+zThEtMNQ8pvoxg0eYIKJ/yOaR6kemH7l+RFbsJExEvpp9KaqX03zZfJnr9dIoN3ysyi+zqWnNaPcZ0fmcTpeqrc4D1t+q08px0cziptmcqaLfKKlCpfurZiYab7q9YTd2W5Vf6/b/MlfrzUug9OWmNKXHm2tQt+z5T6CN3dWq/lTsFCx62PbmazY/PfzGF/+Ekpv5DLP27pBF8rTFKFIWOfE56GxAgzwsMzuIpZMxEt0OOhekPZUoNmA6lpbgxXG1Xug/fI1+OoNdEr9ONeyBOYtNEJEnYXuXdE8MAlEVkk58sZ0iF9GMeo67zJuEovwc+oWO7LybqjE4Xoviq0Hz5g80o9od6yZUqVWexUyzgIjEsRAsY9WJjIX0YRBuNpXiJVppIg6kCPBzSYcnlrGjUKydrlQ7XQgfP6wTw02DlDn04s4nK/jwHogDGj5rdZQDwQ6UgT/016v/+OPitlhMHh7z6nN98bC+L87qyUPxmJsjSFF5DyFFhTeoUk6DqqiOISnSBjEJCf3ILKQJSTs/boMqkh0MfiaGBz8/hknAYC9rHqV+VPox7VvhvpX77CJfO+GmWr01gR6rfZABTMwhBTOA7lDXAFI7Zk+iyvFnQRpxIZXp0pU3wX0YLuIPHDVI/68m+IMQvff3ub4Fw7bvpi6nWAhmt5qKKjWVkaCmnI6Lo7IQHZ9mevBWUyw9VAtxdC3WGqRTvbKzwTpyVrPF6rqB0qYRAfw5FP7n5ao+K+/OqmJuFE16Ojbas+sWmkd1ROUsCPDU4W4hrUOU49Ob2UEKzdWBeJfnVIxwbSejXNt1782z5tyqp2YxKVqfxeiTe1d4302WIy8tuVvS/DZRJXFVhhQQYpwvc6PVe1mGtapopwlx6KWHHCy8jaFOQQ4+rq8gZbBuNI9cP4p+B1qUqrteasw9LSavAINa83O9eLVF9wmtxLnit5Xnb+1aTCZ5d4+ATvVReUWKu+6/wvx/c2PXYhSqEu0YTDtLrsFkxNOvnPojmSfh0x8nrduYiT7/cn3+he/aPGbaY0qG0tfdmo/ByrX21vXzeZEvzNC0uCuqqpj+cOuqi2J6BjxjvLqqO9g9VSTEkm9oLEhGteekSBY7xSwoFW6BVRpkQZtZcusVE18e+0db0NGbTqKthuhH2jOKet1ArZh+yhfN59LVJQ3q/r7R+0TLR4op3HOb10ceP6ZFXVRaZKv4lH/VRfRFM0e1V0I05AVdhpLuOLdnKG1KJ54sA5L/zYK4oRQhh2YuSclMEMJSEvLAQCs1tOnx5IApzQYTQqyal09vqtnyOMQ3B/jiXv8ei+Zqm0xrrj/O4GpxdYvS76xBm88UNb+BqrAeeTysR55CyEweLtOBbWbICOtsGRus0HYLstMAvG6Vp19/aV6DMh/QO7oHB8XslEFUPk9YQTnvo9ZmpsY9K8SvZcvYYHyHLsKGw/lGMEF34Th7zJdntWH4Xfj8GJ+7IqUdPJUi8sVcHtHw1BWtlXhBgFSR09UamPd0VV7839FENT+yH/Ll8uniz7pcnDUvbr7ybHF/9vhU/zU/GNois5r5ivM0Lt61QtZvGsRdMx3J7eSA44u3U+TCm2cifnwPVu1S9+AUHwjxZhpW91Acc/ACTix3XJ4ncYmOp4hMCA9EuQxBeTtFSD0iS+NHORkzyk2p19kcar0ORTZYsK2OFldLFpKEIdtJ7WY8SB3NTJAbbUxZ/LCWA+o5rZcQPRwc27P75isfvmJDoYBFxMyi8kskC3NLnPVaIAdLQ9vp5qFwdUueyUP79I6s6VwDa52zZXwogk69zL8uLh9m86kpkpptpP4+LK5X03I9/IL+13y2Ks6+5NUsv50Xzcr+ODt8aSfc0k8g5yyuwEoayEUWIYpLwuVjclxCgfkkFIi/11zCxra2D6ZZAw1KH5eN21wfT7Z3sb5qPkyd6/+uh/Ni9RilkfUYRdX7khAiZobUAaap67zg/UVFKg9V7jsncmwIH0whRNMGjgP2gRnPQ/OdIuFWvjMuCWOEikZZiJNOsKIql3HcThCS76TyUDkc00tvVPnOAXVXW9wdh3bdA/ri/ztm7c6c7gxZXM1wSZDIiANoiuHZIblknvYMjB/omfAfUyty0MJNRkQnNkjOJ/qD9DhmUueYSaPixauknyykRDxs95BJ8UMm87VQ8GfpjfTbuHBM2ehwfH9fFffNTBwMZMVslUgVFaGK836KZQwraHKAbGbH9S5SfnCwRMjR4TjJxoZjLS+toQqdmKsnL5I7w1YBh90FkES1MJOerW2wSlS3agNtAsiTcRaiHuZcjBjM89lt9Ryau+NWXTWNuq6akH7rMwJnIdzCahpTYfVheFbjxfMhPBGepBZPJK48I0Wi0QwL1TltWSkmoe5KY7QzhGioC3pgJR01h5CRATkdG5Cb6Z8tZovDwcwyW3yOZZELpKreLeid2IWZHQfHWfYTrMZUjA7E5WJRTFYfqkuNp4OxzKntJ/Oo4nBE9mvKQpA0uXQ7BlPUUyY+ra5nygxGiOZEjg/Nzcc4nJ7ntLiQUZ31kI7vQRimWYhgtfT0uJDZwVluLsbnVtCxYXhazItV8T5fPB3uWBBbPSuu7u092wakIUuxmRu3CZ06dCWm5+NDMVXjQ/Gy+a3zXrk9QS1ehjgnNC4H2RWCoFnQYY+woMMexYkZhPkkmp857LER4pmPDs+zZpabNz7cQXYqcXlcBS6sX4YP65GO8C48tItDy3B/lPDVYb5FMjYU3zWf782s6kH0Z06Cj8XlW/RM8CEusnQ1mfH83sHpPULOCRnfYjy6Y959Va6Xrw73jynJiEX4JHER4VhY6M1djSmyHGcOkNsJcgmf/FA3uS0aGBmSR7cgz+4XZVX0KE+xI8gkizydx0JgrEJWY4IHkPnPEEBORpcFmT2CpsHh1DfObNkOHtcZj4Qp1DgrMQ/R+jazgwSOPcWw3K9QZipXRuYZjy4PMoiaARdO3864hDrSnoFkGlIzaGYHOewdTkoWIwxZkJFDurd6AXeocP9D9b5UXuJRyvsZUJ2oMaL6cH9ZZJa2sCHSxtNwwT33kSAQqzQkx9fOj8u0z7KDmfba3Ea2No8uyQeAhd6Y9apq3rGH+6ybZHXrn6IqzuZhAo8siHDP3IYK2UENFSIj3I8QzqvZl+LMPDl4cTYe4P7inGSRa22oECwLLNfnhjPM9LhgVunPwE8eXRHUcjb5fHhk2aEQxdXsg2RBWT6X0olAWLo6AjiFSP4UlM7RReSaH7qspj2SI8KGMImcPSRCIBzEHjKT4+ZF2M8QUx5dMM4o0r3rI0jX7JZp3M5EqGqR402oQG8C7zWmDj/pqRFSLkaXq66LeTFZfWr75132IihzZqf7eFxq/klPkj0P4RAxhadKDgW0MmSAkbkXo6tH1Y9eZSJn1GpRZIUt6HkSFQFDqxr0UQsVGB3OdZQTPHAhKD1QcItwo2U2JmHFRPclSshQworVenFTTzdtT9e3V7OqHgLhzX/yUEw+F9Nr7Ye8XSzXPSJ0itgJ7rgCdD15n0yGuCFmctxF2xfTeCZAp8YXbyajoy+vF1ou8az5jRo8nZXV4QRQp4MvSyPna/DePGaHkM/wDr6Z+hl4zMnoYnRf8vlsCo3oetReJ1HDODBQhxBAkTAHc2uvk0FgnBp2+Mhg/F9flRuHpZnT4gKUzt+VuaeNujNqRZpZarnQcfX4JElYL3VHlTnNQkqj2vlxg81eNr7y+tDZOTm9C31I3yuSQc+X5lH286Ff/LO83TTzNBAbpE3QBtefir/WzZf6R76YznFso3fYATxldU5PzjMaVz22u0hzlByaOG3dCCYswAgSxlPKE8fz4Jx5cc6YYVEPCnR5IY9p8JbA1DSPQj9K/aj0Y6of3bCIDDKALgCRPrbNUfJmp0v7YWlGzBnz7eobPjar38/qZp4mD7PF/Sv49+1iWnwzQ78ZZ6W59zW0hNONpsvFl6Ja2SNHmN4Eygjg1y2bH7X4WJXfni7y6fTD7Z/FZNU8XTb/3axAWyz6b7MOAOpnOwCgNQdua3aCdaET7hEA162R0TdbpMOJ4iFYOwHq2zd/8qDdGu6G2pUtlMdl5KF2FOVpT5Sb+UHorulPAHM+IMw3IBsa3pN88lA8v6Djt3Qlbxw9yLgOESwso7Srenwe5q7ojafnokrih/lwVZAW0AaHusbXZeciinf/fd21nVutonlkHY0IwpqlaFcv7jZGJxmCfOIgv50kZIX3LfEk8x+gT9EdnV2w45Z5OE1QOPY3jy57i/W0BQSE8Ckf8+W/iqf6pnyXPxXV5iTx+pvWE7mHoaHNpioeyy/f2SI893Qd/iSLWk0q7aeAjZIOnEytmZxgOamo3KDB+GA2yo5GerG4h18JGm4UzfEdBCv/UUAY69V6NveEU7EbuhFVKmxSQlzMxwwhJQSxd5UMKaZo58clJUhPpEn6GTZpNq6AauPzNz9R80h7BlQ76NqLCHWuDxpk9RlCASGk/Stn+gp6BsbvsYRdRdT1+YHCru7yj6htS7fqkwqcdBZ/tKfxHfut/y9ebmG1C2f+INTPFjolfNagKa/LdTV5Bv3fubd7Tk5s9TYRl9CK6ukEsRDWg/R0zRPkJ7CCnqSH5rNoeF1t0fXDjWG9ms2BeLw6q4pV9QQ9gPEmku4NVncyW042LhlOF/ukZwscN81s5sYtmE5+AuSLAdu6f9oA7BS+f3OQ/rWav1xMXy5nzUkaAzl+i1X4RBKblBxVzF/yMFKyEwzlPMTXaecHISWrQ0nJqWk7NC64DxYOtbA2GOLb8Uv9z2t9EYM6Mt7FOXfY9+xcxLWiE/eom6ZYAJQ5aVyeiqBaVe7h4MvER8LPkmcALwbve51epEcBHjJ4zSPTj1w/Cv0o9aPSj6l+dPO+aZAP9Pd5eZvPf5+tHj7mi9lkw7b4myb2Qb+RYmpwCpfMX9crmGZ4+q2YrFdl9a/mQ+tX7MEa52toB+t9UdcNwOD/fDdbfDYT9Cn/+u91UT29aH+gxly2lwa2znflJJ9vPjtmntgNFjXVkopmxu+ISNVR9gxEkSQJcbraGXI5FqknNcH8vShG53bJniSLLrBOd85oxz8Vj2VzwH8G6OgdFsePiW50icRWpsuU63QJVIrXpVqQDGGyCleUqZ0ll+OXMh/e/W3p5XmSji32Ctn05rFnQZgFNB11Xa2WZr84uR2YQ7a5eAZ3NQh6XGL24LnH0thTUdOOkJUfpR3xMD6GdFX28CJfMoJ467FWkGorSAcri2zJpcZjutmgDj4h/PpvqvLRHhrMNJqfu1xswlAt7hfl6uyu+UZTYOZ9Mi+7Kf9fua5e6e7LN3nV+HA+Zup3X9CtucykXXOZRs7eU71leBzunpkd14h+eGvFExiR1IcXqYYyomeh15I4/l4sIA5VVq/m5eTz9fr+Hma1XPwoe7rd/0y/5/XbRfPqBl+r+dPHWXPMmmI2Ffoiiy7Io6YLnjYZaGYHIQv+BGkQOVh07LvA+2Fms9bRiH/k9U2z+RVVMYWggdkTL8slGkYOfE1XopPZFdNxlTGdVhMuw8v0KOM/gdEMRiT/Hu5+lM08lF9vyjezb+Z//qVcvYHLvzSz/ifquQXcbxUXOZ0r49pgaL88exrSDMJMjhv1OriJ8LGtK09hKoPJJz4HuR9lJkYHt/ULi+mHxdXs7q6x2sXq4zxfwSRjxhL8qo7JpNSm56Yk8u1F9ObnOgIzZnbc7SVRP1oV7BRGM5ggx/eh96NM5y9IyrQbW75orr8qtAFjBvOde7tZT6dslUYVEkiDAmuOlYggVVO8ZNV3bvGLMI3RBxtMJN2Hth9lGavmfyggyaM/0j/yL8WrolhcF3k1ecDP+EGvsEqjRNQKkyf1v8zkYBVRP8FRZbC2Rc+D7ocZS1k2n/3+oMN94Gu6h3uu/ne49x/uOS5Own4CerwcjB75PdydyGa+Fr+X6/n05XLZIGTWzN/bu/9Xri/h2nXzIxZvF3clZiYHvK7rgTnqxTSqvUX0oxEjxxSXbIZrF4tDpYupGJ+diMFEQ0KAN7StGJ3Bf+9cP8wi3OEu8IW1SdBzHlf1CHWl2igLaW2TqZDeee0EuVRL9hOk9bnOSPKeGckXeivQCzZ8iN2zl4vpp6Jez1evN1+2PiHXxRiD4brcFystbdVKaH3Mn+ZlPvWQ7v13WnFfEbccJ+l3PEfOHcpV40zFT6ooRXg6IOkewdqLU1kAxjX2mMAzt3bZkErY/c9UVJFc5bJWCAsSxRchu0QzP2j+gzN1cMsSLeszLjeJDGgJKBP+VKagJwOkEL8Ue6qIb307wndutzwnWzufRtVy2D1c0yA9hqAeEYLhPtOhxnCKDhFH7wvZgNbgQ9xpLGJe3mPI313uLvqMS2vRZ1Et+kKG9alyz8VYfa2Tmmjnxy2w9R0NqL+vNhs86y0uxHGLvi67ErrsSuhzgtBlV8J1i0Rv+Lf7QFsJta5X78r73RO9VbRXWsbwdlyfa+HZSQzlMa8/6/8BMxd7sHtaoLZqYVw2Q8JCSTREvN9VpKKoZGGa/Gjt/lM4Sclw0v0tvk6D7QXM0LwBaGM9KDEKu8GqAnT6rGQ/IcaJCKsEcclQeKf6MXDYj0b5YCnrDspOg3R4xAC+d72La+moCcYlrMz7+fQUWbszx90xs+Oimv4EqGYDuvR/n63+sb59W9fr4tdqfjyywQn6VCymRTVb3F+8rO7X8GvW20s3VVF4ex1+/3aLsGc1CU9NSWY8LeE4kjQOyoWxNA2p7049jcJpIke5vB/SfihRgwV6lg3UVgC1H4X/cOijqgaprWoQF7WbIUkwTHMkc/R1kDJvzKERuEeT+rLAXn1NotSx7RAR3KsLdVQnF+AdNo9MP+quLlJ3ddEle4nUXV0QGrgKSpO1h1wDQ/iUODJfYKUVs/nUczf84DCsW3+ahhXda7/l87V128uqyrXQSKXfqnnn+jQ22vw3b2bFfIrbpTXatUXhVFnwyM8WQdm2sPMznmVI41d0TlTSV9FzC6cT5JgRXGuz8uJ6f7QbTBWMWMHUqNIF0t1hSNDhQiD1qanbLMxMjxtLTT3HC/6MgPPYiiEScRS4zUJ+anC/0ZPToOt6Bc8xhOO3dNUNhF2FrXjkTVuCOKc0hEqncGkokh7aUZqfa9HcUWGc9KRL2Kg6OdD/f/bedbltHGsXvpf8HtsEQILAz7STTGcm6WRi9/S791dfdckSY7MjiWqScuL36jcO1IHAggIenBAuT1VzYgLUAXoWsI7P0rqSUz2xh9sAj039JMX/eHpdiWyAJz48/Hp1AIQnnRE+OQ2lN/nZEaJ+JLgPZB/fgbk1se0SQmaeQxoWCxrtx1eDuY/eolcH8AaRjmx/qDF0JgX5vm24YHT9IPA7FXR7uAX0JDaKAJLAQrcYAY0VE7B/qB3ZwhHUesuEe7NG9gZPXPUA2OkJwjSaXkp0JL+H2OujninRV9kyU/j+OJMVyvKTHMHu0SXgaj5bzkqnBNjDbQmw4l9JWPGvnhRK2MtETeD4F4pxZ90mpZNTbnp6/o8h9fjo3h8l39npT000zFUStLmKeb+aYlCbp7a9SjrZq0H5G3FfwEPYenToO6HuhHZsJemEVdiFsZcnBlkRLYCmO7LK5eEMHYTjrhnK0QSx3bcX+osfg+XZZrN8+H0tXuy1s/sbOKWtrKQRNdT1JKygbUL8eqJAnXITrxbRzRpBOosrRdnpV8fxY0B9YKOISEYXxFWFbxMVvlV5y5HKW45U3nKk8pYjIG/Zr1HEb8X6gEQgSGtgVS3HUjo01+2bq6y8zZrOW7uY7vXDJjtUUG7X+d/b7LJYi3Vs+Ft/EYtyJYRIyM3+hcTty2J1Iz744uOsvnuXrW/ru13TXjlJvqp8aPTArvqq/5VfQDFoNLLpSD363uS2lynlUfu8Ysk5S8JyNGG70jLmxKfLEUFQDh6QfdQsk+1wQtzV1zdx52JoV96UMpBQPF5jX4lamd4gq8wu72bLL++y+2z5Y2TCVxygVr/MSIHA+JwEFWOg1GYES6FgMSX2yUaYF9v+bplsYooUuQxy5Fbj0KMocphfYD7MA6vON6zON6zON6zON6zON6zON6zON5nvJa7KfSWDPOKqniXqWaKeJepZop4l6lminiXqWaKejdWzquVwFKtnY/VsrJ6N1bOKNyCK1bOxehYoilO2aR9ac0BQFC7l/ffbejtbLh9ef5svt1V+nykfc9We9HYtBhfZh7V2TrQHX0sR2rvpvjv2YZXXp8b1X6dm6EZTrdf5ff1lXXxd7+epL2F+B6Uo7Kco1bw9pXmVnS5x0E9G3N1uZhVodh7db5/jhATN+BnbKfRg7zbrAE884v96cYBgUdf4P9aqwbSMzr7NaC+LZVG+efzo0KbM6vrho0xM3qdUQtA+Mc/oh2OmusTJc6bivhlO3KkZTkilfhFKx0uTt7E29hZe35XF16Pz9Ns827iyAr4zt53RGBtZ8+g8DkpNjVm/zIAYChdZnWya5bEzGmncebeP46mFSZHSAxHtGSbdA+vjrJytAHYoJxLHkY7qQshctZrpRmyX4k0FQOZ1UXoYcp2ebJ8YKQq7gxrpV1+IvARGrw5wZISf3Y5xT0JOT7A9ku7UlhIvgXC76y1ehCSs5BrSsxUA8yHMSWBiBESiJ4D9eATsPy7Mdbn4Rr3fP8vZ5u4/766Lf105EX9ypqEkGbhHgXElxH7t/myD2MdKaFbH1pGSpCODDtXsW1PSkbDyzmE8Wr8/GHVN4Off0hV0zK02XFHak3devJehq8WBzfNdDod8TsxrHwacmLHbsCg1KdBLFqoyT1KLPw04D2Kr4LZZICBwy1zWA3OaD2SCbZWVhxqRvm2VIaD91nxwaOwRTo6DdChn7Mvl0uS8dUaB3HPbZwczstNQYM5Uir10Jju9AWLwx3bNIIPz02LaNfl+kiKCFOka6kvO/NKBNKfF7YLmi7FFRVOSf19M4Hlti5oY9OVxYCycCGhygcA8N8uy4MTHsmhWyD5JIuZwxXKXlHDdRWNUIaEXdJiQqHNEOhjEFasrUVfFXohss5t6CY+ia379LZtv6+xytlzeCIwDIpPXqifZy/VCTlJ43c2u9mE6A8Yv9oBTEtq80270TfP6ak1ar64mtl5d/khiZS+3lfiCr2b17GNZfHt4k4l5o8us99nmc7BhSonRdCAoPxgDEvcg7Y/aLIlAciqye57p9bH5c6mrjNJdVkYewSMQX8TDlD8lqColAamUBERsQY39T7kD2iSjietos841+Y5l9luWLar3Wb2TKCHxCyFIm6ysH97NHrJyTFlaZJ/FV9p/BkiK4CltjpTIjDyS54YE+/pmMPCYdo07TrERbTQa87QBsjEhLpNQd39dFmIRvtWu5gPwNCOfBAedT0L8sE6QnQfnU4+pl8c/owS722NOkJYRj0nLaKJtTMyX6mj5XXqRIazbw0bZpUGakpwnYTXqgxQi0EtMe1XrNAsEeMMQ6eoNQ+wxkD7UjFFJnUgldSLlNkYqqROppE6EeT8zBpSDy0bH0YmTmgyuKpb32atsI3NG1vM8qw5lBkdz35TF6r1YjuWx8aFnHClPutfYVb7I9rmL4OiHVV6N7l+4z8XPrAwure1B0uiYYzT3oMywUMIKVzLuFbZJYw8lKwKaolEwt4W6aqG5O/H6EfSsoa0PkJI66ZkRsqccDCoNG2Hcr/XBCyU1/5W40/Ea9c/GEbf78zfxSWVBj8M7Z6JWPnd/eG6wEOXrvFa6mxLQt2sBuPU8c2lu0KS2AKVWd5ygivP8uuOkfU4zvTS27DyFoupRFbYWyAYD/K+qWAu7vi7mxXLfJ/Dtyd6AcOOnlJssGWlQwUuAK9iP4i71aYqjV8dW1VzND+ITvZ/UekwqJhMpn1UUjxXSPyBtT9T77+yhOmLCGw3yefVHmdfgjt4eaoGdqvyPY7DT0OnuSF+wW2qQXhwb6zT8rK2IjZbj3qBrXDRXWZmr7iH/EnebZkyOOuTTU43mTYS2U3QJCis0gRKAqJcmPhlbKIY6InNqN3HSiwS0ceJdGzk1ZPOPvMd3qkBmKrOd9c1sv8rF11S/sVOV3wPy8UXCTxqA1BOKmdH7LzkPKm8RkoMEKuWzqPCSCNDimd3ytVkiO/0kShEsBmniVHaSRzgBkguUDDsDVGkvU2XBXJUFc1UWzFVZMFdlwVyVBXMlNFyVBXNVFszVs1zZ0JGyoSNlQ0cA71LiWSeo/LYHs/lqB+Vjj65D1PZoV1Df3dUElcduqv3Q/u5VExpUUH4rhXue161nZotFU3G8+JQtZ/UuuCh+ifrgZdMv8Pob8AL7N93XgO17N9hDh1YP9pju7zB0V1lJb8WF+uSfss8gEXh7rB2x4Wa79LB6qQCUan7mEfFpFK1Xxw7YYPLzVcahxhFTxhHraRztQSVlDMq1qXYTRgK42kjAepajAaNPkNWbJKy05bgfWyCUtZIiu0kQqBXyCZRvkQsyCNnq8EPq8EPcPsCIXzmLhJUT3Gr0cE7oP8cB+uz2tsxuxYtWh3+C+VvGoEFLg2MjIoKC2tcVPZJHM+iUWKF4CjHS2E3P9QrZhDSJI/ckdbYwiaaXtIWloYZVYoG4SrVO6HL9kragdJRqezsrf690Tyr5MZtbl/KF366PRzSGfl9L9Ot+Wnvgji8w6otBwnI8YJhONDWy9mlQ6VlAB0Uwa9+zO67dNl0vkG03ubghnFZTEk3vrMDKzMHya4sr6XdWeEmILQf6PUaXgduy2G5+Ab0J7aG2HKQJN+QgrE4pFHmF0O0SLzB1K7IJIvQC2XJAHKESZ04Lm6QcxEoCEnWlP1QOGlSOJQmqLmYvDu6qLnNKWxxIEpmFwEGJA069IimIW/40IOXd9qbp5bErgUna8VCYIiMzYslY0RQDamNiXPuqVBGJE+T2nBbKOTEz03no6bp+HSQo4DKOTZDr1bGdP4R0zNZNzymfHMTxqBA/AtqoGF9us7Wbrrg1bPKXJEaSblDIRoBfE4EbOLbQfRb7sY3rJYJYTDqXGk7QAkZMJeYylZirQiOI8bEs4Nus/k18WVXFN9uzectbx6rOEUabGR++rmXCyJgiopIVnRJyPGqU4hoNJ+JzzMPyjtq5IhiDpbiJT8G6nTbbLBFQi8u7qvwUnSfx1ARERQSRigiqFmPiSscSkAP4XmgwZMuXelgX6akPqWix9srRbxK3CsTNUTJiTZ8pL5Ws0tVMRd+vkf3eE0YmLUrNYtmgStx54tfmgqF+2bQI9CbR1CFSCLtL/qZ46qhwOlLhdJVEKazpaHyhgtCoakOKot4LmAL9Qd6265ennx9HyDQ51yL7PNsua6UQ/jpbL5ZZWTnKZ13zDAoiq9ddWLE83pOLMfVJbkkcWbwxD5+PDuERq2gtrI0L+tXqsyT6UiImjzMQ8Y5J7VMEUbMeA4VdjwERLnCvkASyQtd6dezIXfwE0I5GQ7uJs1Gh/ld1Xbx6//7NSai7Jj1D/RnqAuqjVR9ZOBsM9c32ZpnPL+41by/MKmoOtgsxUjOtjtJnfWUfq0thz9MUiuoGs+Uot5Nq1INUox5ERnM77SGnykk9/hgqB+Xs69nfMg9X/ksl5Erf1nthiGSgTDhntX1PyOgFGZ9HgXln7V4ETSTtO9nqKIp9mlc3KwS4npydIJ0ygvg5JlOTEhVoVl9SXJWsRKwnp9QnC3Nv15ut8ri+zxdCy/86KzMxSY5fC3wtxZdtKvagKVd/Qxl/87ts/uXlsh7BF1VmQqKq+qLJHFQswcImWeVw6yb3tLYaxTA3/E5p8CxtYBG3rUoxH+6dZoFsqqnIEbJG0YmY9fTyubEiPcAA6UHPYlcAeG9mspvBQ3PGbLProhkYTSjy6rsCAU9pZ29wswwWBRXboP2UL+BooRZXtV4bO43pKbTtIOMVwbYwNhze+g8ZL3TG6xxz2gkbyOwSH1aTeNazWAf7FOvoxQGKdXjHMtf4PEkmlp8XKebcSDHnRgiPl58niQVfrVafd/E2FUUwkHhd/DKr1Kw97YE0t/dM7UMkoy5nc9n27Fr//6/ZUhkNjuJw5ywzlzUNO5fVk6DNooOKsdcRoNfHP5X15x4CnerB09FS9/Tv/76Yf2mh7rEQ/12wQzjnZseBNKhYM439inwI9enThO2GNXqBbKDHrGPLAUS1HE2qq1+qCrjTvi0HXj0IpOVzG91WrtPoArCuZuodmmiChuA7IWqqgOi71rBjZpv3KTE9sIo9L+QOZlD+HyZ+VLRW+p9eH9vDxLqKBommSG0Wj0htZsJtuAQ8bMRo9m1TlAJdPUqbsQXusPpo+EUXrAwj6qPdYBjYlDwBlqfRciHGKVg2cHz1Jd9AMD66307qiVIzqSeoHTr2qj5AXj0mrXozvTj2/uwMALg5W3VceVKqiyKfiHqTT0hEgXX5+4ERYX0t/lxc/Q06bYyxtnoeWep5FFQNfuzZOMXqm0IgBgpLOY9g5RynJPgocJQqPqVUcTEx5bphqGd8awex3aeUH2t3D5CB1exLpoZVUOzIY59Xrad6CohSh27fZfewE9MebqdFJGbBGQ1LKaf9FBeIbYhZ5qqLN9+lurjJWFPdtnZCHkzEZWmhuGJ17Vlp/2IHLvlBxL9fSf9lvm80D2juzfRhiD9ubexAPTClTUaEKG1jn0TnPCivJIdq0iLIKGV2K60zAtKyWEWXu3Wy47TcRThBnXJA4+l1jxDgT5UIMHVVJ4Ri3IsUFUUEMO75NcE7RuD7bb2dLWWrrflyW+X32YfNnudOZfwvssXrezFRHgnqpvzjROs8A+Ev1C8kjxJ9sLTSKgbT2t3lt3dL8V99+BckdeZgW94Si/wrDivFqB8TMvexLfTi2IywafCsdli1YMFAC5aeWRB7kF1fyY+1/3McfKse4c6W9aBRkUSG7wfF52FZFdympmBgdIvbvk0GOjdt20KsEmhckNSlTCVu3qJkiuk+qiU37tuS2wb6tVyqfSOhZVG+Kcqrh3U9+/Zv8b5D4L6SHb5hQqL20NOynokffSOJver37bajne3nH0vMNczXKTSj0Tz4DciGQLgSis28fr3egpu1NWowzMUmsxYNKts5xl4lLjHuzTAXw8xayNGeijr1/SmGoqLRstKka+dqj7UheNZhV6nvXzmajBhjRkNobNa4J0FtzYz6OTaZza2SQJCmdktoDJe5T4NcdChZHFN0icqHjwEfvp8r51VezW6W2WKHNGWGrtu34JaIx6ODBOCq2Jbz7I2Yf7XM4fZp8JS2qUmZ4dkJrAkJAbh2obxM1Qnc3OKRF9tus0Y23TRGT2CPx5T22+NNeNmAH4zxppFBWRbl+6yqxOQ/8vpu38PZkWjp/VRb1UE4NTIvUWClXXFi85/QyCvoxSEnv3U0iDWCvS+YufQd7Pa/JD8gstsl/xLH6lCIR2u5tpK5N2LDr5oTQv4txeXFYwtGZ5kAol3M6MpDA8tDxgTwQkJGrOZSb58MmHpVuItFgqNeqetowM6zAT/K4cAv+DBPjdKWiBIMomh2iaLZVZXCWFUKY1UpjIkiDIptwiDu2XJnWZTaxy9B2iBz55xXKT9ZvSM9sdSqT7OvwFTtEIIHPouvqaMCmttLymnzwFvZmlq3vVExgfzzw7HgtAbeFXPVheftWgn2P74jacMlf+HoqLBwNFMgyMy2IyjwWIJX1NovloDAdLuUhR9LiFVFZTxaRWVevZrpU6zhvns1G8OKWWRzserLf1Xv8i8wroEJ7YL81Cwri4Oy5xHrFyxDANk1szKl9erYBxTqWlf2GDUEQy2X8eplBLqPcTYGrheOfIvWiBE1wGbl73Ph7y5egEGzIwm/8JeOyBGn9JYRsJttLpfFWjb7cxAf2hMMXixudXAKKoOBR55eJRPNKfGhSGnWB6DGcmgeyBn/wtEjFPwObeBElUVAlUWQqlhvisZr4HQEPqVwyz+adB71732q6D+OoKrbXI4gG/tWmMLmOJgUsJicnGv0PKOmxIRFJZdyP+pda/+nkB6D7Y5ncGZdQh1BCYROlEOq3MVRJSa5SIap68qqjpVVHSurOlYyFNvJQIkvs9BJo9kFTi008kvv7zVmsZC3Xcad+OtqPlvOSnVjZKH6lFXbZe0hUe2JbXGKDQ47fB4H5b1i2I+kyy4zg+gm7BhfDLPYUeQ6gJxBPpzqpZ3UAZSoQydRNnCiXFgJ6VnC8OqAuYVA3EYIUHZanvYdlSG4HvXdLDNJR1G/loDUg03D5cEC9bksVq/XdZnDPaTs4bbwWKVt+OmRmlrnEPMhf8RwYVuCnoAdko5lhxzBaziUpXNX33AUL7RHjX4GkdXPIA491wPsZ0Dt2DaYiGcfBGnk6GnwJJI9qApcUBW4oEnPZI9/7kH2YVtLdkZo96/Fxt3MajSk3V+DRWBZ3ELYP9xuO/wjs3ggsN44ntwRHvs3tcwIvTi2wz/p6A1F+DyZmsc/VXpOSnqWJe+qbAAyIYG04Sj2t5v9rWbxc5pqPg+rUgbZ6Us49mHLYtxHz28WCAC8I88asROOJoynVY4m0K4M5lQZzKpsGauyZazKljFQtkz7qTRuWxkeOa53ztaWNZ1Xqs7sl+3nz1mpAg5ypcpsUxbiq1WNGdC6p4yKt+uxLISGZjs7LoxrdoATfPEnphu5VHFi5VKFRWNKAL5HAgU0SGQnFlK/3PFmlYBsKurokUCdTEb0UaiM2AUbZocrzStRzq1EyWqiZDVRspooWaVKVqktq8zv3Frl9X81PMWXVnkXL5zs89mrbJOp9I6jotIT4G5UuVf54v8U2/fZbFdkpNi01+Id73faniKb/KAcYr88/Dt72OWY7P8o5fuWwKcdwUj6OsvrN0X5y6ye30HiC4wb3ufENJSCMvlT6sXNmvqVK9n905v1AbzPDjlF3M1oP8Uc4PEox46h1gfY1bzMN/W+CduZ+JjZtxPd11oTDL6OJGi+DmLHIFlvwmFi83Uknfg6nHm8XHcfnZLZT9TBQtTBQoCDhXTmJHjhoh/etyBsjoH93wMS/uRX/n2X7KdZjH+RvMUw06pjTpt62+pAyIPqQBgzr3JUO7cESC7hlh7G4Q6EeAodCIdKgnSBiCtR13gs6m3V5nbfphOi3e6D+ya1XaysmCTTacFEdmu4velz0/tF08BZ5mMv5lQENLC1CGr06kDp6h03fTxFVgHVExrzvrx8lwdknfCFHSYNhnj5R1F+ERv2X06Ut2e0gM6Yqd0w+qzd7E1HlsDtFNAY7RT++rnKOhuPJn4MNN9m60z8Ftnb9ZvCpaQ45hiV2bHpzA2rT7LaXI1oHfNKGvRqEdKsjx2qo6hjqI7rUq5JWaCMjUd63cbaEGTX1+K7nOTOsya0Mc0JNjAd1jbNsWdnM6tbIJDWBzhW9PrY8QnSlTaS/RDlu1M5KVduT67cnjztHXzWaD7gzK2ctOCoDVLz4f7CUGX1dvP+6uo/7+CYnTFq8iFFJh9SWNoK72eAEkAKOECGFMFkSLijttLsLj9BK28WDdjXlY+fR2PVoUlXu4TZpX7nfxxDbyi4HyqYKNsabYM7tsAdBwXuxLOTjZd7xS52aNYHoLPrDm+cTg3eandn6VjwPkBN0ZRms/JV8XWtbwxD98eiqm/LrHIC3JjQxrgukj/GOA7cgci99m/uhXC9OjbCI9qxH016TvnEEM5VEjXHoyJ8h7VjkO/vdcS5/FLVRYaziz813LNv2XwrCX2zDYh2YLydVZSaHVhJUPs5jvpVYkK9PSxlRS8OwIU0hc4eg/rvIcr5WDboMcQG41nSxpzNFrNNDTtXgHFj86bU3LzDioRSP6c49ei5BPDt6uWxd2/UtVsNIeeETIrTCKWSnl1c0ZicRi811naURs2fu3YdQ+FeZnUJEu4eD7Q3bELMDZsElQUa99ywsQ9pl14dmzC9q4flUdA9kGmX8tHchgpdw8G7XTv6Y4NxeZN9kQdmOmJq5y/HYCMxZjkISQrszlbIklNE4eh85Mi9Ik4Ec6RLukYuVRxS+Su2Zqw2aKKusbom6kp7Vv5eZavZ5q4oM7DBUr7WyYiV2KuzD2V+K77G8qpuuH02Zb6ud0xWedUnMGSJxFf5aZew6mKMGd0CmEmingTVYy9J/XznCdAqACreiu1OAQxuFMCTzkXxaHoRfbG7C9EX19G8K01y4h8N6j5ls8WDpnMrNh91nn1/uM/m82yp3O1nugmfdMA40xedaYtJajWWDOtISL1yce02Y1DfPQvyenXsDJY4/sG5WjK/ryyW4gcfT5tJYzwe3Xq+7g/lm+16ob6ZKmsUT59lMlO9J6IJMxvnkaDi+kCNVtJXPU8t5yFxkEvT0EvKUYpH6x5QFatdeYbk6ewNbH3jTPxXPmyKvPGSd4d0bPWCjMPqBWmnqqRekPZia4sdvSAReQqbNEqnsUln6/uz+1l5VmXzbSnWqxnqDmak8z+PFe2w2NriqGcAE+z1m9h1einMPsi7NitCP4ZFs5ODEPHxEq+U6VhdF5d32fzL2/WrvBwA728zuYJ9dQ5Liyahs8L66RwA/2Bq0yDAWjR/Eko0nogSLZdFiWot+8LszMG8hnGcg/mDSWRmecc8cD2D9iU3tlVnvTq2noG7Bm7QYNf242gabBpIzqtqK+4jGiN2Vi2Lr2c6cVzVMJ/d5Ldn1fwuW8167tUooSbvcVB+PhT1Y/AG/N9AM1A4NsmDtw5ZX+vwxfsHbQoObjhkI5wzSs/qSuG7kG1bzhaZeGv1A637wjs2VZGwtOue/PSJDx+TXhsb3vQJwDseUa9+ddMvfRtAuPifQPj8bL9Y1VlRrPpim2NmmI4sKN8e9axvsEI0cerDv9Ssj90elOHQW4wIhMs4JcO0Z73lVbHKLuXff5SzzSaDWFuk2+9Nc2cw9DHDGJ2ttss6F8t7timL+3wh9DU9v2+4JrZyT8IiGkbUy9DEHv11Egv+MZx6giL2BAxNhifiCFSQblTws695fXe2Mz372ZzITH9NAs9+TXqbnJYvUC8OYHKmT8LkpDyZBqbXYl3+qnagXhf12WfxcRYXKPpzVayLMtsUZ1VW3melLNsv1nIHP5tvK/HBNUmreOZT9vrbpijri/3byCfEd70Q583FXTZbnP9VfbPk4njA6GpiCkZYLRoAO9WLGZt7pIVjWC6SMdSc3Y/0s8KYyWgOxV8FtKYsE8vZQ7GtQaloD7WNAGL5b8gzYfyOzRj238RPQS7QWHLxqSjqdwpgU5YO+V4X/1+++P/F8G0GSsnxQJuXCJldCsNK6op75gukPn58vTi2UpXEHQtEE+19GFdMhlFwIUW1LK4qtTdJxqLg2pX2y9TdfK7YhXXvnkI7R/+zzUqV2/hRtqwdX6rQQarWxZUpV+vi8liyykau3op1ETgD5Guj/pptcvXeECXS0f22VsZMycKhZ5fFvSO9dn8HBopWOo5e9hMLm5h0ootrMlZusCU4dzOZBPkIooNPHEidBefZlHk2ZToITTpxU2Z02Xg2aZ5Nmg7yQYMwaUaXkiGmTUzM+HZMnmCqHfJJ7wdyoQlcsBJ1bcDOIH/xT7ZtmFw7ceUqEBg9FduGnLRt5pB4vRrdrkkiEnbqH+kZhwEOoZTZqX9wZHGUjvA/1bBJ5c+M0iQKz7CJfT1t35OaZ6Pm2ajxF5iUTtyoGVUung2aZ4Omg2wkQRg0o0rIoDhNbMVpSOCBGq/qe89ATQwHaih+CoEaWRQlrkxd+VMxZpLuxsxzmOY5TDOWNcOUNcMDtGZo1zPpOUjzbM+MobPxqeebjSwZzxbNs0XTQTrCyDobWUaGBWhw2CUqjxygwZ1qVIIK0KRcJZ9xlXzGn0zyWdrfpjkTr/09s6Z2mDVQgydGns2aE2YNGKVJoykWP3Yya1IlV2kcnlnD+h5MoOTsLZvaZdnUz5bNZCyb+mdXDEw9UjO+cDQWTO02bupn42Yyxs1PF5A0CONmfDEx7JvaZd/Uz/bNpOyb+mcX16hoTaKczPTJJKDx08U12demK2hRPrZ9Q1QQMNxeWIBsxX2Jbu0sNL063s2wQrJvkLJvcHD2DT5V7tldcp7tm2f7poO3beL2zSMIR0/7Rqn1LfsmLLcZ6dmxCwEWjk04rVbHJg1LJyAiA0nDUq6SbIC2XX6kYR/LYgO1Pn9Mc+cRpGaQuWO5nOOgqK1Vin4fLgHmQ20dM0dhQNQ5RS2ho0tPMrBZGFeVNqqnI4uQumJ1JT2bhR1sG5dk/WRbaGThe7aEni2hbjwDqicfi8LjGSB/VrlcYU+Ojhb7Te+iNZQEzR34uDVryEFXz8LP8lRdhhkKTkjiYyGp/EXkOaPzOaPTXzzoxGk3hkjBc/bmc/ZmB0kIgmBjiDwMqj6LLOpl/kwTuK8+i2Du5SR6CtVnVEUyqYpkpk8lkpl8xwaZj26BEGqKEAmrmRDvaYLEPu2T9erYZnoUPh2g8oMhEpwFQk+eNfNn++PZ/hiudU28oqy/DDxbH8/WRwc5CKJ2rL80DKoSi6OgafyAvi9p30oWaoXk9eoALc272h7puVTxp2Z7qGoWqqrE6FOpEku7MJSf4v5/Doc8h0O6GSNYheZxeNmTzJ9Y9rm/0rN1Mo5WxpJpWycjCsWzufJsrnQQjDgEc2VE8RgUO7EasVL8nBa5j504OrEmbIy0yJ9tvzCq0k9UajFjT8R+4f4kF49kvWArGomezZe9+YJhjwCJws/mwkqQwoul/FmJXyhbdM/tRUn78CDnUVD1KBwwPRiAdWb1sT+zS1LOhH5pHSDNEtlcLsx1gjgBj6LoEdJ86QUdlOZLVZpvqq6qq0Wkcu2RyrVHtuOYeuXXX4uP8mGjRcEWDPVBxd3brP61rjeXzReVt80Nf3f/t2LtGnq9XmyKfD1AxdsoMT3T989ud6n1F9l6u6rO6qqYqY7i833n6epCyPQ2O7SihqQOnmLQLkdhK29pv6MGAyX8DKBdho8aOkkepW6qW6xcz3FPIqUX7x/+sy1q9TnVP6oDzmx5G10uDgradrmsHzZK0dooGel6BDFsklgEdQDFtgAwHwEggPNLH1LHAqAXxxIAHCU/WAAO6Dpp5nfr9zJaSuRqlq/H3/zXYhnE3v/tbP5X1QvaSZSE3cnItsy5lx1BgchibHcycoRB6FPAdhIItrNq1RPb5BnbJ7D9iF26fjq20yliO19JN1B1tnqo/l42s+Trn7uQbQ62Iw9p2t670XkaVOhBmRGGYexV9hpDTiCLXKtZH5uqISYwwqnTKMYqN2BKHEDK9E3RaEV9UkG+vMvmX9RPK+aVwpp9XZZFWY2NfrEo9W0p5j8LwLMA9BYArMIKOA1QAMTmn9fZYPgTZPTDIudRGlZOBoB/SMPRKX/fCwMgm/gAwT2xVDQKEgDujKxNjwVOOULTiAckAKttvZ0tlw9n2bf5clvl99lZof2vSr+fzefZUkX1zmaL2aaGPZbOWU8r4uzXK84vPpYMjTj/bN2/m9uS8Ckq/97gPw168CTgZg4S4YGnh9PedXXWIcDBJCTOnwTUaYhQP7G5u3d0gcawqdVwT5AD3pzU8sLr1QFqIJ4EzOMoQJgvss+z7RLU69tD7b0cW3t56ITpfjD3IkzXq2PBnKEnsZmnAaJcoRLC+PGAgXD2jPATCAdNVoafBMJZYAgf6qPBEW/bofhcchYG5KKktovGC+1J5NWETK8PUDvjcFESF97p5Bw0RJVskiQIB436OrvgayYWIauEZKyzbHF2P1vmi7NtubwQ6Mk2FSQErZG2kx4bxik6x0Hp7bGf3h5b2TPYRwCa5bFrZHDc1UfPtKNnVBHw2/CbZQNqLXvu9y9ef9tkc/GDK3iPmCxWZn9v8zI7y9dn9V12tsoXi2Wm9BjxubNvELSPB9p7O7FKIsPSY+J+eZHcJ7tAL469r6dPQY2JJqKoNzn2n4vlQny/JqzUD8wkNr0rJCg9BdGe9SRA0wdqFTLq1bGV8ieBZhxPCs37ipGzqqrPsqU4B8pi3RfW6idqwTr0FsBJX1vTJm3Uq2O7xunPT10fDOrRkhurYpXpEqlLYSQOgPdKPH4m1y+X8nuzzZeLnQXaJO92x3ccm97COH6O/Ox5gSjsE38S3sIYTWTbBnDdF83UbOMRh8XJg3qWicdezUIpguGcPAk4T8Q1KLTo5vcSX+9vWRQrjMUqv72r++7RjLP2Js10xXIwsCaQpQipIZhb0D4jYAmrVUTEGVxFhGMHupHTE4jIY5SwDu0OhRV5NFFpu0Q18CSqkpv07A4FVHJn8pt8nD0si9lCfaFZWWVGdbdYk3I2r427n5fb6k7+lWdqle7Fvz4/7G70liXpsVxIu7QRpP0h0YT5z5b5jcyE107IiyrLFpBkHd03OKmUk6zlXA/KtciA/EevVoVp5NOqsFkf2wlDHApQ7CYWUcbDqAJFLuJBAqVIpVOkSlSRcrUjW+ePBxwhe2y82a7X2VJ9o3z+5dNsLb7E1famyurDnNf3qtr70UWl5xGEeMgFrKSnXoVjnzR5vThAAWv8FPQqNJEMsT3A+9oGPDZtAxa4beBn6SY+nhy9OkAxH3kSHsqJ2AbbdbXdyBoOgeSbsvhaiW+ZyQiVzoRZb1dNjQeYD2MNt/BtwTsKKoWX9uu57GX4wtj+4dB+DC/laHmN80G+ydPAXmdfG0clhGtrtK2jMzPZC4flgE+8OrMia9uOfJCtV8euT3Ike2EXtPEUsY1+PrZ3rzNbXvy5rfOlGJYJNO/zqsrXtx/L4j5fZCWY0XJqYjvBBRFuJLigoKj4CPOKMZHYpicDXDuRlZreLJC9gbO4Y47Xozh2BuKcAVR8fXEOQW404OsML+Weh2svwBkGDxIJ2YzEPbtsQ2YkozYPEpkGD1JvIjBnGhdTbbbZaJmMCmJNTFW/ufxhzJu77zGWBCyyz+Kjvp/VZf7NUZRhjrdVGc6x4W7kQSV8pUAuL0T2Ta2dHkiSiSwbtFkfW5uJXSyUTiJjhCbowmeqCyRTXSBZqqgnU9VLIsX9XPgv3mflbbbQiDtQGF+pPBiZbHAz08m+r46QuSOsFLclf2X1ZjavxSq8Wb+AIgKH58aSotuslu97tc3r7O36cwFJkmOOoTYh0s7NQZFu/RmO4oRtgdpRaxhxMYDaNfJUnvQy2edK6lKfsJPFAPNHUaDiCxQPoXdNlCwlSpYS1SpS0tmKqzp2ZKRRXBUFbKIoYBMlh4mSQ6qepepZqp6lgD4W+4mjEpT3xWLb8B+blOMHVL/ZLpe/SbT/o432j2V2n2df3whMbksdS2s9pjI1P87qO3NECz00oo9EaEQfk9abqJ0kEz9TdSW+z/oWfivz7vustu5dLnN1+xG2jo9Car63dRzNabvKaNK2uHho7dCAqpoYOolxTK2NA4NWl8V90iySvW/EyLFvxE6NNH4UUuj0Ih2ya6RqR0jVjpCqHSFVOwJTOwJTOwKzT+bUayvY40/6s8W3/s52IGc2wvP622a2XmSL1tgfeX23s+jeLGf3smTnO9M/Zauizv6zUQtZ3RXb5eLqS745EvyD0nz0OXevqgrZxEd9Uxar1+v7sUQ4X7wpyt03AeM3wIS2DclMR7cypcIpB7JzYRDxYtNFHimLenWANBhHxD5xatBU9yGaEp80UxVxbLyKuBbYmm+W5bfrf2cPxwMjYX9zyl24OeUixCgxE1VQ6Dx1EXRc+RSB2hTqzfIAeSpdG+Dg6bkH6Wi1Qnn1qszvs/KlzgjZwfvd7CYbzUfy9yY7+1qUX+DN3Rpt11okJDb46MJK30XYboaGuU+0h3OfRJNmgewyIuYIZTIXzplW+EbOxyLDgK42d6qsNUrH6vOku9G8z6pK9nHat6e5qmdlffTn3bZeFF/XY4lBmS3l77gWtmCmQ0ZvP792EV0A44ZcWKV1YYlF5BXbt4Qi9SHngo0Uxjtu/Cg+x3xiWz+P0KiRoQZij4Nxsajb+oRzHJrQzs9KjAyWODC2dQT0iUFQmiFmVjNM7NWmPHEkaSGXg5y7uzSdczY17Z4p85tHPbvFXB4jDLC359b4IwnBp+xzVoqH8tnypZr+Tnz2EzJxan7bb5Wapi8P6iAgsVcfGcvXjQkgHrbDKoVNXxdZNXYrR+nUREPqh+I8GCgaINDckuKe/kiCox3Lss+zK8HANa0lJqowpiUmaVitLVOvTF/iQ91rp4zp1bEPEdZVTFCTpzQpa5mPlukLgO2RsC8+vx5XZDWOzBpoTttHlBj8pvg8waEXM4FFghbwYyC/JrEZZRKY4pTGcUftCTd1xY8czeiIfBWw4CqEyVX4kyuDmiuDmqtgB097hjM+HSFWZQ7MyltdvXRpQPNqPdtUd0Xd8IqJGTIYcWomNPaLziGDhkYic7Klssrq7eaNeKh6+Vn8Oq/X93AtoWNW22SnRsc/ogEZTs/Z1E8YE+6jrGFLGMUCgfxO3JXt5qQtw1RXOkwp3y1VkpeOFqeoZmshAv+bSQXst+3qJiv3fWE/ZRsBkhdjysBx+N6Rs39inpGkg+0kHZ6GlaTDPGPtPO2fpIMdSTqqUTGolkXu0+kxgu22d7dTsF1VrDNVsc6AivWezl0IhgqDwP1W7KMJczfZomp8951flrfV44jTqRMFmNQWJJpio1cVPSdBJa0kEcACATmCY4bspBUOCZLNhtksk92yCrkovqlTzaOPk+1GLtAwUVKqHFF5K0TlrRDlOItV3kqsBC1WgqbaL7NYHUaxUgNj9WysnoUIU0aRQ6Udqcr2YvPwscw2ZSE+fJUpTonsfrbczqQb7jafX+pf3hbZQ4pZ+/6rWT27mVWZe+QVamT7FXqf3yqwrK/mZb5R77IoC/jFNuJjzkrx9Il3uPn909vH2RncbvMT88yD1mDy2rl4AyrSB5LaMOg/t7Nhue85C1N6Yebi9MLOGKo4m39INVGnzSEerXURhLyx0K/vL4RR+QAXUhwGDAd40DXOQOaXV+KXT0cuDuuP8RRrnDshmo2W/6JgNS6Ev85y0D46ut/epokZykdBuQVsU8grdRGgoFApYe3NGa7yJE8AwqM5pSWuxkfwG9jr3B5qd0e0aHFpGjghEBRiwVbfUCAfMbKaI8KsuCjtypoVT1DBYHRMLL8pRguqSH4gMLP2eKC9GTNTZQ6rHJkiv6xa4tX92eIsb5bHNqUpCp44haU9i+5fvJ99yRon0sv14uW+rebv5VJXVjb1xqNGKOSqFmIxxZRlXtUX6jtLSxVspWIMtqsnEpMhl4XlRML9eIKgRHJul+AnIEMuRniKJfhd9m0uLQFxHS0k0az4u1xj7eWLw6+wu/fLixFxX9z8lc2HIB9hFpl9hILKnmKoH/tECuTR8sTuI8QiuI9Q9POxH1/Eg7AfKewjdcXqSsZi+myW35QBjX9bJh5HThYqtrGj+qx2KtGqmH851QkdGG+LTGwxE8VhMRNxL2YibBXJAgoStsqOmuWxRSbhXem3ksmdF6qanid4rPNCYu0o+Hb0Z0NA8VhCsDlRbLo5UWeaWs7G9CmSFeG4j4mbwu5G5GqK7i5EmiAjF09GY+SScajjuHM1Wk1pVukGMLX4QJVcKYHivwDSUOe09k6fENMUDko3oqxnUXWS+BSYNstj7/QuChV2os4osVMH//q5xjAeLWgk+31W1xJrm1xnDA4HulypRbY4+3qXldnFnyouBbcQPRoxVX9mqv408Prp1KeCLoGI51JA9Wew6o9DcfQ4M/FINGo8dBw0K2KNhk7u9e6Gm1HOnNJO+6ZR2lZUhDIZB+WMp0CyKYMcmRTIsGNQhh2yKQKaZbKzvxPEO6Z/P05aELtAbJDWIstGxJWpq6oXUs1iuEq94yr1jsuMMXFVviBZRCyuVF3VsyqbiKtsIq6yibjKJuIqm4irbCIeA80eWU/TWcnIHt3HhHXG0Afl/NF2wyJbgo+0Rw5PlFm1XcLvYgwdnnF8sv/ms1fZ55l4xvkZ21PgT3tqjvUqI244qjEISMtwNGDaQIbTLE3PeVjFVBEHgtYpyLKnpxrtp1ICbTAMsIhgB5qwiVwtqFLnFpM+yh4zsAqRq+xBHqc9qxDfFbfHCbfyk5i3Ro+cHMFfSzuE/9aI5TQ2XGD4PAlKAGKAlIRGXg3oaeLTJWq3RpDruCsPfQRZRz/ZGxCP1glWtymT9VD7/X7w/n67LG5myw+rXI+BAfDD/bbqGOmU7CPVUbx9WIzEkujTADcH+ytY1FI0Tn1YueUigQWzCcJJZ1ri8SvLh6Vz8GS8BiIKoBLcEowj4vpfV//M1jLGXpSdIS614nYhHmLnLCyIA4SBHIpiICtZiZLYawMXiwSqLjFDjgb1KHJDPGETwzglE8V4XlVbMYwi8b+LP1fOIoD2kBGiM1oqoHMSVt+nyMu1RWxSECBOQeyM/xjuqkCSYLoqnNi8lR2f9MzpsIq6Lb6Panx9fAd5TFLWE/KK4jvgFCZC+nWEwsxnM9erA6Qwhd/tjFPcM2mvhfTHw3SSpD0xTdPIzKcOq3F93LMzDsTvam3iFFZPEE3Dx3TCJ43pGKeot2pibNToPMaB51d7qiYAUzeJbdUE3qoJJeGrJqqtBqcoPNUEI0To2cFveCZTlfL1rWygXc7KB/2gywiFCw0ixcjTLs6lcVgbvN3HEkNbPLWFAfIiWv7z3RoBfWqm0Kh1GP0FV91nuOo+wxPWj/7ixfti180p28h/fyyLbw9wY4kP91lZ5otsPD/jsri9lVKgqml6yACOETHoyQgNyw/j1/zMClEnFKi2sf2Men3s+HREOja5TPTCTimZFCn4o5ACRw3eeyA9jZM20tPAWhZrl6mhzSdeTnVws7dLy5olAkgoXboPdvJ/IfxD+L+6eRyVY4YmAeF9ldV3xaK62G6qrKwv1uLXu8/O5IfP5z2EgKdRZLbYCiopKY5tIUhANm9sx00BxgaGbcaGKII5G5yBJbfCg6fmdI96Rk1f/K4AeCkJ67NHIHsUyJVqjPwGy3xeX8j06PosX2vF5uxe6vuLbNlHy9cRxWN7l6LAXfFgErXlmYypT/eSZn0Aai7UUcOhmtl2UhqO2vHRaOWV4o/ZJhc/oECT+nUrKRXSHF7+OxteK1Na9vRZldVNztmFzlO4+LNSLFx/oj/r4k8Ep1wDM9pdHYwS++g8DsruRakX4wkC2ixCaWPWIRDDNfYIhV9jz0fkompgVhfoJ0B//V3og5nZMTG7NYTl/nx06MPNrFDEngD02fjQX48A/YNX9QylOEnOVvm3bHE2029ool8N/tkMnhICaKJxDJjxrcAa7iZ+fEFWDuVZAsgCcArAAS4UPYGgbTqyKByD7fFForsdEBOeGI2scFiNrGjsR/6OaGQzXoPdpVN78+cJvPtz1rV4fnosWZyOxpKlcfA/b+tsVT0G2isBZ9f+L8d8tn9gnsEWR8Nmi0u8+lbZuz/gB4q4TRdHO9HFhbT5R2Tkzf8Yao8uDn0ivZHR+INr93c4WI/srAcM6jocUPz9Nv/dKtmuz8TV/sPpCyIT3P0jPP3dP18Ls3czk9R1Z7d3DeR7ZvqkyGq4Frhyn/ROXrNCXQhut5Y+ASs3SieZu+aB8xE9nJjEZmJDWOo+86QRpbFHg2ZbvWnWx66fYklXRZ+dJ+nUZADhaTo5e4lAT08n4tzkiQurMW2aeopA1EsEmvWxI1+cPwkRQJN3dnqJwOq7IrByigDRDUSOG/6lYXn7oe7lkJW7888fN54FhMBiYGlWyO74l+BpOnw6CsHYlu7qBwmBeuZPdFYXZ8hp67bHDeTHSdvfSVJdxR8O9hHQmiwFPZ4RtxpenqWRV2+y3ULZEkBdxVnIafaiSdq9fGS79/cqKytZbvvyY1ko0P9YgVh/RyBgRi4eGw3IxamdhtXmBbAJwOQ3ltpOoAR7icNumSxxSEnisI1R7KZVnKA4oOixxAF/LAQGf5wwrBTYz94X69vi1S9uoQDntfNCaYrMvNA4rFgA4B+F9CQS22R1OPbyjzaLBGSGuvgYwnKPspHlQkmDkotL/V3yrGow+KNl5HuyAQeMU8N+jrHOnwxIg2IA1TqHNCjEgCQJUC4SO2icwoa0UMviiTJPd5MM+gMk4+o/717djCsXK7Hpr6TALW7OPs/ypcyw/ire9WxWn61mmzENbUzS2KwjC4vPh/plWVPcy8xu1sd2t/KnQADBJ29kf08UxleojD4FoRXagApV6qtQEU+FytUe1dUgNaSefJyGpFDV5Wzer7ASk8jAOsbnSVhFxBTY/SOwyTWyCQuhsrLYPgAiGOxJmjrAnjjRzs7jqalIcc+Y83WZPUKsWVWNqfbyPQBNkFExRvTeFY6fCEgUBbduu0YSqBOOrbzoZoFsFxGjHbV9sVOwyVXFK7p1xMeqGbvN6pfL5b5l+7WApiqjVF9SDO5HXuXVZjl7+E3ic6gAbNf5t2xTzO/OVtWZxJn4kbI+WdMMGzZwaAG0OPJjSLHoghAiPk1omhWyjV8cTZIHq1uLvpEt36My+c7oXmUr8dV3/cPeq7+k7LzKwSZi0IR2ehw1e66GFQ0gzC87IvJhLEwthUUvD8CbH4WOasr6KistTI2ktbRhrdqCHd4GAjY8pb1rR2aNY1jss741jsTHF2OFuPTqAN5KFD6yR4ttGSgbY8vWgDoNbsccgyA/TgxfYxSUtYn8KKtibqskNr5RYnPjxwlMjY86pvQgpluqTIizjcoIjLgydeU9Ods0ac/7YrFdqk98JX6uWZkXulc8wGJoAXMMgRAAm93MqgzsMdYee1oUnkC7eFB1AVyLUOEuGszh+WP9inbf7E7+dlWZJq5KEJgSBMbHapyt+ukd6TkNDOXHXZSFY0R60n8rPmzrzbZurNrDxEv9hUaQl1vdcOJICrU9AcnPd+Ya7YRik60fh9VQm/YrlSHIp9dKszy2NKEnYAok4/UUhgE3PvB/r8T8T9mmKD2Qb082suKYqUvxoI4STntawQxgx7KrZPTy2J7OmAZPBk3lDySueDxHpwN4zZHwa71aXgtULeUajiAV5Xb9crk8yBvo2XRNMhSq1DwAwkp/i5kfJ7plUWDAYAYo0VP4AKCOjFAaUN4bZaOVCFhYGwnlp01maELbG0STyPDhJ2GxvUGuzhjOYrPCsz4Ab1YIYPqhuCPC0Y8xGLqZzEQZy7G6JupKx7IXWuhT3Xu3a/nPj2Uh3r/S/XxnC3nrk+rnqW4tsjqb1x+Lqspvls2B8S6bfRkkMMIaaUhxu/SiS6wq+bBavET92haBjNCWKylxlMljFrzmz3uWR7Z9R6PGAG7y2zOdAdcZxdzy+DP2BC1YC8bEq1MRhz3+GNOOjM5E97KbFI7x5HDc+Epn64fOOE6tLnJpWF3kkBcjod1FLvbhak5htyZi4W/H6ZRh/HK9+JTV23LdHc+hJxk8Lp6fbo4BJ5PD89/brOyxIxvJkMHtyD0VZJz4aBYpnAmJWFfNIp4eguPJIbgW71sdlfd1wTEl5k5MceB0aH449qFD04tjwzhJw9+Io58LY/UJL6pyftF0ClI3IOQC420vNYmoEffHumVZOJtxCpD6gdm4NLFC/3HsRWC/WybbXY1p0rWNFaaP4c9LL1KPyE2zgCakVTQWy8VQ3R+xDEVheQxhGQXAQHuH1Avvfx7jb/ehgUyY+9kyl/h4/W2Tlbn81WbLNwJR2zJTq7KZlVV2/FpXd7ONWpQb8f4L8F2gx3aD+8dXsy/ZyaebbhHig8mgUw8J/fNPXd/350W2vj9XRSTnrnMGnGFkYVpNVoI6cHA/lwyC2g4ROwmTdkrCRO6uQ+pknE4FierTh1PSs8vc6/W9+kSfZ3P1ScXfsmRklBNooQXEfQRBE4x6EKt7SliMCMSuBgEDSSaqAS0qsktB4MRi3BXT6OdRqbkOnWS0zOIWxl70R/Eht+wEkq1JRvYLN9AcWEsI5IVm3gfMGOb0cBWr/mwsd9mgEzQylvukObbwLN75JJTNcSOCSdrx/UQTUARU7mEXrJII7GziyTWAiB3JJJEjlIknwvInQD1oh5Zqh2zgi6VFhSWpIZZl+Fga8ViSt2FJ/YMlWy6WjldMAZ97T0H4nlFwjOHD38ezzbErFQg1777Pb9XPvK7MEakkLa7+tl7nv3n21Z48u1lm1t3X6+3KuinznKtiW86zPrKtrASH8QBIcmL24worUQcjr7otKxcTMZ885MSRpEPSjkdSoukpRpXe5CIZILtyX8Mymw5TKaKSuhSn9imVdHBcaRwL6+F1WRZlY0nsmpS2hVegUY4f/V8PpC+L2UK/55uyWL0RMyHgO2e1Yw6pUeGVBkYogpmdsUYg3jWc2rRrGKpxsenLm0UComeEToOo06/OxSkT8iiT3Q2U2w7TnilrL95ZkHu7lnUqthzY4JSf/nD3uvpQ/kstiQpEyHX5OKvvqrfrZrx4eVMVy22X9OYyW+iup9VZVRdlpmRJLEMGdns5HmhbMixGRh5/WFSFzLMo0tYAiU+GZ7M+tjnjqmFJnR5h8hhJQMNy+dUugtOeba5fvNzWdzu0Xx4AeSXx2N/vtMhutrc94ZyQhBgmDQ4q6oy47WgiEJ53HYdazRopdABYQbtmkQCFiLiaNUYnyPsnV+iIY9mjDccsUlekrnisxGUFz0uFEAW/2efsqi7z9W3++aEpWHlX3KrvP19ms1L90R37Mokfgv7RfSNowEMOGgD+VT8LIPLJF9KLAwQNcOjVWALrKoKXsrGqscpsVdxnb68+vNojfJ3XAlfSWdUNzKvVZ4Vl8S3uM7josD1k8AMy08ka1FbOvXysPi2IUmazAjKYFTZ4UthovF7rkgpB/MrZUvpnrgvtGJL/9kdwmQt0ns0Ws434nme6sEoi+kZqICB9VGvEcNIYJbPJeRxWXxWA7RJDmLaaSCDCfJLimhUCFBPuskydyE4fIbw7kH8hkp5WcSXqGqtr0tM4Vc6ZT9ltXtXlw4mki3mxebh6WN0Uy0raplfaISmpF8rZ5mX1sJ7v/riS/x4sGJn8XKDn8migrbikZuZ+TMOSCq/8OltzwT6FVHp1gAJDFnwdeSQDCuKKelqfrxQGX2oIameljf+8ckwbhPJVMf8CgfzofjsDj1nEOyyoSFtCvHJ6YotYLfFqqMjg+pTYRbvjjLDRR4D5MN6pSLJxiY1eYR0IIJN+uo1EWoNpleJ2+PPNbF7L79fc3Qe+Xn6dlZkxZ7AglKo0F6wuPx5pJ1SnZioQDWrDj0m/hGpQB7IzquF+D4g+gQ1fxmLENR3LVC2+qLhTOcKO3mRkAmUBRwPtWBNnxIg1hVU5S4DCACh5ghBLdzkjXnRqzRIBkSaeTIFPbTCemcIz75uxKZWRS4HErXQfvmmgrSKurZFDWmdvn3q2vpU/XU+vOkJGowZ0joIKEgFc3rwvz5ntjGmWxy4T5xNwx9jaSyeMY2neiGuqrqwnbebrdbUts6tilf2SS77MrHr9TViurnjqbVa/1oCVYVKdWyBf4LcsW2SL1ku86CMBusNDdbEs5jPx4SWalnDSgTXe9lBSZJKghdUpN7VVGQTp9VZNTUJ8cvWb9bEEgyakY78HlGizob9oXBbruiyWS3Hqj+arxGi0BlarWb4ehGXxPesTULaH2zs8TU0DlQblbKfMrw2btcUniU+zhmZ9bAvV5YdxpgHI0rtHyAIYtsnL+K64InXFo9moEtN7WLwTxuguWUAGRtfbzf6WL/A/Z/X87kzD3yi8+lPTnol/idNDvmgFc1y2xsZN6sdOEcA/xBGJ+4VQuY8fsmNWf0ABJ8zT8ahcNbr643l+J2Dycbmt/gcMlpqjbUc6ssoGUVD4pV74xT7k9tTyMerVAVIA4o4uRpyeq36Gk8IwHY2L8oCxASjW2/vlbH4HJvMC421tJGLU0EYiGhKUCe/HfkOAmBCzC9X18tj2Zoo6YpmfEza57Xi0IqtjmPUH86L4upapvGCFVXvM4AbmvJ3AguJzmoQE4xhIrk0h+5DYSE4TL9dJs0g250Lq6gCeupPR+SOo1ii+QIOi/koqkSruFleirrG6Juqq/CuqOQlWzUmwTF5EmCmVXFFtq0ozcVXPQj2o/FIGlN/k4VUD2X8VN/JL/TOrlXxor8rDro+JGNlNbA8AWTbNvCb38VLa2GL4PvtlpkJTN+p58XbVdaFfS+W+H4akV0eOZbt3zHav9d+srBqPqPhLP6y6HDZvdfTBd46iRetT6/S1+0xqZdeF3ggUIcTDTXZZbB6ui+vVZvjW8H/zzand4TDc1td4Sg16ZRbUKYcS2+jeEby2tofUzn0gPrtDs0JA7WXsqiZ2291En6RTCiCooi0h8NFYATGFUN0kdLs6FgcBwf4w71aLiJFB9YB1VW0wsGbYzylqGdI09dHemvWxczfjrk1wETrn8aRqr8TxpI4z1WJI1bKJa88WQy/kli5z1l6v7/87W24zOFCgN3o1p9wdAip+IG9cF7/rRkOz5VJHFPT96iqr+8uDbEkxq+4c/qWjofZ2j00+xI69t372bs/65TNDtD7MNs8xzIcY0a6t5/B5MjmTJhrRwyTxNQi7H8vi28PLW2f/K3uC2SOUGV3OeVBWDQK6hIJpzHabUAblbAJtQpmDospRboKdWgvB55z8nJLzE3BW5ghX5ghXpgxXpgyn/QrPAT1GfbVfi6peN+q+4mn7rVDQ/L/FWt3blvnbdXOv2fbVv+Wh8funt8e3FJr7S82yuIXjwzA7EDUT3HBYen3cc6fHPmwMenXsmDANP5IwZlO4WprPvQGrYmGu8kE4+pVyahaCB6W2awZAj45uiU9HN2ZHwPQC2cB1ZfmcsEW5rlGc1K5O1U5O1U5OlRZPlRZP2Vi7ugD1p6LQbhvZB/3Ii3P4c+cE+r1U/JzFfVZ+LfM624WOdXmiYmP4rDKA/KNtTZ+5ojy7y5abrFSS8s/dzabxECQ0jjkt+WGxUa7IznEckvwo76MP9Qiyyrsw5M6xvDnNCtlhCxQ5JAjzE96ciRWdE1luRuRBT6Q6RzDrafaaYDtyye6H9tQ8ujXWr7P1YqkLAcyn+6eMgtJyyLfYDzdv7uS7PTWxJUHE9IeSrr2IfvYJBIT9wCQkuz4SJFu3VCfi8Idy3jmI/SOM5A5lMoSgEVWn19+y+baWVG0vRkK7bEUnP8vZtv7MzqrNMq+dgP/O3LbWFRtJR7hrA9EJOkuhapjUJmDkUAmBlXmH4wTOIUVda8PIjykh6IR6sXqEkLHc/3Mde3unVniPi6ta/N9KGsWXd9v1l4H6kr2d+2z5APIjahJPRUGlKwFMbX4NpFPm4xBt1scOE6Cka5ig8T9MKPJFpGZHSDRyB+k94LShUG2K9WIY2v+qivVZuZlDKDfGjNguMZ39QakymHvV+0Y+7btsnge9OkBYl4TuAyI4HkuPyauG40HCuOqiydRnslW6XIG9y7/52+Xwbw8b4VxsJOPh6DwNKjGaEuyXxkSRTaqZpF6kmrtlsvdr4mLxp07rlvJHUVXEnj0oXYGqMgGqygSojJiIq+oQjVWHaKw6RMujRlxTdWXqKpMcKFHPEvUsUc8S9SxRzxL1LFHPEvUsUc8S9Wysno0BogjsaVLXHyptKgvdaPtN8RWKhd/W2bv85urq3dUmmwsMzlVm0sdZOVs19nb9YZOtxYQmE0m/BhyILg5NbF5JVpaiOYSK5f3RDTXeftH9bf1Zju5q5q0qa9+dOz9540JrT/8sfkI99+36XTGf7b0Jh4H+e4tYe5AI4+i+SYRhnIsoqHPxMTm9EEx+FIcfGKExHutUlMAaANfi9hY2WVojhlvK5FYnYXml0p7RvMSHrkKvju2R6kqtTs9pOrHsPIrUEYT4WFaKwJgi25qV6/4Qlt+k4a34S3cPqcWigfaJNWzwV0TY4K9Ig0pIUl0pvLjSE2wTWGCvnoApg/GNeOrI5XAqdY+i09ELOqTHpeImooqbiCZKNVMUdao+W1xtW4Z66VsN6lTJdX6zrXWsQvwplKGsGZR3mhjF0Z3f5EIs8/9VWsqnrQ75NdNeiwXdTQVSRjpSGn1PsK7Ws011V9RXWZnLTyQOh79gGXPObLM/RnFkZHvzsPL/UtuKwlBVU2qFN1IguhFbnt5mhQC3AO3KtY4gUftroA6UXqB0iLAlysZRHEg0UTaO4o+hiRJCRYZHqRJCqoSQKiFUYXmqwvJUheWpCstTqp5VCeQ0Vc8CfT9Q2u+kWjdi2LTN3BsX+/s7huv9jevVponhC5FfKc+F/dR18fs6/2bf/2de/7q9EabZF2N+damaOV/VQmqvy6axoc4A2Pks2k/obGCZHbDLBd4PaSK07Dpfid9uttpUo2wV93l9+hSGJrQTB4jB3M10FCSccxjgXgCJpHZy3OMcZthBsRO5KtDDOoeVqMdK1GMl6rES9ViJOsCI/HTOYUlKUm5VKy/5Imdz+WHFa2jX5bK4mS3dqQXWsJGHSU16nqDyMLnNWoWRVyEK9yHFb5YHyMScpMehi0BhPhqJuP793xf6AMrXt7+q6NC4+HZDG6LFj8zAKQ4q/z6xHRII8kjEVlExEFyKbFjr9bEd8WnSVYtMk6llmSHFwyL7SKorUlfcN9NMYez6Lq/+yOs7req9bcMVdnU3D7bkQULSOaIaoUBjPaVICc9LVWXcej1IktzTnpp9BjinU0CurL5BKI490je7m2foVPom4mNLVnqRDpAsJsNUTEapmAxSMamYMhmiYjJCxYid2u9lW704St8EkAg2VZRZ/Feb2frf4uNdFx/qbLn7S5X05tVmVs/vXu/naYLExe6feSUUtVUu40lfdAOXu2K7XLy9FaaQnj9E6sBtApK7UxMNogwUGWwvYXnYk77cc7EnRwYCBY8kwXcvYnKDYrhn76IXh5a7noeXP/DFOmja9DOVAmqRzekcIfnvo7nXDjsFnmJQ7BLUThlC6DwKiy0GIKBLIHuF8MT2A8Reret2y2Q7Ahh29a5LnEnQyaO042YXiA3ICZVVV0R6NRSFDpHeVCKNNyJ3BiIPeSK5YYikhiHylyUywYpIUgEiI8hE5qEQWYFPZLiOyNRCAlUgMy8Zey+5UpoDRX6pK4GAWZmrZAbZ4vpm1tzP6loca5WWxuw+z742fbwP8tl4845m7l7tqp7VUIF/Lklbq02mbr1ti5HyBYrvkq8yYGT2WfwyL5fL3TtowplM/KyZeVfordvN8feqhbYqmTOO7wmBFi8oX731rEy3aP4+1DDtZzS3VrMvR+3Af1kKY/LFWFvR0fjFSrzpbHEjRhfNLwPtRtaosRFR8zQOi74jJv1SF/3aMzTLA3B9Rx0j3lgz7E4peZHjEYswxOG83snt5+Jx8F5Vfy+HoT1FFu9xGpTu6deMxFY9ARcht5kG9fLYOUnOw9bZv0Ef5pNCexwY2h8Gox0RYu7tQYWaYtxzb0/99nbi0C1J5709nRrYSVhgl3z1t2U2FPEMIyN5LyjPAon67e4YYjRI7aAqgmOqSUe4E02XMCm8o0fBu+703Qnx8ntVbaqBkxwDYA4qwtgojY4C41xK/JKHqFWBgQEnGbY0lWaFbIJ6FnXsNIXo1JrwMOmfZ9JZyGLaswPPHl7yY/yrKtafNvPWvbfrJrx/uDvIfXaA/R+zavVxts7nu3a1EPxdk4wODTTsDg1+Te6RR4cGm+Aew/Q04XdoYH2rB2xQjQnpXTtxGYV5J1mLSxeunTONgmhs0IWf87DCILaywnzCjwSIPlK7471eHjusH6UdTdFEq/5TCoPIyCqL0Xjl0PUx5gQG3xeLJonLHlvJsMlsPc96qjUHBX6RC4DI7C8dmHHmbZ2Y1+4Uiw1OJaorLwNiyKZ+MXmAS4/7VFI3K2QH5ZOEd9R7iOrfOaEkrigejU5PvvurNugGg13H6c/kLzlbL1SW8KvV6vMJHiRr3GjBhuO2sYqSwAjhk8TW8inYwye11XwE+N+J3Sq8WSXbJRk501CczBjsEYgxhmJ+tGZUpXj3opSE17sCldEhfz9b5hJLTsxDEwzQEyNHV4A+LLUnTm261AQCfYztMjQERb1tzBM4UzeOuINbADu3efwonZSHop5OGPV7jenU1m7PaGcXKtLkI5gnXTso/3ROYMB2xV7t2SIoG93itmtWyNZkiIsVBqFT5V98UkxfAuKypiuKR+P6qve1VDpjoWogqO4MhfydolFSprMT9I45BuwTbsI+DiupFvBbci9KxzjySarVCwSgHsVdUZ9qbXFS+3o8uX19vswvZO4tBOmj+20YJ8zwOyZhUfv6dYbFkZ9+YlFj6/UBQMw7BpJQNLkUVfGRZBFeFPVNUpWg0ny9Nqq36y/r4uv6UivUAxA9lz2ffl9X282mKAXKZLaZanwAt5E9PdnIGTDKU5HO5Agnhhp75Qwc/C2WT+ao2shOGYg43Iqzq1cSR9Pj7Yni8XpxujA3APSWG9HD0wgB3PK7o8DxDQVWbeMTyBFAQE4M7HbHDHfd2x+D4scP4K5uZREZj61x/Tkrx3ExSmjLIrtdHPZqO5dx2ffiPzHbYX+ent0GvHa1tQAflFed2Do55FPHrNeOjuFG4cTVKNzpaXkUR8uwTAIUSfNBN6ISV9IvmQCuCYUBePiyx5SE6saHbb3Z1sOEZOd2OemTAdLC0jQ1ODeSNCx+XjvYSkC1Jk5shwwgBlZkqVkioFuHs9lA9EOZ1yE+no6yECspSNSVqqtS9RXvWyT3RBQpytNIUZ5GivI0UpSnkaI8jRTlaaQoTyNFeaqC1OKqngX4rf0IeV68yj7PJFlpUXzZbiT9xptZvmxKaVpj+0Yg7Sc0TalmMNVSsFtAdx/nhix+70R6u5bSeRwxVlXihxab7Zv6hWeqac+mFMKqh1W+w+JoM5DdEfSQZKS/yte3y6PePsdj+9PUHpIPfChbE6wPtPvG+un1IiuNJdM3geUctCNdP2yyal7mm92G59icXPMMjj4zfTUNa5tCXtyT9hYFpYRY+at6dSBuPniDchYCkuQ8RZNzO6g9BI3IkV/vOgrd/CXkphEaC4cD4H83q8RjsLP4aKR9FCOTXjUscnHs6V7w9K3F1jkMF3/jCE+z/UlHkKsDNKLjglzCW7XJbTrMvXsrD4ROjXNtcFfqdDnB9AZNaGdxK1KJVhZ3GlY0BFG/bj8ostv9JF5wb9bIJhROWEf2nvTH8Lx1w7viuY8Uz32keO4jxXMfKZ77KI56Er1JLevqGH5uNW9pTpVfx//mRh8h+v5Bz9xrX4cyZyGH9/kiG6JOde9iSq3TJKgEKuJXzUk8DxM7XRA+TFAyicNkqG9DNZeIVHOJiIzm29BfR/2+5a3+eIPMhGJ9n5X1ZZmJ1azzGQxw56x2XBIZyVOJ3lHDOVCAJlpgeB3wYoA2gk0qjODUKYRdqVOJE/QxPY/5tPjgmDxKmDxJmDxIGOH9uOBAd8AOetfF72XeNFy/Lo4wqeiomupLaUdcy17sdTEvGi+A/rd4RNfPFaWc1FNuzNzDTMqgJtECJQgYbytjidmJhCRPsZYo6uMEJ3DPRcZCryXiaLQ66Nli0VjMr7J6lksxUefCztc1Dsz1Ornd3MC40b3EoJUi5ywsWkNke7oRVFeU2kcEUPWPEruDCcwoxdOuFkeMdAB1QqyGXJ6SXH5pLm03LpeEyw/JpXub46gnq+GbI9gd+mW9KuaKfa05Lq7FQuxuHQ/rhyUHVPOoS+nSry8f1cmG+kGVcnhYU1nBNJKw6VJvRyqBOdi2O6LE1MR4WCTuUeRXqaQ5MtpcMsCRYhVoNysE2B6uRr4Iu62P8c+V5CLpn0nAIylc0unBZXIUl75bDrhuE992dRpp/9XlE+Ib7oMW+zFXStkepkft53RXhGthv2THq6ReohpPdnR504nKJ6BPquaePWbdDYzYIAaOJ5B1l/vUvWLLIdaskC03yovUyWhn+uifkAOYy3QEjnDP1Mp/amCdEIVX79+/GQ/gumT2dFwPmtM+KlJsuqhoWCdFPw4mqJ9camljenVstFMWPNetrG9hnIwY6mhhTTcM/Zz907w/Mvwryfl0EvzHM9rGCI2oYYwkgRkjttWNOGh227V+DHLRWkHtZo1scyRCHfu+s2iCMiCZbHgyugwoyB1pPPruSNBf7rNZHK1uT9jfODW6LOJzGpSLltnJlgjsnW1F/AjgaLLUm2Z97CY0nbt1YELOyeiMquyCDcK7dM/KfBQmi5qZbN7BpaWlpFk14OSRfSL4MTO/2wPvYIHLe6/y2e26EEs5/2VWQaTKB8QeTGv54N6wFmIl//5jVq53RM3GrZfVdRMQ/KrvXBcNNZpamWbaSPK3yoThoj8w6OoFxg32NBYbx05YtJc6nO4jhJYPDAM+MGz7wPQK2eRRvKuNgRpK0UkdOpJdh/dk13nx/ghdLkvjGIEjgf7vbVY+6GNMloeJd4Kg75zVPoRYEhuHUFhJVpx5toyytC6otU1s4b9ZIBv/Lt/UCZ7jJJkYe6Ak/mQydMMYHysovl3LRuzXAj0y4UP8/tlylxl8nEcMOLA2s7LK/nOA7ZBYuikzZbYUb3Yv+5aqBOCPV+/Uy0OS8525RhCFBN0Cnntl4RKPdmuxnbDF4ehJ8KFCxkYkJYGxNhLsDyw7pxh4oBA4Q6Y5HpY1DhwLfh2pIYJkgFRWL5AdB+dJV1LZRG8ZU/K9SmOMRz1t8RfN1p65VKId8PpiXL7sp0wWCwtDwpngYc4wOmXGVqfMsNQeu3wCTI6y+q1DrUyo3SgTZlJLWNK1dv08oRPLi5It1JnknmPS3cJoMlZe1HYj82L/b7456DqvD0jcdfs5unWpVkwgSLunhMZe9S16lI3Ib3d1llWrSLj6Xl0waBighOLYpF/DQYUjYgL0hIBsY2JzDkIeKiuDcLdGdkWwivqCxwB1nwOP4qUamCQiy7S4PP64LG7k8uty6STgEgocpz2TRHTYWao81Yd7sV3n+qv8lmWLbJc7Vb04XU28cz61uMqrL/nm7XqRfZN/7A6a9iO6XdfRvVEkTuWdX9zocLpKeNRGjPw3JIAnZ7Z1MWJGBUlgkRGvdEQrKgicVKmVtk7gmpDObVkQPp9YnwqOR2tUDmNtTNxn+1e9Ln7Zvxuom52a+Yz7Z9xzqDa+H+5hrI2J+8/5t1YGFZiHC88xWCe42YyIBk4jl3gxgCY+BP96dSC+iY5ofwyeoYGmtkzV4iQdjftTTK/kdzmGnNz174VVvtWcKwYex5QHcfNItfvl4XRC1Imp7WImswFyEhgtEQKYuJqybyM5BNmULIApklq5IYmj+TEirn6MiJw4Eyie2qHARmzaBeFuZClo5Vm9KcqTDb485hvV4knQQQfUszOpV7MjvTh21IF21YweI1w91CTgI0qBE3JjioLi+9m/sruE4sS8tluKpYZXSrc+CQb71NaUUOTT6StBgOfWbsur18fuB+DKknUy3/BzNq1CClnDzaXZw6WXjMsjlZOkdyFFC2qXcgjwN0GwbNxOH8pcyM9s2dKl9kqWenAfAD/Q6qzF19HpUPnnh/6C9lGMZIuPetxxpEBz2rIUc7PDdRyWg9cz9wP71Fektns3hvsOkNRhZbt9u+k5nZiZzSgd8SxpYa0nrO/y27ul+K8+/AvkizIGjWK72KRj54GzonlpRlA9K0N2oV3sqLP7+RkZA4N6spcrk9+YyR+KMTJWUG8Pt/1mrjJjd3ev/m7/fX3V+nOwKIhzpFo5FKb9gBG4SxixAndBeU4TZCe1MqiwO0GxXUsBsUkhasfuHBkcxJnCkTh1pSSZYEGFzNtlbLSCimu5UDvatGJZlMJkuHpY17Nv/857NyhYFre3cHfU1sjT8pX65dxFPvnanDyar5Scpz9H/3cCWibiMimETOaUMEnLzBLWzwCA2M9ud0UL6jM2VUPZLjtV5VP3hPlGt0ICdvGjAWMXx2ZvjZiHtYf7MbFbuvnhzlFuKbG3b8zh3Rt3zFDij9AQbGiGkkS2NNiZdG+xNOqnzLz4tK2ayh2gK0F1GG0Kc5qO2M0eL/8ekoraIhiA06ztCW03Z2wV5wRVH8e5X/0/skpzaOoTFmvWxw4Cpw59HrlbP4qjZGJCIHuGM7mLMFkIzJLRNPp9AOA3CUSTCmNXK/3JvLmaPdxkl8Xm4bq4Xm2GCYXub3BCKFoTnpbTBugF79X2OiY+maudfTbOGmnEzunEynWkL4PJXsaMorHKdRrA/SY+v+4EX6nS0H8YUFQ4rMt880kXLGQDmkk2L/zxy+0JCTiMtuEfxZHZcywo25Ygv55MVoeaMwLZtRb+9frY+r+zBXZADffUwcZSPJZJu0N4+ft6kX0Wzy+OcC8A2BPfmu37UHopK3HcrODgvLZTExstaeg5ImHxwgBcrhDqkcUUgCjEDWMFfZslAlyblHdtSSM2/qlx9TF5eqnIHpPkB0xWLTH5jZms5xAmf8807HfF7bvsXrs0xb/f5NlyAYbBZGXmv6pirRqz1AthFKsah9m64W+9Ll41ZK+H2ofjO4uy2Bz/nX3L5rNhvS2rbL346LKrzUGDeCNOTeKNoPInmJ1NhIhP52FQmFKbeCMGhYky2rG2jWpSzSnpUPKrMRk4ZHHPkucXVztwAZKyB97eUzoE4zqH4tB8O68uc2fXbXPQNBtY0GYDBfpLIB+7IQEwzwhgNzDYbog7502M708a2Gs7IuP32h4N0errzubSpjgBbcesNsYJMTFOgiJzSYhXUWfkw2QBQFwvjw1xEnfkU0INhe2kMB5PDOPyHcr65fKrgASEaWC8HebiZvkLC73BG7RfY9SzszyDHT0Ykyl0AxqY6ElHQ/MxzEbA82/CXCjdcD4ebqFZUZu10RxWq/jIC8292+/o9QHQnHRUP5IJojlm46JZoWwQmOez5fLDeg6mThpj7U2ZmF03GQo89wCs00r7eR/18gAdCdMpoHhgpZasIOC8Z6XWi5fVw3r+Zg11123w9mHd9Mcehuw7AaKPy231PyC2zdF2nRUz0Z2kTzB70qsK0U4HduSLoTjpSISIp7dDJ6MVlhwQNgjGi3L29ZfiG4Th9lDbAuRGV2R0zuOn6OWwCNkS7OMmRxzODoudjdudG7T2G05pf5a5AjwZLTi0mn17J556l61vNXthg7tBsBbrJb0YH8vsPs++vhE425ZwW+STM9vubE6NXTssKivWjyYBqhy3yqH02tjknXHw3croeCwJINIGwVwvyvXsZpm5O5MdDxtFHOy5iONEEQfr1KgVubdwxqYVnOHSpcNlTjPncc/gzJsDttydjqvlVtXf/aOFxREgv6rceF/Buzc1s9nDIllD2CubHdlNLzBkUdrBSMrhJgBdiQin6OUbTeveIWwYhKuz3avOliCOgQlt/TuNjNKjwDoYxdSzOjv2Slu3UnabBbIVcJxMIG19KEfHeEakQsD17PY2W1w9VHU2KBN9j25n03hjzNigMTWyRZKgMJ16Yjq1fdexVySmWSF7j05cnBsnSDceY5umF3QIrqUOpn4rLoOqXGbfcFllyAEacDoE8K/y8u3n34r69be80l/5a5nX2RsJb51Ocl1sVMLWm2K5yMrq7Vo80gz9Jr5ZtgAG5OOHG2W2Ku6z1xK54s6wA+OQ3/JHXt+9/pbNt26GG/fMtg8Sm9w2SVgNWVg/Rn0E0TxZ9qxeHYDlCXV0sBOm838mFSZCIzISAHAbivV/5vWv25u3VbXNfi+XLlZlaJLRcyg2W91FaVjElsCJAlm4sRXbpwCJTWKTW+oVst02rGvPofic44nZuNJvqhqI87RvAqJCl9u6tVCoTpJiu1z8n2L7Lv+SXReXCj0vf8u+qjmDJEN3CXOm4trDbfUqSbipXgVOxI+8gk5p4sPnJJYH1q0I78hBw6bG2cFlPTeX6ZlcfkeepD3LXH89IEx+GvWPV/lMFnQDfB7tyRtjcn8hqD58XX8si01W1g+wHAAzjPzF1FB9wirziL1SZCIPqn27+a9eGzt38Qk48tOxtJ42wgbBOa8ut2UpfrZf8vXbtQTCMlv8c1nciH88OJLPv/tAu717Yvo94yRwPZ945Rp46fl6dWw9H8UdKzBI9AiB2qF6/mihq5OoGygAb2VtUz0TH6p0paSbE9oAR2ZnuKAyEZAfS41dsRcBnVMseDvIiiPSEd7xBL36CRkP3kcYGwzn3zard/nnbP4wX2a/FsUXF6od8wyt3YpaBbV7p16qSuqVzIvsztXw7k3jKZRgD0V3NCa6TawNBvlRldB3y4iAPZuY9JFx6C1HvJyPQMvDxFLB9eIAmzbrCuvHaMMwVAvvyYb6wumGGYZkocWv8iqT3hoYyfYEo97T1D5Q/GxL7mo9Qe2DJMHbkgkbb3M+AtjAXVn1A/1X9VasXC1R49CnXdPauKbmDo3CKmPux/0IFHhSK1VGr42dW4CCx3U6okptwWwQumWvc5C+9HDfzFA38RtW39l++AUyG1M7OYY7ktNDx6/Q40cLbUpgDULsarb5dwaXJLeH2gYfMnNyMXp6Bl/koRgD3ZIRmJGbhO+bZqMZew20hiJXN9JQXTZcCAamGOUSSdDlEkDzJK96CRR5cf9wMMEk7dxXcnpg5mxEMB+jbCCov8FABgvcODVDhGHVtwH1x2DUhPerP9bLY9cfu1Rg4g6bTLD+WCyK0CSiEQvcZHaUbEI/2/fPFjd/eRgI6Ieb7O1aZqA4nMzgDJPx0IA5DSsJ0E/dQH4O5ogCdIcOtsMnUBXB0vH26WOgDUL1uvgKQflw22CpJRZLLQqc7iTx6lHhR7aml8fep5OuVT2PkNQ0NL0vkpl9MmMc4KntydEsUCY/kVgn8YFmq41i22w4mteLrFR/DUG3+PIg79rR/XacJDKJIkhYOrSfexnoLgTuz5YWrdcHCJVET8CVgcfaniW6BsFW0dK+/ONKkpf/VX0SH0ZIiGp1XZ5oPO39lFGXEIddl8B7mo2QCyS26xLiTnUJ7kYUyc9CvKvtaDwaFdv3gTdcGnaN3p3ANyYYzXUN8xLpjORwCDRtkINt4yxi5DOoaVxke6gZbGDG1FXpFp3I7fhpJqYL6jJUylM6loHZwptOthY3Wv1y96PDgF/fwXjf3zd82QkySg6C2sqhFtJQFIYCZISRV3PEZoVslzZJp1HROVBJl6nGXNYY8TgdS0mXaLsuPhZV/k1+smUhHq5UGVqxls1SPpbZZ2hI3x6E/3wO+lmO7hsecFN7xyxwygmvYA4Cis84QBkEQj/tSq8ywQJ9moymyghoDcOs7I+u+6n/MSvX+fq2cnS5dUx7UumojxlVHy0ZNdaBsimp5qMRTgA4GwrvajUTh0F96+B3A2cYTkSrBWgUlA+xJ5s9BpKdUsCHCDcAdfoQkbtGGE2NylBmHfOYjKWIy2S+Y7TpT9a+9yobRnevm1lJrom3a0dvQ3hKuzaemmmr5Hkj38kTBdNWeRR+CSQbmcvwSiFNls7In2oQrLP6Ur6h7BUKN5qyxtuAtjSTsACtqJE9POVJT085gbUTxqcQsB+acDKaun2MskFwrgstGtXJ2kbnrBa0U6tcPQ3KWYjTfjSdGGpEaxUZpHDBOmITyAoc6D2RuRhcOqE4JWN5T2zIqYjn7q5OVJEfrKGxWm2XdS4Wqxm/Lg5bvnp6mPq+Xed/wz701kh7p2emOJCgvCoY+5HnYy+WOGSrLwwUCP4UUlbS0WJEGl+DwHsvCxzECmj9vjFqhfzI/ptVsS3hrifeTxmUJSgxbNSwfImxn5FqJyQCiS4I26wlCEynJbhrzeRj9Izwo+9xOV8keTSXehqXFgjnqCd7j4bafzX8xDfTTJ9i0n+/i0hlRr5wFvkcPyhf8PsQ7yl3X2fVCpKpo/uGZyelpmcnKKsAMy+psfMbAZJc2yZolgfoYc67UpxP7qhgcc9Sthea1kTiVZFXfcpu86ouH/oXHq/yW/ErZArBl+/eQgA+3G672yNmUuJGYbVZYX6UuJT4JQrYZRR6hewAKnYkxKDY7XefnsIjg7o9YSwgNQ5k3+t/Q7BtD7WNVkTaCgs954H1uLI9MjH2Yp5KgfinpaY3C2QbrikjXXNcEm0XT8h2RZHsLiGusbomPQk4G4BdZfV2o5WQf+xRtyOEONwZB+/awH29vhWfzrFdw1PM3Je43VcWo9A278jO3mXQ7p3Edp4XhrpORDGQAAM3Sxa3XQ3BuVMMeBRNjXxTgJ8qEUjVlakr76nCa8TtFXcDhm0pMQah5ixZmQtN/X8bks6hsvKHQzl3zGkr6ihJjUIOdB4UJycBUt1jsA9zmnh1aImsojuxSBTW1xl3aDvY3RuRTFBWkNwgxDVRV6qufclqj2H3PqvvikVlioVEo1to5OjjSM2fanGqP/+8eHXzcbtcXlR/iwUpVUdnMQCGv6AZbRHCOGamCPGgOFsI0BVml2XQliG7KwxNfKqud4tkO4oi6so7w+58BsWo/sjmQrNQfvLDRgvwVgLdtYDS1X/eXSngvV10CorBeG8UtVfZvRPp8JR21SoivF0kkvDAoI5SDpgXCcz8ye0TI06gMwMndhM7/YWgNnbOfrpuktsfZCJ3w/xodVLzZTYrJR3Xpn67lrQDXSpFYMD/+eddttxkpfz3fLaRHR+v6kUB5+1AE9pGtVUblYZV7Wrv76lXV3TInWkl06eO2iiGgvdmCpSnff1Ax6Aax0J2wLsQn1e3rLuWwyDC4Tnt+G5kkBLg0Pb2KPVrVZFYwS4CpGQSK9rVrJCdOu/sA0ZOtCdSUvPISZndNnSl/rPRyqMWWTUv85vs/awudWFI9SXfjLixb47iXO4U5Na4gfjYbM3CgwruQr1ZoI09jfuQmDfLY8PdpbL/2JSGQaWAAudEoT3uh/YmqqsyML9BIdplMVu8yb/JI6AJ0A7D/Wf9WrLDei5+ivXt2eLm7GuTyn+2Kta3xeJGZnNuN440zv2AwQgdhc0IzfsReSAoCT+2KaEjmOcg/flJbgPxL5MaxBWNtdsrhKnPs642QocfC+9Vli3OPgvj4Exv52f6q+n71d/LvM7O/qrOVGL02ay83dWmqAnnf0GisL9vpPowszg8rFRmwrxEwTJqm1yd74gCcuS3kZh2bNSF0XlsO3D+6iANctsti+UyK0fU9Dkdj5YpX/9Y+PfFPDZiZZHWSp9ac3Yvrkibxkmvjl1ZOEZBys+HOw4V7tKKqM4W2UZAQwLvrHlxIQfF+lgSjua4hMKeYvTGNh0/mD7Lx6EvNuj4cXGFBCYf8ZOXj+eT4vmk8JGEJFRJqIVdUK1akK8dkK+fIT8dyNc/HfIkXMg/w/0Z7l3hnk4S7hrRC9Qg+nz+HU9/e0I7gkvN9h5pWL4d1LOWF2BeYFZ6jl4d283JcSjUC243f08KnRev1/djR23LzdyZfmOMtXdmwnibNgSTcxJUmmaa2gBmUJqmldFMGeCp1/QJrf25WSM7oZm7enukzoqU8whPLdlmtP5KZbZZzmRpYVNZPnC37h5xosTUMygOfCuG3OzIizreSjbWqwOkjTkKapMfWVA7dC+OxgNxVRdlttuju8L3JgeJsw+3Dc4m3OaTJOdJWJoxkP8FJsYwOzEG4ALBsc3chBFM3ZR0pVMlzck2MQ05+vkGofyxZutFdfHq5lL/E8KwOWgoEsRMeAmLzYABNl7kUxtIIx/OPbE+oEc7cZUG0nDagyEc9UxSP2BqHIX4CMivymIDo/hopJ2vkpC2KhzrYHJAhGO2/kAiHwUCYQjEliYcJ47mSc5mBe5Si0nCGPeGsQTV6Bh+/S2bb+E6bXOwjWQWcQPJQRVqI2pXUhDsY9IhyCthFw2JBQLL7gQEXEB278f4nE4NyAj1BnIDq9GxLKviYCAfjRgVpNTwG8sK0qCATLANZAqSQGJipxECnAOxTebbrJJdQsqRw4OMnZYdSrXqMq1dOekNZgmtR0BydedCcgV2zWCxUQrNznFYzBmpnQsbQ+ngdhUnlALIrPoHpqvfbBAj5NCPiZttnUxvQ+5r5DWgGh3DV44IXmukbeClieEoPqdhNa6L7MaMGPlksaZeCd04dcTxmMNTwU6oxsp7N6lqNc57I1hCamQENyXFJ7wV4AyDXzqmhvMtDisFD9n2HobI5CzdIuUAopFNMB2DWjJjtLO1l5wjPjktuS8RVxtbjwPtV9lmWTycLKc/mtA2/3QZ1bH5R8NiTgdI5oiXM077o78bCmlWCHBkuFoCoBN9dBmenLqBhiFbY+uxgH3/PZIIyBaMDfVD2IIoKAczSVI/KhRE7TKa2IN+TqyRwxJkrlyi+FTLojieHKyjobC+fyRM558/nwL1Ydgg+ImMbtAC1WF1AiCJzQIdE9DDYaGaM5/+uFL1ZLCDgztIbWNyCtbkH5PqWCRAIGmxMECLhTuBW4AMqBa+zepP2aq4zxa6b+jHWSnAKb7Dr/m6fjEG+D9lVXaK9+d4vN0XGkWmnhJWkTxKAT0l9nGLoNgr4NKsEOCnTjuHv9NzRidnVLJhG7qC1uNs6eKli+V9dhrXRzPayE6ZwWYVmgbObO5DQnxMSxQzD12lWSAb2LGr5hclJ9wlaHqqCh+MbAmux8H2VT2rt9UJaLcmtJDNE9QOLfKwSD1xDLQughqd48QmgYb8gCayxQKBCUuYpA5mBxyf8GSnfFrpojiKhwFbQ2scXNcPG7hD6PGA0T4CcRO/gTFqEjukmIDdhuwe5hj5kK7t1gjoDxrzrptziqancCNpdIkr7qlwf9rMFWGz2KM3Ar3qA/9eZeWb2Txf32ou51HwrZsSzfKzavY5q0FnoDlo1JjjyIjZJEGBndphR+TFwZPEXv2d9frYIZsk6crXj9h5gqeGc5mSiYSpMRYRzyx/eZs1zZ7lVxIDl3fZ/MumkLakmL4QhuW8fqmnvegP+eG8mpggZOaj/j/23ry5cSPJG/4qDm888ewTsZQIgKf/U1NSt2xdFtnund13QgESRRItEEDj0GGHv/tbmVUAcRQkkGLbSMxMjNVEAQTzV5WVlZWVBynWHymiWlR+1SVfvs5IVVOu7I+qKVm/X6Wl9KtTazYwt+ZAb05uTcnSQMYVB++EJ641q9Jcqh8r+KoOirnVaO0vy1q4sW9utbI3iegdxelOb8e0scPvsLN8r1AfYHa1gbZ3dkH+tEL/VnHeeyQ48pbQ+fmXlayufCSvrvfHxWpvtBSYfq9etawSo/d6dc4xZf+UM6eNdy33pguPtINy+uB48C5O15HTdVTWofiMhl6S/C+WlNDLboGDejMgz3dppYgvgZ1pni4CG5KGK29eeosH4OWqKooF1oYXPCneXm5PXvyemReHvE8mnuMF6hWmfD+vOY2LS4s+Jp6sodbSonKJKSXf19XzbUi+MrWm9XFW9TFTc39wqOLUYRR47upjwBjOAnF5x6ztxQcnfg+78w7k+hrUIZ2bITuDFLZKtn/luYLpvq8VTfe0arMryhYpgye0bikmc6iIyTR6ZeN9X1Mb742KzYNRuXvoDY/G/aYtPANcZgY4IQY4IQZYuWgwxL+jPReeabzgPxFe8f/4MCuWDd8MQpat0bv0AIZg3Ynp8o23y/fXMy9h4+3dPGND+4pFp3O+nqQrkB+wKLKXL7eB92hbLHjPpAMbl3qaZe8U1pVCMSP9aEQrQtTYU5dTzapR2Rg1VtcxGlZNqmrfHRElc9ApNTwevmtKaai/aTixNJxYGk4sDSeWhhNLK0+s4fvqYF97IhXFOX+dlbYKn/qLlesF7IvMcw7Fgc8dc5U+JI8rrhmzwnOPz8biHTx7PnMfr0GF5P1l8on8WHrqlD1WPyPCBos/cUCjwzJBpJyrpbuFo5LusKAI0vLOqJlNo3xKMqjlliS6R3FIotHXBYc4T4c4T4f7Vno9e/ZZYENfm05uat0G7NFmT7m2MzNwXk5wfdy2H3AmwGool8jfWADfn5pLpXfHq0/mz8J7RnGC0PLdM2pNkPJJuGI965Z8l0TvKM7Bq2qUVft3NNDArI0PlbVDzW/vUM7Wpms57OzRdGJYgPi7HS9ULgCvPllYDEqGuO6Q+GIwqJVaqVerCGV3rDxN0Yf67rmVRk2LwNWGB6tBKTjus8swytycO2waMf89hmYbUvJgWZDpN2WAueqBfByY2DFn48A0YulJy5GNmlErXKbbr7M1kT1UDgTrGrtWJ9P0Iywm8p1rFO+UAa+PduY+2pn7uE/pG3uWKL7YMhvfVTiwSYgdlYU4x5Witk3+m7/GjHcBYoCzGIs/dubChLHeM1lCWQ4Z+Fo5WRQP5Hfx/VLZAlIHj+P9MvkOa7mT9NVFC4xd9+89YXJvlsJzsDSROR57BzM7dhilBydK/Ub5RCEz9bDoJtIjVX911K2Xf69cp6+mn4jooDJTa8Mdo9pHjVTjD5Y3Ms9r72Br13tS8fK2uaCY90dFxZyUQ7bR3dNK06+TW112T1kxH/R2LDQ5ap6Vpof2mR7aUXsHO7HjjAZE8a7iNJkbH08bEE3AXIsFeLU/e/sB13S2ZxwVKdcVjxQiJ0eFcGBieojC9qIsr1rS2BXH1P1yKLDonrJfiN7dUWr39COtcblIhgczvhRY7XB8HdZgbLWlZaCPiy5PpPwvBjWPyUqmlr5eS6KL/imxdq+7+zHZWG+aSNfRY9vADamh7Wl4T+gCTpsip03g7o9vsn8ojoll2wZ8AW/mX/etuJqZF+f8ueoZkb2bz5tWqiA80ojrNqNauo1eJ6XwSG2U0auMMs2rIPyKaoMHwr3RoSIXtnyWsjhenQfeZusJaIXvZfSt/YdZYpdbyfWVj+bdkQbFKdCn7uit18pIXMvRW/SOwhGpu6N2/xeZXHYyS3ZHB9Vyyvz2XmbPTJxKLi8/U0hVVazYQSwF22DPOAajXpqqiixVo53jGAbjxgWnoY+B0TuoiM+wWyroDybfec9G516Qvu+aM7qa8V95slAYflA8VqVVfKnfrbWNLWW0Mob1CsMP1OENPW3X+Ex9KOxijZoCQ3R+G+6b+GfFohyH3cSROhyh+OA7ZkGAuYSkV12VVl/1UN70rpWKQtKyvO8n+RVmy0FJrxF9Uw7ObIBm/+7IzPHhKjUVuOwdbB2abzK1+pFCvL1Buqb7d2XpgaEOtafP0kP9UCxd4LH3MPSOJXrHpaivMS3/rn6tYySjThXTsn/XWB32pVflQ+m9ss9sXmpv42D8K9y6GCT8ziZH3peFo9ifeIuHwDMX68pCkMUn8gr2sFu0pg9I8bWipNOwjmdXT69jP5HdUzam68MdGXv8t6U/qawJOUQr+lA71AYzz214RsrM4NR7creN7+T2q+n018tKTs/eLXD5sOgEMCTlwaio91TLUN4f1nFflN1T5vJeb/fae33j7zkzqmRzAzeRBhrMjdGhvABgywjsJkKrkONSFsyyvmh4L9t77sqrZvvM3YITQL/kBEAqAKOnSG+l15HuRr9O/QbZP2XziWbsnB3i8Llj38n2PXTX7aG7bs84WLh6ynDCJxft5el1yvTY8F6mfwnVDuulu3mmH4+7BaYfk5L1w249/4AS0/dHtfwDxupQjN54V5VmcDRumEajo5DXRwfVaJDTctyNDe/k7lsvjFZBhSVF8UAxeduAdPK2oV5TsJfz/ijygvcHiuxtA3X2tp03pH9b9Gkll/eRy2G287/jg0r2hOmy7J5tC2IX4y7StnfMAt92XRYo+T93q6DJFxKHk9Pk67m89Ms+L4qY0rJwH47Uwr1XYUYcV/o19htoSOwezDYuOGAqGO0dXAwwOjJcw11xOqRZR511+Y2H81F3w6LBkVZpV4VjS69OMUGFEtMr2RtF55TYfPxXp5niu78o8ByHBYdzazH6h2LyjWm77+VtEZB6a7r2opKly8/kOHmgjQqcTEpX0Qd7BmBodVxYROeUXVj6bWDl3rghrBy79vPUWzyo6/CU7hZT4mvFox9SDudGr1Zov1HaUHZ6qgg4XZEPX13Roa/vmMnCaGIInD44YCYLwWbgVZvktJgEjHdAZPPf34vBIVNMktPiN/h8cVOdyiL/QN7TcFRIZ9SjVr/YKG8qdZXKoWnlnOCGgtO75bzJI3VOIygouXNC/O73YPZypP+OJV/BXqhjGjLMacD/9vcM9f+U5TisqqaKsMjx5Y8pB2UbHGa6l2wZeY8sgLa6s8TlPfs17Gw8yGPme50nL3gwA8h01vGdmOvfxxw6ez76qsqJsb2R12WG4/wsGRwNaOXCUJSM0FX6jNbT6qQ1Ks0R2UPlOTKozLk8rEydPxiI4+j8HPn6d8Yg6WCB0qFz9J6+ZwDSbWCHG/MWmVDtjiieOLUDmalSXO/m9PINLDWc1U23I/wOvABXDNFx4bEVV+ceL9wrhFz0SYdc6PXy3mml2NKOplol+uWgi7466ELbMehCb6A6ZOjGwaIuMJurZLSDcfU66EBotlIHyt0qWFuGtK0tWi1rS528LYNe2doybIS15Xtw88HyW9guHzM3mnmfgpm9gwv5W/zsxhsWqI0v+Vt5Gd0bF2U0KTVF12vxs15zz1qur9lT+nVplQm6KW1ZDV07qIwGClc7mMnfYmlgS+W5z7a96MdSjALSaUUBlUP+xyoLzKjIzYpMu5rKjUUdBaTt7r7VRGbWD8rMU85F7+Zkx1sdc9Ij3lHqIlXZW3k/8mHJmEgrL8ug1vmlUdI0OrpKeS6d3I/V6bT0nr7jwX2v27ywfQNWHc3oH6zgIN8ZnmDK9EtvBRIa6uXY0TrXdgheZ498cJXlDDI38i4qeslFRSN17DPW6rmoDAd1zCSlk3rZP2UPlaqDn+ry3mojyd/M6VgcxBj09wzd5Lx79pjUyCw6qgS26XC+OgO8FrNOoiiw53F0ANMI8PrSXJiWUj/J3clrKKNSUqIhKeN5f1TrjKjfr2c5L9lEZAeVHVP6jSin2T/uv4/bB8jtQ/w7wr8o6YdlSd/fT9JbbB6jm/m3NO+trH7zZAZYvoalJQEOMAP45UvFFMjcys2B4aCY+XZIyyzYrRXdqfVqyHutNAFE75Q3nGONvhGlrx3WLWvCLz3nkPqL6BolQ2fvFNKeD0bFtOfECv0pVBhlUn9tUDZ1K23d43Lm84HSf2VUlf72rz4QfWepMwO27vwvajNY+8/oo6xHJ1yjv2+ps59Dzz1HTJFQ288DcwWDAp9nvAe2Nyv2sXx2iGe2h6Zpk3znhgUrlrz4MMoR/6/jcKVfGZhRvJnPVaeVlgdSs0mvV5FZH9bSkMpWnF2z1dE6NeqNDmrE4Zx+CYx2KJ5eqR3Rc3cK21u9mBddI3VgNNJrmSSHJZNkp1/LjiM7SLG/7bdA4dnTJPljRqXZq27Xa2wc2u6D2qqethdYeGgUg4h0WmeeZf1GOt0WC7kqjvKHKqlcrmcsOqnMxoNRE9L7v3ff2sddKsSk8L8a/tXxr7HfvvVHqbpPOc8BXRPTj+LAdldJA9Rz9DPXE95VHu+h9BvntsNRJk98j4liL45Ni9OlFvn5W4Uz1YLjS1/U/qUzYRTJMjSV1B+VpH5PkW5UH5dPVStcX0Seup18v4yR8EQ46HwZHY/edxaFuj+GmRo62nkwIbWBCakNA2eQgTPIKM+gUa0ZdC4sLD9WbY5PBIOKegPROvCepqZrR5wptwVcQ9mSNqT7aiiPDBX0Iphid2zFntGEFJh+8rvyMvMzcDnjNIfm4iCeOnIO+r5y/qXN+bmnD/TC3CNWg2zQq7lY9cpVyBQHCqX9g+whxdzT+k1Yqt57oKDjFlzf90DhxPcVU4qzoqgjdhieDpjIE99x7I0dVaR+VD2SN6SOiokfhwPiqcaU8SZGPd+dEqeL/lGYUvtt8N1RJPytt7e4k5x1CYz1zvrAVWwesuCRBcdrZlpMXTM7f6uQ/VEvHgn3B8T3zMoykkO93ilZr5wDUh+ok0BWqE+V2tOwgcElhoH2U8zHZGA+JkORj6n3DrNQbgpg7YJPgh0RW9bdWHUPPINU7ZVv/WJH61O2NGPnANZVObU2tmU57MkM2PHCsTlXdSLmsA2L1OdxFc/kDzJGBVcMQxTLIBTZpdCdxsqDjHIVv7Fq5pUDykdqd4xxlTsGscAuo4fnGFgRzcCKaIaiIlqv7kLDOf4sQRdWnVBMkDdnCWuKSZPOKuXdm2AGO5oPpnXH+EQJ8XCD3/3IIjgx4b/s859gh5ps4h91Cp7MnXycZL9QkqFHrSRDb1DPs0nTe+V6yIqtSGkyyS5S1GXoGTtvRRq4jOGWv4dbfsyyZigCwepNpSmyGRDzyXM9eVW18888IoLCUMk72JyIAnNhu+DX6jgMbAFqz9b8zaLPX5+0z58qLZUq7GAwrLXMlEPlZQ8pTkWMJrhBvXfvou0ZG/bjTPDeJOGuw+9cEu4W8cZBdYi8krONbq943Ecr/fd4WG/rMhrXO+8rHZTIHipx9nDQbYLj9jvrDmIohbCk8b97lpJNuFwExqMQn/qmO114PvtRVQb8lm817JDvOx4OJ91tZdZ721J7tRoD2l6tw1rJwftlcT6sl/lEdJDCq3W8Y+TNoIkmVw336NrhigyC3g+TgMnqU7jr5lPgwjoYf3t+ZbX7/K28fC8V0jRoHYUbe5ZZ69ap7iB6p+zjp+9aULaJKsvBUlS5AAHiEoCjb/zdyty/xdYhf6c6VaapztEw7hfPy2iVhtX18imC0VemiK3p3NEtBwGLTlJkahhVFRB8pXBJE60+XVRYumhx7aI074723apyTuMKyfMLuHjwEQM1PeFyqcng7dciduChXziBaNWxN+zC9ePDRcwncwVzEmLet8qMhdm7hYKDBUVfOzJIzRuFi4fq8K03qndEMSiXHFTr+YbRiNO38oTZJWGh0UXTjoamHQ1NO9q+pp1TO+R0mnNHaDwBnxyPtqU077js6cL6yFzGe95LjDszTn7hm8Ubh5sx+DrlbMneyZ9SG8WsnkP932k9U0uSoU7rOert6M39PeoGvVdn6vYOVqIwdi9cEa0Ma8O7GVpk+8RIOGW0cuZG3nI5Kqa0Au8u0ul/lL5FWr2UViXHPtE/ZeNOKzJa9YaHK+8G8lLY5eGc+LP74HpP9dk6xNzgHWgPO44HJ2LSuwgOxBwzrUxeWYTz1Sfzmk6/FLLcI2XcURQHUmo6vXo8Xzbu9NUhy0bVvvevtdW/z6JpjLl8MyAjI9+3HKqEhJr5BOe5K4fBpeBYVz5w53nRQWZHjWnx1nwY9EqVEDXiIfzKyhJ6vcws5doSA3XOrJ6m0zd29sChttfVD2XqLDAckh94/MfCMzfawd+0iufBjdQBF4Y0gAJ/5042q+bAq08WloZxscgKLUc9hYeDyu7fq+eBWlaHZAeVl4bxqAmb4PdOhT5MhcGejtZqNlPsemPX5mo8+NAdbjZcuFdsw/vqzcnw2oP5kwEsk5rPAkBqZ9Dt1ysnp3XLm4NBLZOQ7KLy7mCsN8OK+j5VqQeG0x5Yj3vdPattpex2LelNrmcBy12/MWcONk8WZsim2Ov2I+95paeP8pHCqVlx12wYxHfNtU7NFCWKhkb50Ey5ZR7tWlpU04/6zdox9w5n/xGDD1x/zdlu5v3CXq5M39/BtFnF6oDr82tnAJ+rjgB6pVTQPVqpoEf7GTY1RR6jYbkEhjoXtKaN//6w/rKc38H4b0D4kDEewJ/hwXbE/CuC+56jOGC3ZoR10ZFPLdwOv5fPpcXTDfnrZy++Mm9d6W6hpEUxI+mAVn2u3p78Plbw+7hczkJTV7PYNW+dPhA+JY0S5AfL5b9lsfoc/c2RY8SCjjDo27xjVmvIEJ1mi05Td3F4r+Xv2t7Ob2W13jjvCKFRK4JuKLzYlJ4QWik5o9FV5Pcflc90tZ46pFIfDbs7bmi7R7gH/s772V0OdXVMcqEPDpZ0dxl4mw9cOx70PgdO6seGccQXgoG/1xzYJX2d1u8Ni0Yc6p4MmupQqzeotW9VeG+KHlIY+ActyDWtYz4XfXAwk2bk5Zhe4PouXC+qb1VJ/NLdvPY+7g0K4VkjWpvSQdl4qStd9csKfL+Oa4LsIUURO2Ow43GudtQbNUqJ13QdS9dhsghdkSzCeM8+9cpbPExEan+E+NetA5LnKyeDUvHpFsS/Rkr8K2J+jVqFBrRahdJF9yg0nn4LXBr0w9Us9bHwXJapw4NxtQ9FIRmk+/qd5S5UnK64nzdGjsf9gqGeVrbefr9mYUZFEnZdFaSllS31oo/KUe5V51Z6pVlS/y61Yt6Zn0vHzFw6ZubSMTOXjpm5dMzMpWNmLt3AFUKRZmVUN8MdLgCqgK2ZuVox6zfTiZlAMWWOSLh1ZQYPwoOTN3pBdGoH4oZ06pysbcfKrC1Zbi9e38y/8u8WW3fLY7TT1IShCI/9wPNZENngPlGhmqkfKcSUdfv5tJPa8GhAq5rTQGFhVR2p9QeKA+Z+rdCEpJsUoWVaVULgyu2J/l32J9roWBu9R1XDdDCodPK/OHENnLgYX49lVjWss6ph8R/+FycuprDQMYWF3sPv9vC7PfwuFtjR+/jdPn5Xlat1tKcWaLqmyJAHBZ5MPmEm2xb8hFP/JJjLmcH77MYXXt2y8WnNAnZuM8fKPhraMGpf4J5sCcCNCvLU4EuyX544Zhwmj3EWN4U4kA2cy/isgNri4of5K+DOocRCuDZ9Jv4qo5EyNwqpn3rFzAD9EfXUTyrvqlHZu0obKWa8Xk4NILqonPtpUFVavDJphjZqYCZ9HTPp65hJX8dM+li2jv/F6bt3Jn3O/sq1eLtK2uEZ8phYfHGqpesycipwbbpo49W7F9PIXL3fljHuF1TaMbGqtJhpqOiIpUzcVJo2el+RcXZYypgmu6i8j6t0xfp784zvsEAO9MOesmetFwfk7B1sEvqo4FeoE7PNKVaBQa2ScKq0SeUYC7VT4VDf2WWkeU5UoAlDBtzBwUxyyI18wxUmRQ9/LTZcQfkTa9u8F9NjAFxHFvR8t0QfGIWouQGxmkKiamFh76NMHla2yyklesk8LbuobJ7uV8XOVe97jgaNkujG4c7btyI9SSrDnJ3cpmrx+C6yXdP0gmzv0sr9VdNPVpHcdVgvhk70UDn3l16hqYwrY0Kbd9xoQDJbo9s/1GEjV9RNQC5SBQB/7qq6RGFnHtsO5GlFlj4JAvNl6nMGU2ZAKt/OW5eH46KrKy2nwMGeCWKMOkeKonfKZuXe36+Cv4+t9R5MTv53vG/a+S1bKXapZuHu3nxd5flXvFk4MSm5b9M6MRnv6fhXa2dpVByVjOjzNChs/K/xHp5OXf0UHL03L0/gV5Sxa5kbhahNXS96OZEyLA61eokZS1zcV0QhjMo+TqJ/yscI3f6O/qujo4HerD2ljpGn/K+Bf3t7xuYgb11EbIP1qODilPH7wniuSsaremQvbvc4FniD6VTJb/UjhaS7vVGxjBspm4pRr0htaQIMhnVUE9k9igJu+t8vyN9nUtd7kFuV/9XwL86FAc4FsLTwv/09TeoFrhN12nJNHwQfV9+BsM7JmvHt6asvgMcwkbwVvv3gjHNPxbKzKFD8jikZRpm5XTEnVc/kl6WuVkwoOaaVXMOoFUFdmpTGQDEpS7qV7J6y1b6v7+huPhIhh01Sr1Bx5H/3D6DO85ea3cuP7MPvp95iIoZUxemlu4WFZ1DMia2T8jAcGzXL+ZT8rRR+tl1F6dCBugLuoL+jvUf7HlUQtO6x1n3X6tPFFaeLK04XVxzoBP53gH+H+Be3z2AM4xoarlaaVraBdutl1EvZUTElrO1N8IuodTUzV8K8ZG/whPgSh1cmqDm3gzC69tz0TnLj0iy3yyPm5HLFogvXSgjdZ2KePfteoJyUuTv5jHwFxyq5q/13Rj5p3zXUGflGO56u9UQ5vkbt6A2cisa+O3rBU4pZxcc8dljm9v68DPnQqvk5czevSI2HxXysY1Lbm3G3XsndElcPtTrhqbJ/yvv78a6aVO9IN5q2v+njqtLHVaWPq0ofV5U+rir98Z77G8g1EHJ2TRib3/4Av+uuwm0LPGRtL8WnE8cBTn1jpuAj4IyXecW+kweCxFXTJtNe2Hn0i2F/XVI+Fr3ufquAMvip7Fcruqe88xjserisaUc9o3GnFahi6dqe60CakaAQ8LpLooISA8tXTUzHUTJy+X7eZaJQNLRLLC2fPqzlM1RLqxmW+LmiYKhWVTCU0DGFAbOX/9336C3LWCqmLt5+D3NX2W8V9wtReuNihR2N1LlyT9/TTqSS1ooovbGSvfXxeEelXRdpD5qltKOwNrR38neFSXRZvL0Pf2NSentxm0QDqXi84pm8J3NJiI+J6ySjWlyuK7i85MKsFuEYs7ZTJOrgSO83zhaKMny8rwwv8paCz1eqR/bh9YtNlckld6cQ19IdFuNa+qR8KHStXtRpibfHgzr7U9lBiorm2q4VzY8wHXezzt/QrjlEOT7EU7ghGmKGaBMd9t67PxWMl92fbltwf7q9vML9p7yu2p5uH3cz3957wkCHLjmZ6gSr+ZsFr41+McHwQP+310bGa6PfU6faNlrgtWGgJcdAS44x2jujquSvxHMjbXj96MyuemzvGRCyV7cAFc8UcjV1i15MtHJO9gf7KUi9Ua38ZKJ7yomahv0dM89/j2Sq797m4nHxaN/j4iJ/VfF88ZF9+P0XVulpmr+VT8lUKEXYPerROpcqC/teLT/TWg5KvYoahFWinpKj6RAt98N9WVvylIKjHzJ39mRkb/kKK+du5gtrdotlz0jp+7q+Jy/X0ltE5ygyiw13TSwms1U1ips15GbtHdws2ErNzzfLd3H0FYvWnjKyJXenmCJyQDpF5KBmisiyGt6tpYb31Znydk8QOWqebO7irrW7r/VRcJVqp7m9sQ8f47a2SjIXb+YPirSimjH49znRdqaotYy+0QLvlx6aXnp7ZjrdcpWqNGvu3t4MjdlFKjk6e7cQdTgiHXWo73mWrylOh4b9ctThqK1RhwY6vhj993C0yGhTwdLbm/vyNBoo33CVf+W5HJ+P9KLnIqkYLmNPNtdrHYKKzimfD1VFcL0iupsXXYvmct14B58X+auC4/GxvRleJJOqUktKd/Natq4Vjd20cn4Muntq2b1xLS1b9E9Zy+4au1v3MAlio6zdA7R2D9DaPdjX2r3lsMTcvW1RMLyXv7kPx7965P/qWf+gwO7U9PA9o8r1Xh1hPlDz+j56OJoXm3XYr+Nh/77S/LVTfv/dx/u3gb2BWnaVVZJUD+S1FKPI2CNanoj9/Wx/yviKUkyf6B2FmtLIPHw7Wv72rBCf56n96zmWeRnzLL+o2Th3L6+K9ErZEmil/Bjo+xr8tFqqSE+dLcHo93f0VtEMURKyWXk/0OTX39fkl3CWSjxnb+3D0dMosN3Vpc0xV2dDqHooHwVnlKLgiJX72u8oXVecNmKtxnwUnFERBdeA08b3ato9PJ/pob7d27OEY5nHgKJcY5VdJcw+tPdEmMW8r6smQPFm3sd2ULR/j0kdsytyBY/3TjlQcrIdqAvc9bo7nkz2j/oHt3/3jnvvs6KgtVBH9teR/fUy+/dqsT9yWLLHTNlNwe1Reg/6Nf3W3my/TfWhZPzS7ULQW7HI41F3SFzoq8IoSokIdEV6vkHZf0p0T5n7h8aO3D86GjZMNzfGexajzvLU4TRzeOkbRnH1IwWTYaFcArWapb09/QGNUa2wIF1dKsHQtJ2luT5onBWli1aUfbX0AnupRLfiiX14/bP7ittr8WbB8UQbF/1dSZ34KEryjva2iCv8XbWx2t913ASL+LuP6zF6v7dvTFDKWQrWjt33uriidv+KJqK4n99+dkvhyrQSvI9quaFotdxQSkf2onfK28/hoAVn9hgM1NuzzHSOsVD55lx8wu8Gaim+L39/YY7zi+s9udOXzdxTRuSrH8m7dGvF1ME9jXg67HpusHodLhe9U+bybgtcujUU3tq+wrvAWwoR/qR4Yi9GD+yK08vcnTxb90bjQvFog5Reog1rZlPVht1yoTKjVmlC2UmKiAW9IueQZlSbyZtXPZfr3vse9wjOOpywXmNRD2VG7PytfFByKQ+cTipGoaxb67WOeOpUl9HVWeAGBvlDSmM0PFRxGU7S/lHBwgxuL5WHk8WbeceRkVZUnYfE8xfWO19XZYkoKRWidxSqc3fHkGBdb+DRZA8j5nu9PdWKacJXN75g46rjGf5Ifc7mGnhnztzFemMGDx1RBXluhvbieOHYfEg7nvi1I3xIxe+vPJd3LRHl6Le8Pzwa04orGymcS1Tcn9ics4pHOU0KVC8vyW7ZSQoXE6O/Y7LDBqodxkDbU+v4YIbsNrDDjTlBdnuH/qHi+KpKd1U17np6IdlP70gjlYFQ65dtIHpPWeNuVJLlisNIrWTg6+kVgZLdqgToWqUJuzc40g4e0z46Hr+jzB2AMEDRMiCNBTrPGHBqaoDZ1IDeNfp8C2EMyraS8X4ay8a0ZSlfL3aszz6wxtQ1fX4temLFIswlxNuTJUK0zjg8UWQ703BqcwaJvMBmyWMfkkkBKRKxMYjd5I3yMn0G+5evNtEdC2MnerPyZGi61tx7FmtLhw9LtAr4bNy9CF+/FEdBK54TZ9keMXCq6OSyWaavDqTQjO5frPxDKbvAcxwWHGz10LqHUv5xKu3EsOE3h29792HXUsQmLZ3H2JNbh3Xqj/UrIjb1EX1u1f8OZrUC+5FjMC3Tj5LNqss892gdRb6Kb4s3C8XzigVeiFkKv3PxPKWmPh7S512jUbz7FFZy7pPSODgoeQkO+sSNLPXC5Lt13GMHajdBrapkCyXG7TeFcf2VimfT1ryYHfVoi9nRnmJW4dg3LMUriN4pi9kBfW4dN4Zb+eCxKFyY6joM5dt5/i1UY+D82yd+UF6PfxXuIINSdlhDXYxhNKbPv73G8G+FuK2QtwONNr9+X3mrrug2boEBYdQUft3V3DzUCvHmA2pHJ4pkwj2V978xKtu9BnXErOwixdnhcLTjwYkmqq9857PDHYzNvAOG+x4abniHgLlXdVqYu1eDlaPAXNjuag8rmNbtj0lXbOr36iXDLvmM9rp1bAmyf+qXbHqlCEi/cXbbv0PsJrzqRcyZsihWWr+KNwtl+UqZI0l5OfcViSO7tUSuQk/olh34x+rEkb2qxJHV8vbvO6iW/Vbk2IMdNKQM9ibbLgLbB9eLKi+LSrcKrWuMiqJVa2FMbK8kWjv9Wi4VsoMUhbh3jTQZdL+TUvsevyLYvWp7qgfVh8xB7NZm2Xjjd5i7glFRcm75fjFQqku6MMB3DgTsq+vIG8PhjnJ2eDQaN457+XTV9L+RexdrtnhI2LPj8a1aYFtKK9irT+a9gwbjYuTIgHhK08He52Ylv6BBhWf9zvnTe++tlvQ9dN2/1saQMLF97Mdzxw6VqkP+Vt4UpnULtaeN7pFBKqWG+Jni1kzFr+N+rxwP0h3VUiJ4Rw2UWsRwOBhWubNVa7z6d3HO7BnHvfekl4HzcqyuC7mmMc/df6G7EmbdgJwbkOARYqPAsY0/B9X7wK8V8u0Y6AX3X5ipBBI4w+IG0YKw/wXVDYpoggM0OMyCxgcSEZZ5CJSFiGHI2wQ7FvCrA7c6GCtwqgOfOrCgg0cdKGyQqFPhRdqrl/nmzny6FY6g0EvbK+z3zJ1s84SzkR1duEsP0+Q4/NYVC0N++yRY4RMf7ehTPM88p6rgF12aMCTiqU9muJYLlfCfS1Yt4YmX/fnt5SnzmcuZaLF12RMusYobEztYxI4ZqL4jxMFNIIMwf2eBdxPzH4kWa/nINXs6ZY+/sSCsETufCKFVYPrrjpX5QZUwqnyqkMStX9IJSSWH6Jf9puqZixTB82NFDre+Wicc6DvqhIMjTT/81vtdGiGnVesdSiNcSffVj8B2QNQuy6rnOi8d03G8p47v+pujrwoLkvKRPC8Pe8UN+pB6BRLlBr1O4bNy9UzZPWU7klGxro4qV9WBCKbKM/PXvzPgQTuYQ4q/OQ+8zeeQBSerJP7hFRa+57/HQbD7+xLL5m/lWLXg7pdnUskaeR7tFlmzW2a5HDMp5VZJE6oYsth9gKjpkhoPcD7wH7DM4EWRbK/kmtkfo1YDZ2j872C/NHp1IlCg6cG34fYfP7qc4TgXeXz6CfMTMqu1yjRqPbGth1Y+KUPPieH19z4L5ATtiy0V3nvknY7fBz1Ux8197JbvdEc4ZbiUSttwaLEyato07uImFR/D+Zr5UaGr8mHmM3duOzDtMhSN0S5uMdO6x9m+vdXjqjS/5QX+2nSzBrn+tnX7tCFexIc4ug8XXsDSX168LBzeSxaL2IJzWsJmj6v7pel6Ma4PIuE8qhf5U+iuLg60/ft1PM8QIRo9x1u93Idr0xfpN2cnd/efPn9AtnGRQblIyHEv/4q9eLl/tD0HcwtlanXg9FlxAVI4HrfY3AzZPdQodBybz9+FwDZOU7am9wM/YJHIWQTkcEnpAy3f7i0bovvmsbz1B58wC/42Jo3x6A+18rykc/g0FXEbCdFeAB//hHFce/dbbNvh5c0Cm+w3oXdw5o4CvmhG94+mY1sZYSfFyFxOvIKygfdsd8mCIMOMnOsNoGHDQSKKyAy4wglYj0G4hccOW6yPb+9ufj6bzKb3nBuTi3vmMFhwwmO+gMEvWh0A6XS8ZQe68NgMIntpLvgDMJk7fCIwM+Av266HHc7d9lykhDo+ChiXIFy+LNbs2EdFGvP82RsumcyNn19KZ13jp+7oJ02sqXyIX0JYEvjD9xuROBtjVx+lzsy/2zvinfgjzgzezVwm8QG0F1KQQh/4a/6OhZANXNgJ4fQHro4odPgQu+bcQX6XwpcPBXNX0Rq3rmimAbYwOT9dmc8oHXJtNhCi/Smk2YP6lcnDScWwzE90j3CsYHoin7xOEEfbx8c9zuNhyqXpNxK2CUzLjtFp5c8/ccJsYsdMudp0uFQQhAMPQp9i0ylbmJIxdQwPeGSOt+CTfHsDFJAnM9jE/sxePGwtVJ5j8UUjadO73T9zfC0HwH7+R4bIpQOTw/2fpAlJNX2fc5TsrD+4PHQt2S8W5wNcvBJFH2T9XSq/pdYCk+7Esc0wwwRzvrdbBTCFxOBzeQSv/DFYzf8TFh3+f1zD+CAFoXoMMiVkcQC5BDEtlL7dZEEXde9A6PrmIpGMA/x9x/M2FSOVGVztSM8OnejsaM3n2Jp3r0jAgH2USAPZqXwxyf4kDOeTHbBcI64GvmlB8e/0p/h8uUeVIDmR+RZD9zlScP6ZLJIgAkI5HJnu/kMUhHVxVcXOBEOEBpYIbSi2J/D27AMaTGA4mh8KrWG7lCZPgL6gQZ9q3b58ROgj8j44U4n//t+PQOATs1frCKlZx5xU5GodVx68llMWNWKu3JlpF4VmFAfJnOgJHYq/iavV4txAMvDStljCjJkfyL9fiImdfqCHM+TJtnDo//gRFqe0yIUAdY/eoLjudnPEpDc4v/2J4mWzHQ7UQ0FEi8XoSMdHsrzQHaUjm0wFPrvY0gQbCey3HpzF+j/1/v+BZzXIAosDAVpLuL3fE/dHvC9EjCenL+JzPftIFx8Z8l2DeEUs1Lr8G8Y/jMRIC2Up84AhHuhyvUk84K5ZYEelV2jdH/pDwQ6IfosKxA9XbVGxXfFJxNwO1zYdJhaYlehEY3jULwyfXhy/QWn8sFtBBGV+LrKlrJrc3J1tqRzCKCChxqD3g24MuHxFQCd3k0+Zx4ZHQx0f6+vaDyN+NcKnzv57tn2o35MP6VwSgcn0qDfEp04vppOb387uzk4zD/ePxga+sacPOE8f9cW0+3z9y/XNl+vMg+ArJDqbv3U0PhqNRH8GQl788ePpzdXJReYbIz0hdqhxYrvJq09uby8vJiezi5vswxyLJugY65xhoHIRPn17dzY9u56VHx+PESOXBFzkDo5GA3z84np2dnd+MqnTtxfX53cn09nd58nsc3YwBsZRvyc6sKfxlx/1xLsndzfT6f3k82x2cf0x0zPGkTGS/W38YHDSDdHfs7NpZlgGfd51AmGfD4sBPbljV2cE3RtPrjkfOqnYC7nOJjV2lJA6mHS1Edp/kYQ1nKNl1jtdVIXrJbPWzX19PAbxDX80+XNLx3vCNUAIweTHJ9llVPyogdWJ/l+y573iAsX2HTEpNEymDVLnCwi9aU62+aBXwv7j9dUXp6XPxO6Ed0s/I0LF0rhEKxGopVLnYJu5nJNlwv9juRwtuqg/JgRk75mmuMfF67bZMDRNNAOU7OODQfFVW1U9afuSEHvUz7ROM5CUnWQcdV/v0hsh3hOdzhBU32SFvlgGFsx0q3qj27V6y6W6N3rWsivu5XqDK4+arpd7g+MYLRaq3ugpe6Nb0RsDNcv01b0xUPcGZq0qdgdq3b5jhhuzmju63ar+gOFW9AfwhqaV+2PB2UzdH31FfxhV/SHsyMX+6Km5Q/SqijtU/dHDHaPJt7/P1fwBPaLuj9GIz6WRkj9UswV6Qz1bBor+0Kpmi0hYoRYpCv7oVfCHojt0ZI/YCVk1d/T4/6q4YzRS9Ab0hao3FgtdF7Oo2Bu6ojd6lbOlp+qNfhV36Ore6Cl6A3cxZhx4QeVkMYzFYj5XdwdMFcYUzJHAzneHrpvmeFxfeOgV3TFUi9IK4TGsYI6RcrJgh7hg3kn2Qnw3IJbjDAUozS1z4wstiu+pxhhTEHip+al7JHYaifL5R+H5kTC4PW5NbTjMqb2AT2fAz7/j2FFssYyGn1VXc3Tp2ReMil/XhAHL9n2nhAhFR7ot4bv8P+U2CXw8xO/4psvkxw3j4kQaXx7t0J7j1+Sa7nuhnZjgIs/vBKjQoArPHEsY5GE8Opk9p9yFdMRZR8Fc+qM0kHaSQwcwcnaEkTNjh/wxNYuGsrmzjufhj/9Mtg94uvwmyXMvAgOYw5aRTBjzdIM3hLaVxwGv7eDZQNZ8nbGwS+N4Ryg6GRt4zv4t7Zig3zza7EmQDBa2ICoQnFgXKjs50Zp6eleYFGIOxw0lA0bmxvTFxcnlpVonW4pkNz/94MaOA6+4vPl4MXnjWXgIdcrTk9nJW8/yZ/BZvv85u7s+eYsO3Cf9KffDwlJ0lRouPtx8vj49uftHlX7JZc+HFzGu0raSNIclSwdXhsz5cih2pD5axn/8j7624CoBMlccJY1cS5gPUCji0dyP/zFnvbk1R1SOOWeOOFrhv/LD/OWHi+MbvDPl+6GzNwkNI5kxKEMltjlixmdJwvZl7CSK7bhnVdAwxbficF6cn03+Mbl8mxLHXjI8PShQI86sCqTE4jwp04d8iLj0eMl2mJq22zXYSHCEtxap84vLs2mF1ZWJQ2bJ/zNvxTf8P8Bc/IHPlNh07N+FFIY33p3d3tzNdnmRmHg/oLwTVMGrp/F8y3WTm8ubO/U75X5KGiPh258+X15OX394HYMJBh6eXH6e8lnxxrudOIS5AV+4Orl9/WE+438U4jx0bMjCKc1CySnPH9sROT27nl7M/vGjMCEmhyHCEibMoRHz5THs1q6kSaOwIGq6tXtm3ixh/XB+c8c3+ar3b98urGzb93PVpZ+1jm5X7MwPQCf/cHN7MqmgX6QOSn8Bl8rsT6ChH4bhix2w6l/4cnGXJf8Id6rJLwxe/QXjz7wikn/72enHs9fof6X/B93EYpXoQpn3Xt+cnv0wnZxc5sjeUm1U97uWN7F/CHJqR/oLH04mv3y8AzH85rhibxV+AObWpfrNIAJ+uLz4+Gm2fbO+ffWoskf6XTGabLq2l1FxGHl/fLo4z7yzo40yBFe/trtV6BQ9Pfl0d3N1Uurr9MX6Wz2RqnUKqrEXSnRnOkN/heo/cUGDsnPpefsfqfHoD1RxLuUPJSdTvOkW5V/alLVNpeLTMV8+cZlyFYqUmUIM2IuHjP1q+/jvnreZedkjEv4rpywybSd7qONynXi1Vb9RpUZBBipZR7weNwbi6ABI2rb+Lg5kwAvJc6T0Dm04Ig7Uqh8cuHGVKCs4U8OTMOULPSRM7cCyig5u92ZoEpjpWYPgP6V1VTwnzasFA2rRQpozgZZtnNIqCfZLdJwwN1wxll6ZoHhBue+7j4lJ+Z+JZwTeF9b9rBk/sddnLPNZG/w/s4qWgJ07lyotNI9QmEL8WKpNpSrUVm8SytI/c7xZ9xtbYSMp+eE/uVIlrJih5I/XKdtqUFm1qUhN9VMpBVtFaqsevfXjUmGSWlJGNSr+/qsPboVB8sM5zYlPJFDw81M6zM9pSE5ZmNfQfIcaj+LGmWQjnJuogW+3EP/LlWcrUf1z5InrDfrE4rE0uAfxvc3Sfs4w7T//RKcr8Q7YEmTfIa9fewc8knuHnALpO+T1a++AR3LvOPvvs9w75PVr74BHCu+Q25r8i7aNr7+tgEoImvQ94nL7hpxEyn9Ry39Rq/yiVviinv+iXvlFPf/FRAJmv51pU70iFZo5Zkhl5pYf0qbtW0pCNveSgrhN31RoV70u+0junUWZnb60eEP11twzudfmRH/6zlyr6oXbBwpvK64dmVcWb6nfm3sq9/L8YVpuN1e8o3p1/qE818GxW47vZIPqPXiPf/2ffyaHSBkvwYJ/YMYzcGmLk6ixKOrnRsHLve9JNxatb2gZE1Lqaif856Qqh2+4f7Kj9T3MXfmyZBmSSgL4I94nv6WPZa02aEyTzY2N3nCYNmfI7qWNGd9C9N823VVsJqv6i7nBJfOr+WiKPSzavF58uaOVLq5cxQN/UukmaK5YJmJcHkvmb4pb0rux4BQCTj0bX5wo6sPuOOtJmTGjdPPuIRg3lHMHGej9bva7kXcvfGw97IjEQXEzt1exJzxmpDVSwBGdzKHeZ1oSVMAj2XbZ6s+dbOsYzlx7vZHeHfeGeg89n6t8MPHAgAXoUZs4jBSHbZQZNumZC+9Cl+eONtTGox5mCDTlgEj3AnF/MOj3ZTZiroDZXGG7903OYE7qHFa6Jb8qwEEKa9+LCt6Z4Fw3f7mHfkKS/7+4ayx69+D8HaO+1NG1br8nThHkTa4dRia+ozMadnN3+Niw6MkLHhBRfzTo9bvFJxxvgUPeGetDo5+7O+f3HoTxu6ON+3pX+FynZPKNhNyN2O4yMLnSEy+iGL1Ysf+G/fFIHI/AEbCbWtlTOreH7MZRN+PBwbvk9W6Ad6t6AB04VegNXY0aXaAUeLWB4F4w/NpLPobphOJ08V2KoOtiO4H49ND+KxtgCdSg9YB/gb9UOLsl1mOEIDJMwC9gIZCRfDjtVXlddHvie6dki8osO97gxMY60N4T5i+WRmQz5nPUskOcQRW7AB8dYt3w3vTh7CVxpU0dACBMQnZBehP8ipPvJU7gYbziQg7mj8ue8nfRgMJZ/4Xf3uTpQd00G65VsO3iqzNSSfxUZDn2PLlK/VJBkqPY+RGcqRM42A/BYm2DG7XgzD9+TJyqSyiw57duzuErP5L8QOqAjX6/LC9qEl9gMbwY7wZ9mu9rK91LS3hiEvGvzz0vjDLf5qMC0SdyzydegCOdHqaIXYTCsbtgMz3FgAH+CjDkgtTkP/fDOp7/8H/5DjwM75Nl6//+8J985xT8MJM/8P+O4GXCXHufPU+Cmem5TKzJYuELgCHupX0xI525FO/LE68gNfpmvN9HwgSHhs60uX8kDvnYM1uI+ICl4HaFVNfKWsL/NsHV+rgqqdRPSRB/k4hUJoFvJKVvZQAnQ3Q+6Sitvsa01GRIllkHf9rmgyNE9JQS0SIhKZ0puGq2PC5VkWkWrer8SCRolKkImkSiMnHAT6X47uaT3MTxL4ex/1QMOG4ax8p8eM2cTglxDZxHlWmsGtmTucxGP1VkUWkuwbn8Lo0ms9kE5vP2UKAzbPxMokEoiWGnM+bKfFGNJrkqk1VziS4m1Gp09+ZTfRGgFk4ZVuK7VKiexAHYqpEhzr0A/5W0hxS6HAkmxCVX5vOW2gt3ESApFMguMzcp8rOcTYfwE8dJZqPMjcgsPk0JzMzn6Mp2vWAawUFm4+mdsg3fbYJVAfnkA2RSafgCKT82vmvPxHaeyrYYtvA0dGaZB6jZRKKTQMgWUeMXZxsWBTNkKLYaPvLoM19Mltt4UUVjWtnh9MH2feEy0lwyn8CzZObdPqx+Dps+tZBWKhq6sENQ0ADMgJ0l/lpwzBzeggOYuyJg3iOiY+XzqzeXTlXm9+ZSGzLXylLc/IMd9CtvNJWlPP+NNzw1jlRfqifH4TdHJhBnQedbzIKXTmSuhN+JdOeQHj4ioOzKWzyAOzHf8zYOi3Sa6cwZeNBKN0EDobAg8AJ57O+foo/NGTTRxEAegB0ShbDwXJlaOOEltnBmEBFAHQRXsKyJ58QbF+CEdPGgf/sWCXEgN/OvbBHRBvLZZc8+BjcADnJzPt+EKmhkTRy7QTb1/WB8wJbpr5fQIPxjpqxNmK4gu3174PwK6lmTjhgOgGnGd8ah2SiT6QFQXUD6iVszMDchbVRC6c9ha7jkszSCynKJaBoKsiTb0jpJVNOp9ol/4muJ77kha+SO903izadm+YrWoNxzP7thvFiwMFzGTn4QSMH4CHEE9kIgoMb8nkuNYpmMgLM86hbk5mrzNaIqyinoPZJ2mttrNfHhxfTmVObFItbn0wgSkhDscyD+OoYaC0SJJ2CDURJPye6ylZOQG4UFQlIKRSz8YkdrIXKuzU2DbZMqELdiib24IaNUbmlvvp1LzTZf8DMl5aBMPSEFIUc/GSUYJ6eIw9EwZRL/peaxygLnn4wT7QQx1AtlIrBV/O3Eke2gzeAudjGT0jS2I1pA0oKrnIWyMbsf4PPGDB5CUnA4mTYkEWoHGsjT2tlAzU3icGDafw09t+MHXuQtPEfsCGbmasWs3yDFLmUgLiQVBKZrCR6LpdOIJqJULpvhKVvYG5GYmh7xH+LlkgVEO96MiLLMB3t10UC9uxbtYrNPiXZOZWeJ+e86eAaThPPA54ksFUUZiyiRjXAa5of6PkSTtHo4ITyL4MWPPHS5xk8kSQevVrrU87215W0+f744JUR+YD51qtU+auqRzDeKITN2tEZjzdQ33RPXOntkpCb0E5t3fMeMwM4nTCALSiOR2X0fP/LXWfi2rZClt2JUIyK6qGcB2W5nwzZe8AJyAE785SySVzcuu2MLL7DaCe8aE3oLhGE7IV6Z7ks7AVp2GNnuIvrw0raRM1eYurylsKb8GkrrhRFRgFkbplgFzqHy7pkbBTYL2wGKfzoJAvPlRp5XtwZVy+Ag57UGDbVtxyto0q0UWA1n9oYqLBHFmT1T4+Bwf3UnvtHU+M13wMMDXKg8w4eOMksqwdnh2caPXtoEyQwJaxMViMiZvWtgIr2VVGIivgIrMf3s2e7ZM9QzA9c/8JajvX9UM2MU8VdO1rZjBcydebdYeKpVENmj6SBzXrh2JF1IWonvxmfip1rFoL7vvExEMg2qbCksviIRyNYCPGMbsG+z6TenVbjOA3O1oXXW8BoorCsa3Trmgq09xyIrO9SDdWc+tYf/LI9x3epbbAfsDKq7UxaGRWzJrAI9pKEx0PsBW6xj96F9iNBqSBSQrDslo6avvaePSUMrAH2ObatdiCatQ/TZaRuia9P1LlqG6TbwrHgRUQeV+kRDkg6RX1I2cPWIsuGzGliDY41f9W5Korc6G9PlTweqNgCaCfT6EuBhROtxTiNaZ+U7oBQJc+D0yIuji+UpW/KXWW3EKtOCQkJQkavmRETYtRgrJzaImhyY6bLn6GvIf8D14DEMyzQDL3atju/EHL/M6fo1W4XMDlqB49x2GujKsQMSAeMWW5s3iTx3aa9w1gg6J9gAs0J6WLKzZ7522UCR6ZxzKRgHTXStqcbhm0HIso3TtdlEpaMawRz82rONeCzuNjHybIdhSEA0fjgsXOzpT4wiDnGdRSHu0cMw5d9K2Ioe9Ve2rEkXUkUAuzhr+o0s//xmsye6nQ/JIchSf+bGG7LEn5qRGXpxsGAU5X7E3JCG1HE80xJUQnlD2BEAjstSK+bnpQdk2zoLb4KfQ3oIcHcN59S3ZrQOL1yJxjuZh54TR42eHsx9BAhn7uMv7KXJhN7fg8EivL8XJEM5h9SEwalvcLKj2hiaaQ4OmMV/yzadsBNGfL+fraIT/nQSR2uYB001kEnLmEgohaS7sYPFTcSpUHIBK3GjjxrKQERi7WSriU99dh9c78kFJwzOVmdJXgHZjNfNPuqvROl4K+E1jj7/l96K9Dj9ohqlX5o+RrmyWhDqzvhvYNTFq5W1ZiIo/hNzmngMVA8UVhU1N77TwGOPJAmg75gui0L+PSGjM9eYSc9znDn/TrMzGb4B4hYvp3DZ/EyYb2BpelLJN8hHk2ajs+/szlMU8pMW0YCoQjv5S9TgLMJFqvNJnYWTb2NDFHcFQRpAI0cg9XvqrFGNQOpTv6dbEeCPZVQLbTc+2pbpAhIZtj9xgpwGak9KGGmjpFq4u0PhFosGgO0+vQxFqreQc+eZLeKokRrIG6i4am454DcSR8tRJ/QdO9rq7VxNZItmVUw+CC7cj0wj/s8GjHcT8BJv7nq5MQPbtOYEy36pKadR+ytLu/yM7mDw8XTe/B3H6/RT0G4rEEBmRtM35zaf0jYLqZGP0ShX/EcbXi8jSz5JDb0OALLEN7Ln4RSjM0/S5ndwKT5OFt2N2UCvv1cpDtde7FiffXBxmrqmz68bGPf8KgQuK+VGgjV19/MW/TP+8dx2muh4XYf0UzvgKrTXyDRsb9GfVsBopuvxq+QHsZtwPjnC036nRTl/2I1kRTMalM/N0F4kp3WeEJDbGjAfzNRPt5lFwiThcGbFH8UU2uLEEdyxQMXEQLN5bDvWlemfe4HMj0YAyASew3ha+AB5LJvnkQLhfdJhVfJT3gRxfy8sE/A58+wsCSwyX+acv7yN3cAaxu/ENl0wl2uwXttwwcTiQqN948WiyHZXYdtw3Qbs0WZPMiihfei2i1NbRzCRJM0MqX0nOHPJtzUnjpOAbN3ozdnSC1ibEYYsiv22LncR/2XLe3Lbim+JdgW4ai1/rliKrYmB0IdDF7YQ3sZ8yITWfHC8xUPbIIqMXXk9jd4kzNw/5m+JVvzXvjn8AUtuGJKDK891mUwREnB1jTTQ5IziFZQX7tKjjfHljXGkjzCkiDDEQOfOEgzTHQjFkg4g8PGOQS5XS8RCo+k6iS0r32kBsBCL1zQy8GZ3MEvblU13nheRAqTgN6qMVoAiiyY10wpbhYO/1HMe+cXE2/Bv2xFOkfBONgOu2LW/xQzSuNJDdeFeYUWrEqjkxnUTKwC+H9YsYM312nCZPL7YOrttTJ+Ct5uCchpueinheS+ZtNbRvdnI7L+1yXfjDQvsBV0AVpPdrN6kHo5LOT0bvwUQot9pg6BNPeHO33guIyxCnzcONeIj7+ewwZ7ZFVSLq+hDo6MP32KXD3ZEjXYiDtlvUk+Tchp9Dh8w/ODu7uQf91c3p2f3Z9cnHy7PTunQfssC6PKLm4aHTpQIv+b/Nj9iSEn2l5Ao4U2OcFo49nG4CGyfv80PmO3y33Qc4RT41QuubLeZBRzeJPrWjBZrQpQ3Miilmlz2DFlpoinbmG5kL34TS9Et//FGZnE6lie/4JYszqEa3ecptcLsCCnL5cdGk4v+3UL99l+EM+AXM9w02NdbQfqa/+B/06CVfwEqEJ7bQYih8c2UH3w1hCKrIm3EqrGLYIbMdAcGqTMbT+0pW5pcB00yuDcy3WqBZDPkxEVbf6LbwHu0G1pFEwmfxnMoN8t/D9k4dl1QQyciJRsxqomQe+1vLoS+0cxjHzXVFxvfCyJKFJ8y17v2omnsA+XMajbtk8sLjMW6vGgsiXPbbbZCv6VxjfmDLlzL5uI3Nhs+05Io2sQvLA6gLL3QM+UGpLlzLoot28MwEvzE/y6XBKhtbJhZmVTOEp8DB0Nlm6y22VwHSlJGMUs4oGAtZzThRg1WgqAwPVg9j804WkPuYyFEJqZI4QqsQo32xpZHzBN9z7+I2z+gGVIWo+bpRkQo34hUrEnmwIZW56hBOgQIUJigJdJv5l/ZIsJU8gmKsNlbxTyWr6HnJoUt4Dy6sUnx36D9jj2CIxtByj9g/OQtpFcmSH1TUw4llIvyp/CzHdO3jyPvgblY2IK3Ci8M3hDOvMm27gVZLJnaHTNvhsCoYAHlQXjUrxq8uRNFHrZVgfL1jBpONqbuEZnOZAb3JPxQWoOk6aLhMGB/mt2Yyg2KxMCsbMKEpu9dX0WkAAKJbMHn/8qz4ibGm7wH16XHf+ZWvKmRjnFvgwvYt9gOmAxpAFANBwHntR1hqro1XXvReOuaIJs/sXjwPS7OZDK1SdogxgSvSYGIgpeZd8dMC/b6wDkiPKvpGGRWtTjiG56Ob4o1HAL2cSfaxGj9XQHAWEDFsCk6a5BY6BdiHUcLTBrpu21qtA1PjQB0rJsAzjhtPD3Owmm61uWvILg6WfvEVcNpdn3eYvqQpgFdMr0wWnuriWghQHsYB4/sRRx1hiSmbInqKV401Ae2Fu1nj002o6pIv5PlJBpcW/QV6oUal3Y/ZdovNr5Din5ZROWcMQvOa0jRLvKAcBFJQC/IUw7lXwhK96fAjhhBusN4vrEjqsId/GS9mBbNdgh5K2wXoo+WgblpvK7L90p+JC8sxvyz54gJXyg7nPpsYS/tRbMPmN4EsnA8l7UEC1xNAM9JI/Mn1MYRmkv2EQyLns+CiBQQG1IanvFrOeGTq+ae2yz846vJbWJ4a/iRwTYdmur0I1vTIHcLjT4eAVT4dnthm07HFwbcNOUinAuyM/cxqWpDAM1CHqolaXdNMPj8zgghuE/sVwAkKSyOrlzY0nS39i2Qpf2MWTqP5wGeMrNnrIbe4cIL/F2O4ZSg8acFCjib2InsTjZF1fEjf63VWcQh/K6wBFODJ+2l4fEpm8fS3lgSBLRxLBxmuqRkmYQivE+Jj8dvMEfQGE8bRnJWS52pMFgjV+m2yXEbiU/28RcIHRe5/u4aHHVbRTNaPX6NWUyAbK7SBl7I96nR9JuTWMvgINPi183MVloHA3jYYixN2NQCV9ua1bJsGn83BmV2oDyZiPnv2GEH1Q7M1oJ3t2fMFyFK28Y6EVeATJtSwWRaViJbwbY8lep8QAiUUOcxLPwjw5B74XqVYrwyH9h26HBeURu4NzFuyhjbBG/ibea2i79xbTa3cN7eI8c/ZyDSGDpYBqzNZoknynxQQv40w+XryvTJITiPHefl15i/bmkziwyTZSEs6UKQ9TI7kRmsmEhP40OwhUyeMsNmMmjAZtFhYPoOsZIpsBdvOktafrGbaY6tC+ZR7jRzoCgDQl7LoQHr8mf3wfWeSANLr2beNF4u7WfKYC7cJQtEioncWDU4vKkuNLsCGh5yNNg9ri6+DWzQbXf1c0hPXgCSwDWdmYdOZ/zTqVxw+ZrEVR2/keU+q9BktoAI4AaN6U31K3obAopuKC3CmS74AGo2RdGNyT3sRXgSrMLEFXnm/WaHdnQRsQ21oWEixEOyWGLRksrch4Ym1KgJCF3DQEhT2uWUYSQ6HMiyk5UJyS1Pmfvi2GEU0mY3mSiHv/TUDohjkVMG9nLnXkBsG1RGxClgERNLTkMDj5RINmiy6SzlMaFURYUhR5wdUtNBS4iWGU1TACO8eErTmg1WXpH8A9agVgG6Y0v6eJY2cyz6MEL+ajNoz4hQQiLs69J+KHbQMt0nNJw9QwMxME9muMGyiCELz6wVa3gW6RpILAY/DIr/oHcSAh6iQOCAXoQdN7LOaxWISO7AxDkU7sewmgSmNso3UVNkXoOGTSI+k9T6n8d04VrsOR0pvCI7SMkHtG/AcfU3B1HR5rrT+Zkbb9DQKT7Sx8H4h5n32aVkqE3BbEwfmCtMuEwaaYmZ0ZVwtibnlqABjiMlnGdTYc84nnhxaqfBz6BM04QiLDLpkikuz0ltzhRYmGQtUp4QKY4pg3D1C3fhxBa72YjSEVIFwDaAdmsG5iZsEzi4aCcycad12JAeoWSnZ7tExaAS33w7dpDeSNxDE1ybABIzlLyOCFNNYguuYQRnGvonb7mPq3uOwEJzYqVwXL4UC6954kBwXE4cJx0Uykz27AXUITwFpg+JOE6iS2aGBAWZ3KeKiDdokQ1XQFJ4ypZQOYPSbvxNZDfRmqNoIzIxZkInagk+33yBBI+Q/7Sp6e5exwJhmSIDsFAZTtxkH9UKLKD6UAYiEk7f39/azUzNVhcHrEFeTHooLkKq25sthjMbFpdpFNhtwHHpeSFpMfVLM3Nd1iX/JKLPSVwxps5F197Zs2+6FmUMuF8Eb/uQMopZ7DuM2vFg1WjcsSVhi8QWDJokhB41fbD9GUEOy5YdScPXrDBJGkh5L1WENpcRUbPAdENOBLirtwieDaFSAOuRtRThN/AyujOf2oSJPbNFHLGWoUpGCp3D2gRsm9yT+IihwSxdw/DqlBO4wmyffENtEYa0YtG1556sVkEGD7iKtA2T9CnHw+22YTtlPqS1chcvMsseKW/FMsiPLLpjURy4IBOpOV8qx2wLhzaOcyfmTV8C0/dZQH1IyHleV6xIuUFpxUILCc7tkCXV6wkjAcfSm+BW4Lm0HygzWxjPQxYRBrDMThSafpdfQ8vDIps/T0+9BVFPthSEaVmXtvsw8wALYRx8OeE6WMAW+FYwx7srenAwM056O5QbujR5XlKvXbxn6025XXHC1mLGdVZ8haw+WoQqmnMIbwNmbuYOawM4MwzzHNvQkBTTMv2IBZ1NGH5zREonzE6M8VqB/SizFZOi2w5pUb7wXJehDbgTovAWWcH8i9Bz8IWX7JE5WFS5mbK9JiRMR3USR2tOly0Wq6aKs5qIlnYQRk08wFfS/7it9C5ym5yaEZs1MXK+PvlESSfS6/gJ04TDB4wdN5u4QL9FeeaYjRLtQh1EBCfiKUrUY1E+2P021C0W0roFMfyceBiIFz1+kb+zrX9FAsNJcrK84KvUJ+b4ovhHU5faHSAwd2VD8UoTs0TPvJuIOckVZVyWzbd70WJ9luKjPUoWdQjh2osd62LlekFTh0Nk2w0zGkY0CZgFqjVvRq4yI3NuhhgLPfNuAy/yFp7TcCiQ/2iK1e3EZLj0TIsl+XizN/iDDU3Ftz+gDSw8prtoOqYk49NHx5ubDrj130Lxzju2svkUe2k49SEXULei2CgEicgLSkRjUo1mFq7NUx2IImkfbNcUWac45eKikecfbxC/MV/mbOL5LzNvtvFpUL/N+CEbrvnPCsEZNjLZdD0UooEa8WA48u8YGPUeWSPTyucBoEn1jkH2A2nwin2IdPwf2ydHuagyebZtJ4cAimFl6Ie8/pAx2iIHJGDfYhYSmb23D6us3Ak+uxacODa+28OMaimVBdwVXHqrhib+qEc/HiL8HIryL9OI69IBUSTgUG7S0OPW9mrt8P+i7SdAkF6QIR+fS1VoxwvOvWD64kbmc0NtSDlJiizUSYsoO/y22EHixE6vGppCa1cwp7a5cr0wshcEFNXX4djhFzNwm3h0+zoKnCVg+JZ+0eJi6+bdzBP2HTDl9niihEhIGY84XWxogek3cWRqh51eXZ0TAyD6fjvpzzPXJEVyEdCatyY1XSjYzN7Cc+ot8Djgc2ATRzJjz1GCpiWDItgMtoytmDviupHVHfJAuOzNejJua4ZJ5zqxVGKWhptHvvmyLUYc0TVjFrN+Ey46IXEwSem6bStxQEvb4Y9ThSMqpPCvuFtYW22NL6FMuHTayxeKwJb2c051xpgj8LUCcZe9M/PO3Ee+b4gZRZjpqRWKvQ8vv23d+SpuNRylHL2ws4xd9Iozna2NfGauVsyavoQR21DY4Mk5xvsfMDieyx/B81HPvQ1YE+t6q+i3AvPpg/csDP3Pl+ApwHWKxh8RCeLFziA9n/60vaRIPn44tU3HW1Ek3ydGfuQJNRkKbEYmZ3z0jtnETmT7DpP3ZvKh9JmQBDY7vNgm+2m2F2aZeNDF7OhTPL8Iw5h9DhyRAZN/Jo/iCfz7/uHFEBM98ya47p1csyd8hsrijR+SOuKeL6KEPMfihF+4TSwhrMKRbFhk/h7UjcGj7NSMzBCrCQoDOhqdsw+1CN1vbz6FSfho8KWIb4EwEXR5cWICmxsl6efbS0ryjn/ZuXEFY52EL+7inMZu5P4e6uyG9/d80ZzYadFd/jt8J8b49pEcitzSTw3OwrFh6cTaF4vA9qP8pvc28BYsbGo2bCWU1AAzjRdA+xX/jz+9tc7S2LvXRUPCRVKCyZj/2dLkmv+l5z3E/l3ssHPTduKAkcZBwYryxkg0NYTvVQgfk4sL+RyNdbyEAytr4xU6vcmKVw6jjYPvUPja4TU+XuQNGDAQNwFZMOmFCOOJ1slcoTcqroXlIKgKXAGA/sIBDkmOzRXER9tiyUQhKK1Sx6pWQJF8JdoI0B+m5l72HAnH9UTqykYai/l2Q5gZEbkZjKBKxDOBQKBXQfB/Eyc3QkByhyalzfnUNf1w7UVk4FiJ/pF4F2RG5zR/jwymok9VYkxtw3hVer/SgWZhkrVOkgFG2L8A5dx2ZYi7DFcTYeGNVSxrAFl4/sv0ZTP3nBC3YGiUpwgEasGiVZgq8VNStEMC5jCdCRN+OwZ3r3PpdkMeCM5p/uPNTQnmrwrZITemTyE9ZIluGlktS2RPvcUDi4gRzXmEJN12SJTsmROSoDmfy9GFgxbH/p3dm5DrjirxbryB4jRUybeanAb0Ddoje8MVfbOB2WR2BRD9ThkCZdrJdvzGcxlZofm8cWiRHnmQNYMWzTKx4YeXiIVEGeWDHdGinEhq8Ddop0g3hf72MXBtGslyJDTIzaT/pkT27ar5GdcLBDc50frGXvHHGNJ7JT5jgnjxccqi2G+mm/XrhDf1GDRLdTbP7eTyAkVIvolI9yuAcEptXOmbGe+WpV5SzP9pNJmprfnOX8gTpNDnLM5oUA0EnmNC8WaatLJEz21X2Dttl8y8+yKzT2fbRCXikDQGzBROTwwmUAjJQXGs5dhhJNZQWD8xdjzXQgCCCNhPSUbhnm9qPi9VIik00QTxJbAzLVOMpCE8Jk8KOG0YmEtv8QBFHFszNAkgAlhCWPOuXmTVqO0VOdIj/upT78mlQj2mJdrGGOMSmDhpQbPwcsJapiTGgllJWuUY9vPMampy5TLx4PbXmVYkim68dp6dDNPpr5fS5Rw/N9Tn9C3yt1fkSE/FEBHqTbsTmksWYY0Vi0VsEZ3YJ6smmmmrut5zV96Wa+CKHOm2G/q852kSn7I8EepR3BfSNhGR8lxlCDxklanQei62DRiY2tBQ4RpIcg3EAeBQ4PERSSAh5J2w+NWZC8dfFhWJdOuF0SoQqnSugSKARKpSxhDELs4CQhgWXuxGUDfZCU9ca5YcK0ygmQL9zA3jgJ3K6qNnz3YoEsOK9onp8i2By+f6zEueIQwqn32F/Ojk2wnACdjGe2TbyGwx6YuNVCTXxFs8BB7/Rrp+pC0kISQrCCkUZomfCk0kTHvexocaCqlBGAquJnaZbFtD00S9B1KjwWxDgHG6NDwnnJrywM/GzPuOCQkqZaJeIhCk89Qpe0yRLBz+I7fIZRcupLVr+qHjFs39/Rpr18NnP5NEVOiN8EnmzGgBHihAe24/R6BLNt+2vMV0Or+NOUHhN4eT+ggBzZLvQtO1I/t3Nv31cop3LixCUmwphiIEYHbEOpYmv3i0SIeMjmRL0TBQgG131bHmnSdRuy/k1Lgrz5pvJTd+aCc0aQ8mx4WMWZ0lF+Id8cWO4ELRLln0a5i8Fc8MvxKwve6JNAo7LNzk0EbtRRs+2H7YsZgfsAV/ldWRL+cDzn890wmZZ9o8+rX7o82d8JVPgecoMDtmsPoXmvfk5vyjzZ6SUia/weeLm20pGdnQ0EqANWDkGigCEA5nlAHw3Z17yZaRB3F3DcQgMoKJbDuQ8ehZaM5glZ16G1Gi2GYhWmab6aaoRCDsyqLGYg5Do8kXKe85ZR583eW/7jiNFaMqwn0onE6fbiF2wJm1kWlX6yAAuRP7jYXANQZIQsjA77PzDY5KO5x6e7WOchM5sZEJv2MOpqkGpd3wgB71wQzZoPc5cIhj8c0gFC4fF+Ihcnh80O8Yv2n/znIX0o5JkuFeBWWHotpmM0ujvhPalNOKVvQrM3hgQevgeYFMrdvEg4J3gYPU52vbsVo557LX7UXW0MpMO+FD2wcc/PqMkwBn8YkaYkLJ5baCEyVOw0mrQSI4XPZOgnlLQYra9Te+KNTVXpxPaxawc5s5VssHNLQ3vsO+ANz2ggyYg791jtzbcq6dOGYctngwLTMyhSrQXowu/5dZ4LoqRC3/2RavKbGDwbktFrLJtrG9EL3AYsGHl/YCXMRB2GaNB7/Y8qXx13ZjhJWx5RDFwpia4ciiDdemz8RfgMX1GeoQ7PBs40cv9GFMcUeUshh1QPiBpjFe5BCW/7TkgEuNqfkHXUsWLdYdcTq8DWGRlvU7z4sm8LVTOyBEuQiqgzPsi2VDwwNLxFvekwvxAv9jo08z3p+s2eIhjDfkqM9c0qEdCEe3n5dT2fKzN6dFfvKZFtVYvdjBZfmRfTADWtTPkWU4q4QzT7APFJcNKYIA1zdAwZIJwOhx0m+iVAEtuj8yscwKt8OXpuZJf3MWZzA0ssLyqwASpic8BlYOAi3aIXIdVLaZh2xEi/iN+TJnE89/mXmzDQGdh7mPWAWDT1IoEnzmPjZzJ1lFOBc2SHMw8z6HBMiWrrXI2RlXWyKcznv7NvCeXzDT4bYI0CcvjNwmhv++DQD35dceNv6P51KEEAf2hSshECQ/aQDx8/mueVU+wC8+iOHn8GEIXYsC/m6BxvHmpqNwNZ8FWE3jE6YEoImJa6P4aba2wy92tL7Fl1zkv9o4aMIi5zum2xFZlb1AlDoRA3Ic+iamHp/yf5HvJh4iWvAHm6rq1cUElTUxzGrmfQoaWZntLSQiBC5IBmi68HzSIOwQkrPYIbu0H+gAcbyVvTg2fTThnfg+TcL5RTOTib5BvahSBwjOTZBKhAEELFoH3tNUZouxmllcqjacJOsNcRhCS5EZLaEkShRwsXXHVuyZLqinwPTJzxcAcSIuaYNock3NKiAixdXxmpkWJzbdHJ7G4qWwP/kk7lGHNOUyjDCcJBdZ+NMnz/VE/jG6GIQ0bgMSsMU1uvTlG0g2tsX19iczYMcLLLnciZC6KMAyH6JIwNlzxNyQ1DaxHjyUDKLU9CxpFwLiJpiBFvfBtO4Y/40GpsF4H3L+z0cW/Rx6LjnO5Ytv6mnE9wuBudo0sQZNPfI3LFixBENICgR7lNbMtKIoygmLWScR167ncdTAFMxyLqyYK4L9IMmg8MtNm1LLpmlZU9f0w7UXwVlRsqMLSIDCQ7rNZglAIE1pyJ9mWKXgyvTJITiPHefl15i/bmmzZqZdfQvCki4E9iyKDc68tOygBAUpvU3fh9SkZNBkJnr4kzDwCxXg5/BjcqupVvFamIRW421822HBh9h2LDxnch9c78klAwnHwl6EJ8EqvHCXWD9s5v1mh3Z0EbENoaGJTq+uzuVsgY9kSOcv9ZxHlp0jMg9+sZk6pKXtWtm2Jrp87wgJzpjFVycbi5ogY1scovDFKVs4ZkMLjNfHMgdhTGzGlFFwzkrKvt3FLhzAfmhicaidAJ2ypRk7EWc2i9DUV0HJthAGgmXSwSWS0nalDMMOv5jhRtSKnsa+7wURoyyNH/krLSjIwjcAJytIf8SnjvviNDLOaCcJIHV//lK++FPG8sjV5uWLXDYx710Tzwfr45GVi6QyQ2rjXAYDiqYYGjAptUOrAddvqQgQ3TdnwCy2YJpZRG4nofbZtb/FJKdOefsvrbI2OPuJVEmghbYK0B1b0sezhARz9GGE/NVm0J4RaQUSMKaTQSEr34rF5GIDuj+eqYuGs2doIAMmkjv+Y7Rh4P4fPU0xcDzfRE0JeA0aNgkvCFKrTYop+YDmc/6Zf8Thoj1Ip/MzN96gd5f4SB8HXv8G2+sLi38TTgkDvNkSaBfuYyvBMf5h5nFFm9AeLgWzMX0QCmEiHeRhbkMLtu4EZ3s03RI0wHGk1qDZVOxFjydenO5I8TPodTShCNtNKtTE5TmpHY8CC5OsRcpCkOIQWe0u3IUTW+xmY0epTirbAFpDaxK+AxxctBOZuNM6bEhP0aOaphhU4ptvx+4mSO41s7zJOwAS27e/jogvyLIF1zCCMw1jv7fcx9U9R2ChObFSOJBbxBKB7bSB4LicOE46KJSZ7NkLqEOAUEVIbXESXTIzJCjIIBOtJ/JZoEg7cRM9rxVYQDRTBiL8EO/vb+3FA2UcMEe8mPRQ/PfNHWXyL0Kq2uMWwxnnIhZAtoE24Lj0vJDRh0FavJrRYv3ZtdjSdplFGckv7IUy+SfRBzO0F7Qh0BdMXI2lLpSuvbNnnxNEfBio7yYmxOnHDXYz06/vgOIjiz6Zj7a7omqQ2kKZxT5kdKZ1NKzAcQX5ndsCBralcJLKH5w7tHXZZzR6gC4YhAsvYFyhCskLsDu2JGz13IJBs+d17DgTxwxD8kiEVWf6YPuzNoH5mSCYYqCv+IL03rkCusJT2B3aEUlRXQOeOENtE0jffIFqCjNPQGvZqN2A0aW9TNkmYBLSZN6WMdp6WmyHqQVCn2GqLci0DcVkX9rEgnOwcPINYCafapvg2ZBCycRyby1FiEnj7synNmES2e9Yy1AlI4UxL20CFsTuhOv8nDDiI4YKb7pxwatTTuAKSq6waO1ZhCGtWHTtuSerVZDBA67hbcMkwxnRmbVt2E6ZDzk/3cXLbyI1CE39KgX5kUV3LIoDF2QitSA55ZidOzFv+hKYvk/x6DsLhWAgZoUkzw1KKxYoXxT9mXBK5yZF168UCQRg3QRNLmJUH0sYz0MWEQawzE4UmvFJX0PLWwCWn6en3oJoxEcKwrSsS9t9mHmAhTAOTPrnB2xhbusB0YOTfMgklmjkJJG1cjq+vxIppaFoRiiqB/ungf3IgmZWmKom3A4p0b3w3EdRHR6jS6AAAaTsv597nkOWeDMIzBey1KMXQgM9COvSD3kgyRIPkpKT08B65TsjiH4njYE08XS7fuO5jK7sfN5QW7UiD6otESMaS0ncrj68NLGWT01eAeLNE4KagriKaHd+A4MZi6Tzf7eBi7deGK3467elYmnS3+RqpBUA5Bnrr/JQkhjZnOJpxDXiRhajW7EIqrhFUHguqUpzK6/lqceNdKu7tN34mRwAWQTl1A6jwCNHvSiyHbLp9PI3IUTJQYB6U3wWXNpzDmLqs4W9hBPPaB02NIdPnSnhM3c7JA11zXwLB78kzFaQL1/w1IV76S0aerxcHwU50u0wuYJEzKcNDTuuMQmyMK7YxuPKKT0clh0uOAXNNDnXGATplCUyD1IEcMLfLaopNvGU5e3JzKVQGDoaAQUPUr53RAr1Rxsu+I4sYs+y4gh+hH+w0DCFyfAaHvjRJhbp2XVQuA7OZAttLLeBt2Bh2Aos19IWg++9ix3WiqE5e7YjisPztVWS7Ct9Ofa1NVLsa2tk2Nc2SbCvrZNfU9f0w7UXTVlgo5U/OPqasflLQ3QjM5G8E9qlt2odptnGb2K56/1Q8VV0g7vjVrIf5l95biW0j3b0KZ6DZ2n7Ri0UPprTiL9wFpgL1hKEAdt4jywxMLRu3D7Yrhm8QBVQmHFtQ3dlr6Bc6CzxImvd8J3OPwdO20DdxWFExPq7O7AJpyk55GkbvhMgxV7wW7em20Cn3/eucfamLauaz19pBmzK37gxz70geaol8JL8/7/GXtTYQgYIJTzecAUjeDleBAzijU335TgpBCv2mFeeFTc2iV8ew31aDfYKG2YSSK6BOhL4KO0btKEw04LPwuWDNhaLRWwR3XphaM8dJu5dMvOBEigpAHK4qEoAFZbpgvGthu01O9+AEo7IS5JDU2iihEYGWsrh+Rzy5+9YUri78maLEEafoo0zYxvQK6gtrCeOs+W6UC5J+Ua6IwXkb0N9q+5RwmeZkTk3Q4YOsCyK/S2YU3mLKhwr8FqE5onvFq69hvps1cQA1aC3c6XJBaHzUKJtGAfdvc8cCqUQJt9edUK0BtDFsN1Cn7iWSHBFFwymLSRIPtPZ8YZvKG3JTh2QrB1I5Rq4poMmHMgDJbJi2G7zwUhB+8SF1MphAS4Wph2de8EX2XTHd9IvJIGEkeeTsGVk6A9YFLwIA0YU0Ol2GUE3jZgfZiLq8JpO38cuuYkraebvjryA3QT2yuaCCMMYqWHgj7sRnNVSI9wOKVI95cuXv+ZM03zCA/YttgPWsd1OtGadjW1ZDpOLrcWe6Uxa8UBH5gSzN2C1CTvhN8eOWKIgcSBHiWIEeQwna7Z4aB80M+RoomsPj8JDqvg2LxxhK0euEhm1gYORsIARO7jp4L+48bm4DjpJMgD+YoAqXxQyZtERKHuCE3vJ89h1mdNakL69eLjj1HqbaZNTqB5qNM8ege72gCS4vEsRyv8LXnyPa7MUQSTGjE4E5RVDgjYN5j52Hs2gE/I9aGBHL/JWOg6QUZ1zXDjzcIW+cJvoPF9CFbth7MPazGfPPPCeOK0dTGWKI+SyJ7mCo0TgVFPgNHPj01Tk57FrgcwSrhn8+5mhSKGE3kZG0kxIjIc0aS49x+LQpOpOcHAkDteLOBY+UJ0w5EKZExsF/F2kh0itq/syY1grNyKvgSO7FyE5rb45UIWVQfUzqbvZbmiv1lGYh2MxIOZWFMRsES6RShNfhxnuWgSNK31Q0a6d4JZOHK4BlM3CFsF65ICWL2Rw5aX7Jo5iTtpLh0EN9NB+ZB1PuE62ahHbDSZtm+grWIFvzcWCEwsub1Tt9W8AtNjSjJ2opejYxo9eWopty5qJEaqtQKmh43cdZ2siRL/0BOvXkKIWneE1WNVC+seYaWmjY+bGm7AThZ6ZJBTnO27HASRcTYkxJY9oAKxXLxjARheuy3+Zo33uLCQrJus47VHceK4HL+q4seMIHjV9v0UA03Fj4YYgLJVMpChFXL7p/Bp2ita6Y82437KgN2UB3+hAbmrPBVI7izjktAhfdk7R2TOYiU7tgC2i7Y9x3I/2ghMh0r77thjjr+FPlkdqk1vZSd1tJ4WvdpHr3clOKncPzGvHfPFi6Jrnn+48L7rEy393jH+8ZqaF3fKJUTBjff8Ogd86/l/b+idOK+yaJIoJHA5leezw312l7Kp/C563++iWfyDcNaO6XZMsWxeuhQsX10ZekUERfRl0+J6Ry1bUlmXr8D1UmF9R+8T1X9JnbZHbf0ln0Rbgg/vQBo+U3Ra3FirR+3dES5Tm/Tug9UryQbumJcL1oH1CW4b2Xu0K15v860jR93RFS+Toe7qg9ZL0wJ3TEll64F4hblIYv2oLd9nTx+RYo57eXjCIR+0xiH//nlqb4PRNuIuGux+s/Isy0/fvKfLM1NvVnlB1RtfGQ6iDdk5bDqIO2intP4z63t3VFln9vfuJtgZpZNVplWJUqVC31nfikF1CfRkf11d0XjvPbS2vfLf+oc44rx0nvTaB2q/8HbBnWqL5HbBHWq/2fd++aolU/r6dRNxk2N/fdvGv5ED7nbuJvH1nsK+/yL+GhefA3dMWG8+Bu6X9Vp7v32FtEdjfv6doL/z6a57Zu59/tcj9+Dv0TMb9+Dbw/PDfndNe3+zv0ENK11naK9lf00stWcz+Ipb6t2Rqu8v6gfuotR4d372fqO/378O1GTArxRM1vu7jLmiwLGLkQ3ny9oCCQmgk6o3uynfXnls0yLUL4JlrYX5ouqj6b5yhL/7VnAoO1yHkLcfa6564+fOZf+UjiO/eUeRZSa9/0PeveQxx8A5qy0HEwTum/UcRf0WXtUV0/xV9RdsyMdxlcfuX9C38jj1EZeG3wzDm7fpI17UOFtblKnTHD7xHG2pQiOdJ58jEQuVJ8kHWsTwWunw0GbM6j/zlVicOHL5HTAqn8iHmIoJZmAK62SiXsYulT0znmIUiMyvWOl96wYYFwIWAMpxBm287+Ho6iJ4jxhnO6jyt+ZaODxCLYh8rhsAHMjBkyU8kGsxF09iO2CStE6Rqp43tzH0sA8NqT63AtfD8l1v+UlHVmlmtAMW4IIyxtv3KXkxE7YMWcuEU1/8WAjs1I3NuhqzF0E61VoBbsehUu7JX4v3TRWD77ZhpVuC1lB99/kIz4AzYKlTAiPPPgdMqMOeBtzl3zEdCivtrsGTVdX71mxnYUAyUGiw+MCmoC3fpYdUBMwrs5yvPituBJ9uGFkgWcTxTDtJdtQFflDR8MsMZlM+bfnPagMsORRi613QLVhnON591nrzgQZTxEKamK74daby5sh6UacQJaAWQdRxZ3pNLDYvFlrbLhKBGkc2CFbPENYVDlrcRia0glJydm00vavc2mtPMNQl/pLchgbgOz00Uz+fkJhAW7RHKzgM7ETW/TlzrJC09xZVVMVAmTQ0cDXonSw4r2bWbrh3Zv7NLPorX8WbOgrAdwODpO+YzM6Ks9Nw6potyL7mASmDsuRWYeNvZs2/CYUHu3hc7Wt/KgyyxKwzbDveObbyI/eqzNgAN117sWNMH2xeHI3iQ1wZgeFTXxkmIFS+58gF2GC4+qeGSR8U4PEKNFyOFbxHsdwFFoQku2qL9ybSjcw+RyY90cSQgqCEImDiIv4LfhRqCcZRReyfZBuLQXMsW99GVAtDdZR5oHbiZyTfJUetgTQptU9f0+cocUSiRvgdc0KL+Zcaw9UA/iKW8DWvEHVuygH/JNp0TfBx22pklQ3mfNvA1WzxcLM+SuvfZazLAsog62lDv9zuhuWEdcyGKwuMXEF3AzIj990XECFlXo8Bc/P/svWtz3LaSP/xVtk7ty4ceW46d5LxaWbJiJZKtaOTkv7W1peKQmBEskqAJUtIktd/9QTcuBDnkzEjJOYWmnJMTEZch+4dLowH0hRerFsVVxegMupzVNyKVs6ZUxNazQr3qTvWM+h5PWkifsfQIBh8hTtIZd7yIJCgxgP7r6saMPf2b6zyqRVR4I/BCqGxYBg+OVHIlKs7k/Nez48WUsF/nTuQmKZQ+snujc1GsxPG7Hd1sak2vFV5BK7zy0CM6QH94UYklz9hEMRdDmA+w78kgLuJcrTGoyJ/xpJ7BoUwN0PGWJbqTmqaWY6ufxiWv1Xf/YNNFGUtYl2AYZL8wOgJRJlYrAIqwWjRnYmXO2WjpwCMMVONssaxYfZhl7ogUlGZQfJDUUbUKnlyWWbz+qCRZMpiagj+onyU3US6jVDHEmuesL38TG31oJINH7uYC/b3NQEj4K5dFTtvhUeg+Lb6wZCo9h/RMteO64CbVb+qTTTbZGddDN6meG+GVv/H4mC1jBXvKXHNyKIf558RhTrkv0TsgT55Jl/bRTrRn9a+eCdiv4CrjmWDl9QOcM/Gij3faYt7k+nFQ4JscSkXtJQKVU5yeug+1ISv8GCYm6fmIjJTykeEqE4s4+5Tz2rkk1VWhayCbDBLjPOjVS/UP+Su1cTA9xQpJDdLBq1ev30btFFKUJLdwBo+vr9btIei5IHRY8Wh0x4yVgPCiEg/r6cJcsfrTHasqnjJ6jN7OwoM3b76fDEv57uD7VxMGQ50/vjp4/f0P5PunFSt+nrtgCtQlDHNbTP+eeEAPMOcPLJ2IImAHXh4VioRiJdJFtIx5BqvUvRp5UVxHeVxOUDNpyR/qRr1oZt1Mhu4m0xHMiiaXMyCVDMlpXMcliHC0yJbql3F1xmVNi+6F4sG0KEbeQ4LkG5aVQBTaGeIWpeJKdDceA+ZNCe6GWWqtmMnA0N6dTkSVh2s2v0E0OrMGawqeMW05AppbZMiHbV9TB7/j26C7UB+6bArQxsJGD9vOe4P8+1jm73iRqpXfoCAGYFGJe2kGvCZdkmp88NhxJd7Fkr39jhTh79WYoTzwK1AEreUlQ6f4odPdblYijPRQNUXk9lwUZISC3WvK7QNpwq9YXqotIzMunmg2/u1JwJYjELKh0uwFPHacidUZu2OZOUTBZ5qko7czHnIwA59+8Bp8JmLjUORnsSDS6P4pG1Dup8+bulHUro3HlzsWuNO5HdDem1AT7+9URsgy/y4cQH/oOsc7MNQiYPeyO2jn0q5q2vvvYVXFawpYLtnXRq1pH9BpaWWNfSBsjD6dJjS9B6Gc1g9TQcPlOfyqTm7UAHsHf08hLBNVML9BBCZ8XdDxlrbDSERxx6qaIJZEVMwmQFBBa1LU/Ovl6Q32cZ4vScPCzevx+fkJHMOTQcJgOF2CiAKrygxiUGjHL5moTgqqMOKyzNa9OfPCbq0qrAbeROAi8Ogmzm7J7FiGwNY3lbj3wD4kDFchLX6aRNiutXdBVOgaHJf4MK1RKf+J+Rv7nhPOslTSYvePAXxaKKAp+1TM8fJyukDRqdRcUZ3QW7//Is6Q9YH+bqw69VzQ/uQ0wiaJ+HNxW4j7wmFGZjxlXozhah1cXGanC9f07mG1aoDuyQM9Lcqmnu4QbrrdGXi0or/UoZc6bFvqsHIp1Y8m2a1wuAYDF07NQ/YG9HdwXtufgHXyy4wFO/FVBuFdCXEGzrunC3MucrNXnTIzwnzVmedxsdZof1J79Inu5tJWEpw3K/VGMpcaj4SJZxBy8jDVNk1OH6VdVuSEYWYigSvgzrZ0kvNSyX0T7kZZZry+iMMNB/HkvruLeQbRpM1F+ET3Yl8ENyHg4Btk9MUeuftqJyBpcJ8LH9dHUbQZE8K1zOK6ZtPElkOM4LGdspwQ0KbgXxsw8kjiekKwFC95B+6dVfVJ7A830B2JfMELlsKSfsaKFfGFfQMfPsOMgy4ku5obl1tWl8BJ0RdxFbC5/y5UbtvjskC1RYdWR+FL508PHipc4U4hbG/BfwdC0nov+wAko8/8GIBG4Uy9VckrAUev2sBnY29d6b8f0FLJ4dG+NMDbVaecOjr5z+M1REpJiKLCoCfaYJKlM1it0/lXVE21z6FHGN7A9EWq1bkStUhENlP0coy787PK/VV7ajQjcs7zMuNLDhIYKT3HfQG6oukg80DhMaYTxyYJsb1QYfWUAOq14BSmX8LrSfahvSdKWWqdt8kp4RM518pBcnoD8/3DhAemy3XyJ61twpMgEtvrPQkjrc3QHhC5vIzvUTRjSgKV04L28/zTxyNtpscX2aSm352+F/IunEX1udB+7tMpAVX9V7OHemq7BzjkNLkGIU1scIGA9sipOzX6ha2lNoWnYzUa30cYYQCesIcUx5fncWmOHy43cvFobDL4znmaZuw+rphCCkVdlwbTxUnE7YQ+2myjYeBdEOJznv+kDsGDfmgPixQcgmjXhsYziJwSTmQ57x9Y0tSMkuuTffElIlfvZUeNVFSALTsGLzhhCjVZmIc24E4X6uFIGTWz6BbtHZe8xk69dFF40BfBb1BA6YJ9OyaEM61uQkgfmazJHVfvAHbXAqMISYez+lzzTLZ6HUoAY6k+HjupRI5TbALgLO/XACkCOgelsLRl5eB2RWs9bOZ/DDjYxs4lbXQ9a7NAyJwUPiU7f2QsleeEbkv2wZUYhqIkLbVZqNdn8ZqSak6x4oUqj5NEkQN7gNkHBu4n0cew3vx0Mgi5QxsDiKoefk7ErGLcocsjptJoUKrBmKt3aMUBvT/AEsCGoRyJqdc+CpbavfYnKFWkDSzqEM5In0cj5DOxogrHzDidGxWijpaiKdJZnKbGpfmV+G/RVO94EVfrK7CudcHpXHCqd5lIbikaMNi20OWXLBdwiwlnEJrpfKjrMuz4VLswaerbOaldyaA5TVzwxDg/nAq6I1EULFFLvs6aCiz9NK/jejqQzCz7hRfpVDBZ3X2jCg6T7IwXt1OBh/fKuN5NBVGiYwSRg4Vf1Puek6wxTqvV6PuodkV4tEzJ2HUbGKCf1HZ7DMyn+wLuUCnicD53Mc9EhqW1lR5CY1xWH65WFVuphZWU06MhQEs8NqV51tHHAxtGw6w7JzqVEPU0kWE9mtPKziDYUzaa46Vqs7+KK6rsu0W0qkRTvltPCpN79FAdQc+dFuTA6ZsVXjO8TZ9pPeSjTqaOrlXC8nslcIJNDh5sPB64rHmxIiVlVDoCg8Glo7AoUDnXfvHvtE83k0PLXlHO/KAyzrx7I5MaKn38qX/0UxWXN7+eXYmf5779+i/gH9TfCFPAeMNXN5n6f90+ARyXoIUBK7trdYguIar5uqjjByrnLXqcGbuS3qGK0a51oTPkhABhkUlbjU1auvx7AlUj8zK+nzTEpZprmuHrXTOoNU6rByFkFY27kT0xSVSO5ss1tfXrsfjOwLeh+tBpQSX06V4IbUBXkdzCbAMpeYrYaPWZ2mNaw5iOZZoxw6DI+7dBShnQ4fKmAUox+8NqRSWm6l54dCgkypC0To0ZdK6AjF3yDkjHbQFoD5WikFOAZQ87GFjW1RjtR5fSMbbWCK29qn+mYXQQASeEKyIYSXMvbLb4mJUMRWBCupd7AVTs8Zin/y2acxYXU0J1mKFXpprfsSnBwrulT7iYvVv/wtaTwQZ76Gkh0hFRB7gjIe4Bhzc6Q8setVq4TAZVED+51KemJmIIbiUNVh5logCXJlrCgAQRM+htEKwnPcI4XAYxodzot5MTa8Y3fMMllJw07kLICqLnDuOQuPbO9K5ZLll1xm/ZFECV6n2VSJiU1HZ8+2BCRndaUIMGp8VzrnVijrmEqCqpzQsZhe2YuinP11J7oG1T1Civ1ZuPxX1BhPiVNoBSw/1EWJPMfh6VLpjPfz2zm0l4PhLFkq+oUd+miFB+IWS9Uu91xNsMgvTb2UsHgjEAges0rU3ikgQk30EIXpIC/6yvmKz1EYlhPm0GQfqNRSxrc8mMo4G+6GMJGcT1NdyPy+vrUSGVknP3Fs34HabBU4G59lXFSxp4tKMA/G8LoSmuZEqXfozetzjmYZ/g9jEUaiSlSsqTdRVzIMcpmKgkJSBNcROX5Toq0BdWJCqySMzNAWEEFUtElZIlP9H+Az5VR3hJTxYH+PONlhzuOnmxikojkJPFw1cFRt0hSr6zuCKLIEXroqQmC+A/1SpXyBj1sAmzp6ag2wVa6yIyEhRZYUP9ILllqdYeRJ/hhPlqDgHM6NIvsRPA6SRZCItMrDTx+K5qTRsEaeIX6OSMIgZjpz4VgTWH+x/SYOjKqglKGXTXhJSVahca0xb0bhTBEDWVKgBQ2zzhFeF1WX2S1ew8Lugy1ZInt3RFO4yCZWNAHhHd+fCiZivzazylnA3tQ5MscC37bYB2nTVJtcOgik1JIbxm0V1ccdAIijKe83YYgqFfrhYbKUO/bt2Kka+KOPP6q4zvi6MbnqVTQXQf89oY1H4q5nUqmnoik60rJ5OeabiTVxPMExlQwQT8WdIDdX19gwHtIT/nkMuOF7h02QQ9TMYDkBRNlbAoj8tINiWcH7kO+380QC1YkdzkcXUrZxhZLlIdtRRVHhcJU3IHS6NUDTod0JFBIGpFpsinhg0SMLkWsWQTwKYVn/DVL7Ci4yCTBbcukneQmCrAqineuR9NAORGzvQG6haI2u59rr6TxxNHCtu5qXdnypZKIGDpVDjQFqi0+VAmagkfrsxRipwt2gBSdE5SPEQ3zYpFEhmJ/9x2mHphUc/J6Hg+BhroGlIHZnTUJzH+vLl0XwVuK/YYMMGH3nwMmNBHmUwqXtZw57CMm6yOeJGyB7PI8oI5T/EkMaBzagPA+LILDkecxmXN4PhpAQdqgEefdmgj5OOK37EqTBdGA6TrRzy/qNNATTe2kn3V3pFQJP+ML+ZfMwwpBLcGFIn3eoAW+drpjgZxqCueqO+Kav0uxHOuLVjMmeo4oHOR3FIAlIhCcU9g/yYUwzFLsiDdLu5LfFyB5UzW5AXAkPRw8EJt3lsERAFoHxM0AXwu2EOJoSqB/jBFi1pGRoiWiAC9y7VStZcMnvRjkRyJPDemralLXcUrYrTXFc/RaegZRDYkRrxTC/soCgeCIIazmDQELqlSHm7MgT7dR1kscfuID6c1y4MnGZ2hqZfjyZxLkCAdvU55a5OfDp54F5RBb9lNIlTPERsDXRQph5/FKNSbMNx+FpV+2BsJhmUAM7AgZc+/BAuP6lI5PWBXVcNIoGp3NeiB06WC5MMpWzQrJNs7s1ZZ2n6eArkyXjLHc0Mh+MVKjdhmMbsX1e0yE/fSHa/HTS2iJBOSRbpOlHKZNFIHkv2Cl9Xho9Aeo6MvYiEjhUfRDKSHdE1jabcUa+0VaPOojlcv8i9WoeUnHtIm0midzhZZ/AfTtgZpowW6+bpI8FgXFBzCWY23UHxIj2SXANIp0XsogyW45HophL9zElQG3JjarEqrHMIT2M7ToDQsj8L9zk9ugdJf2Po8LsOmEf6G2+s+lSH3eB6XqCYTam8b+tSfcPu6pTHknr5Rn9HKavop3CWoT2nAy9Ayi+uaFVptLtQ55BF5oh/DpFPkvA599bE0wt9wOZJPZcg8Sbvs1YbycHih5ST9FBrFRtsX7r+XXEfFMXos74u6WodKLpxJ1EEdp/QpxFPD1rIGzzoDuzQYJ1llNDWjQm6cpk6H9QTsQ2oKJB9rVdxPTX3Mq+AJZg8sUUPivcSBHDy5CxJUZmI1r9UHaLTpilEZrJrSkNx+bCP1ohIgywALg2BnwfLbMmtWvIArseQCH/VEg70M3IAdgzUED3rFGEQAoRWQfB0sOFlf6Puoj3HOQgeiqmZxwuAGtQV0qTPzgPRwHkV/XJbZ2gMhw0chRXbHLuL6RrYwrmRYQZoeR72fSwPHkmdZpBP43GI5E3F6BK+gC0GtZRmrJG0AOhX4rmI3FL2hO0XnzCfo7IkuFgkamyB9QJccFimhRXwclCguNfeiDAGYFjX68QgMo8FG6meZDneJ2jtXQkeJnQIimCCXLE7PWX0jUjkFSDp9IbI11DgWTH4UteJwGQkpch+EsVT01595Uf+AQYsnhKkAj4osnQ6ij02+mAar0HhAWX81JUDvIKqdnA4erWFKEQ+7A2K0ZbisISbkP/5XwVASanID1u3XhSJK/uOf//Hq7fc/qAJRlTdxcY1O5CH35es3KjdVq9k1kH+tPpwwLPru5YtXqgh9nUv3gzcvVZ7ndvJaO2JQJd+/fPO9KsviNauuISBRxRcNWqj/8z/+VD9ZVrHKa5K6qZjKOvjuhx9VdfDPq74Xm4o/HvyfI1JeL9bX+LrhNwDtXm2V8z9BdJ9UL16IB9DkS8BJvKhZNgcHcijX2UQog81p0PJZ2SwyLq0fI3MK5o7FeDjmjOM069SnKkR7Fvk1S7SpnGJA2p9ZHa9kV98d869UNk3y73l98yt9COesWrE0XCDWfn3Bavij/aC/7jnG0RbtNQXvOAM4uvb4aDBIl3zFmig4pNiJI4/LS3FPmv7DakWJ/m5W63HmHebPdbZR2JkqLuNQJ1h46Su6nHeDdvChQ4fu9FV0U9el8QP36oN6xiDskhDheuBr4kOfyXtRT2S+klyiB2kPfFkeoznkpbgd6GAeq71W2KH+O+bQmao7EBCZrukrH0Ho1MKx2wzC5USZUO/AsB4QygPXWMg/g2wb4CNUt+URK1a8YGABXvOcaV+++r8RKrlTcTW/F5DQI3bsBUIrJ2iNnUb1CrihDJVVPRoWej0qK6b+G6r/nUdgUoXzJlyn5MMYcjWeIsPstCfy5FZvGCiOsiE0ITvX3YnFho9awVWQmjFAvJINJX0kH5msdUgsIlhADMCAgGUlapEIvG8swDwl43+wn1XJhSnA001JGZYzEqYPJVXfqbjro0smS7XOMEKQ3AJjtCnYHRmu3CGfy2PGSm02+f5rE2cUQaTiF7aW53FNRqzskA/+t2AaBOeDax8QispoiZfwER5womdniTtelRfmAecj4ShZ+KYS94eyxTVBSJfxPbXeWsCM9y4DjkSufqUkGELSGOAwgdeyWDt2l/oABpf5CzDQuRFBOg99EqCftKhJapxV8X00LmWqieMLmgSFGfk1i5zSBjr4RgPv+dfM+J2mjAUt3VooARn4PAUN2rROpmNYQROLUTvUgRbFHVfc+Up8ArXDtQzRR+04Et6e9s3u1OtSHYAYgOk4oL+5zEmgSgWTc5WSy/VlkzGimHgR5SwXsMZWImFStoMRUpcsEVUqJwZuxWoNTG32iEKD87YoB8aHHBAO2s4xRU3y3gIK11uDjCgiLb56OYALNVW9yxGi2CrQNDeauXonCGkENxFETHH8Jq5ZiKoP+yFa2T0SHg+5HdMlW4HJB9V+cke+kQlU6DKUDDg5TGpXSAtW3V7JKW5eqNrVUF4vOOm5zp0ezvasbBMttdX6r0D+KOoTsER8TpiPILjEs0J8KbKMpe/UR54TavQLd6XeJJr6OeF+j34G1cMzxI4SfBFnR6KQaM2brCcP/7TAQxC/FaTIkIYzdseyQBsA9esQsb4/0Ap3WhXilvl5tlMpYSjjSjLjn/T9A/g5Cpn6VBPakt/JIED5FZOb1LeZgSNQLKBDvEuHTHcGLuEweVKJHDyFan+s/dyQMbDirlWJ12S/L+6CZ5iGbPUnPCorBtFr1S5ZRrIWFeuahh+1xXMoDXVdNguy1jTW5ghNhhEXZRu08H3R5GGaVe+HQrIaY/eG5Kb1kRCOFx9VElEQRQDKBdQxHBZr6hC41EOJLPl2HJEFYAYRHfq1xbeV/LHW5+K2EPfFJfvaKNnzvd2h7ahCGnKrQeDgBm5Y9FRYW4rJQUWqwWf4O1CyPLXi2U0s2wzS/XfZjMw/V0AOXiasosQ5k1L9hDACOIsGNSuyGLi8iAue0CUf5sGZWNEGgBOZMAqj2U4Rgb95pLuZHFg5ftklwf0yKfntFHzVg07DuLAzUIW8bIDce1RAaEvD9sCIS6j6hko81N2TNiw60iXBuvoAGxJWS/U7fU7opdtuucDMOWSG7jHmiXhC9x/Th0XST9s4CCIO2/oAYGbrCyP45Od6+QM50pvgggnsJN366mldqhybHDIQum7Elpxl6ZVoXbcRxRGoOzSn7Rtpp/Sty4SqTPROBtlOsIaFgwCc1vKFNuLoaDKHyUYfj8Pk0UDiMj/EEE6y8hy/uLxgZ3YeVzxOF3SFi2EARAQLn3jz3Eqr55BxvAhd8n4EhtCl7REovFBixlFcxgueqf14wB5WRwBU7L7i6FivYEZBtwrR2cYQjA1Rg4C4tJX+kD3HbiU8RDe95vAJzmVUVfQpoc+h0FASPov7tDxfXonLXglRMKXKZASxJLE1OE7iktdozEWK7KYgRfgxR1Yfa+PNW7Z+tyZAdRb/sVbSv5Kta6TbTxMgHyM1o7plSCGbtxDcFPxrw96t9QDXzwTIFjnHYyz4Gxy5Xoi5qGay1tch19f4fH2tnkyUPPXs1QWleS1u1pWQJXNmNV751LCaBS50lFJl5nG05BmTESjam60/oPxs3Q1mvGA0KV/yB4hLeBHXN0SbHvLTIG0exujX96SskKrhYTOjzQpsigyMSgcrr0BOYnMFQG2Q77heu/UhPfQKqCZcgTNR7ZWFHjrwgCgUNkQjTYR2POkbLqGH8LQ4R+dAGwAHC4LdwRbMSAgkDzMd9d3N92fFF0qwZGTpR/W2O9z3BX0CMgKEzo3XCIDAz28c1fDQnsJ+VKnQj5F3kx766fEWBBTCo+1HfqidoLaILrRyWTFeqG9m5rxM7TuM3vZhkb5/4PXp0ueoipTf9AwPE5XqEtAD1Gsxr4Mlct4swOOo+h6Q2qaCJfiYLZrVabEUaM9oE8GSayxfmIkpjM/BEnuCno6BVP0ULKFX+NFan5K6RLDkGhUJ5qlLhDsIfvOCYAfOYed1k3JkBPopWEK5WgJmsI2L8E4Xt2iwNfsdU2GTbcMhpXof6o9hPLyRwZJfZnENXptncZKo7wPFM1bEC61d/B6fSBGfcmmpP9aPBMhv6huw3+HIUc7ggQjR8kbcI2+5CfMOfbidRVObhlZP4ZMNoWKlKmbEmrtsMkmRm2i6KTKSa/VDzC0h3jo4nNUhx6rVp+oK4vcQaPxKgCOcmT5jNw5+QpYFNygnNkkN1eqDTLf3MT6FT7mi7Y4n7ErcsoLgcOmQT2vMdEinN3BYcccrUQABBMeNTz2tYeNTTmbUaN+o8NkoLvmshjGPbuhUrt2i4kSY6zwqQEAWRkdb6m+w9tfbCMdt0ryOa1JNHmmVr1aLANof3BcmcFZw7n5weHEaLCyj4eHuod/HVbY+TMCw6SSLV2GPJk083p18LuGk2dyguBuVTm7gMCTPy4wds4VoikT7zOjkBE6+UX9Um/CyqaMy1hM7hX1LDg5rsfgTlgapwtVDo2+FkCUhjngt51z1wgmvwGtw2HdGGkNR4kfrRuqLUpF+LOUcM86EuG1KAvQncQlKf8iZ7hQZRzpNgS31yL8Qsr4RKx8FhfHTVHfM05Obx0t2yeIU1EjViHpYB782iLysTcIo+eIpSlKHfNEzQDyuZ25ho7Eue+TXLIe9Ayj5iapGcyDtZNilwpX8knJ2fnQB1J4n4TJNe281+x1cNOo7N/MYPs2tOcFch9LqZBCkX37NjnkVqqQDklrrJqCWM20VEUtFZh3V4HUX1ZQiLiOMHoI8E0tBIXKOhacSFTxI4EPXLHm+xEOK8/OTD7gUkCHd+i2r42rFaukiiBgLyyvMhogKxn0wGWCoI8AeatDJF0ULrHPj/t6Wk4d1moM632QwrfxeAvOJQC0nHgGJux6aCB5wC0F52AEciO50JWycp2PDxxXLOxKKAR6uVhVbqWGoTxdC9jD6CHTDJWSANdbqTfXSXBGU0OqXTfL1ldJ5XKwPi/SSqf17QRyRORydBKLTIsmalFGnf0qDzECa0igb6B695gRpJbYPooHeIY7oU87pLjVOlKE7RUAia4cQWRw/VaIp363pjqS7Ff3BNG9y+iDOeTEBEPHDRHiTg3FaUNssjmMhuPMdXPawT8iKHmbNOKxWkvq6dxGvwf8G/RFFujMcip/YBCY3hLSIK8pQTsAziBpRdJdx+LpFIWnDoNwP1NkrDqFLtpSk93hkBQ3V8odZJu5ZSrf94WatSOe3vCTVDS6jHxfsSrrAEGTAIMU8kbAYWBcjJs9mEeqYGhQ7LIP1egayicIgRrrWBjhyVhHHrFhnPPAwiHvgWDQ8S3WSMIpuDhkg6otNxqKl89WDmjTnmBuu254nQqGow7WBCnVOSHbQ5oJoXECn5HQvZsi07FqCCSrxGEYAWTfcqMzk++XOtY88euL8LE7Ti4rFufFN4SWvxFw0VcKC9Ti0c+RpV3V+aGA3EAfKiEG8j2Xu4PzE6t9VWnM8ykAABQy487gkBgNV1vXAO9Lhj1u5TafJAAIo6fxrptEAU0t/bZh2/dfLIorp1AahblP0kNiHbrcEaqyyR6ccL94XTY5HM+bxjMuaPhg/TR/NV5j2CoEkiieP8biv1RGkdt87hoSg1tzVXJ8EzFCXQIeJaAgtlI5+3fZusuPexngaCDwo196YKA8v7I/3D7BJ02FvvTQ9NJ4ROdxEsvpGpD/Pj0XyTqTrCcEhDeW+ghCstOT+kS45rFZ420q/U5hM4pL9LAlt9h2MVSYWcfbJBPRrU0eiWPIVPTwgPmo3rk1Oj3ptv2QMTGynmM0k5tFcKMdhQWJqmHTJ5FChkhtlbHD3gc4E1V9A8A5gETKCdkBwc6kD0qgHXEQJgzDsbQJI6G36HQag+jwu0R+W1vrRGcdsCbEjOEXRxleVGdCeOcpiKZXoSVac7uPbAEd0R43+qEhd447QD06DV4G6ft0xtLQab/fkyWQSZG7zdpLYZ6Jjy+knu0HmcughsqS7BbSTQQ+PWizjJoODDXmY8VjqM/TNXHrIrNeqI1HU7KH2Q0eZLHqY2vv1aKF3AthdIufTAQOeKrlkE8ID77mYGCpRwrvjjCogZ7iEvme7tkw6ix4y9DjmiiWEoM9F4XZ4ErSJWu/BvVJaum2jmE0I4jhnGNjrXSXuFZwu8vE69PEPAp4UQu2guAuwzZsIvgF400DXm3tbJ+Y0EOvsHu91efTxofJTF57LmkLvxbK/cNqsiaEbOmsMDmKcxmXNqiiX8mumvXa6cDmJKO5YVR9XXP0J08xtG/l5XNIiXbV3wVBYjmRd8WJlXKVW6otz9Yo8BguqI1drjpWoAkPzMJpg7tqo6jno4mRNXgR557MH9adSZPimM3YX4HH7HggOK5LD5jLASIibZONTe7N0DslDXetEfVQEaKfBC8VkGvicrgwwNPWn3ZIWVq+ABCQ4VrljV2pxUHxTh3xAzYbNbMpwuDQnfWf8lgUIRHsvl94UB0e6KQRKjLUvkKRNXonPFScJoqn4lfDySIIoK1GLRGQKiRY7RBXkqt3FAnaLF3HBk0u24mrerHXso15m4CB+8j3LhOtLZgvRoNp7WSYkaT8tFBOFqKdUqJesSHF4Y7QpmwicaPUqkd2xd7yI9STtZFAjXmIwRDoAMrFaaZFBPZGh9T6uCjLE8hBdZo0Ry4I89Bmj9muQFu9datG1Y3LL0gtd7tw9enmBQyjtmnLZyJrCmuII5pIgyU5KpULySjs7eU+Ad5gF++J25YkaKhW6ZIfn2O+LFYRN15HGcW92JlZhHkDuR34SF2ZPeSXABdUilowqFLyUIw4irURJBMINX91k6v91+wQIXAJg5EGqwj8OR4jeYx6H4GpOBgDWQ113cctC32EwnL7qK3r+qqUNbqTu+B8MQkyfFhfzM1yR9UI3XEYMIsr7LdsyGpNNkfHi9orlpZv0QQbZfgo2vazoa2wMrY3fmU7f4XX2r20RRWQ5q1ami7RxiZeeAh4/TQyK2pnocfVbe4ncz5sAJDh1/GkisJzX+W4OeThmr6lziaFR66tRpcKTYpciDeNG5WXsTOVROGzZjkUNNwDye1wVvFjJKWE5lFchGsk9BtG9hnIlAtXW247lToudeHBtRFCSYpqPwz7TW1W0dymtD2ASFDujg8Ql6IE4zvOl6Qx4pNgVeOX3ofXJFqepESGPWR1z0L9CWOdMyvDvqvrodAiKlhf76fBvDn0rCYjE6VI2NKfLmBAW4lDkLS/DdGC+FYeJ04BKK6Dfp2Y9TiV4Rm8mgyUUMfZ30Cei6uh9bSuniJe53roS71wvorbHYAlFjOonRTsPW9FiKH9K+HpZYVrL/QV84Ea94mqUxpkZoHGl8qTaiDTTG6ju/uLT4gtLaor4lvyh01Eoc/XyAselgXB51FSVokCRDoYuijaW/oRefrO1VtTZUoEERNx3oZz8O69v3j+wpGmXwIESEqCMoxsh61Wl3UiBMYyfNxEYx+yOBhK44jv8ff5RfeyLNAHn3hd3v8WVd4WxuxYRsPWNhlPfXAnVVfyBFN2ZKFSVWt/Qwi36RcWWRDAo0YdV9Ud2p5WDvSSVGV+YczB79u0Eg242kfXztPhY5md8yZJ1krEPQtxqNraZTwJQWsX378SD1pPDRzL9AJ4GY7XTq2wHuAwSEPRNnbNs8pJEesAzxqVmnashJDfqexdZI/8fKiW5FAnijS8QtZLdcXZ/wuK6MSLVcAkJULUwGjmdub2ZOwUwsAfRK+AxrwiJIofZfbyWrSyi0zSEEZ7gag1/iawR8tN9YYO76WXCzyEBQuvlgycs59i548gIPQYXNQks+qJNh6i0zyQIL8Q90FwE6GhmC7mwXVYU5CVa0jBKpFesSFlFhmouUQvmZ3mKXjKW3IrVG9kk4DQF/9owrUcPT3TOlPB0KNO0dzIIQ+ick5PCA/fgvP7QLE6lbNjnKrPX+p1MElDyuPyFra03RHikseLKCB88c0RenS4/ivr9A5c1PRD3Fa/DdL+7i3I17j+q5ZilJwJ91Z8WVHYuPRToj50m9RXLxR17n5f1WpEviXCe9ULJ/sAzzXFpN4cECKtca9z46qNrtYWH220pmiphOrA45NOyaXsMvt21CG3jruKF9s7sJWnsqJn2IA3e3LVXrDZN4+RVEfOp0EPKPn8q5k0CjsmoSFNanQVlWStV+VlEYDxo0h/0cWSu5PWYilJES/w7GidhYNFtbM1oLHrCRPwNMghWz81nxuG49IZJ529fwGT8oPKokX50dgpaCkRIBysLfdJyW4j7wqhYESIc/lIQ1IBmNTow3lRS8bLu2n9v5NOA49RGzfJvLHL69hPdUhrQWgMd3+OFdlYSYkTLHSBcAmQFAs5IdgP4FGqkvR1AUH1KJ89EnLKUzrRwJxl600WJ4rhaUSKXSyqLWsor9MC+bi0HeLFk1XE3nwAS2d5o67C4ECF77mdSBFFqj+EaxyWTTUYShmOh7WmV2iTc8ZRRmCSqVnL7uZBNWYqqZimAUOQ/rLXy2khhcMDSPF/6cRlQ89RaCEFwuyujIAXP4VGPQcQiGxvHHMdBbByhVYvgr4mJQ5r4UAP67IXhnK/0uw7v44pRRVQho8Xjl1uKVLOK0BRg1qmkDhNoxkyYAtRuEFwSgGHpL1d0Y00a2rsB3bx1+CM4KEUHykHHBByEseQsSyE+UvAhDQfJDzwaoKG5XLWR5y5WoUoO+xAd6vqaozDAkHAtGODZonkMmty579H87BTIDtmh7A7Se1lkyIcoEH36IS9oAJ715WlRV0KWLFHrUe8IcbOIAChZ8sIY05hjdZ1BgHRuzlBQf0sLal4GAQCtkEZD02kbgo/moOFENEVKj/zjxUUjb05XhaiYtaGGe42TLF7RQ2OW44+MpfJEVAkjC+FSvb9+X9x9FMUpHOLFGMyWLJxjdjcBMMeL40qU9EYXOOM0oWvMpf48Xtq78YESApCagj/MRXLL3Jk8Jk4qkVtAIQcXHhGy2isF2XF8ZfKowwjZf9cIFHcIfJo6KF7eRGBQGFkxjyCWg5Z4Y364Ysb3CygAqPcdweVVKXhBYWwFbEg7SmzoZrSjhAdsRDsyXdG0yE1UTBEmHRZlYswmaaR665HIrOPiuhLF6qeKBRj6bF/qL1lKlvZ3IZr6DhAvGrWuwgflYZGiKq2+itrIpgAmLsHnz7xOhfa3ceRnUNi4FVKRa7cD2tDXWZO3MmqQIZT2RwNbuMWZSPCllHulYrX67jpYZapNKEt7SIYA3j+UrOJATpxROj7rorAOv8gCeB9X2foQ1fwpgdCe+97fxVljgiVnQsrWp9/ngqGrYTAvndesJHgYMHCkETSI6+tabXjk9bV6utFBYNRzIoqUa4X/K2Z4V4omMwt2HtdVgB5hnwYKgnVQhEJXbHGRefxLgP6lAA0Ex4s5Y6k+NIcnUu1+zO66dxfEqC8zse4AgAwq4wauWNrLFipUwy1qe59KarzM67hu/Ms6nUGn5bPMtnyW0ZqpfLn056lKkqRfbUEv0aNQqr2zXcRVnLOaVR9CP433xpGxONdDKVTz8x3SAkRR7soLkEMKhdcN3Rwq40hHhGF6HJlEcLTr6GZa359DQL5uVPEgzbLl1wyamYEGSfS1YdU64oXkq5u6h0P/8FeocWoqkANTWhbK/2CdhDnAdGmESQ6evIlLpv+rFRgD1Qp4JA58oNkj2pDe/NEu5t/Fkr39LkTPpI8Go598lhAcpiWrk5tIM2a9plAJLLFBue8l8wh+EqKPzK1UH4v7AozuQxz844QrCbwK1zHsBt2paWTT5tq/c5DeB7eSXtKYlJmwUUPfxQRmIyvuOuNCx7sLUjAdo13RYwytkHY5ZwRWHdXg4DHOtH2QzuOGaEY3FagT2DruMxnh0+9fZCAzV0/WwbTvbDpA/yKyrhq88obK6gMFhmTRvYLxXq0HNkxcqUJerD7gZQ1VNHJSaJJMfYICniTj6lNtVGX1thVXENfGYYROdAJ/X5rM4LDoLUuZxUXETABhRFHrHsC/2jaxaorT4hDtZeZlXJBDIhXRetJUXL3zD0TxCw/wOG9fJAAgTKdIO0eVWmTaGAAFuz9N3VQhDuaYS/Uq0I25wqkTrBLZ42CBP1aVMV1M5LAkIsvQmyBAMQvmkc0jh0arlvlYPugcckh46jR7cWSdppQhwBpDEIFAR7h6dYEDV7veawe5kgwefVosZzdVBEZP2pMo0FNfiQ/VFQ/whGoXlELtBCodIxpHGNhhrwjNc4tDtldgapqoBDkEaaPf0loimAwySDKx4on15tQ6UAnV7dR2GOrVqIkcZTznWvH10mSdQU6Y+uNjmBSJd6ya3bAYQqu5IdZBhPZ4H3SNyQLDcFJsGTdZTQ6k/oN7TXyiRn/OUyVDgtNUe2hTI3XmeAY77ggLrmy+7jUyQD3HIF4gamQVMAY/6xgmlDgh/D/K2B3LXBedidUZZJCCkXQcdeuDMwVkRWtd8mHcK05GFsdSu3NshYQjtQ8QGUUoGZIMSCj2g9OEsVP7JMzAGfuB0GPJoajJ9sbPUhTUMVwpRkUTgzSR9AxTmocYUG8v+tHCjRcrsgjA1KekDACCXgrJa7qD6IRnoFFMsA+UkKrVPtSC8P4uRI2PHSKS2vtoK+JFsyJK+9cglZ73o52H6ABkP9LVJrsgSjoL8mBtQ8vki9Yoh4BDuFCdn59QUZAxpCvxDINAXYlTEw7q2IAB9WxwTXS4WlVspSTqT01dNnWQKriPRzdcQgaYf2E+Z3DBTKpfNsk/wk3beVysD4v0kimJtSCO6HOZTgbRaZFkTcqo0z+lQWYgTWmUDXSPXnOCjAy0D6KB3iGO6FPO6S41TpQhi+CnSjTluzXdHrhb0e+EeZPTB3HOiwmAiB/og+jusk4LapuscSwEd4yDywX2Cdkl26wZh9VKUl/3LuI1GNbSH1GkO8Oh+IlNYHLP1WvjijKUE4iiqkYU3WUcvm5RSNowKPcDdfaKQ+iSLSWs1WRRkBU0VMsfZpm4Zynd9o/LkhXp/JaXpLrBZbRRk7US7c8yXCvOMTBIMU8kLAYQf8GZbfPEZhHqmBpuBZ3fibZnIJva+DKa2XjXyYp1xmWgJhBb5/ls0XBYJ742vGLgNAbw9PMoQrIjTWNRO3GeY7AAFEyIAao0+ad5KaraODtoM/QSQwxSnKYXFYvzRYY6Dl7ySvw8D9OJy1MRkZw+oGJ1WvAanVE4O7yxMmIQwSeiBlRAjFoQz6T6KcmeUrt1dNcIipVq2lS/xzJXTK7RwxCrjJQTQ1tDODDUL7oSLmKYlyQJB/vnSLvodP1l0mQAAZR0/jXTaKAz9JBzgNqsKzlFVEdfJgnrvcyJwjq1Lq7bFNmRN4CF7ngbAENylNmH7qxRGUT75XjxvmhyaZzxw+OZ2tDSB+On6aNBhXGFQBLFk8elk9xQb4/aXfIYEoKabFdzfYA1Qz0FbZrVEBI6Hf267d1kxwMenXdRiZJV9Zo8JsrDywQctPeCrL4R6c/zY5G8E+l6QnBIQ7mv4pLarnOkSw6rFd590u8UJpO4ZGD5Tg+G9psMGtLYLS51JIolX9HDAwIXBk1Wf+lRr61wjJmE7RSzA8M8mkvLOCxITA2TLpkcKlQ5o4wN7uEBDvwFBO8AFiGzVwcEt2OABB9wESUMwrC3CSCht012GHwlj746zlEWSzktSPTRKAE6WHd2O8Hg1h8DopJS8hih/1jRBkrZhHGgIiRYehLlXloHuHu0ZDLpobEP6IpsTpVh+Shos95W0x/UtN20dzn0EFnSneTSyaCHx/hFBsH+MOOx1Mf9m7n0kGlFaKOq9vOcOIB3lbhXxJPHcUUWAPqrtY54e1n0MLUKWtFCb+a1I/VK5FyyCeGB91xMDJWOrRJnVAE547nExYjpZQWHzES4iMpypV2NgR0EUp6I4o5V9XHF1Z8wzSP6xGuSpVF45lJk+BLcEl+JEDV8tiMwXQDiCjHKlyA9XokjkTV5mDvI7fR/LmRTaguNjzH4pQf7ExI41N92f3UhZL1Srw81bI3ijuBDswZH29Z9pnFAr54okRukk9INesF2z6TN4iQkOap1QCkIeito0v6pZMV8fvabZjc0MZzxBWEIicjLpjYg5iVL+JInYC4pKc7hd7yIq/VVXIHvAFEdNVWlqLOVKCKyySBtpP9yj1hXvQTWN+M3PwvRXb7elGHkXTnLWS6q9ezaGAlqF5yYB4F423gqbR4lPC3VxxzFjU5G2EjYAbMwcpHcRl5MRUiHKpo+AcOJDgQVPpSm3d1EC30AG+HGXx8BFE0ecWewrj6ThQ9JV4j6BzUIRka1FLHd5SmxMcsAya8Na/CgU2cA1l8boV7Z5oWPu2AP9RcZSVVZwS9EHS1FU6SzV6+vc1EIeJfK1TEWMX5LAaRGSSMVLVo3XVH0/gF6W7ESltTtxyDUIU8UEXqjWXL87osv8p86pjbd1jl42baO7LdNwe6dsxnXNqdFiq2jhtJmA8VliR+d/Q9P/xebSw2mh39abyPzWtGuxMsqDtbwZ482u5Y3ccVSPQbUXIG//XEVPjouZaPyX7397tUPkczEfZSgcT2+K1rwlQGO3IJbi8fztT5PoYPvxx/evo1gotuYTVHKkiw27+yAA98+i6Bv4ofwqX8UviSCCBgFbEJlJETeRTYXOUNVtd8rcIhVTQyeVPBOmiIJ2IuHgbY0VMaZFaMkq5sS5Nd5w31/TEP5+gqChKC4P9CeGy27JwzyrH8HRJ6qPe5FJe54qsWoTgZ5NGo3zPiq+IWtCaPqDsP3xd3mZDtefL48pY3rPK4r/rAJTedTwwZONC0C60DQzztpsixg95RPxnVRsTvO7k9YXDcVk5PrNgEKDwE753sysjmKzlNEZq5TJ4hMW3XKaQ7FqaE6Z/XkMCn5d6Kw1M8pIiuNiCu1ElVn92XF37N4wTJqwFK25IUnI/ppysPvIouLjQVL5VHDpH6S3J5zKXmxuvAH4WABOXS40Fp9V2eYZA4BQvatMApJ56uPx2s9n9QDNQwV02e/oKU7M3ohLYvoZBCHVqRcl6Myr/Ya1c2bQt9pwe8Di80kG8ieAsxLtmSgU8Jjo1p+ppYyD+9gORngPuLo1fcHb95EMs5ZFGstevuea31Xcw1l13GrdD+QTRM6LyLJSri1YdHqxsDvo391XYvrwsP9qiZ0H/BEvK+6eF9NGG/e79+cUv+6C0g5E4svoF9wDXVAn96wKyARkocTxPRuYpjAs+wU+8riItlfEL9mer21E9U7Qjy/J4xJxfZrY4w+teX8sVDJruQpHoxZXVBJXsn1L0Ejofu6G2Hp3fuDXpR/9inJ3f0PbKNy/sDSsX0UFg5spPx8muDzqFAkFCuRLqJlzDNerKJ7XiuRu47yuCQtchu3sx72CJVRf1b/Oco4ugnRj6EiAK02Exdt5nkxo+HUrEN9zqoVe4enoeaRAtUgTZ0Je2LWpoiMlwFHeATcS3VQyLriSW09FefxLZu7HAr0Q8RJxWM+oF0AjqJuDgUMiaiYTbhwk+094XGeLwOPSrAJB616LlmhJrNa8mb1TSXuf1MvTfGd7x8SVtr4gGNlVLGWFatr0NsvwIFGg+Rp1zmb+VQxnogqj+uapcAtCnT80MuiiuwTntWgE7p5s1I/tMN0sIAqyrgss7U35+zF3FA+VYyHVRUDloZpT9s2RbrPPhcb3dVm0Z5zrqu8JFVE2kO9Q+Ql6c4ms2S5rKuKmZk1VDI9nKg181zAVpiB4QkI4/PW7N4STnpRc4DaFFlG6USp3iIwWEAGJS94DScE74uV2sGdFkBKwswZQTeTDKa6igtpNAV8bydnIrnFMIDGK6g7PetmU8KZwNC80n8/4CmnVXP18+ggwrDh7EF73phdeXFoAw9B+ygscHrVBqIO/GLoMcC4pN5N6IMC3UPCA1UU81te4tqk/lLHwCUpFF+kKNRCUotEZDMuf694zTQMfKSJQ9HL1Qv/wHiNyLS0BXE/lyY6cEcX18nNaWqd0+kUnSP5+D7C6NnwhB0B+6Fz9OjhrEMOs5qQJNB69TBGSe9tRnvf4LIoosITMewrB0O6k7Je/pTwaVH8EEpxmrWloTtqeQpaxfFBdfmwSI8U9QgYHhbq1XR79TDLLplssnpg5A6UUcR5xyWvsT81GsDXz6OICzb1NuUFNRnIpoiuwn75DFt+g+pI2/qkePQkJ4BJJUV2x45ZCSdTRcLZFFAZkyx93jTnKdMhc4kuBrvAfcrBUJcoZzwHpa205e6ga6797W7mk13hRpc3smtb2Swynszu9I25vpR1CTr9hHNIfSFJFDkgWcGK9rnKlIB1WPJf2NrwfT+LMjptjvuutYjvZFBGpsMozXiBozBS4zCWoqkSpv0s69DQWHbsiojpDoyCdo7Z1Ifram0j5EkMKKvT5FCC6ZG7b7FnKEbF0Qs1O1xCHi06p4Qrpzt21d4+uQOlsWLauPNY3rrDQJcg35fIZc6ZlOrXv/P65syEeBgpoo23AGVIOMM9EysUczoZtLHBf03H/cTrD83iFHwHK9GANqxMrGzcRD0SJwGHy8tGgiXLhNAgu5gKJBNqkTAcI33ds99Fk6nNQVmxhCux7HT536I5grw5OPC3vur2qUe8KXSuF8Jg4YVlkr/H8rRQv4aoDtn6ghcFQ4FmZ6WptUp9oz5+JhL8kvwQ37F3jBVzpEc3yfYaU2sPvGvU51lHcaHy37ETKICWGCubWhsUGPTURgNPPxXHfKkN+/1IZ7trTY6DNGjO9iGWV3FeKqgpCMpmQIhyrRWUt9eZHP8QAuypt7bJrjpTa5M4TS/1z66EWlYrPyCgPm/dVmFqrXEj7q/ECX/Q/f1R1MgzP2KgIWiMbeX02kKXw3KZvX9gSWPOozsZVFFdslzUzIfVzaGKS1uK6/GHnjG9NFVMen9jJiPUUqTlpbfZ0fCubMn0cKZKKjmpRE4VKH5R39npK/6LSjys3XWdl0cMElJ+yZZosGyeT/MyIwyDS5uiOLwOV6uKrdR08XSdXBbJ+ZI1xhuIlyQGpKutT3B+OABc0jI46JGvtTopQsDB7xyZtCmyMCQom2rhbFN/ZbTG5OA2xeGkALu1RuU2hRev/XMBryCkDLIFEDzQxbGqRFNq12ZT6RoPknmki8U9agsS2aziCoCEHFD0kaimMuw6oFyCGB4TUinPl1fi5zkuRBCLEkdfP5MmNO2zGLfXxoudNNZZG/kkAX6RV+L4/Pyk03cbmWSgOdfh2DNwAm+99ZnzdnLO+3qIKpaLO2ZQcGYMJrp5VLFp1n7UyWxZfjef8IjUPlS6XTiQTbYX4cdddL0sOkbHWoPXDEwT/rV1rDKQTc3RhUXI5Qa6XhYtp0Zy5jv/PVKb4bpqoGsG/CzuV5MafuvKHn70UxWXN7+egTjmUA+XUEB5w1c3mfp/3T7h/bFNXM1pocDK6P9H3DIS1oC+x6m+vnjX5PaK5WVmj01ZTURK3hPf1gp0cKaxdd9yTGQH2qf7N2NDRYl45lzLXMb37fQwBzeDZVTRaYvSAWh0nAxoWMaalPkSw6fSBUrZUkyp61JzZ6qf6FCulhujTWcWH5Oig2COJqAnPGPzjGsXlb0sOliWqHJTV2YL6CUpzQVWHmWiYHB+rqeEl0EHhzVvyWgYtmii72Nen4gKTWnRVsVLUxpCCc/j7Gd5xm+tlOVn0UEyLq9Ql1bAXdXc+DB8X4BpemqzaIIAr0AEAJhtlshLtbxVv4vqllUvvmhvMioHFr2Qyb/GuKTy+nrG1Y5vZX59fW1Csal8GRe8VvPi/Z2NO9PNoYFuwYrkJo+rW6mtoiKFDsx6wGG24gpMe7awQcOMIVDYR0kyqXhZu+u9iBcpe+ifBYYMAPrms90F6yBVngeVZehe6LeTn4eunLad/H70sOCQmHinkaouv2aISB8ae2YBOuhpmGfCW+nP45IY7fqx5T5nfDH/moUaLXgUQFSoT42gCPVabACMHv/WCy/6V8yavACn75Ie/Wo2XIp7knSrLTahwX/PFv2x/ztbBD78axkt9LolEQv6cJLaKyUMeO2hrJtHEgSnBsLsIYB2kfM6eHqtY2vYdqI9l5cmR/ySEvEwnI9ZksX6xzaOjJdFEUJNDII79nKWWixE4W0r2SUZslFLpzdi+nkkQSTUQGDAFxw9+il4gvF4iiedgd/PIwliRQ3EOatvRKr9asMTIYJzGgQfi+RI5Lm5zm9TxAhP6RB+lMVSatch6oHUamQpT6hR/gtbi6Xd6LkELbJv2foTDbIvKq72o+Dk2ZDeyQhfXmFZ9ksh7ov5Ol8I3O31sihCuCcGAW52tdeXjJEhdkmBWDDWk6q0v58eyicLprD54Z9sNGXmOCUmTmuWEySbBHPvkF0TJpvEIMF49/OyYjrqhZekRnpMiHR7Vm3Hi58mR/ySEvHvMWoz6gjiEyGC1TebjBEhG1b99Lc4a5gVXHSKGOEFHcLxxlS9vL3vXRKTFDsIOEUEOFI8JTJgiYdSgsE8EUk9tVzdJWiRXZAhW9YVL1Z8qSPU20TwZM+R0jOMF53ZVt/InAAMGlx/EIf0M4OH8LnwhEmXoEV2Q4Zs35NSsG6UthFdUiEa96d2gLgELbJxU01kjwTu4TunpKR2eJb6d7xIFfOWJIlHUYwk5Tp1mGWQQYx2/2CAIPkFoUFzJNTshJ+1wlYviyKEhBgE7WTPUt+miBEu6BB+mttTSLe66ixClNuVlRzhuKqSo/ocVyVyZOc0yS4IjZFf2NrT9KKi5+VpeQVJcsoWzcp5ZGg9Cp/OPwXpVG2TXutW4YphfG0ZMMnO1cCKkSE1ydTrQiLWmMfNFln8BwPHX6ZBw6RPtahoisQEZdDPYVJasURUqeYA8BQqlSWLa00lPIVOJYYjDJNItSRJszQFSmFT8K+NPSn/2oQ6ceJihUTiQ5g0qr16EpsgRPAUJpXLLK5rhnqe5jFMOnNW6R7Hh0BpjOuKP2h/CvAUGpXG0ReMzCXXHha1T2XjN+EI80OlusyaFS/krBBznrL3yyVTr7/ATNxXbWaHjmTJsyzSCXyGOmVc3+ilVorsjlGG8EXQ7oIyriTpDljEkhUBhRN6CoaUV9QhFOC8D/x1UgSxxGWCPXBZy/m6SOhiyBQxNW0I9BGA0r+a0pMAQRsA+jgn3w0ZL27Jo8hgpaCNIrlRRFDvCBA0aGPIb+kz13wCEGjT3xT02eo9xC0IyeD9Kd0wARD3IcWPeJrETZH6pFqXtTAn5KnIP38+PZ4CDjUZMqqMqcWiT10/xPKGNg6qCBbNcsmqSP1MeyB9h2n0yUQRDnPxLjDOxfuc1wF5pHsMEqtgUmIQ3ICs7J4CImVlxZKANHqeAkKVlywhuQbW2gyJy7iuSQ4kE8yq5VMmlNU//vf/FBqIhXG9zMT9P/75H3/+Ax6uF+tr8OSLGWijXajKkOCF+vP9q+9eqt+JplaJ199/9xLeAuFTKwHfayv++MZVO/j+QNdSay97JxpolXVbs33fwZsfX/+fI0tiGD2p8v/nz38YkvovUXWxncyPu2/6//7D/50j0f/Nix87VP6v+7bau+CXIacWdZxhK12zdIUUvfru9fffA6UQY0fcIRhdrVYyhuQ6gOQ//+O7lz/AF/Bn1/e8vrm+ZxBAGBro5XcHqii+W10v48LQ8OLVDz+8fPvmzXev3v74/cHrt4AIog5fMyC/XF9DwAbTJPAI0K6vtRbr9TVAc+969fI10vdwrRjhAtr5xcsfXnX+/RGbaMd7kMrOa1599+aH194/33Ves2J1PyKPe9frtxskHXzf/eftPjS93oT2uve/7/Z6z8Hme14dvOn8dKEvINs++n7jN2pSHPzwpv1v5/fzuknVYOu8YrMZ1Ezq/Nt5xaWO+P5B8RMzgNtXbbbEd6+/+/6Hg7cvf3j745u3bw5evd0OZ7MJvnvT/V/3BZLVTQlKm/OG12ygkwfe+Pa7N6/evjr48eXrg4M3aoDjROvOlD+D4KxMZryoX2jlhhfJF/nPTg7S+V/AU3Q0qkiXmp8Z1qvnCMx6Pzf6oppspEjyvMxYxFGhO5Kg1T1c0dR4GCnOhMIXVWqcS1cDjoVdYpWJRZy1hQNQ8MK6amuY7C9yI0v/qRJd8H+BrI2mRbymmOlWkxHEM41knLMo5UqogvAeuLaPF4/1N0bBAx774mXIuFEX+AvIX+oBsTCJiu7qCysua9PPB7BUv5gpgiOEGsUVixia6LHUr7G9pVw1jKnsXmDeaWmAWgG32XAjoHH0WPMQHiHjPeViY4/141bUL1+87v0DC8RoieNR/bJQmk6qFy/Eg/oCrOUm164SuNX0MrBxYLX851LO9CbU8uOumPADTBes2DLpsRpNlY1W+C9Dpfv8cDWFql5VW0jJ1/JrdmBJHq22YHAyEKm6av1/PVwttI5TskbCi9VM1CybgwCDFpk2oYezKBUxSFNdraExa/ZQR7FcF0l0I8TteMP1fmpmTBXBV1kk6qyMbuq63Pf3aitXVw00jfaDtefPQNvP7pj2+oFMbw2JoOS1969YHhc1TyKM/lVY+W370NwLUqiDZo/pvjEFA+L7fTiOv3usvNvFccnHWPWLmT9rhqvYttBbAwp8PX01lU5WSDpmYG0fp3ov5s9KGxovfaWLQgOj2JLiM3qhmUoHdTANTcVe3wystlrKXumgzSydbc634HoyxfCukQElnQGjEUkmM/uGYaJgNVWMwG4KJooXIOKgqrJNDI5nKPVGcW1PRd5QwFlmccFqqV6BZkRechBrt5wmZOzNe+k69l4f1v0XJOCoHERHJRNW6odqRynbc4DRjsfSpkh5wv1TA9csByTaBchFQ1FN9p//kE3Jqi/SgHyaXGR3e2B9WvU2j8HLUEPzpdSMrlwNz49yRZcVaGQamMEx0J0bkFfjkrVrgNC7WsswU1u8e6j2kM06w5eGPIbHdaC8kpcRK1a8YMja/XR7fuWOpZBFx9WqTbAHlsRt8jZjTaV6NxOVDI2JG8irKi5vopSpnW7KioRr4Ju5+iZ89KwSf3DH/4ggxDPZ80w7DBRkbeUHD/qGwHXsG3NhtFiHOYZVVnJrB20kFIeueKo93A2WILwXL1qvKUtWJzemms19YVbwkPiTxctnZbPIuNSGpfrRP2w2d/wjMoUblEM1LGczbdZvjZEfScUa4dSxumlUA8Ad5HK9pXamXjq7Zws4TB2tZrnMUNkC9IB5sYpqoVrJXpMO1WxH8VCpN6qHijeY2VClUvVlXY2/RLL8ztyvbRT/X2j+g9T2NNHhOtWq9rVh1Tqq45VsXRPApaFeJ9SDnUj6374ykq1i1sWxasZ/QFisZWeDeGdrRv5vU9gsd7wVY/Wdqbv3JInSF3+QjeB9yHV7H+Jv9UbeFyj64RO25zvmR9oDBoNaQBUvRCNufOpIw93dURTgzfc+EPE2q5JtUHeT2geqnetDZ7WU2qCbpeXCHqI92uLV294/sKrjLWre1IYXDtUZulceqNZKcK10Mlhv1unEsUpuQA9UCLbv0lff2JS56UpfuaXYPOpRmmSiSZdZXLHZvahuFf1agWXnVfX4uB74kbfcDxW/mJmrtbHC7XoBWENTv6UOLtCRUc8M+Fp9rAentri4gRnZG5G2n/982jDb2JEMVlqPD5Ihnjk4mNTch6aq5fY6Hb46WMnnq9RG5F+RBWiMTM1UzNh0HOaJi/vm6Pyry7Y/BJ/f0m6XNeicPRazg30Wr4ORLjjYWIgOBhaeg9CbC1a/WcalVW+1N5PaadNA/sa52cGmMubBiHLlwRYdmoPwmNuiAbORSHLwJ4pGw9HqD15GSyXref4bvUxsnD8eAuVmPp40juyEKFdDCu9br2z0Dc0MrLMCFXZHsKpfg0bJHnh1zSlg9pQp9uroQd0L4j0e3bPF/r0OZ+1TwJ7LPQc7VpwCYtCV2QdwT5mKNl7iagS7MCpJZY8etaq4xGdsXPE43YtVmaqkUGsKzc1xVDUF6Gvpy3T9Xy14u4t1J4f/+Q9Mg9G4p/r2wly4qOYoK6b+C/p0HL29RpahGSW5XCS3VrrfyAfhNlQhdFuTechfOI2EjUyzExKpLBlLZ64h1fDyDW8P8CS508jDbazvp7wcb/fT7TWbK2M009U/BPlCBro52tbY/gjSEbA6I+pP21TGWiRQHrsNoZs83mjq5/3dg2lgwm4ZSL3ZSqp1gWzFtMvSb96NzL+7fb0PTLR1n+19znBzwACAQ6qorEQtEoGuazoZXYFQv8T8euNi1ksTwu+EiFZ82IGXDqtGfIrKaInLTIRntYi1n/mYC3ia/ez79IOn9mzSpWl1LJxUOEUgdz27mau5W7c6ObColKgjZdRm4Xsx63MqJ6i3wqOfOzTo28J2fSPMvc0g2Mx9DB/fbFZKLdL2PbREZySQvFYcR1rF99HG6r2ROb0VrcfiejwP8d5moojJATO7QTR4cxvDx/kN0A5Gx8vHfccQaid/z4Luc/BtzpmOdX6BMn1vKRhqlLGVYaTu1FqQF1HOcgGtVImESWmG4FD+SKu+6TfNG6Jt4W+xuzvu/RZQs7Huyx/bRtlBv+3MMVgiSkZqb73z6K9dj7vngXtsPF6+tYe4HoNrM3vt3RZIRX4e9zN7y4Vf1vLdXm4hVeOpllHDoVCNUA3l9X413N9e+Qa8jRMYV2DsHp2tjM0fmaRejQps7oyhQLekHWJt1sYJmyvqsFadT3Rg+i1iwsn4LfRE/azNYThSa3hYjFXe/s3+uBiu1HZ0+Bpa+3VhC1vHN/caQXXfollJNSFnScNTT3krrhQolmGvYtmBKyziQnh1m8xPuLcQbazOpO6c05tZvu/JzxRW+O7kN/vljUxzwNCbXYMS9QZ/HazVTsGJSI3+DDSt2MsaakNa+7Etk8ietm3kPuYgdXO1fUNrt7qPUGR2swOyktdOTLHs1vXxzuVXMyN3butyPOHw1aY892rr+rux3uqMe7aAFb1eiipv832gw7kWp/+J6XVue6OwDfqfY81O7nhmvwFvnRaNlLU3D0MeiIZEuKcKpJ3RPygabozjXbU6e529a28TdIMbAQV7qL9I9YFCQDXUt4orCIZhw34MaFyNeiNBn8zbnUypKorNwPeJSAh41T3TZnmeKmEnwzPUD1uTsItGWr/FfnrAWc9AH3pmilt8VHkmDlQ6eovWxKAH7te7nKMMn6zuUr+g0lywVpjgLG5q+OkR0Ud7fFouIYZTLz07aYqWR9uzIrZUK9SRbzETcosocuMmq9sm6WSYzUKvmQJmFx4kCNOyAavNpArNDS6Dyh9sQ+N3YFJ7o3lwV9wfArTmeCbiVJN+UmG8S3SLtZk7sHqMxyjQp7i77efbHdOwSftGyw7X643K4WrJq4PRspSxUgmxKxbVVOyQvS68voYlW15fz1hx5wR3+zzoa+gFVA11sz6ErDuVrReHfmYfq72k2BxIvZIOo+uUUlqd2uYamtWm0UaK9pzfduquWO1OFJyTW72XM0LokY6KMfqmvoDxZMcZe/OJF7NBtjZc+wuvOXlWAIbfXYbgcqbBFpb8oW7ABetmzwKUCLKj5MtejmedK7PwBZv9GgDuYXWcl6ipskht/ZGdpc+yMZJGwkfBth/fjjfB5rVRvyWiKbcEzAtwbJChL9Nv88LNi0i1zPNsEL1+tpNjg2F+eZ7tAGF4DS+A+IWgnqI+F2cz0wy2ldwweSbtUstv8wRen29MlPyZzpRNGSt5Hi1RMbUL4ncsgm2T3Dveo9tk2a1QyM5/H90ovNDilVwXdfyg782eJcfQqpuzXM0VHqUiKkQdsQcu6/0HineW9pQrie7YonQy+agWBpXRjKkmZvIpjbylAffphefVyNi28lvj/it4xDfm8K9t2siu1895ORrd1gysU1t3Ot8G4d/Q6N+WrgBa36xpe4z2b+39N7CYb7zl397a7cr3vA6vHsUAnnkjjbTFcxSV4oUUWVM/+Vzn2/Kw/VKWyfyx40oflg0qa07gzKysWMIgsCR7ngepo/jr5w0/f+bd/+zgPy/JYxz4F1rAK0BR8ziTkaxFxVAjTm4PAdlfxg78iMCQqFlerl3K12x0zi9DtereaI/n67ZyoylGombuYYKyTb58SFdRXJZaYiVlpt3xQfPs/Zt2W6ONe2bVZbHW5+K2EPfFJfvaKJ7w3lqw7qhizDjw+Xe1I34HjghPO/I1WHTXR1ks5cc4ZxNoqd+cz5fBVuoVW0eT3TYI2MZ3rza4bEbGiCswuDOxmtZIUIC01nvPhGkDPfUu/mUXO/jlGzMo6tOC1+iuYpwhDFSZLlO4iAuejHKGtpROC3Qii4PvAAbHvmCK8i1G/UCb7AxTby1+eCHrqoF34AfxBepN9dMMyV9QOuXcr/mGQtdsbTTfnmr8E4HHVvZjrT37QNN+Y8DI8NJ4jtMJNPcvjI/+Nwc+T9lSLR8snVoA1X53PSW8tJWTNoII0hykZg3o5w1aCxLGvCNss1fbhoHd5RFldHgMLn6OsQe/9jnPd5Fmyf9KJq8dE8kZk/m8zHh9pMBciaMvobL9jbaBofWTzbzQN73QRP08L2zHjWqZ647DhAH+ilUrFqdgs7fbwVbrVmGgVlIJKSNZxvfFXwvTrSQbFudEWP5gV7nMDzHEJqw6/h9NXttVXvuHuO8ZRNjewWxi7Tu89Av+Dl9RaoIPjHuKLK/bknYcKB6//EFNJMWoPB+sw2WDo2hcScSbWo9r9mAXYBvm89lvEWxD+PKmddDQJoflLU/IpgXwMQJ1iLx1CJt5xsCYLjDtHtsF61tmY4NmPKL1dmQHG11/QKPvd4jY0xoDZgb76eEp3IlhHBxGcA8TuSibkdZgcJ5gO+vY0hvNXUGhzWoqL6AZe2BJsDGHB4FnopbwNa0HKwo5mbjje8I1lwmixGQbw3UoX4NXb1PkmZFCGLkoPbguQRnjIpY80f9tkXlJ+tgmPTk1xL84Ie0iZDY4LDUvpLQa6YZ46EzQh0nM0JtmxSJjiDHpsewDJc1ozbSDiztV9bmrrZlmQNk/1vH3jOToJYelYl2BDLwjqOfQtalhcFhOBpvIveMslxhGBsV0xqTNsSy1k9Fhqe4AcPwC51eIlHSkp+eWakYP5ziu43PASkor12u8DlxovD5+ylGJPZxZ/Mf6ohKK+dZtYK2NzOHZ4FcjMyuwH99jmBjXrTo5nU5tCv61Ye/aDu1kDHemrRJoR0JQr5WuaIWqb9ey443TvcC5vjYI1bNX98rpv3WyOvMg51Bi4o3+MKANoOSYVBEvqptGfRYabrkerb2U0RdWu5A5Q1XcqdpQoawrCER1E8vxOnde0NYftkQsUf/a2a2aWX7NWtW2CA7zHvUG74z0cb+T5sOP+lW52vsnmjloroCqsSumfb+3++BdrxhihdoDOvjWHn4FuSnilc/UW+qV+prqGZVdCVmyRIcqbydML9djO1sm27jYdH29S+0G6siEFWqgCSLXyk9scw8nNHYX9s5o3iGu0E9sCAOtvWv30t8G3F9sZ8uxv83wf3ODtw2hZ7fXLL4auVpqithTOA37HvFpDfGc+ZxthW9M7l/YyGoVUfu8bzzu39zeW1mcrhOhVcME5rGD/JyZmWmEb7zsX7lgrL9tyP7tzf1NWFt/25LqNvjG3P6VTSy/Mbd/e3NvZW5YxTE0q9j5ZhKwnzUzk9+Y2VM8AqD2UrTkGZPoz/QvGkYG6UhjAKONGD3HMnDgJzuBZfv5A3ZkQ47s+u/0SuAyLbszOhYHxnhW1p9bewpSDXcJKsZstP1Givt31IOTaPj322yQ/WYkOeXctRvaJ5j7tz8HxxOlGeZ6xppd2G7q2l48xSH+8FQj2/ljc2ZsNu1n17pfI22yJ9LNONB+2xvuzWYDvCGDWF/bs0I2FbtSjEMHyLYpf6r5LjkpMRHbMaBcy+YKG6+5WkLWRiHXzzJM0zJQkihBF1EoQAyH66XJRv3cwRKDebMl7MBu1TneTKc1rMryePFeosZok47UPy3OWS6q9e7q9Jp6EJtr6fHSYb3D8ZZ6M5mmGWmVac/IisXZSacRujnGAXTEHuoqJgLa6sAV7Dmbv3RaYYpeDxyw7Sb9UM0e9cwUDFWYbYl08xTHWVYbLIqrKl7T8oDiWhEeoP3g7zeXEa5Z2vNJ3UBmAXWJblM5F1dPcUtkWp6GJc7sC7SEZHVTQkiMNjVsBeoFSWp3auHiaoO8eElE9iVou8+ZHmSehW4nwxPuwjbQBSgyqXiJAZ0Z+KtVpGiLY5saDsfoe6/tXXkTQRmpz1drHWemm2elljbfOPn9ErDVkxObqsbc+5irHJ1ATNYJS/AQtFQMfWMekXzzHJW3KwIgBiTh5bg7RXQbp16dxcm4i0fH0ke8/u4Ssx/1M2v3lYgSd2oXmB6nbWMlCt8tJDIGJXyAz3+9MeWbPo5efvem+7+3GyvsYJX/4sXXhldq8wdHiGW95W0Dy/jWeim726uS48zQmNZubdtvupx8sGoqalZs+TxbLpnxcD5YvuFcdLCWMLvgwcJaQpAjoHS8DniY5/UMduTRfaWW4mpb3Twu1ICAcRfFJZ/FzbaOHaweeb5U9vtVLW5ZgRGhVO623ymeUC9Flc+u96ulBv8sV+s0DPFtv9CH4NZ5TFOXTR1tH9L2N3pAuwTfhntgaP/Y/d+rYPnCvFkciVz1G/LxNrXBI171/hkLVDpWT2wvbvn+SAWrkTNQPuAWeLPSpsffzTo7On/oF0N+6Hv/BNv3x9Bep8VSQNe7xBZVz4HN5kazvh4zLl2yOrlR0ieY3rc3VHR2qegX5ewUbxfOTjutpEHJnX6ru635ZL/Ujq/dsOS2FG54bqmKg/hzmaol8lzzzS0/+W1bvIRg+8aEOcOLTvu832343zfYg22cE7VsxigA6qex+99xf5fDjYRFG81y8CbYhrjCj8KuWLWFS2w7aSJ1BKAQLjgevi54MTD6X75+8/2r7w5+cP8FgKKEqDymKWZKcNu3qgngo22bohshbuW+P5XprYkC5BQnB381IFttqdZKANtq+ex6Wz1/xdpZubev2FKz42JjoN7m9mGg0ouZXoTGSv3lfKyOYwVjFYx3e7alitlPjhXnSTk7P7rYUqMV6i/M05bK87pJuYHULf5Oa052BNixt/jTfqzO4Aq7tar+7Lze3l66chsmektVbxEbreKt1IM1BsTTjXrBcjI7/LwAI2xIZb0NZ1CxFZeuY992Fq7OrO8Wdd2h9Qp7E1sXLjupzRmr8zOxipqy7UOd2zJjne6e+blsLTW7r1sXb+Yi/siLnWZ/4NyeeoYlc2PUsFnndwiGyapuqR6ei4rFt7xYHd3ExarbZLZKUSqKmuqOrYdKJc/LjCkeJJoiYT1UmyPybcACw2/tffBvA/7d/82iv9i9K1gx4+znt11hz/aJoRbuwQUuBXhoYReFEYn25evvu//i7L4RhZhB/Ujf5G+pOrLCb6kqkSQFvtLxtWaL5fIJv0JDvIMn/FDjQiPlJ/zaKiF82YK0XRk7x4JDVdWAjEpRqf9krJX1BipCl2wvVdOj2kLUgOQ0UEu07sQGi5WcOl4KzHsLBFmnkTs7Hqrwh0jHC4eX66GKdltf+jLeQEXFyJN6R3GUiny2qxPdMPbvCcfqNnyPWnaUjddYMDgBN+P4tZH6vuv+C8bHOEvsnB95XbB8DM/wnb9yrV/XD13VyR9VVO9VDnyb2r+7ALjdq4y/wxZkqE3IHNoMD42NUbExIIJVw9CxOPV27z/dIP/PTe0nb7v/V87rXsz+k1aP+62jGmbLUbwVpo2Zh68Jpw1O4YoMXptyWYKkfyV6e2O/IlyMh35y59omThL1fdzDsCJeZMa0BZ62NZhuL9cuZVzFOVM1Nos7N4t+QZmWG3lNwHaa25pOjQvbdubxW+Pt3XhwzgBxSFDJHR+tQpUHlQQb9kB5PMfv60L1tGIhCSMDqalvZplY6XNwfNBDe1hb5fu3Px68bv/7evg4eUut3r5woKY+H8+4rO3WYqDSTV2Xo4WbO5uBSu3OZaDQdWnFUtU1fBu9g3N5W0U7t7fWqVjWWDfLW+o1amwdrtxmZLim/ndzs9SvTWS0yhtxD4MV/m5hw0+/MR7n3duqd/p/W0Xb/9vqtLyeziHTBk8RjfFkAE//0p7qTdNtdb/c1/+GriTSSZNaxVqTEa1KdwMRrP3AQwPZYxsp71LheiNjaMjZcsOUiGwOus2mGatpLJfYp4k6Imsvf9NwiVQb3YvqFufCvuvON/G/02pTYTFlk8lve+intdq37fPT2m0qc8cKXgBHy1/b/KO+6Ox+3hCBB6eCgM+cDm4DuCHbUsFo5xsGN2/n3t+tAd3pf3rH0Xq0q102WEnhkDfPfacOdOZuY92PNc712MhWrqtm9sPgcB+q9GJwuz1csb/bG6zl9nkDpZb2NmTUlhe14ZE7ilTDvyDSn14Tou+GTov2HI8c+FpYkHhIV1Fclmgb5Ptm9Ia5zfIn8gGRtlGyAxo8p6VxQeOfsRGaspZqnLYehCG3CbuU1scPEQ82V+wDMrPAl6XQu4QnWG2XUEYvCilhb7ktDnif925DH1crclCH+stsR4b6cRg+jX1qJb6wpAYWb7SB9dO3Hdd+7fbtlOfxbTaZMx6DR32Q6bmjn76Ng+3tBkrBPGFXcL7+jfH8lcb7xn2e2HBTYUEdUN/40OMajxV3vBIFEPCNDf2FtvvGhZ7WblNhQj6mbzxor7bb5syn1T1ovft4V+rt4RuWsw1j+vac5g0V/KBZALCN5ySjcs/ugKzRs1as4zT7RmsUbPfJbpecSKa3oz9xioDDx7+bbpkG6w2fjtE5Hx53YWW7sTVd+3NXM4+1XLjwx3xfOXWYkaLH+UxB4z7fcH/w9mvEAxeZi7BBs2j0srFhKT2RW9KOfaEbMn66d+4+6InPnKR7VoqhI249M9gYMUetv9vHmSdtdeG83/Vy4I016Ae+N8hDlg43u9yLVOZlDQV5e7ONCe68fOp7ADkInhNsOBDTLpQH3IpNigP2vSlo+8sNDwvO8e3AVFekNtlobEjz3agpKXIAmB1a/ZhdxAVPbDw3P+9x6jRDXpIGm42mDNH6TUARzPcv9OffuXKMC/DUGmxASh2SXf8Wg3Fg5LXcsryH3lieEyodwaTjlOrPf7DizlNyGWiB8cajOuOczOrE192Sa/hCS+t/CU81rSemP/dzhjui6bZZsTteBiqMewfe5tFX7ZrAYIVtcau74U9t0F9vEpd1U22pAD3aSFp+ececEDuJi6ac3QHE5TGv3qs0jt821cpSxADVLIctgKrkWR+Jqj4HYlqPLr0se7DeZgeO3Dh0BCjar6PiOPhV4wtUtUkt1KAEB58mRhb8xnoCGjzg3PV7WYOnr21v2Ftx14YHGS61zpn+ynGoceO0oUhP7PC0HcTagWGU212fGcgD2Z31Z2NP3HFYMuKPmkJ7dGUse5baz/T3hB3kG+saBcy8gJApcFcWafeTLUMbKWrFcYC9c+ZujJatNyHe1nCo3lJum5qe19uRGh3Hq8NXKNe2M2GnECWeM06KU1wHh3EBXU1i7Mhzizy52Y1/l8Qo64qXUVxIvkVmdM6Ih16+8+iWAu/xTg8s5+lmPYIH95wbUxioKStZkXZ8/rqGGCvrhAXTTRB43MAu5qGTV3sdM1xkhcotS23IImYLHd/OEx5nahOKp4sG+GDB9qG/7+qDJOARpm4+iNI4L+JS3oh6zir1Sf6H8Rb710TRfVezb0vW0NAoylYEsc++zHXQP2U40IsIi3NfGWdEJuuU9lxdH5CQUTvXWUnvKmtkktBgCn4QT8cHO1l7rYGw6d4ImElmURiczG1Xe9PbBicfCDxAo7+X/AGO+KSpGhmEhSpmqWkBU+YFq+1kDEiy8BF6TbCoUAGJPcSw5YqscUcea1938NdYeLYmvk7HaRpYH93T9JDX65Kl4PY64sUdLOzPAXRfpHsOmDfPTtDNuhRNBYGRMpHcRoWImir71hq6NVRTgH/9qCkkq781SrdRVJM8J44x0DQMrpBM6jk0gUYaiSJbRzAsYJV8WD8H5Ekj4fVGAaQo8+cA2gp10bJSXzESUZTy6lmMdR2mBo9mnrMwGOVSpZ7RHHfHuc+0u0WxEs8B+sAB/nOF3d5gfHHhXkTVO9eyQQ9BuwBPpKlN7zaEGJzUPiOxrXOS9VzOrtRGFr8rIwtf6/B+kS7g3PNY1rY0hA519swbAeO5fRsIRvntmY+F5yL8PMNj7u4Wfh1XxfNDXT6Tk4uRKf5t5cdWePbL/rNf85/Xgp+yZdxk1nzvOSDOFVxudrg6auvs2dzTjGGPOkvhkBJD3zs57eP6uAKhFk7rZbNQf5SYJ6r1M7qmShfQ1/BxiIc4YeBGn1DOjsEIs+NBpZszYCVx4KmG+qGptrqb6Puz1ypf7luE9BZNw/1kpo5rt07G0/xx6EaxL+rkj+vGHryh1GxaUdg1mpfcMI8f9UXWWmFsUVr2zUH+LrOe3SrTugd3a0PvVIim1KcWievVTsbQVLA9+Zd5ykBTkuIinmP8O26bbyPTnxpo08sl2zFHxL9hDnUilgxVcNRvmwe9WA60Z4J1wWMngpfuiAusWPGCyX0XBrhz1brg+4UHodRmR2enrr3s89bwl/usoepF/awukwi3iaxMPvsdYmSwCtrFPGKzJDfiVgEJ/TrVwVCLZiVkqfYS86+Ztsf1Mh4ZoXijpufs4M508AVW0TYEv/P65thpI+58bcfSaaDeBvt9ahDllv1SCGLcufqPau1US71bKjLrqGVOEZcR9gJawI2WYp/XEty2QC+OufPpMb2BGt76QsFUdqQZJ7TLHEG4aQo7YAD710X//Y35DamwBm3xkrG/2L9b0PFYoqjoCDojHWq8zTY8S39i9e+xzM/RhaDr35Ei7GivsbzlGRqoaoqa5yyq40ot7nKoiv7yvXptp3Qrswl1ud9oXK0nZRrWNaNnIqf+tXVAs5xnbGar+GaDA9U05wjYo+VGY0Bvp3m+RMt59bfLCHsTmAo/BFBwwAwbJ1bA3gCd0/aytkLVHb3hB5BOpwJOYKdX4tQw1mPTzcMle7RGmTUVmr0Ta4otIV43gf4lT5uzq7n2COuOF4+8M0SS0lNnSe0IFUNb7ejOucJVa29nG9lZlcfX/aFZ92pQ4DcetjY8cWFHbM51W2K3TEderFss0P55o6V3rIj5Q+vlKzJ9hwORJ/KwWknr/7Kft8fcfzEzqwOlia+66/j8/MT4aobHndFPR5kjLdz+EPcmbTvoR046X/b2yd9vbAmGagw36FDNZSwVvZlYjNfwjzuHKmwwgqFKPW/aQ1WGecRwzXb0jNXYZB7D9ewCsUeVfeqimcj8a+YettTVQn2cphfg/WRhXJFvq+s2ABuVyEyFTr+gWkGvo/4cEPJGR8cbwmzfv0DtF/R3jIOyjVsABksH1hTCEo+39bYriEs8XoB84U1qs2Xcp2pn/hNvSiNEnealqHAcdjIGmtT+Initny2gPV6LZ7Ud1ounDRvrMj2QsEgAOrNY9I4YB07le0eMWy4KPN/lW2r1thYDNXun4KNELZrlklWEbwzQZ50VCZBhXUHq14ZVa8fD2qxhQ8LOkd/QKmhC12iGuHhfNHknP49L+ISkdCa42XCnRcoeXJthaktzDXPyocYbXDw3mpIst98QSDESTCuc/vmIaTvSgiNVh/b1QzU3G3tLNdvvWyt1JtR0WIdpolb2cU021onj1zkEuYBlY1oX2bG0bdgHxhYd4E7sPBKNPjTAhx3S7tBFHNdm7OCquVhtu65ro98OuyqFvcSWYrVlg/aqt9UZOocdrvkJ1c8JXxp2OlGjgV50uP58VMiotm+2lM+27HvotRkG3nj/ABsSnPV+2lgibA4nSgJ7fxMKINv96CM3td3boEGx5otMRTKRwQGHlnH2Kef6PNWlnnQasPUoZdvco9dusBRCi8Hfx7fV5lIyHFe4sxLQb7S5oiapT4ska1Jmx9xG5o7mtFs4N9gONpbdg/FF8oDgogfyArSUkRv+fARYLPLP5kzWaWGFAooNgtTrYB59GeBvFuUGj3+fJvYNyBb/YvmPXsfCbuQ8LqFrzeMuZjAeiHiDKYxPE+9uaMV0oLLDpG4Phug1pG4iG7pJWIvTj02W2R0fSQnPqGe7C2A//S/f0s36h/v/nh1c575kt2Iq2NpPhR/gVHR7lh0d/PLtwXCfmoLbTBSxn/Fi4956U5Swee2m3eV0e9ll2+MFL2uor12hvzq7zHZ9dlnYBCecZeklW/aqe5t8l3cRryEcQjdzSNjyisd5IFShN35wpwbjx27ZduoD+X1PELDpdGSNrv/3kaYfI096o43ioLAPKGXMvbXD31S8/L7HPscP7keqDhzcj9QcFDIH6+rvO2hy9q4S96rtT7hVe9nrV0dZLOWjfwMwHvsjHGjIzFDseOTP8bz5kb8xbPLxv3nsh7To8THOmVRjjz2tJ3ov2fHrwXWkX5PoKu9WNrfc+2tdZ89LUnK1aNzetZMxCYi94en7tTjyAjZtv5nfONYZv6of4ZwU1yQTZFvxyAjv2swpdiej03i19PNJDpdBYdMoNffkT2vCZAYHSbj7rI36enJwzfzzHy+GF4A3Njislcne0G+b8bW13fSPrLzYTuZUfuwiYh8rFl3TPzCZwgn8FvkRWnagKfdvq9694i490Im2aCtLOkFmxxSeBDdzYrcnvu3Ft+zJzhT51gjD8lvGP6AcVgBzvGykvC9HjlYcPHEcUTrz74FHa7VH9JS1w8YXaLfjxWXZ3/9aeWTAtu4vt/0GGx2p1zv6Hu+l+Y462vNBlU21H90pgr2vb/mx08jerrjwN4gTU5gO5tBIz4b2BOmxly5+wF6tWKgdOfIao48j7Y/4sTVg21XbWX1tu+rd50JmaOoN19t+cxPckIjTuKxZZSJwPVt/Et1mQKcDVSX0hlw/dXlHxe9UbfurkE9wNpGpnigYbrPNhZkJst3N3Aev7nJ8M5l+VUDvrJM9hN2a+U8er7Gb7GUh8hbU49xm2VtR31lC8OvgXnOibayBkr6Vqbsd3phENEYJPqF5gBkHe8yFoQUwBjfYUd7U1tRkoE471EaW0E0/GGMaFwOtPVq3485jsJJj9BQWbl4o0A18Tlf+K0t3iOtWHx+MUi2DnXZL2s12r0CPYlGqNBJeV+tZXPJWh6xbxDd+3Vc165SjS+1KgfXUyeDw+o5dqVw1Gj/YGIa2tKs7ckC5xQ1vHC/t2WhsabknLDdjvU1g5Rlq44FRg5q/g4NpZERTmcFuDpil1U2IPwcYf4ig1NIFW13oger5bpfasK7avSPXFsaGLbSprpgUYn+2SL515i4HaS8MkKayHDfsHjUMp6XYMJ0OhD8910PBMlLru3rLGF16WhLdECJ7jN7t9cqsWSlmPmMyn5cZr4/+f/betsttGwkX/C9358N+Yaslu1+cL5vEdjKeG088aWdyd/fs6UORkEQ3RdIE2d2Kz/3vizeSAFkAqXY7EQB6PLEIFiXWg6pCoVAoEAY/5q8/nWxZBLXYN/f9q9cloknCSZjibhIstzIYW+jk5Fj+/R/EwX4nqsYq07SO7g07o+gtK2f4Sx7GTWl46I6+jhrggqllTwxlJsUpSbyiYkCjsaLpljfdrre2+G0yuIM6MQ2/4gA8wXav6DDrkw9hlkS/oW1CfKODonuDWe+pi9jP8kjx89QT3XuaFZYYvc3u/xumNbKCa4yymHUi5bq9AE69+upDhAwnslT7Qn+vVyFIH+r4DdEFR3PgpBDc2RESkTuKfFWe3qMfkyzkFYOUBu3hKsveH6nXNqiKdsKYjdEOe3hIu8H6O/JBOcP7Xcmp4b0K7Qt6JJ/ufrsncUd64kNa4/81RknGyQilH+62H8jPEtvVxPZ6f05cHtJ8u+UjIP/EJKBXgfO0vT9JqruaGEqD7AlCdQ4MQ3Zrtywbi1VL1q7Xybbti16DNc5NwAj1EajOKlqGFjFLH8gdFH8Q3gZPvVXaGGLEiBBhSaLmiwwn3OiTTAp6RGh0lya4esLBNsKWHQw1q4TwE9NkSSILqMzk9SVN5sz0ZiLinh0ekjS5EAe1sRkX1H60dqJHFIV6xeyP8RZOLcrs1yxCfHrBP4soRTtsnf4otUu2u5T8v+o+sQI9zUXDUZhta/Z4vE/1ndqRGdaoxdHKNvZ5hxaja090aqJTRG2QZd3O3pntZhEvb6GrJaIW7bmDJSL+fHKf/ImoH/wu+3Dzy1vqanDbDd8bnGVqH9ufaTXIzmqL/TrDVu57FjSnkPzuYlNnkbKOuulKcgzq3q+G89aVsOdaXE9zCdWE5B6VW8RDb7wUo3Stplx0xYIpcDCm2pNE+gGAJrzUTuTl8hZ8UKZZnVIuOSfokie7kME/pcIFvBkUhPa8EVP3LS3rPuIncz7/2+WP9due2Z9xwKHRotge4aK2mBEEZyAa/Th6sjFeWhvsEHhqAkiGfROUfuel5DY3WCyO0l5BA7wc2W5Mj1J5ArQ9DYUUO7cMo/v2LHP83X13hPBs3U/eLr1uD1RtLzQdd/5K/Z8x8gsRa3odIh0eEgQQ9aQCIlGkREOglxrNA92xOtD9oVTBZBopg4mNUjd4xD4pbM42FB91pgNYNNBYkiHl0LAAywg9OwMsDyhmB7xvsEIgfWeUoNWIoY2CqHQmy67Vir5gyLy3Qe5/SgWPW7T5xsSPYXMqljLkEqES/shPZb4XAd9/2bLi3AeFs9o5JPK1Tm9Ar87k8EkyDhMYhBx+oJNy0HNU3Cr7fEY6/klbCMllmxvQVProGnTjq7xYLq/OnhtX0c8vwPGSpUQFe7Fr+VzJkDoHlszPLzqhOFd3CjbDzIUyGZBL8SnqxhZxo+pDie4T9PATCqu6lDlpCfcJxkm2fRNWIc7rMkJ6mvZN3iOMm5UZlXKYVdG7n0R3UHNJepL7PX+EZUZ+S37Vxrwkj3zu81E6Q/S8V0qQU9DxGf94kCdAfUJlivRTXkIwy2/X3n/dnXF3fmGXRoiNrBzEQ4E+5hwF+pnl9IF3TPPi0w8qghCglrmP+Y8t02x0A+84CAEk1CL+Dwn7l0GlU0v57lsRfqb5wLJMOZ1nMApYaQ40RlMMmBp7+k0ymCbnHq16f3p778l4+z/RARu8fXW8+uGPm38T4D/h33jFZTZ+lUr0zDDH0BpN82NaQ2PdhEHoFQ6ayV/I9nMqDaYlmgvW9Wrq74UVPCf4dV2W5A1IB9JNYeTdUPwzq2aTssQ/I4GcMkUx4GVwaAIdioh+HiwCgkWt2NToj6TavX1EUd3u44DuiPXlMXhOf4hprEi1Y2MnN1BtBo017z90v1tXYOCVW7iezrmMy/Dhx5wdRyk+Mm6iNAmqkhgkHi0Hl8MGMzuAhjtGwUMSa1IdLTFp7zJakyYkg1PJTZjU0Dua1i79FHsE2wthhCzTVW0cTVhbbZCt2UxowVZXjY2SdkJ1vTlsbvq1v3XKFk535FdT1O70kC7hxU5wuZl0f2Gu6CbvINEFBKMw+8C+ybzc/HNS/bNev8O4Rr/rKrs1AcY7K0OL/Y0LbB+fvI0BiiVedLlHdrhxcNCQhUV04URuQdWgny2KVuUiBUoZ8IatbfXMNBHB9vHytPtkS8u76av5Mn2AQvdWug3k4ZQnDzfFi+SGZg+3aLNIRDSRb5ZDpw2Kf5nkL9LtzsNkZUMucmM7rRSQtRRfYxu5pHhz19gLvPXDazRrDUdhgUQUkrwmeaiwyMLuw65YRfNZaAe5tEgxEvxfmmH0L/yObWLfJM1sYdDM+3QdrlFT5TEQyUl5GSQymS28t14RN3Sdi/RF8btALU7w68R09x39vZAV4LFX2RWHgM+5VA/B2hjCYLVUGgmUJdR5DACnrupMoVmU708fBhvaV+Yt7PwkPhw8JFmcP+BeI5a/JEMPwTapdvU6SOgPBm0panabVriSLpVp1Ara4766sCU6zz6IwHxTSvHLIPC+aiLR64O2qstCuraC+yYZVlRS5hFNIgSqGo9TqeWnuzyAFZj90SQUV+0cQMCHUcUqWtMS/TbBSK2PyL6+g00c0xBU7olflwatsbKDu9tbVlHs9paN0V1JseaimQWKEdyWEUtmS3IuJP76rR2jqjNy+hzTCfouxDses+CfeIy/PBRVLtWAIWOIlOh2YQFfNOOSckX/tdODolwQ3FlIJCqTolIzDQbt0g7GMo/I7LozMS2pNd0n5x7e1BFlR4ol6O8a9rcMaq3JWbh7DNwaZuetLMGuy7SVNXdqmm2vKBg9awIHaVN97OjqEtMi8KYNX51na1kcnHZH60h2XmRYdhFvGpopAp4tZo16tkkXXSJcr2mwn7oZSoYRYRsYVt66q5Ehn5ypMrtSZmDKWZoTNEykaPXS6KXt1uqAvLIAQUIV3f2e4bqg9X5QTKcJH8r88cDXhjQ39X6zSPs+deHp/EnJLAtfUm2BhOiiPQGqsYDNCKUYenm2dHvL7Az5wU3y2GWxr+wBSlnQFVD126CohzHmMciXpOcb5NFdgKs46XZoKhEMta6RtP8EXBHu7d6BFnllEnWd+vS3YSqC3I9LdQIN3AH66mIcLHvkVSo0KXBQW7T5v40uAzUe9TuyVamzSK2h6r7KOTeDW90xjEAF4NOfwEkSAhbaaoRFd1O7use+nVLwwOTiE/l4k4UF3uXVDSrZQW1IOri7M2Lt6AEhKskYXADMKnEbFtDrjNTwxlfUY2RZYkBpPutWHTrspJ2pLWz9NtNeVpt0czCVEfxC7ToXTRfj7s5VEb/tlqN2e9u8+RDHBV3iS1EgzXDE955F8uaprgFeLbBJlIx4PCTVLuBs0T0LC+IEkIlOELerJQpUApMGshYrx0BqZzCLOmNjUsb3v9BFw12wyVMyIV7Ea78kh9tS53k2lSwSNrjXZE53ko7GAOMm2tv9ffyr/uG0cPkja4FWizEow7s5HAEVnn/mUvoc9mFwQ08L9fXYacNgCQj4Gc0obVuNfb00dFWwhCQoDVCcxbBi8MRZytELAqwzzXchIYJpdV1s2VqDvouH9RC7qdDwhjZccaEAf2EzHLx0U4dCe93bscXD7cPIfi8mqwCzMkrVymbYelMkteU5whW2itiws0WdhG7fhzX75tRAr7Y+kBTyVVu/xQk7RhekM/fDtUU9van60SQnIt8n1STCtojP6TsNMbGD/p6vyLinKhCLyn5xU9aPd+WJqm/72iKqK0XUxcsLPux4eXVNADzE3XC2vYFAoGBBXBY6yd1jtYTQoCKzplkzpdgZ1RyNeCYlN4FigNoapLqDSeq0slhOmAGjEDALJrAYpn6dpDHQ8cM7RZy9w7unOQ4W28YLe2m2c1a8/ZfmyHkpS0qSQosUEjWnbKD2SI3T7qSGhWLrr3mVMGj7sKtc2yv8CfT86Xdt517g7mzpe6A4m4a9JoFYWtkrRJ2MICzLUF5b55ocZtXJrub1gCn42sJ2GhBgpG5rrsrbOy1XUzpDgU1Lc286o6Eb3m2J4PX6Qgq+CC0UzrB02feF5RwiS0xMx2bRBZMKIIrUeXIDBZQQaHOltpaoXD8nSonJ9po03d1ThdNjWRT0YMG+Zg3zE/5OumScfeJ8neIA0nDgyjpsw08TlVysy/wOZe7yt0+yxOHeS/Otc9x9Qye8SOttkuEFwvubIk2q14SHj/nrT/jEDSgdMN7zzxQQ8VG3tdq0OKtmoWm8p8cKZXRYMRHdyOmhv7wzUIoCICUir8zf3Oy8NRuncdVS2+LKyf3VA4j22xAzsUhCsInTtsqzYaFE2rNnoOp1MkAZ7Yi+3Mp7RCGq4aY9aJVjIC8gEa2B1mx4+C/9/O5XS9ZD5E4VHdl0Hgw4CN1p87VOMhFCBVJ+zl9eqP+7hNNdjXTScSEmMpFrEMiOrfEBFXqQdHjGCEQFTVNhwkVj7zS329XyN2uROD+Rmpd6RhOpP9RpOpkU7yaSvinzYiLpDULTOBPj1TFgiEfeoCLND8c9cX8UebLZHEP/G9G46sgH2rPgJz5yU4VVbZLUbs8U3SO5DnGTu3MTbnS/ZM1Y2R8otYb2lH3YPlN/hPyk8H6bbkP+Vw3uE4ftHshTyFpHD6Tsiva47AJI5d/fZVWZ4wJFFYq7aguaWwaH4cjNRrgi/uLejtXJIXK4SDJRNlZ8ZMjkbE/uqes0NDfhSeq92UqbQNg7o2OQSWiDsCdYGIF9UYkzOqQGaw20KOBsWuuy3rE3eQpN3ivoQ3wZ3dDWC8yb9rmdLbqQxUkG54eQ9eIVLCo/CGGoacJ2KnedJY83eXSH2MpDd2W5WhM3vS7eH/DnlG/Gb64M6r2Sis+zz/uwTMJ4DZaPssVH6SoxdufTSG3WHFMH9TCKed+iWONHA84TInPs8Mln1tjS662Rehe3vS612VIMb8gd20JwA1ZLwN9pbzphy25u/vNLZ8volVywgBsszC0cWO2uqdprhe0KkwATR4S7m+2FNUmMuj7Ms23e9SG9Yizt6accd0eAW+VBMOtCN1J2Iwy7AseWJrkRMEl2cMuMTO+8oX6b5fYmaYMXN9x9UhoMJ73C3j5vG4SboFrPtihyd3iW0GXpzCzN1H81nB6MzZtON5kJmC/lNdFn+oP4hyz+2OQ3A822xwsyXJeomTS/fUwwPxAZaof2zxt3TsvK9HXL+JMKrp4tgPmAdl1enhrathrP+65E+/we3bQ7/zHfTdBrNIfvNKEhWyzXa9KDZU6eaE1X23LM1Fi1YTYZKhwOJKDX5Gr/b9Jw+7aNdnZXLkY8eQ3Pn/KydTHpyRHcP4XuHLc68z0mbi1547zc1YRBmlW2OWiXcgznG1mAJHdr396HaU3Xy8lQkeYYd/VY+3fclCZllAQCaTZGVLoU9Db1pM1AV1s6izhMHDt/pf5v2bi5m5H7XX6RjqKtHQBRnOlTZ2BqaBCcSN9EWybRHpoYzDitNGvQkJNOEkmsfKdAnPDiaB8Rro54rK2FMKC2RELTnHxBEKV5TcatEgXxMojXAVp1EmumONoT7xekAIi7ULK+ABHhwuBSj3bupMe6QhdWueSy+aEJapLtaS/lqimaqiBysW64CAeUCKch7cfqJtIqegwnv4x39ZTH9DVNrOnqG7Zs03Z1e8m62rg6cwZnH4I7+HW4WeWAdbAp6ZAtesNWsSIQfEIV/Ua5FpUhtXJlFujVNAFeGYFfWSOgNANWEtD20hDaA+uDyZZpNRDfNs/WDdjUbNe+hMrNXUF3faLsFJUeCqAPhqAsuhMGms/mkqhfl0vasyVPqcslLwYYh1Joy8/ooFhIJ09aPTLKS0rdegt4+EnvtuokjQ6c7b4BjwZOkQjQt0tys84uybsWzD6ZPT5YHw61ZYCEuo/FDRB+DDFK2XYDgYHSAPlRy9WFXpeGN4duloHm3kzQ7ToxkbTD53I1dc6xGpllrC6s8z9QBXgfSLaUI+fNm+D3aq5xP5xo3Gu14/zasIkBvCl1A3TfEN+7ntRr7U6w6yM7WfOAPn44Si/FD8dpu/jhKK0aP7x+ktc86bEufnhtp1DL7tO+2UkPuFbyvbH10MFhssO0F/28zjLDyvck9g2C1Kpzn6TNjPOsThvd7m0oao++GDTrTh8yTaKmegOOiSzd2jsYwZo2fTCnXX3Ke9fdPFcz3jRbicfWm0zrS6b1pJH1o4nrReb1IVvWg+AsrKZSmu6mel6ZJmNrNlR62HWRl67s0GtD1SF7E2hgBHAV53X1b3pqTpr8yb7yt7rJKdLcMwXr7EkYAMRa1K1rj8LWBiRBPRmE8UAqA6hOqFTfrghM+7bGylqsMPfDPYjChveapPJf/Ues4rcL3dIvUK5a1oetppmIlJipzEnaFARlViIp25m8sddK+FyrfDfMiiAv1JwIyc5B7B0YLLdKGgIFKNujzGyPXTNQmtLLn9NgX6dVgtWD7Ay31cWSTksgzFb9I+PgpfGpa+MuLI4z9KNmOhOvpZK1attX46zOmfwEmggwedV7We+Vll56lP4YPGjFQksNT0ynkKvzUd1Je0/JeXMz6Y28ENv6KemRfD1i0uHFiyfNU52bqA7GCWBsmMeD5x+NWY0vaBzubhic2ace+waZNy31hHyUY7M7n5re6WJ+58A/SzA9Bp4dck7jbKCTBtHM1u8Ze6Gr0Qvh37s728RnGNcP8qDTXX17l61bL5hdtm/llSfS8rF0OZusJ2PbnmnAyQMesAkychvFInzjeMCnhUAEd/IsPQTMcizwLozzBzIt6FjvNQELwxdwme4L++HwRA54YkpQ0MwUb2SfWdMgXk5hWJV3aKP2UPwNVM0ySrx0wpIKvWkRDVYvV+fXi3gpYdpeTFmx7eFz4QggnmiWsnYiVg7I+Pog3ughqXZBIpWtPl4BXRlwEE0FYfPRdfAQlhn5iAMRmONec1s8pV++zUK5MHLriW5UZUjmv0wxCApFjXeBq0e/Pck6+GsLaEGBuK0okGfkn6dpheND6b6u6jAlv7lBJcqidiLn12TNL6uZka+4R6yoX8BKz/pnLH3hmEaI6TpNUIXr1B/l7rPNlf22RCk/FUAKx4B33I/KCE9BDAT7ZudBsAmTlMwhRIJSh5PS4EnQii5rBUWZPx58HBmkzCAffYI2Y2cO4g4h8WYY6abYy2aS7Sfz7Qjhoy2QTeFsDQBQPJeJJLsnvxAHdZlKGAxbHZaMdZnfocw/M8G7WKx6U8Hw1Fcis4hGDYYq4J2blPgTgAY4R+y8yY5x+do3GcjvEzrPDssyPCiyANxwGBv63ZVnKtEF2aNdmG1RQF63C7TTQSOt95k3MTk1QaxLXfWF/xKFafCQl2kcELqYzqzCovBxNrkjH/MyQTiI6TboLfJzSl1niFXHoiHqQNgMbil8NZRzjtNRaXTuqURchpsqWHquBt0smljIPMjyivxUjRFfkKCHtcyKcgxY3jhYYk6BH5Iq2gXSRqEq92xW2is4AW2ZIqLSXQVJRl46TaelT7qMkPf8sx2vwYbJR1EiejljIjCZgZCEg3323qBKhVr8xGIeWHsDq7diwJMjZo3warOfRgr8ZN/znADJUWBGgB9OLEEwbPVkPUxCZk6gGWLit67M6TNK4q1/cqEGgXkKurcZh0pmvmgcbFjwc5+Cn0vlvJZKA4FfJVUUJI5nWpzjbLlJXJf5A+EGpd4Ep1GcUJEnr8GXBD1eDfV6I3uJ9vk98n0v+1occejzGp6QCH+FoETByKqE2J8UrFbB0p+kusmoXMyYAJKy8haVxp+eC4WA0y9E/K9NSX5FdcFZu0i++eRPsZAJaFQ4QHg/I9Ihgu+SAgcxKkoUhdSfF19OBMejqM4kRaLLp2UYhOV21qkRYBjB2SdayA3FncNHayO7bFxmsZAMy8778m6Tw0FuzoYIEL5V+pNZ7nKe6S+dL8+Xr85fvXj14iXxcRMvo2VNBUyfF4soDgwT7G/9JtBgiqVkf82lNKjKLrj3kzkdGI12DYiiGtPXmx6M9AQwbye/enXye0qnwyVF2zA6zAr2NNxmQFpAhKBUdCtGjGZg/A4VaAfy3QxG7FtFonEkcL5H8xijGZv9tKxyBq5f+oKyes/rUAUVYb+/eOx1tVMWfU6TqPI6rtTB4Xt4SdrB4KREtMdfitOWf6N12yhv8rXpJOjeH8LrXYrqknxxmpdamoKMS0Wlvd0//Rmk4IejhkmAww2qDqOUKMOkS9+Io4vfMsEef6gsDWy0ZASbrKJfjfO6jNA0+p+SFMFfbYfIvFnf0JVZIiz8k0FMVtQehOW2uxhIyepCBkis9dJmq/TnDbqXtIdcAbbx/Ory1epF91/5aMMYrevtKJUKLkQ5gBcikrUQut9TQw3JiHaZn+rUy0jHT9h8ex+mNYWV/Aot9DP+HKSX4w90ijlO+74ZKt/FU56ggP+Ul+1T/w73mreyTOyLND8okk8bFIvQifby5er64kr6r1a0Icrh+AIQ9UcQmGRsYDA9BZr80Qckm9+ntcXovynzght9+snkG8CGnjcrHoBq+3tD+mpiZ/XopIFbvbNJw+1b7V2wW1fWdM6HGu9459BPz9o5ij79pT1mdZ8I2G6qsKqxZCF5g85CXvb+6C0kQDnsVYCo36MwyVgXmp4Cu63/gD2KlaaNYqWpptvOr3pW3eCzDSkBn21IJHmRw5sDhw0k4b0T5TXxXiiM+IcsZnGw8YcMXp7pKdnLM9AlmJfKeEvrx4+Tw87d2APvpKOT+c+NP8i3pXFq2Tk0PILDYx8okixDJUxolzOYbDayK0gudWZuZXD92L0NDj6hiv7shFGrUY0pQ1YUFjTCc1PFeV1BBCmR7dZNx7b5Aa/5R26xxIXBGwBRvbAtcpWn90iNXdEWU1gCDEQMZWeaDRw1TnapsSRCaoujcvRm/ZaVZ0dcacRFF7/BVYnCPQ3t4nqPDJ7VdEdt85U+XGfxnuDgnXSv8FqbPOzzX/r53a+0W5SGsXjjpqC5EeTHF5s6Y4tb3b0WOXZV4YA00C841ZgjyrZJxtYjyqSgGR85Xb1iJYzp1hjpkqHSsvei94fLhfjaM7oirCOjZxWE4M2TBWeH0oK+1bpOUma32AcGCGGa/21oiNoXxDFbNCSnuFDTdjpRiCSL0SMvk0U+aPwpxZ0STwf3hCFF9hsCMmGPdgEnAzXjpAHpFuv4gPxvhGIU/5hkIT1phA3LZ5SCHUhlpGBg3ifiIx/Ezs5OdOiSIWiMQZrTx4U1IOzK14qkDHrcNHzJxEOLYXpyi6qgSMNqk5d7LXFnX44cGfWDnhWdJVvuami5AaUe02mjSndYKtGD03NFqWTRw7ernDg9X2XKGw3WkPG1+VN1TfHnlHqkiLozwecalQd6VEGy3VV4BgUCRRochbXvrkDLvmhGUIs5ld2AswW1s2El/hmk3xi+0lIQirAM94jcTP5EC+YFLDCZrJVJdWiFQGmAR3jle9yBgqp0ih4ZNfFzWkSgdq+AweT9+DbBfVjeEVYkYYHueAVOFW63KA5ohoUkM8NWr0BZhziJ+pgMGr2ChJ2yRbyFCj1286tBo1eQ5CVNnV0fWPnKIiS+N/udFh3Tfa+ASvNtQr4/yInrSV5AMsDwHa/AIVMfwnwlj9i9Jq/gKFHKM9A3SVrJYzV4wytoOOOAFoE3vIIGxVtEfgBLStRrchcOvAuLBgdRQrzRlQ4N8IYGE/aFDoDBHTbakmTbnhsntzoOw5N1w2YAlNBIZyi7yz7PugUzydQMbAX0jByNOfkFtCNRbABsIo9mdGQpOmlZWtd0cTmmpTzikh5U73HEFcBCE34sTnWbm7J+1ay+tIGNRvWVHYtUTNkBEqfYJQo/31Awi7QmP0HGC7y/KdKkek0Y+Zi//oRtwIVl9OzIj31Ia/y/WNizvepSediK2OnLLOGFJZNRNtiHHgfwhhN2Px+53y2iGvbiTNuxM1ztBYg3xGAEjOcgTko9maiiZMkOmUF3xflDluZh/P8kbIuMdDnsumFXNC1/kp9vW4DOIK27kIykylMBe5m2qSCcVeWhva7QvuiuzmivfSjzx8MPWwKW1N7IGbm2B24Z6wHQ5xeryxfLi6vrVy+vXlxes6zr3oZMHYWoMQxTAOn/BqqBlkDEXU4EdFdRDohguIEAICpE4ERLQCWlVVKI4GzBcmgOdM+AgUgxvFqiFIVZXbym/W0gUxVJR4Wye8Nd0gP/DPHOQJHmW8PdTjPA+0BW3YDu9DWKQCDisdw7KnN6kIQ1wyWRAJ7vdT8wA0O1h5VYnxPeF3sLulPIPMWkE3+BS1Qeiipv/UEZKxucPMlwMDdPNSRP7/si2IeF1Omd2tvR392oLnpdGeahBDMgfLGrqoImYz0egrB1EDR0eJTw9HHrkkl7CIrp4rBVEysbulUXNnHfOVTNyq7cANWyeKX+bzmSrGiiH7pIADEBRXuv5wZDJFWyR3ldBTjZZqH+m6SOhW6fDV0gmGro3sB0kvOqoSGdxCwRF1FpT2Gf2CZxG/IklK3hTzXjw9nr6SkXzeUta/pzbT0x4rJHlXObE7SMsnEozddh2pnP7hJOyeQEtnWpzGnDZBcTVyYDp9iDUZqQnwrISMXXi8m3bRPC6sHfsLceEhZuQJuwTqW0J+kalmtBYTe3LaNqibv+wyJADHiJ2kcqrF8/a97FDo/SDGVzISWxSA0KrO03DPdrAVscJYHju9dV2E5wCxdfXSRuHq0tSXfY5uUCPYY0NZlm6JbEWeQZufQTR2aXZ/mC+XZta4NMXtA1S/r6FOqwSLT3RHZiEOJDFgW7PL/DWloc3wXUwqOA7vC2CUmD4RaOFKtBlmCk1TzVwYKXw8dGgJNXVwg7qqh5IbJi8HfiI8OOhkTzMkyDIk8PmyRN9WYrzbempf+Whvw/SNE9Su0GjKpJkm3Zv1xz+SeuuQb15CI0CJkCJaFk69Z1ijUqKaOEizBj1o38a0RIhOGHMidCzVzC8GJHxtBkLxWpWCSxdKHAZZ9MkaEtaBdAuysTctOsuX2Sk3QhmSQ27W2LLWWwtbxN0nwxkp+oCLd9/EZ5Svcc5SXfmiUuTKINDiVJrL8nrIwDowsv+1G2wiFfd84NtYRlz8EBExdgfCeQ6pxI6FFJXsGyoAu503U0glEDhWIWbciZmNzXbTeblMJUhkDMyXjkMSjrrB0qoafg8RYsrNPvOpBGNk8wRaufp1/IYHR4Il0jSqVJ27DVthFFNU3olsfM6JYTp3TL/gxaFIDr9+4KUMUVrHwri8dddcYDdsQpBjGnudzNPt/mwmhSnncc0NiVp4wYikkBKTqT4vZg0cx/MlqJLYm67S3SNew1CgrLvMbefI8Nju3UzzgZgsXPPs5x8ifq9Li5gPsYn+4mrjE247o3iioNxwWjRna1tL9l9xxBFRAuG6IuSqfrNo1cQ1HopMAgAE6Zt2aeJ10/r+zLgTNrRZ/tml+EcVhU0uRYvlaWlsSNoACKBfJNPkFDIiW9wctMgtC2QKxArGDZ+eSfSXOS8enkNCjbAtOKH9c09ua/8M02uN7NQeSeWLaLgLzqcJAm+6Syb3LSE+xWpkFx3odlEsbrscXnlhzjz+lU4mLrgoXoiQNfgO5LCGxcbRo4+erwYofCmNWFIOMH/8i4o6vIkpKwRWWW5ooeI1S0fhC/q5m0NerYH6Lhu60b2t4Bu2OCbeivhtmky6JX+EGKrFfERzUb2Tj+/JnHyuogXUBF902Gbd9ItpNgC1HSJ0AQDGjRqSRuk0POr0dTbYDBCnqq1Q3dTUhTINpWxvnYOkIEKYLmAVktQJLFPonJuPkQlqhhvp0QT3tqQ2RiTfopIC+3ReW0h9otQ2OEk3lddOoBUNgm0CpU8tYiJlb0LXLWQRYONPre1Y2wPZ6VVAi9SkhEav4Db+4GORstnkFt+baegSp/mWCuZIyfwaaJIUeEfSdQdoOTmU7eimkkVNOFRmm3k74UJ9ndCNlguXoifTsG60n7To1Ltm4oyk0RVugGHMUERzGb9bs3wLI6MoMxd9RIKlrYu6V5ytKsMUlBuopN7RUsNJ06WTXbF4awV8lucoEmyd7CtZg6M2vzVL5FqQFIxLk77i+a/FJpsLBMEMyVumxbsz0DshkNC7RdT8L3pcxiexdvJSPOk98ae25cyDyT/Rq7mGW92pnwe2UPsSbPFw6794MePVVfWabrfLjmjkAzcn9R7fWqL/criO++fKzEOrDwb1dWwdK5R5JXNDrGmTcUqHhYPQj2i48P6o7bmQzaObUwhSTdmtyfpnftHhnAIpNHbMD5KjWxCina4VJKjLjo+8ur/sDR94g1FtZS40l+I4y7DALp8ug04onqDjwqqzuY+stfy0AgazucPNxqu7XJw50Mc/GdNs4Z5nLW1d2d4DQKf/Hb7BY7k/YX6Z0r25wn/u7y2RJSCxw2sXrGLExcY+yEGskeRX/ycGGlP9z151YTG9JMigazg57DZOu0qRvj2mtYvOW4qAVlKD7h9kwUSnnGa4bwE1GkBrUcRdNkRaWVlsO2SSo1JrcMy8aupGJ9ULpar6Zs19YWMwXT2mj9dyWRRXOKuWbTzJkoPycXrzjFLBWoJ+ZqNxIYrPLLfr9hWcfkX6jmSysrtugaKw36yOX4Y/5OSPQbwSZ8x8g47/YirYnLdbqbDXRQAEXF9YwasiRV0wB64x9vXrNvXPzMXwK9ltwS+6r6CAAlGy0ZbKA8oqluOlQe0VxnXTGuBsqeyYbXJYYneoNRpW3TbwwKAyHNXEnv0Qf2CiZqa3qZiWwS4R/KLX6XbXLa2f22CVbibCHsqE0mYouqN+/f/yTKMdKPCqeqhInphc6M2sQ3IMVNMtdQuDVFlaCATc8sQOGmMKs29SIb39cunQRgoOoZAYByUOX69ENJIwYZdT02sFs64T2/6P0hPEulsaHbKLsPaF/qv6AvEjCNUs5/SACU8x8SCWiCujCQtOccDG9yv5XjClWwB55YdBZBR9EM+xNIptBWhwLFN5/T9oOBlmfNhHH8oUThfp0iLe3/sQ8TMr3OKjrTzhPjG/zjy+foByHI/w736H+fPYR4f/QD/xdRjdr0SpQoELOHMqAlgduTGnp/LB5GxUwXvDEp3acdUMG7wBhtsa/J5ZnNN39Dn+ukRB+IPrfTVKlNPs/KppmZxGHjc7QXx09OziTTIqbjU0gVK2S5sIjtHu/okgB3X+QGANLmCXFppfxIFp/vGJQHgC+8Nn/PJbBUSX5G1X9oePi1GCb+IGPGezautKqjJ2nAgAUfXmv8x5dQGck+mYuHruvNxrh22f8+NujRujyXL5vvhh7UD472Oq68W6lbg9mo9jGnRwrgM1ygqAnByW3Tjis9U3007RgqvtkFmzeEUEUPCM507i+sDPa4WK1/zJSf8hsz9W/tQddkKDZtmk1WOGBfhEpTRTM+bK/fZvXeRLYPi07uIJJ/fBED0o/EKPzvRXvJzIXd0qp21bvmPNXuamo18H6PiEXNQResmvnIhlhNxX6vLBTw5gOrCNtNBrWINafyDIKYKw1aXXPTG0qjokinmBsxTe4Ey52r3UKgQ1IfX7ZQihoDRPmXjJGO969bAhnImLW2qx0mX+c1j7KxDyNzNGi5gB4fTahwVSbZ1rRKMbZhgs7xzWm1FK/KRAOtTMGUv9ZVUdu+qtF2IueG9mLL15cj5FruG8P9hWG2bh9mIqDAa4s0sYUjAxTqqjFoMj7hOI8cgYwfi/TrPpFOgqJXT4rsGAN/Jom0Dzc6XlDE6L/HYzU0sKCgqfbRftBuEN2l/i6L0jpGjcwNGkfgbDKaWmFbDQajlX7oWFk4FNBRlCIlRtMvRzDLq+lJcVbR9C5rhkobAWFvTxFp2PhmDg64WPE0ZwgYcb+xV2Rfx3Js+LYxgdIXoLNWEFCs0RiaaGbWFgLTz3gYpDro5d90pmtvrR2gHIKvOSNVOn/dQLDor3XozlNV+xamgZQAplT8Gh2RutINknAetqh6T0Xhh0iqemVAWaziNIUNT/9M2FFxZOxTOWQfxgSwF0G8gsUKoLpL8yzU3lWFDiKQg8cGqnaWCt/uiSJIA4oiSCkPxjBFNzbD9xnmPyWIri5vTF8kTYhhgg/hoTvWGKSAnDMdrUE5+vT2STyb81GJbyZ/o3mFsnTaOOJw2WCDTSsmU/zyYzxTSUJt9EObDxQkyc5IdTObOcr5xeryxfLi6vrVy6sXl9cvV7ANBKjkmY7mPhA/11CC7qyGVs77oCmN77KkSmhkpKupOuHJLhFtjNS4KD7lC9RcG80TsvsNEzRBU919MePX3W4Ms2TFQTquFWsTd/CoAlKO/VozTuvuD/LCITLiTaMao/hf+H/DNJY6Mu1Y2no08ujam25fAL1noelSxJTy3ZdbhW2bUnF0e1ranEZFoY5YVBoPcLqV2tgC2aVwtGvazQKvvMj9RbP4baXwgM6s2G/R82+bfYhCOE6R3bZgfrH1dz+lDALbckiLMeK2bOPEiufySnshDiA4fV5Jz4iNbKImU7etbQLP0DLZNqi0yWn0fo6rLWEhCMsyPNhhCPugkX/ZrvZiOw0mU4ZWIyq6EyszZZ8hSNRK6ZRzNae8kHo4ycknaRLLS0suVLReymKNMvI1ctMZaxImutfK+4+8ES4QivnD+7C8O/uECWW9TbQrdS2pYdgXO/I+iJ+0Q9gVNL/hmMDhxQuE9zdFmlSvCSMf89cnG4pXcBE1PYb1/nqbv05xzB8wIomo0BJJYr9A+xdZlCbakX6+Lco8QliuMgHXt8jlC+IHFmFFlxikxl6hi7PFOsnC8vAxLMkbKSerKGW2VjaIiiiXlTblsgZ7BHn52nJPWE6DtKlwYwFrXX3cBc9vl2ZVSgOQyU1jB7RMTthebXDwCVX015QSWYf2Sq4aZBU4n1RoPpmBuVCRuQCguVCxsUtUZNX+DW1FMnW/kSGDcBSS+SSPhpI3Iu2FPLoMrcSFdYJxk4UF3uXVDSpZJJUMK5+4jAzvAOKi29HTWlQ4wRWA2zb/hGJ5e8tqMt3eqgNZW5dJbevgM6JzNuq4iUJ8anlwm9ErwhKjXwuU3dz88t9mTihQ1N3r9ujJYFnh9fQYf5MQC5OrDEttTjBKbgF9O2yV/HtoCsMN70kHuBcJ26FDjGjSbs45U7MuYrQJ6/S095MuUMzKOnxH/4WYEO0nzAHDP1iX+QPmo5rSAPHUJzhh5vDnlLKExWamMyiv54RfX6gAZaHTBksV5bFCGTNgn3hluKyNYtKj+cqkoOd+ck6CxiacMD+8zOQe7XNaw7pEYYXeh9nBsdKaWjabsakrAL4J7xBbjWEfhvsqoVOyyfh1K3Jr+Vez3/nYKzt71qRJxAvqF97yWi94AcRNTzYXRQXytk2p7DgW9SQUCL5AMRw686QVh7vLQUAHLEJFGnGyL1I6VSPvjask6u6I7XS9DlhKiRc3qKrIBE9+JA6rkJYXkJqaruq+SK6CwDMa2ltvEhEisqnT+pLKlmWG0vvlf2z0SyyGeSEItyUr0SBePblqY9Q9tBDuhaUBObFKuVVN+B0T+t9QUzhGe1NIjqrP7Fztqirwd4tFFNMRlPCT3JdnGaoWWbEn1ERaDsH6QF7k+8uz87Pz1r+2DzhiBH9I0673sbCMaqOsYtBOi82EM2qGNhIgMtYcPVuYelL3DGAB4dKfveHAnp0iYMcqbLOMrR4OFlTZmqDq3aA31HRlQBzk5MpJLW1AHd7xsQJEfCVL60ojaSubgG0cDFZzpnM2ABfaWExgn2xpF+iH3CFMVo64VRlmOGTpTU7PQ2Q+hxOR3nyD/E6zfweOEJtmIKC0HDEfsVKMiJYlkdMCxDmcRef5gU22ASbElM5l+enYfHogRJIur4MhXVTphyz+DVV1mXkSRev4ncNpX4MoO9TJaZnhHM4D1vMBi1Zosa/TKhGGPHhIql3QnLUwRZjk06NYoGAwJbmwGoJbXKGCBV/4J8b0n49yao8QJ36SGroRVLYzLjQvTDJexy7J9GdSAEeDjZppCw3tCGI0CSHJeFUg+i9onIrRebrBmLBwh6VmRmjJA5m1blOekNx87gSLWOQ4TTIki9fJj04SdyU9OpUf6VKJaria88Jt4mqfR3fNfhFmDKTrKVtLrOrBOhOR9q738sEJiLii1d+hBHLTwYab8fxzWullfZAaemctipFnaYOpJE4YXcWjhwqXAT9ytAq3k87dtM5DNfHLxwVRirlL9GKCFGLCUbWgacNRpR8414huQwjILyQVejGk0/y0POHpXFhlnDn5cs0SwCLZKljXWZwiZ+Wox6bbHmiPWdnrFPO89gI8fRgQ7C4nzwoESl73I0iyoNqhYJ/ELgs3zK3bMg7zrBkWQOLB1u3o9A+SkADgBM1ZpAE9AM7xLoc4HrVtzCMY5rr1zsS2h3uxoJ+wYolYeC9sJ1Fj18T2IdmqkX5Xm6wwa0aOvRB1mPXGXNWY/nDOi8J3gxrUfszOsVIb5h1PjXAD2SZZfAAteGPGdhK2o5ZaDXPyPUhChcEv7tNWWHQUy+tpD0Tlczq+fmFbYNQIKPV1sjyIUUGx5J9EUYs0r+NNGpZo8ZCXd4RBqTCL6RjyZmocL8fPQm82WgRhFBGQ2jSoaQ/RoCT5T5EmUWgskM2t2TjF8EDE4x5oj7GzKw9ykpQ0m30qdbPPXyInI90xdqrlE57S9uRfKr1OiE3BRcY1sxKvDbemyuCA0mULgjBxKLP0EBR3W6wZdfQZA9Kp5Z01dw8WnZk1A2N19GE6NKopMUMi9NNaGPYH6mt6NCfnDPs4JeeczzPybwvsPCF/fminz8e1J1aPzs61T2rm6m4hrJ+g9/OX0jBDBJJQLEqYanTqHeRJDwEOMlRYVJ13myhAd/mIB7THx9vf9xP9wWN6f2IhV8Ns+tintP3zl8qkC8Jg9IBPzgQ0c2Tw1lTJ0s+R7etgdhQ1neGIXCBRzLbLzBMhZleTDKby7/Ys4DgpWGCEWO1k+u/EKAkvuwbmlbkGkiZb48i9J0a0pj2g+/rTh1qMN+T/5aHIE3LPVfsz5NRtSzPk97icV8NuCEMG7FcrmD3ZkSir987nuzIm/ch2Zaxqdlh9b22dyY7PZk9UUNFDxtxN+e/z6bb09rmdtwhOgmneF2hCS90zhgOxABGvm9oSDUIZIt/t5ELVcRC4akuPQ2GCpbXb2B6vFzeoqovm1A52IWWVE8e8yt0UBZ0fRW829dIWhF3ylWmTUw+OPfSBkdGHHgCUxUmUWDMaTcay2HpuXQkA3ttWgsFsWSUwRuZoPe/N3hwplN0H92EZYNKdZVId3J2x9Rn1IhOITjvIr5FHCaWzfQsy63b/1hmuC7p+i+KgDS7Rg1ad7WQ9x772tGaMokd6J7haZOghUFe0BRjsLo1EihQAS+qkm8Fg+bwST/R47O4SCLDaL/csd6vrZJq/1V5ZzLBYVBJJGeIYQi/W0VSWJy0TqM8Yzws0VMuY+IjVS2pKqZyqDCNEfpSdcOpHYSKV5ePWaenRNd/nBf0iyk9VHhZhkehuid8IQnzIomCX53dYR0r4zesyQloCHN+JN1eO2ulTkdkbUYMoYAfSZxQq6RvHV5SXSgEvwnhNQWOQD+7rQQUOAtIUXVrasJgR0tOSHF7B4/y5vnLHuZyYxQSohr2hDV5ZqgxiVCF2WoLjEyQdv45nVmi41nhPfz4aHB42MVKOjrIvBViHx0QLIAU0FQ/QtqhmO/Oj9bToMbQOBzaHvIIqrylIyw9LEnqxMtsD9XZT67bfLpX3PfkTl3QITlQXUS0AqPcgjj62cmGk27Lhbsi4XqcJ5kW82ZYT7BOrjq99DBkWR78aZr599ZXOaLa1lyeuYY7VGO7nQRiQEhQd2vZUsdoGtAQ3Td47FCgowpK9rZv1EWBenbV/MLuO20CYaY1JGE9CnZ6uOkiqsi9U3Hl3QVI9igmUk6YA5NRVQwAy67YZAFme6Bdo5zY2RgHqrMZtNN7tIIBg1fHA9pBhfnPUtbdx8c6LFcqT2zvaBIEtXOvmx5Rt8jRu+Z98qJ/vBalA8Ny2piDLPq4ZNhVymPy6ni8ruPSjJCLnVZS8SjIkWvhRjgqRqIVlpHGl7zV4fD8FkO+HiHxvJST7PNvm8TrIcr5xNwod3W8KMeqqjYN4dfxMX4DjSTmk1kwWuJdC+COeSp3FAcZVQN4oqkqHt0ebufbCL9Xwrgtm8/mLA53rVc4OXJySfEG1JT/kU6Xylmcfi5W3zP9t9cq/d7eqdh/cv6NmuQ/wznXL/wKQ9aXLTQVAoB0hUvHOpWkle6lfEF9Oqn08tdYxoXvoPvYqnY9WNp9SydyJ3tcVLzf2f++Psb/HaZvu11PKPTNGBXbnkQ+1Xax/Ti+gU54B5HX42AN8xxGxU8ukn5S4/QV925Rdh+5MlGB90XWHRKktMe1+vXVfKqofWRfoyVUdexbe3trfHXLNgWuiPsOeTOK7yxnE6SBOjwjNyCmbtXmh/4SMdNtdhf3Y9d/j+bgUG7BY4th2AcPPS6dhj+Xc2LBnQLCQl82yKDtp1lm50rDr9sivYVo6ACUvKe/txRNT1rrf2aG00JdlQY8Fiir2FrZGdbYBRukmICYhI6NaRDByOcNez67D+200HDu/5UbDty/FRImcZqLoQJrsk4qGE8iDsZuareXW2dONdAw7XpxNx/ZEtd6HZRI2x4XbW01HlB6UyxEy64adP58IYNmP04oAxh0+u6jCwT15PfogmeOG7gZte3w6X/ddYjhzudxjn0+fOvbi7Nozfi99kGPKpl/deuVHt1551q2vvOI3DWmzD5IsOPVLmC/8sFEXnnXrSz+69aX73aokxweHsHR3exTAqr766UZagm4qno6Ea3r3pZqn1m2x2NdVTV7tEKDHKK1xco+CvGC18n3YXWPg3vV9/qMA+LTRyADD9G0bF2O7LVyChSY7dMnEFBUltfjLICnBmOHjJDyanQgzMGhfVAd2GBf9MIPSU6am5raqVE2rKUtAybnTJv0zqj7gq3HEV85BLuE8Du4TEq9GIbUweXZPXoX8zr5I6IkS6zpJ4wbuTw7nz5rZdrzigpn5v6lE3/cuqJNk391OFB4w6niN3T67k04YGBN17ZDuZlKwdILzus48Opybcsvv9MyBmIAOWxkW5LHvxAVHZFhVwToXrs2BZ9V9cVDhPPQkNgOyzvzWgu01Jv80c6ey2Vos9IAN0YsyJ0qAHep3yjw9V7PM05Ry8p8a1eh120BB6TWBDr1U2gEwnPSXvDkAVwc6dd4I5o8B3Y65r7B3KjcAwPn1oVEkok8ei0H0aRYBjgI1wo0j0roeBhPrYCivQ2afZzn9oiCr03TyxMZNKQGwIC6KdyZDAwOoNk+PkZh9GB/dFK9dlBMRL3tPxxgBuS58FjHB/WzCnjmI7tVyiYeLJPPpRc8Hb1XWUVWXKBZpfZ4cyzLGt/OzjTEAnhAnv0+UKHmDlgVnsosKzE3esqtC3+fT7ZGjz61T53PQTaefcNA/02CxfHHbTZTzG1Yg9TUZPPOMvmrAM7h/5QncJXr7SHecv0lKFLm7g+gbQGVSnLEq4wNVgh+4xbuwFIUvLPUtvoWMNj9GS/8mEf8NKZleulSUW7xK+7MPeXkXluwUkCKtt0nW2jxKaYuF+ysALthVWCR8ivrJEJyWaio1JVgsxvC8wxAbEczy3wSGs1346yE/1iII/bZ75HoWoLwb758FNbrmwLYh/79J/P8x60ik7PE7+mHCgVH8r+WLdlqAr6cC3Aw677KYDTvBSCLAbDu/Lfbt78Vr/8zCsyF35PFxs/IDMM5+/V+HMTCUVfJQxpx4q3X78hYn+yJFx435HniQTwPGt6HhaSgJRwbfJUXnzbDL2aX59uhP9c/dCPe+NGKU5a/9NXFPhcY3I/dUnOb52t+B+leEH753a77xyhjjztDDz+0xH3O44dTQ9zrg8IzYHRtysPXA+m+OJRR3qBxdPXhuzHpLhHIWq3QUgxMBmKvjF1bnQedU0Pd60HlG7PyOcz8XkHOk+69EeWyMslu5Xx67LuBryt9TgZoH7r9HPmdj+ZfC+xXRJfsz/l7IITloYuRzNP3p4Pg2xjwdqXmQ+Zsk9Ekpzm6F019N97dnif1bMfcx4fmZkPJtKHou2J5kH7myO2UkTel387B+Spj7aCSfCSnfjOQzwTYnZjTRiIunh25nW/n3QT9c4fnk6QrPc6HoXXT9WYCbQ71/GcQGx96BRbHLp26WmUehvwv4eQx6Xgy9G4GeAbZ5/PmLAB6bMdk/BK1MFQfmDPUTxt5nI/p8yPmenf5MSHqUm/7MiLm/w/2ZAfMnlV8e+oaFt3dVVVhYyFTH7MVIboTHlRCeCo1vXsFTcZqrIfzNcqqP8cEr9HYHAJbmvW3qet4c+Dsl8J8e/HNsAfX5YPQu/vdM0M0xwL8QZLdXoVbT00vm4eh0oJ8Ho2cG0buh6FmAmweivwxi95ejro4Zt+cE5r8ZdR9TmJ8NK99Gm+cDzqO9cAnGNWlfXl6enwcVjoKoDPEuIBCjjJ4Y5e6x7OOcO3/+3TgEmkMmJxwd6YBKvFxeBzjNH8TJm+y7gnWyFabHfc0YA8AfBRlDYkRP7FpYaLi+enH+Ikgyotnkl5J7FFRlmGH6mTCPyjIv3R8dpmDgjRpMAYM/dVzWk9XjRF7ug+WL5Xl3tHlAvNPPEXExA5Rtkwy5riSrq+XqumEfBQ9hRX7AR569MQSvri8vA7rgTudXmPh8QYyiNBTf6fqYYOZ+FgL2nU56RK/IHzZR6qZIQZ7v3Zd4Dd/+yLoGAI/nx6vr1WoZ7Ou0SooUBUWZ3ycxYZLT4/Z7clxtyQtM0RGWdlqE1U4XJWcEdZnq7veVzMYY+nHw7g9EqGZsnxdbqtVxWIXrENNk+e+az6Bu78MyCUVi+ErW6t5EZyUMYrfBg/Wd+FHZBgwpGyUCiZ2CHTCmZwsJfyuGzTrDdUHXFlAcoHiL+NzYWS9Bwy7oHDArUyV7xGJH+T7BCHdCL1yHRgF0jkPv/kMZZtsUldbogwYwKv80WwGVFDT+CXCauY4E6zJ/wIzACiHhBAGX7G7iHOcIZ1WQIQLFPfnyOCBDkLOachQIE5xriz3ro6CgmqHKRI2TbBug7D7YobTgGmOm8ERqhlARMxshjCkUQ5SkmxZPUzPOv6AI7sm7Oh2I0vDrrsXY1BlbZQjTBcLrOkljvvawyUviStAUDaCZsb/RplyJJ3S3v/9EE+GiElFdY68Y3KFD0LyJhTMgCcQyfAg+16hMCE11KIgFIT9DHHMchPF9mEWkgbxbkIV8mYdQ4MXtPqzKhDnn4qO0g0rIVYw2SYbeN3eBKFDj9dsmdk9BjH1Js7EWD9HqYcH2/3fQuo6O+O5bvoTOrRb72ADVQXHyVlkDxT7PtjQvl1xnVRKmQfU4q5ERHT9VBkLCA/VQLMWsGBpc5lFkwlihIJLEP+XlBwGL4v1aDwtGZBil2AS7JJuVxoCMn2rTR8FrxWGLtTExIw87VCICAqpqUYGDfmIQROWhqHLLBtEeYywawL6OMtddMQbRY8EqHRGZsF7S+x2qNX4jls9ys9eDoS7IO7MCTvyTKtfwdjNFAGCCRkcsDnP0gCLCEP+UlLzYVXshFhkVjegjcGEzy79nCRkeGp75lSdM/1p+3JX5g8q7aHQegvdhdmg4p5+dZpgHaim7/FPfCDo07IXbbYm2gtv2wnlxZsa6p9Bym9MA1EUsOpx/cppZ8vOIM8s/Oc3slBmam9MzwRXrw4/k5k2dVOg1I6YwQO1AOoyy74YhcP5itbq4Pr98ebG8XK5enb8YpNpKz1Tjz7TEo5RsbxRhTf+dbQYmdLPO4iRKtLfb2Tr5S/hgS/1NNgD96TLHdKp38zkd/wr6bFlnNBOLfEf1gb3/6y6tEHxYLJMHbN0UlQZC8pVtz73LNrmBVJ2EwTSqKLxluQo6Wra4NNpTveRMiYg/Q0kzlGdN6uGCF1dJEcb6B3rfTZ+fTFykYYYqTJQKTX6G6B9uOnsCebycTAokrE95bI+PeR85c3ZAb5sVU2wzS2DtGesvPVm3Kd4kePxcoICnJQaErDycRZ/wd/1GxmqF5WG6IzmrsAuD1FueSgWZpX6m/fkly1Zljfd7uen7KM3reJOGxAng6OBAMl6CaBNSZD+RdwrvGpN7qeSZ9wYd9eY+2ZbcXWxvbTDdxVKGcluF9sVBacABYYF+sdwqj0Dim9lIEuX7PekhvHizflPmxZGPvOXJSEc+9aHGCsLw6NTcgwek5m5vDGqa1d6wW2Tft6FSqB0S3GvNHhEoe1tLzAX7ttqRSXmsp+XJVts0X7dyfA0FJQkM0d37BNPczg9qp4H0cLePkn4gg7GBVOOZTiNvvReQVhI54L6S6b687P2xTUD7nUOFE+gwmsOnStvy5er64kr6r+xYQzdlc0L+8oRgvFin4Z9oIc2djn8WlVukf3S4AAGTqfYHpukkY3DfXj+Cdnl31VkhdE9flXPbjZ/06X4bYGD43e93eZYvKI0ojCjfywvy/QwR4rHQUl/6m2RUqch4GYT4kEXBLs/vsJ4Yx3c0AzVCgdiv1NIJiOg67YE5+wHPwc3b97KtF2XZ5rEaRda/6MyvGFxhqwjelPRnMDLbhxt7d5aYIJj4AhmKF5OHM5BStSjWLuDJrsxPCZl9/7AhPqnsfiutnQFpTQUTGOpdBDgLC7zL1T2Ww2gI/8XXBImbRDilY8R8xeEt3cT1HmFMOPojqXavueGwVEr77lB/cBYu0pf/cZeSx2TdNCm9KpYOKDPokLJVKI2n+uUZ1biHnu1ars7fGIj9GZ0U/O32oRvEzj61Y1OgG5ao9IloXHfJuKfX60PLtTKVt28gZO0PYVL9lPMtr/wj35iFys1t52017nQaHmxntuG0Hfk5TxbGA0vEKyG+p79LywDVcpxBaWgWsyyPgPY4zuKE32djv7BYSpubfLOOvWGrlP8k067GWA+aneSeDuzvNm/3RXVoB3px3Y7vbeEO26pdSczHKEr25N80wZXneeYKFGOJ5Zq5q7Vd73UKeYNEUZIPfJP1rAkKHoA6fL8JyXybGcbFp+Y0C5sT8IZcz0pB/qXZCmE5a4QMBqQOau6RiB0FjO1JB8hMiAKY0vlthdLvTX+Szxksr1YXFwEOidTwatv4CXtfNKcOTRWxs/FZn+U1MUYQh/0+EL+VATB1umCmHU4mBb0i1CsR/9JNOgiFM52g2oRbeu9W3JMMhNI+HIwgCf4NbVDJd9//wJ77hWiPbXvrjwLPmGp8DETKAsnEgIFax28/WODTdKRVSwR0ITjJtt5uU2z4h2cIw7Q2KC8IXqifQKpbtp/waJLhqqwpfGFb6WnCYwTDvC4jNPl3gGSBKU8RtSA6GNF6cDRLotUM8Nk2R3AaSzqhM9Mqgfwp9MYkJ9UeDCisE39/N3iEUURegxUrXIesPGF7ZI6nJlGPiNG77BTG5iiKnnl/VYTY9F0eNykkdJeu5+EUAJCJ/oPNqgFw7XX0o8Gjv8d3Vg4YlokqwiZX/YIwqxF4VkPFWjkA2dfpl01hgQYCvnOcGpcfsvg3VNVlFrSF6GfNmoDRRDWb4/nHgDoPdMrAP+vm0zCadfMbgDrrJjNftKraAif7IkVmXZykji6NljIyHs3TVMYnaokviiKqvNPfS6JZX8YAOmbu1gdkGHmHyaQdNi5M5kAcZy0UI3peZ9XsMkpYQLF1S8vnq4zN7pnGg5VO2Js1YRJKgI70A4Xz1Ok4SGftFHFXpezurI8aXOYY/vGYzUH8ebR7CkrzaPfskM7Z+uRjkOZhHOCKJrlsD09Nc1rc0jp3Ik3PehDk067FMTWsjvWw2ZhTD2uYBJS7KqiTLs48k64WBx2ANuax9/gFxQgWIshxgsqq9cpcauq/gfJoph0G5kbo9dXdBoKuoTDVsbO96/1NEFT2dCRZgFERshTK7U7s6+DP3O6DKg+y1qcR1/M2pb+rV742xXlkm52zEhy8p4ehvvmxL8lNu1miL44RaWhSPC6kDiK/pAgvO8T59Ww7TqBXsl6vzBb9b+uV3t7T5W2V32byrlPeMumo0afvtbxwHdLlANLlDOmTId0PpHQ/S+lXQfqM+6YHJdyftI1a8y3KhBAiWQyUbBJhNoFwbyC0RjLWYRXt6A7dDD+TT29rWH2IhAe5fkOmPd6mWKdVEnBmvdUCBQQfkl1lfv2VfRqaDWIUpaH4Fm/refSBAHRgI8Vh2iNZVib+7U5NGGDir57cky+I6TGZ3ipIh8CE/AKbR4aOUY+HBV7eJdgkaUWmd3GAizDDvhd76sMBuUmaw5d6f444iWn0Saj80fhTakGncXro8Kfxh3TlnKBHDdWcAHJwdRkgUyMFvT+2C6DPK8dEpDI65mzCJK1L5K1tGiJxRC3PF9MqmbmcfdRHz1+d+oTzLMjqNOUn9XqrUX0cHNph1WdtHkCqeeCYWp7v6FFgdAXd/mHDYw3Kwj11SelZdWlCkKAH2VV0kZFJTHCPA5TV+6ft2fj6/QmElL3Qu+zf4d72MwQnQu14YGYiCl7v1RjHiL3TrJV/IdbeqyWHYdZLCST+Bl+njs5sbBwBxzP96XHvtdokGVuNIQP7fUA+1f6G+YZIAGqhng7vfXBviJm/szVOF8R5FcT7/cZbPerj4FBwr8+av8K+qdOUraaK7/ZV2Ps4OCTsfdZGhd1ONuOwCon0PR7IILYlIrq4J+88n9SrhcUhCdfy6PfxvAmukszjZZsWACj7CGdhkaJqEeXFIQodOJu6YdZjxz3H1ZZ8820ZPtzSMiCHW7qHa48qVN76vVA/ARr6TKMjxkwYm7VkAg7+6k+ab7c0vua3qqgoHHPa81jpn5Wu1o/dex9UwPzeIISjMilAhyPEtFY5z61l/b1N8/X6IDW0+2T4Zfd1UqNcvpz83aG0oMCs0/BPtLhDBzyVdh8WU0lLFNcR0lNXmAbkk+0ZXc6KCXTbOg3LM5pA1TxkTR/SvdU5Tkg7TVypySziHnk+gQQhgc2iix4DyL7X80oJkXz9iWZ2sSr0FAX2wclNsADTbdlvxnl7ZXUkZcjmbPxUPMgboK7buytPpJ4fuRLwKsCsfqvc4A0IsaT63ZUn7LdnqFLu24ujjtobT4a+pS/yJqxCuxfWtRrEBwxJg3iDRyLU6E/zeTBwtkwromC/z9D5C475CuF2S2Z/gsP2wqtBoRsQPGGbe0CdL+QJ244uokuMpgn2bWbHWXZ8XseYnGd1Mhq+zukY80+c0c1evYLhkRPCGT0JvSPnkw4qn6eTwbb3wangrDeTPBX3ZpOMOT/nktJoMmEmOWvDwInzZyKKyfuMlaP2zJnvIJmwEfJJZ6W6dCwMCJzXK9ssITAQVS19LvE7AALO9zAfSGi9sR2g4G9uGy0X4m9KKOf+yYcFe3ZSMEfLX11ZH0hTwCfy/h4VIoMAaE5UHooqt/9wEJnNrxL5Z6kY5IL5YOet0HzydbJNssrvw3YkHI7YiWD9cTsS2/6OI0Suwzql27bHJ/qOb+QcIDH7Yk9Fbh6kniV2squzO2ql2BzRW8Xsw8C4YSiwT4ZByqqlCZXLrywaPyFA34DnjoI4mi61SWvSHoRF4m/hnA6CiWfhATI/Zex2Y+CQ4PJ4p2yeB/swOwT0BJswi8gUmvy8KMolHvL2AKUJ2EysQm/zNHAKDP4qUJ3huijyskJx4PmZxAAUnkRKAM49P5m4SJHnxUt6MHiiCT2ufR4XkkfyWLQL9jigqWNVskceDw0QGtAsRXxjGIdFRaYra1TRf/DnNKnQC17E5OXq+uJK+q90DmPzGHld8oiWXFrygm7r8DbTYlTVxUfCyU1N3vVtdj/hGekYSIhOPQeyT2F57zsaiMgLwh2tAMgOEI3qskRZdKCfqzJPvbUAI7B4MjyOoODxcMk3W7RpbPQNggYOXwdNAybDEpGWmksTkx4nLjVL7ywzuM7iOfeiRWJqCWFfi0AOEfNYj9J8K7bP+qtBEgZPXxfyL2FDxs3jdPPHCmW0gn+jH2+bBr6/S2k6IvuH/0XSk04nYncoepu530FQMe6rR639WdGQDjimAyvUKwM8q+FAbiNgCUcsmSGbDBn5/jplUyT+SQ/cBQSQSefsdg8ljNiPU4jYB9B4Ly97f0zhUSPt0P8eoe9CozDdhC1v4JNqULVPYWM/chJWfaDZ/urWaaMSryyJjbLKPihrBklWoZKQy5XX5Ug/qOlLo6ovtZPIkdutjGsnmUvAjCzttCNFXNAeIf/0NxTpjeuuqgrHzCn7GLPplfjosiL6vQM3CMsyPHi9DVdAMGERt9hO9rRcCcJJAPmrKPk+8Td7lDE/WKaZt0bpoPJXTeCJTCAlFXqrRBOgKUp0n6CHYIPCqi5RECc4XKcoZh6p5p6z+QUT8JJzVVuCTV4G8ZrVOdPf9qTWzCSZ89VW4buk8NYaMeZHh3SbZZ9x6K9006KnRNGTzzUKiMmrdmX+EDTr6f7uKzSiMnFJ2WatMAPg8Sm1YblFwYaMk5XHh9TKIHiSxqrw7PFOp/Dxdk1sw+19mNb+Jhj1YIB0wNLk1B5nPocoNqgkd5Iw/YG14QCj6g0vaeNxdMKECiO/XQZVHixbdRDXx5xe3sxH31O2ojyLE/7zb8tSSWR1uD7yZKCzHtDZDPQzAn3Eji1duJrT3y5vq/x2OZEuszy6XcZ0I+MhyOrU4/1fCgq+bPdSmPbXfeDluxG1o0Gab7c+R1MgLCbGUKRzEshfXEaLss7YXtotqj6w338tDztOrqxD+Hlcv4n0aky3xy/4FvkAk68MS8wsDl3r8vxIknF8nI7nj7Pv9SkjOnhmpYFh8VJXZhXhqJBnqy35jXmIOR6hgeLM1TifgOKsiAyg/YH8dx6qjKh4MlKpTM/6ARqQWUV0wMzD0leAN2vb0ATNPuFEeHwcn2ZHTmdS6KnJ8zClgWUepJ4Mndd65n3erjFFd66YBgDl7zrSLXoM90XqbxJjC4AxNWGLqrbC87tsk897OAf4OVrWmdmIoCrDDPMTHoIE581GMXSPUr+HGSMyR2T7eD0EGUH0eFdWe1CX3yl0fRzMZ3nPZ7tJUM2VpAN2PvpcRprDYFYdNw7tZozOZww/B6hJdk++IhbH0Mye3zRYHNoINsKpzzvmU1rhK8rrrDvEAXu8VR6EYy67/tUQzgPZ84CL0jgQu7wixMrUeb7uBELi0NAF8uf1wlAfEQIIKpNo1gMQFS/qu8Csf62WmE6+8H3k+YSNJ2X7qHEMEjhW7uLmWJD9eWCSEKFJHLOODCFx2Dtj/M1KICGCCQ/GJB4f1UCA4rAiCA79zhQtw4iG8rM8wDS5wudkNggLaGqSF+Rx9sJVeViERcIPVqGnY6m36JnL6LEKQnzIomCX53dYR5pkRBprCgFjQEdG+M7rMkLa78HxHV3ij1CwDjHSUhHpzsQJ0fe0Fk+eSd/YnnWjeSVxH39OaTlm+r2l+E3BcEsKHkozPJLGagnxuGIbrwwSJHtas9rfEm0qDIDF2DDm9glG2jl4EVY7x6PuPZz81Zsd+eWU4JBVQX6Pyk2aP3irPBAWDrmcEHv+Cj6nC4Qt9FbmezDMK7dPhs5fVYpKFFYoiHnZzMDr0+chLAY7+p5NV0ZrsVqrXBCOjm61OA9StA2jQ0BdUUxd04DOZcn7BGX44HkkcAScqVv9vj4jxo0xawROr8OPPWzoDyURcZeJKaLvRmyR+DSr5EScpmqnzcu609GYlauDCT2iqCbj+zzAGYCZB7dng3LWvQ6XfZhu8nKP4iCJZ+XTIuNPZpIJhVlxOmDygre3afoBT97HsxZNg+nYwixju+bd2xc/GcpZLyWfe7styfXsTo5BMzuUzwjmrIEdMnN2O4jIrG9fj+GsZh0gvGqOdDzzrHNmeCAFbDMKiR9FvkQkAl72/tDcQkhVIUIDlqPkw4pP44906YsQqZrO2Kdwp29nw9Chww8Jm71fLSzzSPxMQM5aN5wPjJQA8Xjaqa0G4voqoMz/rDIdMGwAn8cpHSrzMPU8OHqtcvvkkZbHZxsKg7pOYpY9x7Y70O22QZIVdeVvzaqJ8GiX/9q/O5QWlN11Gv5Jfh6V+5rvTrN/RXAiRv6mPNPQVMD28PqrSDIGDm2TkdnyV8Cp7kfV7xmX3fj1DkV3/oo6jMYwr99SkYfZ81f4t2m+DtNf94m/G4klCEbPbluZWHb0AAMJH3/1JC6Te1QGYRwWPA2qW9MIMD0zJuAJLK1noLZOyqmDVz6sx2ifR3dNI0VHvlbWqdTnA/b0c8UAClP1PtsRbpij6EqMTkDWmTBTH5kKhfsgL/fB5fXV6AEJPsThJgBkPMwHtGl2T/0nQOJ1dK2PDyrLvAw2eflA3meu3DYKz1hafd9BPINGTN3ZWYAu2u1mjsI566KEDju0guZn0jPF7lHQKNGsk9NgAnQzIy/5XVsQatn7I1Vga9yoeDmVsthOpkzDDFX0WG2ke+ShDLNtKoQauG/K0Rqhxqiqi/YYzLfZ/aSnpCwtgFJN0ur9cU+w/F6PY4fCrxMeMfF33U2FwaEVgx5n/saD7hP04O8iAed+rqB1LGLzUUfPcmQbxjW5vXxxfv3Kc39XgcKlU/lkvhwthtXweL26ugx40n9ezlM4LSzHVSkANk5rTxx3b81OC6LX0xOByqvz86tZyVokAL3qL3vbHOWXWZ2ln46pr5YvaGlktCWe+oRK2F75USA2LjpWIKOzfuDF6npFoGmrkHzKk0yMoFEZ4t2sKFNAck9jxjieVYdYlXPyZ1aQDorjpixzTWwYxeNUC0yss1utli9Wq1mtOigc9McYX24HulbLlxcvg3/QSSXxPIO5kJIJGAcdKIDL2WliMbpXK4IIZiGXNM+LWSs0uAy2Z1BGXQlQAfzO6kHMxvnLV6/oL9CzUeipnlFee38ugRkbB8cOmNFZP4jZuDo/vwjCcotZuJ6eBbtJk2jWEDM6Dk4hdKzOWkKjd0syuBbbYJfgKi8T8r2szgOe1cQMjzMbv0c5dXzyfX61ejkLeweFP2deKGzPgwGdaV2/vAzQvqgOZLwsw8OsFzAsDjpJAx5nhaCu46uX10H1GHA6OsNCGZ5rfU7AZ2IOvAvxKT0Isw6R4fXFq/N5kU6CwsEoFONrFna6XLl68WIW9g4K72YTnO1ZFwgSr169ugoweaOIVguN0jpGQd0UmJuVZAJGfmSgj4Aw6xIdYVfkC7M8C0IcJQk7sJ292qxFJnScC9LqGJ11hJiRy4sXF40ZQVm9n5UDhsXB6NWAx1kh8OLl+fm8stEh4d1UhHE9KwLd1HV1eUkf2oflIbhDI+sakxTDoa19fXC+qnyJl2fQaKGcqH1+KGBYTTqy1Ef166DxaN2kx/msK2I7wOWLJd9BSU/eSbKgKsMMh4xsdufGIXJxh4iJ39nDI7bk4vz6Jfn5bJsHab7dzkWYDcBML7/swigDADBrDGZfuQy2ZV4XwfoQ4F1eVlE9Z8cbwfFjPUbH/aw2zJxczbUVJSgcDCYzvmZhp7kMV9evAnrkZxzk89gAg+JhhosKwNdqyrPEER0LJF5dvboKsjxA2X3Az/tIsmRWQCM406c1cz2hqZjOoyBxh1evXl4F+HNKjxWK8iyK6rKkid51QZiYlXISSA4G5UY4dn3b5MvVinxbluVVEGKcbDO+u7rKg6TCKN3MejERJyerUowxPQ8sNKz/4vJVk7WU1eQlZ5UBYfFvS/IAgllf2MTz5bm89BXQSgVkFvq5RuW8V3kKRj4GK0x4zGpFjQ2xNtKu1YCeskrXmdnXz4o1EaUJa0PPcFy7S1GuUUhn7aSVnslEc1bBDgoHF5wYX7Ow48XFq4tVEKMo2Ycpz3eaJV+Di3eeHIDBrDLEeLw8J1/I85vYSWY0ZWOudTkdIgfHEyO/s9JQz/P6/CqIkoqWzM3QnFetg8XFXOo+j7NC0PXfl+cX8lQsCvGcQz0CzhNn/L5nGsBgzlrIKlW/OJ9Llh+LjidVcnTsz5pDwFmdn7/onN05/8AEjIMzHoDLWS2Is3v18uKCIELuB8lccg3CxLkSUSp73h8R+YK6mzwWUoYPQVI9zmqgA8bF47yHXLqdmLlcXVxczSLeQTEi1M3cwDTntpTz+XhgulFJZGg/JNUueAjJi5R06pQhRnybJvt5X82xcEE1asSPhXFYVNQLRxX9h3/bi0nZL1+xP8ddqOfNdd9gf+/yah4hJSj8SwplbM8BAorE6vJlUCdZRSaLQX6Pyk2aP8zKYcDGxYIHIKOOz5MuVucv6XhL2KULUXzX6yz5BmyclHyI0XlkoFPI68sVxwMHYYmCfL2pcURnyDTETowFmS6TZ+6RvLtiPpDgq8DzqPjnExGaVZPOHl9dzYXdJSg83NVG2XbcQbt88eqc/ELKvoq9R7APsiAOs21KdwkVyX0+h+6Oweo4PZlz154Is9t6+fH9L8Hykk4Ys7ssf8jYeSvBfZjWiPxuGM8TqaOxci0HYSLbsy9Hqwidv7omv5rW++w2zhG+zfLqFj0meB7aRgFyLnfHwOusLASfi5fziVYyFM4pAONqFnWGxPWSJXrH+HPKq5V0uyZmHZiAkYPKYWJ31hoyQbu+vngpby6K13NhtXF0HFzY0bE6awl1My+X50ERluT90FxnYwwZfxZlQPZnjaHm5IJMzEQ9xiivsyqoyrFzDP0ZVmBw/FuV0QAxaxBevHpxtZrVpUXCO91gXM/JzN+iUvDFiqbt0XBhQOttz7HjUXB8rCcNAjGPTLRa1ourF9zXDarHefVyBBkXy6UBbM6aQQOOy8sXPOBI9yqxVdxZM7TIDOLNLh4NCjE+6woB5vrV5XWzo48NrjiI6yJNaErrrDTjEDlYadDI76w0FKGLV8tgHxbUnFBTMm8f0OHi3GLmkEXH05lfnL+66g7Vnn0pEzD+hY4BEOZo2TeY6r26eBnEZPydVz0NqLg4x++xOLtfeHF5cXU9a0CLhHbQ4X9xGS3KOqPnni+2qPrAfuF1t7llZcZkcJu/y0OYVES2NCRtRZzVYIhbWYnxPKZ9gz3s5y/npGgJion5OvNhbAB287BIpqYvr19cBPk+qebFIAMqzkUk+gzOuoAXry5nF1FCAhhaovJQVDl3yUZ4Xg0DFavx4qMrO6GatYfOOldXy1l9OijmAgTPgeLX1PWdMIFq6hu8p8xF+b6oK/Qb2qCSvFkSpj+wd/qFiKsvE6zL5auLIMli9BjkdUVfYZ3XWTwvVo3AYx4tXYjaa1mfRz9a4uvF7DzKUPhZif7F0c6ge5XoV9fLi2WwLvM7lAUZIaLpU2jO0jaCA8XxcBYWKbkX5cUhCitn0uo0EMzDCM1dJ/NJOVNk1hoYFucCcgMOZ3WgqFy8WgXRLizp5sIs4t84q4QWGhePsIb4nJWDHn53sVySCVmU1jHiVefCsgwPs34Y0XHvDEQNo84f/TZvspahcPGg24tn2EftRkmOV1fnRMfvyffFLLNvlnwNLi6WdxowOeuEVHe3QUaquzunshwBk7MFmbUce60+2zRfh+mv+6T6183PPPpu1JURRbFcS2A0Rnc3r0zc925Kic1QTozlUE3RJTcVie2toAchNDkE3irREImpyxl9VRluE3BTl4aI+atHZZdu8y6r0LZMqkNAVKFAJfkQo6JE7Kgsb9VrMkBwxtmcbvZM8DoaUKvKMKKmKE5wuE491rMBENAoRsSCCAl926o8LMIiYUyS+Yb6h/DcI41ycvFYBSE+ZFGwy/M7PPVRwm1elxGa/ACO7+hJghHdAIrR5KeIKBM1iPgZoRk7g1D7rGotBhT2drq/A3Gab7cECm/1v+F/4p46H+eADUQ+e6tdwniwvFpdXAT75BHFwfiZwDrt0WSVH7HDV5/L/t6B1PRRyI/we3t6qUK2Q9Hdu83bfVEd/NjDNIrsEXoOSd8No/0nCs1b2kfnHeJHb9nL3YqXs1uoP+E8C9IEV0FR4523Y24PBg+On+hx7O9Iqj323Fdd0ALyxGiqFx6pFrSvUCybojfKEE7PZ97n2TaP18EmTNgxzQ9JtQvCiuYWexxBPQIk9vTtPqhyQvieEr75sVW+Xvvsa36bPlCV93Z/W+W3maTDomVSscSnb/f1AtyjnXo9XqtJeA8mBSvAjWnUod/dpyzym+SxqskXtRpLoW0+M2wz8svfbbRTeXa7CKudYa5EK7NxbJtvfpf9lKe6CdbJY8XL4e7DhKk3/VfkIH3ft3YnPCr3uOFUZ1GebZItZUtp4P5bw13TZAN3cViFxMA+Hpzpr44jV/sMkyfD8hd6AI4rnSax5GqvrdN860x/MWZc7SnmaDnTVZwbx/pqh9KCvtQe7fPyELTRFPm6cX25Z83vtE5snf2Qpu9Z20dBbAG76zpJY8on+8AY3OjX81u3E1zsb1Kim++mrnySokXz1Uc+VqT1NsnIDCZJ04BfsM8f2Menfx91oD+UeZVH+TN81w2ZSL7dbBDpHdOXnbocdNNEJuqLf5H/vE4TKhniYzc3aaWATr/QI4rC054I63gkKtvpeXsxmIOtBpMu2tLYNhZaJF/Zr2k9mH3ra2AvOoRPuIp1g2KGHjh8zQeKXvOZm/0k+1wnJaJ530RfKmFPCF8bxv8+wahr62wKufjzsf14DIyU/h9fSpS+2xd5Wf2ffJY7TEAahhCWpwq3obg6jxj0661Lwy1rIm+2JyM14/J8daX+uZQkWJCLHwsYvuNPxWhdb8fJVPUASVmu222X6wYSIZprZrh/ZrhFrHbJA0s5Tipq+x8Po+QoI7Yc4al0C4724i27PPYpts6yeDvGo3iWbk/6DWVE+nmWDaqqAxGGrPqh3Nb7ad/xWKEMsyWQf7DP8VHPhEWRHoi78xvCdVq9bW8c/R3/qVF5eNrz71G5RXH3LJ3qjT6fZElF1Yl307uM6nM03l10ObZxGRbEViREmf9E/yKtjIHR55m14BzTIGeKf8hirrhH8F6GD8Fn+nP002siOMQUkR7H72k9mPK4x9lrH/MwIo8Smx+VKKQaRHX7A7fkk5992lPUNNMXHX1A5GguPvJ//8mGqylPNauBImLKWfwlj+5e0wPrp74vV2H0SMcfFC+S6pF38BuUHSaJZu8L/oV/EGnDRzz0m9Szxz77kR5hefM5NT1HNOeXfPsLMcZGst943/2TCGhq7gMO+Wsy1t4kFRqn5GPVf8lonZiGtoacbe1sBZZ3yK9FNaZu/GGxw+hHugtHQ22D86B2BvUdBt2jzVg/f/ni5dX16vL8+vLVxeXFagn4DXwoa9yHyY8B7obpKcndMJH13A2IFBPfrwiI1htYJE5iA9/QGQAfMNwa9ROmP8VVlg+aE79AdRaqXZk//JdrBRGmt48RYuow/j1TBu5pz+sHbsPzyghMzBDTynfxcc8l+I+yNTNTH9IN94bnDSOe4Sn9AAA/9Caswl/ydoFUQwVZWBMlH/7eUrF5jzAmVuWPpNq95vtSxh+PESpoocYplC2yZNjinqROjmyws0w03icxsakPYYk+hGW4Z5EF8IaI/+pdnYsJgnFhAy7U3kbE4a73Z020oNcksOhaTzt0KjPH+49fUH1k3r0IJyltxgm6TcxOmH22/ay9CaExdAjg3AY+l/opQWn8G9ro08G182Jbsh/GoKe79ljknu/e6wCtcMBC7nKC012K6pJ8TZqfel7eGNvM/ZBcGHq3lTjtTSNAy94fgswn8kzQDlAl8xcDhKOwSYgFnhlgDNAQAZ7iXcBPagcCE3kPDS09CKyeutWptmc+lgjp6bs9pr0/tsqhzpVmWaB6N3uC3YN78+wMPGRTSww4fiO0467fLNBWiyw8HsPjtNFgNsmY2v4TmZkGTAVFaxZW1g5IP+XlPqwI/zcVvaaA9pqEgyt4tdjb+y+tj0YZZB9Utpopy6/rTyiqGgKLHQ3OCHM0b+otebCx7uANGIzuvjOwwC4W7HqNLUteXb5avej+Sx33TzhI6WIf3lUo0ZMR46ME5WCSSYEc+FH9WAM+wGH5PZtAaTCK8AOtTMG3JXGcRqUIrZm+k1eY6oZlWY5SabVgQG+rVvxAq2m35rG7Mg+jQh4Icdd9q964yC6HA0pzp8NyZbVF6VSnNSaKNn0xZ9zIxmA1XflXZkdxNerF2D24tQKr6qVhptw6dpKAd83dJE80dGLdtgCS3NzrWzKgvWe7GgrlVWztE8mY0j5RbaviXIABLwhZkLADy5VQGKyh3BJrdNfol1wPYRtfvjQ81FcjiFY/xddTi5WUsFnYGSNEUbIP03/hX5I74xNAjBWk7NsBmKjzX8DbA//FQDX2UwN/5NoRCZdA6k1B+rZhYHkNhndgPe01np0X1TpgIDyw6WzB8txgijC64fbEECZUSFDnU8CJ94ANgksMmgJ34APGcodDS2NNLv+ofwFNw5inoZmfuRG0ao2CbA8aFm3iC05eFdngg4zWL+q0yCZGwVTO1jgNW3vTQ1yVzCCwN6B1Sun3ySejDlNEL2zHpgfLVESskgooIieC0YOgo72yz7hkJ6hT3tgHYbPadZYP4SHNw9hKztTFIra/TKwaTXArhL/6ZjCPkZ3exlsQbTd3SWGbb9uD6ncKAIXqd4EElYYP9TpNIrtlgGf98Zxk+mlkXi52y2HlslOGpqXrcXb5eyc+tuLUJctSrJS0WxNeyylxC7763X5nm4DI2+F9DEu1I5aDjhAtjYg2DW0vNw3KpoNlr7uW1ncXBVPpMYHuF4Zes1gOzjkHWzlAqt+1yXK2YvcjoX8gb/I63xchMw1qi0vWT+piZgPVLp8wHl4MlcjaQY73KMWh7VuTbYOVprMvbqtLswYmjQzvRNPA5ih31MPrgI1a3Q52YEkNtnAghZQL1LszsGz2DMsjS4pdgjt86+mxs7bH6Nf83kT9eWr5jzyYZnp2yu6brwzDnUnFYuG4mi4z0NrwmmZPUisFvSYxcimbl2wavaCtVGyK2u6qsnjaParZkFKPLSNesino+MqhStfbw3gpFcwEVwdlAmi31/B+t2AI3BuuEbZESsZV13rMFsPuqSkbAiHqko3xv/fR06xa9m6yzVe9O53d6rWBe/F6JGCC2KVFoQatEZPtl926bap8wPZqQfUQpgzUL1fXF1fSf8H9yhCVIZ1fS83Vc4/x5/QDQSEs6UouUeT91Efl7ZZMD1DVLsHBj6paMJ1y6OINHrNnMamzPLzueWunqOj0miTvGupcGKyhL20lOtC28DaVb7hd3IST3gMGJix64m5H8us0z1AnjBonWRrdTC6uqeeMz41M2mxfbB4vD9SKA1w6yBjKhO3OpK1H8KPcIRAyst9vPub/umHzqX+HoozFNFsnbVqC6DkYYKEkmF4/QQPJ7xOcVIxZObjqgrntc9bOq8AbamBjZJpsgM4RqIYoPSGeJvvGhvuQLtibKNUzY0MbJm81Bu+Kib5e8UcU3UoRlKZlzKdWZmlji3rG1P5xQ72aODqvxnYt2gh8U7+Poi7V8jP5V6bCChOK1E0xBc4YAUhLKdQa7R1dvv5m8jzFu+QL4v0Iysp6eyNMcr9NGGKVX6syGTt+wYyg4fSzGVxoRmDTLO/gv3BoINaMweObxYBSsKNDg3nItl2xCrbkCguZKKKYl5Ypj+CpfX3mFEu8fAE6XMpYgWd7XedapEmiiGAYReR16GlQ1Dz8XqZkgCfy/T/RQUR75SaDFnELw8L+1C4xTAM6z8J5XUYoQG0k3GqM+OFjYtpIEVIaFHzE08F9W5jUqlFmyPtI53IToe14neCAORndr0qCA1I2YeyKwFCVh3Cd2r4pRwt8HxQ22A2BkiIe4kHZ129WpGyURaVMKktnaeqdOlJGb6Swa1s4UuK7DX93S43tfoamiLWlZleBQWJHbGyQuOu6n52RXYjgr93d35zVyNdbRS+LfFp5JVa90xiAVkSsR2Af4js1k0ptEWrQNjrS6++646klYW8X4XW33et/OmvtlZ/7Jcnumi1uwC3FIkiL7sA63LA8I0DUqw4OZ7LJ8qejyeh2a7oY9UtuWhtkjNu+8ndUV3bJcdr73RFMLTpdVAMWAosHPY4X/S/FRXBM+EcPwZYwWK+DBOMaBXXpxCiX5qxEHvlnSpaNxewKj1ycj5DlVbDJ6yxerJMsLA8fw5JIM/4jxO8y8nSJoio9fEiyDPHj+MaImkWmOP6Nv8PH/P8ms7Af5efkbXB8kPh3Xv1EX4Jp0busqCuZ5nPncL4OM/LGPyJGLdNUOwLdL3nEcML/DO/RjwhlNwxNFFtXRGJal+nA6yYmILCddItjuCWvvbtTBUUaVhsyXthtx3TgmSWGl8sdkakvZgF20EjoVJHCZVBT/4DKQuoX/yyOuY9/zd4kmw0qyVd+EFrFziccpZrt6V85BNYsf++fIf4Y7gvSDzF15QRSeXHgB9KaaZrZzwP6I6/T+IeiIMNjQnr33YZ03GvadrMLS/Qu2+TSGo253xjJLn/4mP+UPKqk/0aP1Sd5GdXcu5M71zlzn+cprUNh6tsxmrlvT7NvjdaRxahHzKd5ScnYf84ZQZMoUixHRNXFoZ7fp0qVvn1EUS1WbZUGaNY4OIPOYu5/Q/u8QjL7assk/s2bU77BjpYoz+8SFCDjfhL9AvTEp/orsLqkaB5pEKhQHkn37gvbU6NVORFrfO1qkXw9tjHx4vp69eJi9erlcnl1+fLq/GLasY4THgN2N5qeko51NJH1tkRCpO1CKP8r0Dz7hE08t+TQkXS9PVK6LwAOdDRTDg97nkI/OPRxykP9hcGRh0zLUEc9rw3Swl+w6Bt4LeHAFGopJdRo4ZCkPYgWJv8jxHuFWD5ZcfCIrTZDwyU1H3oAjtw18KRj3bTdZX1uh7gP8Ncu8UsMm7DuDNbQ5FgrkfBI3a4SgTeacnjD4d0mt09Kt2db1jFLRm2zWqW2p1TCGT8fsRnyNmGdVux3xK5KywvkqFUA2rqvHAso51O6ban8/LDdlmhLHGRph2XbpOF6cFZX2D7RfdTcj8hss9Lc25Z5Xfx4sC1wKWtjWhOSThHZpZRsB9TYeDFWd186FNlDZWSeNKvsJcpvgKnX4p6lOtie/Ntdje1yH6nXoB7dCBMDOxkMu5AVo2CkVEcfM2mjH+bJ+MQt1tZ2PbRbThUHzX66L7odKRLGjTi1rcbdYzLJJ/wxf/P+/U99EuvdJHkXbv+GvAFXlWQLjUtv2KVMN+PvF3notZ074Tiw3LDWh3CKw/YjE1yJqy+turat70Pb5jOqCaNLRfwwCXJZIPL7SNo6r7nXrcH3b0uLRPyU4tdDg3lhMVSC04NAp7kUgGhYtlg6SrTP75Hc/XT3rtrmLPNKf3cqobR1qiDJgrsqAHHERjqY0y+DffTwzMliIYEREdKivcmw6SVNOygt9GFgXIHaGyui3nIanqFxbesjADfMZrZBCTDOLgnQQHamxOJdEJ2SL/ItEszjE4SHfYJFXV+lqSm832uz7mAwdY/s65wdjhRVeQmcLDSNUpvXZCE2fDjlD/1chsXuP7/QCEOLCHzniNMK5NLy6mL1cHOrDeDtku0uJf+vuk8seau5EGrDvskekei4YsRtzwtuqh2yKc2q44a9uNhysOcmrbct0BKWuJ7yAaifbSHq/XSOooaAsU8rvRBtxb1DYQebJUVUUQlKNydsseoPPyUpukmTyKYII0fxIUyqn/KSJb20vtKg8ZgTWeSH7TFlk2RKmYGYqBhee7TfSPJDnKvN7S7P70Zlakxw7ZIwpah+i+Gw9RgZGxbqtwoQOdOOV/DCHBPghkMbRTn7ogwVkv3LX9kpCViqUgXdHisxSGXjEw5SdI8yvKtQIrWzdaapZ0FrHpvqPVuoorFY9eefGNC8GgAfIm2Tsd6o3FodqF24dcOB3CqOY7a00hjX5qIplWjVApIYitmN//KiYmzUlRvU+k+9hGe7RXUgpYzXjan8LDAP06fbtCpuZ2oNcLABN1zqSQdTjjAxnDy0VKw/dA6YQgAdFmIgkOvmm8iGR4kID7E9xKhtGDhES5sGoF5dDBHEt0qP1TmTOodyzofree89d/6oiBgk929sdu/hbTTKIWr9DTbT5z2N3luERzPDZfu0utmucTes5gihU2ZaeC1iO8MfeXmHSuKQfKe2MMaZtEfEu656oWFxfgeO8myTbM/WdK8f+f1tnYZlt5vLAhgwquri/QF/TrncN1em8tQUBjlesg+JtsRrKYASVjsLplbNRjBebuNd9lPe1NDtt3Wlvjby8M5aWmaX0DmKbUmd4BPky0jbVQ0+Dr9FNBXX0S7M0B2R3uIgPdaLWC1X1kjezc1/fukkj17JTjQXL4w/p6BwkStebswOSWM8fshxtS0RbpluGo7ROBWDYmsNBMLG0hkTTxFtLzsVa5mjvKFHFIW2GFMyFH4kc3k+EIrygV3DE84OGzUmhmd60ySAsrNcwE2CX3RXlWGEgiIssWkj+1nrR0zeQLAALKxlefa3tzRug29vF+uaVmkKCGGatpGdQSPr/hATZrRTfv6Mea8O/7tDaUFREQq0KNJ6m2R4sUnSNOAX7DOlkd9EW+IzKg9FldtX4rPrBSJ7v+TbX9A9SuXynUpbE4yS5LW5f/oTu45V6paSmRfxNUNeflqwC7XLw6mi9JYol2YNpl2c0t09amo7YdnHLsxQ8TOqJJS6674KDPb+WaMFuum7YNpw+ytkw1B6w0qFAoAzEkyDDh69TFrWw3LKFxzxuCU9QzfK0YhD1xVKy8iRUZvuYzc/oJ5cXlbBHTrIleNub4UHIX426I7QXNkDloKTqSa3JoBlB6d7epzXj9JhA9J135qLezaZcWOWQXOW7ghNDwa9+TbnLFgjEjwKXym2olLthBKtAhz+XuwKoNBMJAHKCseTDjlXp/vj9PAk0c7pCe+yjIxSMc9HCRP6OvzZMxFHblOXRYM62jZNVs1TAJ5biYX9Cfs4rLNdWBSHICOtKA7y0oduHTLtQb+KoyfJdRC3J1CKa75iJEwhG33sG1Lakyd9kOCOWeckt2PNdYktUZSXsQ/iKjh1TlZJf2Qoqn4tX7Nseh+6ss+y833quhVipzxukrRimelBIdZ0fZBlHevOybSOUddlO9lm7KBy90VZcOqc5Lb1mnzoxI5Zh/vRdZsTJ7hKsqjyQWBbXp2T15Yz18X1H1V3hIEPIqvw65zYKty5LrqsSqcfc27KqIMzbcqW61LKT8bkWQp+rJlJ/Donswp3rotunZEHojsU35BvC/nJd9iPBUKIcQcXCSE2nQ8K7ekOUC/kuGHVOcnFTGB/IZM0H7pR4tblnnTd8KzTfMs7kH1XeWg6srl2okMZlx4oZdebLqkj48ofRVz//+y9a3fjtpI2+lf62573A+PYiXNb55w1bsvuOPEtlroz73vmLC+IhCS0SYANgLKVWfu/H9x4FSXL3Z0YBbH3TEyClFQPHqBQKBQK5vjsqh/a2yCIdEd87ENPLKE+3xlti61aL0SQexaOkOmMDnsYi2Bxhx6IYFHuQ5PelyYcZpMNvomi2Djj98IpUmENL8iiRBZ8jAXOOY7RvqxZN+GGtwq4QITqNMn7sJBbYg2XxWdVzzew52EzBeic8P1wPNdgg2uwNbTwB8sU6/NO6Wo/xsoKbXhBiTW20BttTuKHfWiuBmd4i3pKjlje4dR8zem+xOn1wd4LbsPVRjqDyNx92uyoP+B4hrl6kaD0xMTZiojRkdHM6rdEjBJcbbAK3XX9xbWz1jta6Z+aaSN70pRuea+bnrb5XjOBVEa0+Hg0bSSY0ull7lVFFqmC3bOEdASVm72J9N8Ofa3NNTKbvjS/aJ27rO/R1hxFuzTu3s8920CBphlaZy0hwu3GjnQ2331rtF34aw33+SYEGP1+5ZvaAf+WsfJ418HyeJdR8Hi3YRCsBbcnmYK2Af8MVVIeD/NcuwDbLAgVmApi9nfsrwG/oRY+v8HsYJsDngvaWbDYv2leCXy/jBKOM7bESZRzvCT4MZqlaL6H5PdVwn41hL3MmrR7NXjv1/kmIL/OPmQ52oh6v9SOMsWIxNFSH1s3TXGUkozIfWO+vxI+y0I1Jw5EGcqru7+UrNvPJQDrUGAyEizCTwtUCGPfC/Vt+iS/6hSF1qkE0Za07D1nCO50hOAGT0U3uzpc38LGSrbHpbmT4zJ3uPjmA7eran3mNK1NDRvmMSIvqM8903mxQq9+CtM5oTiy+9T2Tu+rIR+lYl9hrw1wRv/ipRa3GqY6Orl1DOWLTO+WOR1rNzSqfgd6TbagVSdexvVRl9/s4OY0ldSuGLijViOrzd7OZfsr4Zn4nZ4TxNZOsfrHp7sBLHjO1AiXpqs9XvIta2C/JriYFtneaR4Les+IfiIy0ue+7xvZe5hUbddKWOsBw/z485ZroxlGsuDYLM0MK9jrVTIsZ/cu7M1i1RV+3rv1TAd735ayn4/U3oPsK19SMX/rKueV/okhdN1ywniC+dtVVMad7FubXMO/X7oqI5RkaO80UQl7v8jei8x1m2HvdRzVXhocu6V+88q2CCl8asrZo5J631pdCfvv2QpgtwRH7ke++Qh8ZpyRJ5xEe7yBcr0C9m03WmNxcC9HqZ4aeP210RcOZGBdEuix2ff2b8dBF/8X+m+bTUQgSiT5C5/VgTTBRR8qyeicDYGe/1xVD+Gef0et7pvRVaSSRC4gZL/B75e1uSdJJrcB3y/C9zSg2wR/RCnZv4behP51E3s8Ez+6WwaQAOInHxfKyIw+FZjvcxRpsxb2bM1QuwbcTpmIJHtnPnXg/81KpuGICVvDxAslwv6ZZXpxKqJFmuodt/sOf78Uacrm8+DPZ+ghPWVIRhTlZI+RD3nCekZWlpDZKnJv75tZ0QK/Z8k39i2r+W5VsF+NoNxREJmonX10XfTUwODB+Eejz20CnCEuf2PNDKly/9k6V8CW+xdB97LKGdrkF1d7L2hdp80a6GljdkpSFruXoU5CMOdMSRsjGunV8tLRK1mUIImmSOzRwLBDXQwz2J4Ky4gQOtTcpZNyoX3WWTxBXFXI3rUhQk129Ijoreh7jn5fZnQO/LZxPMEzVKQymjGOyZxGD3gVmY/tZYr4r1Vhw7FP/6i2N5FU+5Y3sQ/8esD6DD1gHbR6YC7+VpfF8zuojvdMI+zhzPEr1dcwmfxaTAhW8BjrFNCRKPKc8f0z/nqqYM8sQEJjxrmeOsYsLTJqdkTs4SSgrxb2rCko6ErTKt2bof3TBC3w/fmGNeNbsmH1+FLAT4oLnu6tQ0BjH1xoz7rQ9q59FFTdRO5Awb3aD7+pAvZsnOxk8Pywzy1hU03sWZN45EwpxD3PJb9DXQzRMl/TTpGRu9w/E62C/lkW2k5bzTubO/o+86yRB39z+hd57fYsW8xXqKshr6r/jui9CkD8GpU1uOy/9tR7/5IBb6qAvfPRcl7ke0m9C3EjJvI+I3JPrYsN1bBn/YBNP5pwx31MS7m5CvYteq2dG2//jLIO/n0bC20CvqWSXGtDU7p/w0FfJeydUdQZEvfW97q5JvasSZTzBBvOsbfTJAd/WI3Zz7nCxooYUiJ95Y4m9ys5UC/6PdMy+nT5QuI7ZYQjkyRpb62OzTUxHCH+d9EwxTReZIg/iAOT4jBSYEz0Io2xQo4Tsw9U1311Y/vktr0Y9ugSe2QJmAa5tSZs1nXz1d+YF11e8nbhWu73wx86/9ZSwfe98Z8KsMhVddcyqbqM8rSYE7r5U+0uUSVN73+7+uaNb1S9wHUu7TPGBzZYr6rCP5HI/tC1dWrT0vNLhhK3C2jtSwNoBzuo5Da/rUz/jd30AdTFWkndMzY8sqr7i1o3SlCuh4YplvqPXRn87ms083JQMMcw4At6ztKNLdmsDzYV4qZ3dlSSIXSWlEmhf7hcUgvcftmKfFoQ3Xg0ZnfpTq9Q382UtYtFMFDXSmotsOHRjlqgJ1Cq3Zu3RV+FdcpHg4BFMS9P9Ghe15W+VrhulHx/9NPxj43/rhslPW/soLZ7PtXRvz1vaKMfbXz6zOE3O3xkvQ2sfQh0I3BVUtujuGeCBFTbNHHuy2DSxLxxGPmcQ5CAh5WKmJNcfWkZJWatJ33+VrOg1Q7cXKVc1Cq/9huddbG5Aa+c4DgdY37zg/2M/8a6bkLvjeDaFL3SP/m2bjbdsj7nSTVT9Ly7ONNcf6Q6LE1jrG56pl/P9oP1c9e2fKR+13p9YHSicsqkXtc+e+ewssqlUi1tR2v5jhtRDspXOntWu69ZxevrCYCdetBNyjoeq6P8GremPpbEXZabMe0L8PCV0Gz3dy/E7a2mZSNPOFEKMyq/rXapgkBsL83sw1y1FN5GaNqhi8SKxlFWSDOKVE7etUHDxrOrpr5sDBFH3eZxBKeyIq0y6xozt9sayjcHVdUCaxSumzdud2weGnZDGRytVUOrpKxBL1cke6qnbst2FtFo2b2NYMsIubEKe7c9NSoQ2ija6D6PeNroPequp94ObDGIDiRF5GYbYn+NhWYlaK4vqCJf2JioySo3+rJb5hbG9GVtbpeU/8mV/uBA0E6KPMUWptOZ7ZKudeTU3zXKcOJqoioUkhM1EZutmoXV1/mqJp/n31VM74Nu/Xz7U5/6O+EcrapK6H/nlNGE6O9G6TNvnhe02RI3vdbTaDe92qaz/50bEz3+zEu3iKuvKpv/hnc4U+pBrra80m5J/e90O1//W+/pVvTet0anS42/11463dOm7Li3SvzvbKcpEvWsrL7rdqte96/99Jbn7/QsnsTtRtn/6hWWC5ZseaFd3/3vtFp2/yvtlu2/g7pLWKl7TpVAmrLmvWuZH1BaQB8Wf8erlu5v3q+1TTfStZV8WbqmrMsH7itbZZ1G5ko7mvewd7gtS9sK7xDKgKu+vDPSViW76YIX9PXq6wd98OX2o6qBEY5TZD9sDMh2kdMKb5EgcVMrWEfKiMWnLMtacXn9XB71DnFHXd1y5H2VVbB0ZTUx9lbTd7vYPr0vNSrlO2hmT6XFKp3QLlnTCb0xOR2N3PvOun7ufa3T3fvDhNp9ufedjnr2Phaor783Vp3aDXH3Brylba4NjuAab7MKdCV1quR/mvh9XInr4rHCVj2xcdu/dgLK0lPTbiE7I1i37DOGsP5xas00Bjh8VZqwahDtkm6b+O55h8N3z/sAwCmBrg2jK6rHrulvV1ucbGsNa63PATD5rXWtq6Sys3srot9m7nS4L54P7PQO17tjyRI/Y/J36el/q8EWPJO/rn5NYIuMXhIBDgpNo7BSc2uFuxmhOxqY/e31s23RXb7nGXsVivPQ+Q1d83tBPTbn+J9f0a05fu8razqh962mToBHxZoVVbp0+x6sLSqVCyBdq2uridUZHvuWoABaCa7eeh9sWIzrd5e8YKEOgjuWzcrF2OomnFXYlnVh3EIdcyMQnH/iNP2dskc6XmVTZhYQOkUhGREuWP+8jNT/5uCErhoK7vkxYd0g7n3t7EkfRPTsC+ecZVteusie+RbQI5RWhEI97Xqr+8qfZcvp0U0TtwYfIKdn68PRTuNQ71jTOyqBG4DWljnKYJme8t2mBd1J7D8xKdjFQb2+egOxt9cKr6KqU7STm6qjN0P0U5WuGFdLjdvd1l2/tjPm6yy87vBD4Fde6zi9RtDesIzYrCOzADjOOUbG2di4Dcembrul2m6qbT6Ro77heYOvM5i1d6vQ6+HgSy29rmMCorVn7f46+Ka+3RTp1JwpbAlGylZXJh+GKfoBQE30NgOjODa0j/9pBSE+68ZqBx7VXqye+Uezz609gbFGaBY7q/VBcxdWhGDpkqpjBBslXy9KsHJ27XmcYOlpryelzYKvOOv6Sm7/XWZb694viLOt5oqg46ZTtNNsq0NOiLOtRmRrI8x1WLp6RUqag5FmpTM4DbOpvsifRtBPODOpevys1FinaLdB5qt0zu5g/jeNQt6TUslvMpM2wNS7uXWCWU7Rtv3HXxyV6n09jU3VXGoAdgOhrq+1wg2dtbc21qz0kKPMGwHmIS0rlwZybSxv6TlftAa5k2W9ozmxi1EM3/CoZoLVaNMu2c3/3plP9r6zPrv8bM96d1j6HNd63/wTnPu9wVWDuHB0R3O5rLl4FlCARmfHvQtX62zCD9C2bZq1DmHDZD3q2bsYUux56d8uPd0BNehql3K1YTmcBrzWWesA07XyISnHkJTja7bFBE+L+f5mSLLwdSfUWb40cv23zsHp7nzcyliLXmWRrbPHPqS44Kru0zKV37Z0Z/qL7EKm7/OMGnOddtiUfcM4mROlyirl2VNctueymmzLRUIBlN63zxowpssIU33KVB3b1C1ba8GbMs0/87iuqu9gaLK+toGfJFY4kk7baBV324bfPb6RdFvbdhWw+m7nBrCZ4WcaCJi+khCx3llahfvTW76ZE7kopgePjD/MUvYoqpTkqJAsilMmcGTf0VUUF0KYMy8+il+2vmBdbyyW7IHIA97cNF+VzjnKF74ljNxcIYkyK2MZfWRTESnkvKC6FtZL68ajrEiMMm3xiCLDZYplBXTmmflTmXsp+gvrwyVsBnLbD6QGxtIpTj07caEtdU7sbFD/dVNBc/x3UphFZ2/l5jhm3NjY9srJzrHvguckfrAVHj90hS6n3UJJFUufG/ssRVIN+xqIu3RYVK+NUTPVRxOcn1iUjpmbPmAuwDSkDKnZtpmv2CsneE1H5X3LUN68Vd+MUSsatdHejjwliWXEqFf9F2K30faRKlPfoL7tUQ2WY4pysWByjDlR3/EX5npc7H/iALvTTfxslB1Hhcse7nwWfSchftN0ffiKRpsreoxx9kl5QJXH9d/je4oXynBUv259aT+YTo9FXfuuyJlX7m6esul01Syp2HP3ylK3fVPNGFhBXVfsPmzqo+6zhaqUtP9jpc7qlrv+v/7AGTDrD5rmTP30wB5WJg5m5Ml6+cVtfXzZ2luMnunzHLa9oshj6RLfqlra+lVSxJ3HvjalUuKY5Su9RdmKbXt2s8Tv8ww3odIa6ZYzyWKW1sjWS2v1lZV7FQCgq1qZOSq70eTU/DIjMWeCzeQBykmEn1QPie2RSc4imAlbWpfUx2fX52R5ai90a0K9mqIY/6lG1rpG1gqbh6mZnSn1vhQACLuax0Ls0Uf/UzIJoAnPSJq6MyXNdQ2tvrPjG1/lktXNk4lNDdfVCZCW260A/c7a+oo5VVlG/q2wvARVgmOSoTRSn7NJw1sFBqcr0eeMpmS+kOVnvsl8O1oei5RQGaVMvRhxc9ozsRZGNFMjZCRQhqOEcKyVrom8u3fHQt/fG6gwQZyNL9Un3rtTfvzmQ0kQyVWORYQ4VmOdBoYTOFRslh8SC0v1kaSS3gGqVmFhMLEdg7dsCPXFU/akfqFICFs/UNfDyq+PATVSmhWqBM8IxaeV2M17Pytc29qEzg+YxOkYyyL3tLa3ylvd+F3HQ6v+p2o8ORwq+5+s7Fa4ksfaoyuqOVf1zQzLePEfHH8qsJC/vLmzF35WtgkFicSnlEg8tPF/ruG0zg4VFTgm5Fx978DEazORrfSBpgMN/6weGtr/P1fxLn4pJgd5MU2JWPg61vYKOsfy1tb/COc6PpPGBNfubb8Ft3c33N9TKpXyi+1eVqUblfnCV5FEc+G9YfYyAKZ8guYbY9/hQdIBFn+ECetKhy8l28F5e5T6FEv9xxra3xlwWK+4C9870k4A1AiojCg5MraUiSTwNDZ+CxqLQbik2EApaYNQY80pS4vM7DSDoQ12xpah/I49BofphM/BKzYQBsIW+dtF7jAK9eG3pnxsi0/s589NaMkKnrpbB7kHbHk1P/j7mqKPM4oSZNNlGuntNJgnUFqfkz05rIkYHfrdpiqRo4WUeVPuX9U93JajAxaBNRst8oGa+JcL7AmSaIoENha0Lr/UxaOy1PMhxYGCNYlZE7p34uJ/d64BKJNxTfh/w1FGoLR+JTURVn2atCKw5lU7jQfhIWqOcGCmVg6Z3iisflRC07Itua9O/uv+7cX16P7DyeX7szEILdsC8O7s+uzu4vR+/MflxeTs/uzu7uYOhrqF59jqFRywM6sXD0AH1iYc4JxW9ZhhZ6DwTJFa7nK0+9OUgHB07AwD1MTUugUg+zEAzDe3TqKDdgZ42J93D3zxsftOC707OxJEb/FGThWJKJ+7BYyPfjeoHcTvCUf1tJdvAKM+rcPwIPPRhQCekzxFFEuhvgbD7ih9OALpMdEjngbQa9owwHOTCejKrIMAPCMUqw9CJqQNIAw+htjv16ZBzVEgd4qm+PAHDcQJSmCP5msY4LASp0T9VITpXPVlncdVkgwfTDFV32f+azKTeO99eAEMpbYw5zh5q4urc5ihotENLQwkMcdIuuGkUPxcsfih6e2Fj82cDJJzfU7HTS5dvmjYwNTDcUEk9vTU8m1IBMpypcvtjgw9WQat5PrRjC+ubi/P7sdnl1rW28uTa3gtrh/ZuV5rf3998cf7s6Bw/XZzcR0UoPGZouj6NCyWRmdnt/cdqkApv0wNruWecMhqr4tD309s+phfTf46EPEHL0GozSIbEQkpmO2lCCc66S8yZ6jBiLx4FqBeAAXf00oQc0yx+kKshb9jj418nbDxXKuJOk70qjR0RO/HZ3f348nd+9PJ+7uzIND8eTH59f72ZqwE7gIDog60F/WjYDTKXYZqmAqhFwbVeWz1aQe/qSdlBm5zwLyvwR27Y0vU77izHDS6OyxyNXnHnsZ9bAYG2JXXEt+eVXiNl81TiqGBIGKEcT6WnMTy7FOBUrhQEvY7XokrJOMFXBACzUzvHrcOwQU1thRKymhmZj+R2UIFuK/3QeFYLjh7PBEaw7l5CHj28xKYd+ix3gAXGNwa5WaIgDrhVKtBuB2vEt9tHT1lmfqUmhW5eR6cRUwwqTq2iV+tGB3ouVCUoTy3XhI9Sb0yd3Wv+fa48w8SUTVS62xtlGi8Ji9WYwUNPmDXMnXKeWtqdP4BxNIlqbnMGQJXXXzjT+lpmdstWJANX+wVoupbwEPVobdVTj4zoczzdNUkM5wmSxnL11dEQkAWFCpZdzI1yJte1lfmcAfWH3cEX08Z1qsgCCNo5+kRZIybnEYhYOr36YWArN87toYM0NSwDumAOz9sYyDC7nU2qy63+nzMBUsTXzfLfxaqd3ah1ttMUJtBcfQYBbL21wulWv+7Q4/NJcDGYhks19HaJAEmWWsw7IGj9WQH3IrNrrM30JjM6e6BkYTpOqJ/g5qlaCscripoAOj3ChyDJEONQkuizJwJu9HnGq6ExBk486Dp/zZnkppvC2Ploo1HNTY9BH2oCqE1vc3QEobFWN2J2erOu9PnX4iM0CjDGdOGOGcxFgK06tsFmbu7wzHjiYDcKjchnGNp0f2OV6AbZ2ctNLjFXWPRuhVeyA1xhzVrqE2wd5EafkPcde0dWhhIjZDr0/TcSVxhcNZFZO8NaZCVRxcWVsZWgSQus7FC1Rzz0ocpwmh+bTyVh/YOz4mQ3h4dtBu2Ku5fH1ETBl1rkKqC8acUsr7YDOwOPVbY/h1kTABYh9QXBT3A0isvjnIImtTdgjkOj/YkjOWayXNW0GQPoZ+mTOB9BH7H0hQnb9WP7CH4sVQyTtQ3sULuIfyzJxwX+mJ/q8A4FChKTxkVaqaAabzal1q4oGbhoFkZgqVGhku8xGmrHv7taVr8JZFYyCGP6T8rvQ2GOoVW6V2xM/SAm2WlMvD+IIgukBxxgUd4hopUnj3ljEtf55mtHqDFPQXYc9tytwr877tO3IlSm1Drvi37WiEIDlrafxi0/gHpU4YSK+s5Z9k5STGgqu8Xfvz+9vbmbnI2uj/7r8nZ9fji5nrsPxEw9kN/htbxMa3kC06P8ll4TJdm+Y0uoYjatNHO6LKeTR2B05Hrpb5mG11jAYiK6TTvH48ht2+vpx3399phIO7vD2bkSRbqa3savcYY6eIo/iiGs1I8JkoHdwlW8BiDpenLgdbPFM7/pm/Uv4Knv7z5l/p9OVdf+Cn95eBgdDI5eXsyPrt/f3f5r/D4jxTkqKC2kSdDp/WYNImmKRaBd9hNIPFTjjnRcqO06q74yXoeJ+ZDv7yRvMChsB0XQv+oPoLXfLtZdXBfGw3901PrR5+InCpkgyIFOPpFisGBOJ+Js96jWimuTTM+Dnz5zNcjkQs3eEUJ4XqPk/o5lB44/ko2h27nNY1ymN2D4itb05PZoCi9ZmzdgRYPjPnEGMc65muJoxzJxaAOfaZKYFnkUekriPbCjbIj5r3zqmBaZKFzvwHj3nGts3OLmJNc6vUo3RkiGbz7dDfMe9cWiI3aPhArBfnJRnMPgzYAwiiLhPrCDEVigXJsnAc6Cx4Nfunys2ogDrURlDMkbOK094f653DHdSDa8T7xTaj/sfo7muqmcx9kCi2JEhZRplETIYfxyX/WdHquFEc6e9xAHEDiDF+D+waMfhz6Fzy6otJXOvDmP28bV2h77JNh0RYwn4PlEiijzqQZOid4ZTto2ZCIrM2ggdFQtOzAKdg5/zArgcAcmgqWFnIIswG19IxFtnfL7dsw791yu13A0bnW2sNioM3gebh7GGjltoKrfjGobY+JyjmOcYLXowmGgGMYPA3dCQRNw44LGDwNNHlK0+BhAcnT0J/+Tum5rnRJUCoiIRnHgDIFbhf9tH481k/9PjLEZRSPCklS4T0HC3NssG77WW46b1rMCRWqg6dpZG/MtX4nwTHJUBqpz6XmZJ6RLbAZzuHRgbNcrrwS/iVsaC+oRvGRufhXgAxw9AhVdO3u8zQZ5bOy36HHDygtMNS6L08BAyi6i2X3U3yUoFxiHk2x1H/Ep5RI/J0BoGyjpRLUnZDdaD1whmFapOlEO+mBHMr1DILr8gZYV2iBGE01DMgIfhOMQsdwQlfQIRABvykREUJjIiKA5mQb02mKhAhBOYEH4ppUAwccu8NsMBfliUPmrff0gbJHeoc/FVjYQ+PAGiW7w3vmFWhunR7gH/SWVfOdwXHaA23LY6BcGtn/JHLxFsl4cQHCd/p5kBZI1AUB9Ly7IkA92gLV+wAocymbQ+fJQZhjeYWFUB+xZskPnX9AmVGw9IHGkqM4LGBE3CJK4sAwaX1wyeYBojJaLjRo1pm6mTFw+lxgaaZm1yjD0BV7F0vzPgBD6feQJ56/Pzft/D3ASecFJTo2gvwV5sRzA7xnXglkSmOMlSDnNW1km596SqT4lMYs0z+HeWTMZL3fQ+InCSfsalcM5tGpfeIpHeXKdZ4iiqVQn7MxZI1739nYEYLtKbemcKwLT+zn/Ez794WgzpUYjK88Te+3CZzVeFDbWy29m6aMOFF/6tNJj+HxkKF8DQWY5qTVLtTGVMqeYP2T7+XsJ1hNqJS/IFT+dMI5gqaLEjxT3QAnUBtQU/6YYyTxyJUAs0TaAXQQqWgjmBGcJhN2ytIio5MyGPa7zj+Y7MRIyIDgqNHvhM97AYHpPiAmVF/N2vVRsc0xxeo9xiO7S8Eg+ygYjXge+87Ms8ITYUzDOyxyRgWGxMG7svCWsxgLAZKLPhBVmcdzj5eDcWWe2pG9eEAo317Jq8Jf1e+nmNu17XYZiJH+SzpNeNiafch7k2bnhhlq7/J5mpYhTlAyBei365ccms+uHwUof10TgruG2IYaohM6w/wU5WhKUiKJ22J2dAyMAY4fOZF65YriWH/bWHJC5zDB2EnjlS4YTZtrPkEgaS70HMHo6vAcepulV/q248iD0ao2+rmAin/HHsGKrxMinJaOUyB9GJRX8bPUqY+2t24p0RTTeKFgPEQmp9RByqTQv2ZTcTM6JHh+bUamSJB4YOGVWVgUc+wOfR24+MfDGXV8nHpVg3CRjSMk0ZX+WSABmc8gSLJsNmF3nSeeniG7E6JcFeJ+QABaWYz0yRTw2lYtd4xyInUwNobSimrZC9qVHkCTGRHj3EB8Ba/ZtGV/wKu3KzADQor+Wt1ylmMuAdZ8V/rmPRgKTvV78Oq+EttcgKntgpJPBX4LsLE3JS+vwVQ7pkUm4NV5JbaQXGn5M3Wrt1AKKFZBJT+bfsRr8gNoNywjEl6zKaXWfz3tooRKPLcvukl6Ozn6/b3L46uuG+9O1GPf+fhCaKqIM5Hb1baL9nM/+/0XAnYT0F6o4Npt4/mB+hY5V7/2KVUvJGoaPUUCQ2+9OwEsr4Eqn40YRYzVPIswESyLLYTVTQA8lis/YfbEfnQBdcMaYJB9cAO8kDqgzYQeaP/rBRdQ96vwBdn7+tEFNfqtwrVC+7CFNPKtArY9e8EF1fFEwB1PhN3xRMgdTwDseDaEJ5qRFAtzGrbbQ6MBvtfJsrzPFrULgJRQGIkAdkLjTrm8RXIRDihTnuiTOmFsn9sECkaKtQ3C2/R4mArVvHTMvTmOsLoDpsLUl7J0qW5iNXiOFQwiyZL4HxTxOXhsDhrde/Ri4IT9jldXKM+93ef4LMZTlqlPE4tJ3Lli8NRthtX/BCp9F/QKZ4yvwmJvI6reB1C5U6okPQ+HtHU47RLPd4JTXAZ+gNoG3iN27x5wEFUPb0/lBtH7s6P5u61vA4y4EOonbhHXIsOEAGJT6AbZ36sZQZ4zLnFyrb5tafYzNFqT/x0a1AbLSmp9UW+tvFZ3ffmIva/8dRi/SpmDSq28hiWMdgRFHe3UEY6A94QgQHieQCNOycGSaD/ksHv1H6puEXOSS72NHhOqfjOFsGN1g9QZItTbfQMbZFZv0vJswBOanD0ReTFrWnRKlA/W1vN3S8GBi37WO23tuhyERtQrtGtD3nZXpWn0OUYgOmlDViLeFrYBf/tz+3+HvlezUuSoSOXYOLZAQzijS9Dy3yqNCBrA+7tL0PI3M6suSeKMYrDNieMlwY/nGOnlewEES8vi1DBaJmddAJMa/RciEdtM/2+/Ofyp/b8jb22LcTE9ZVmmfg+KhdGWuL7z3Igb4Wkxv6AzBqWeWwJXN57X8unlBZT6daKqP57X6Qf1gQRJDKVim/KW155X8TnjGQIzx6ultVeeV+7E/KgEkQdpXeDqxvNadlMFMFqiKW957bsihhED0SNu7dD0uX5DW4JQ85AfOv88nlRhurThzksgoq+1GgnluMN10d1B65BazlYMOvMKpyjtx+LvbFwWCQEzQ6yltVe2sv2vWxusf+tyhDSX+wEIj9zxVv5LejI6uZ2c3d2fn5xObu7+9/35++vTycXN9f31ydUZFBC2rYz/uCQSA2spVvSrlRK+Jbm32o9QIg90IHlkDujhUPRgn9x6J8Kf5s5zo9cI705nw4mN4wdV8T2yl/M5s51ReE5AniI5Yzw7QHGsfl/LrWxhNE3BTKW3IzgzVwBJSIiAzkIDwsheAuSB47k++AUyDw0Icyzv7N0Nnyy4O9npGCghCo07ttxZ033YALS2Qi4OUjYnFF4ra4luLm74mMxpkUNpWS0El/oCVLsRC/YIs9mUko8XpqvCGBhca2GFBNtXneyX5gpKxT8y/iDUYwyzwa+Lr8YuLfGf5YPWoAXFhbsd38gGiFUQA0Po9BaAbDVrYPIiFWDneV3hYU3xrPRQZ3dr0gOb2N2rDx58fIQ3eDcFT7D+vd8eJRATuyk7EUrus6eccJzc8Au61CFSUAxuA0Tv44HZfErJrWv+V3UHqttmdtuagFn5TelFESuDT7h9eJB6cRNFeQ2q9+Ycp0WCYbahhvAFfaDskU5YmUrHx93iz6Jwqt8/ycWnVB//hHUgR/SpwHwVESrIfOFywIoFyrH9rx3Vbsx5XFB5kHx1imS88Hmnfo9JIRjVa2xAjbmG9Dpz2W/uHtSYXEBIEvyM6GXxLeIow7JMKnX4/dFPxz82/guMETMw3LpnE/aAqTO7w0P3nmrfJuPkr0DQzbE0jDU9ZvAx2bCIU0apPYtvLDmh8yDA5SxNwwCiE4Tc5nO9M/amkHkh+2EBGZ/UVDdREhAEdZTqAGjcalthpPS5SbFUZYOHYnxuxwUdTq6TU57WZQFRA2uKkCdAfXVO8JhRwVL8nqcwV82aWDhWE2khQa8CNvGY3MbnnGWlGVq7YuCtCForQEl4ouw0oMsjLfHd+rq5BzWl1qVUn+muF5uBGi1dCHbF4bosAsdHXrkG4BLSxmACQT8V2h9Q+T1gWSlrkBCfN8cWuED6uAkG2U2uvw6l3VYHSBskRGkxGS8mDF7+ot3R9JWDCbLhTC/HHNhxB16UzZr4btOoLYcVur8O5tRcQVk2LuUHGXfaFR5SrHUpu/pBDLgT1+KPzBWU6leyLUmMzToEVEW6AYO9gqVGN0CBpUtbIEAq1F4EkLRqCwBQ1boBAyz9iumScEa1AFDVaz+ESiWBowGkRuoDoObZZ3UxrIGuD0+11eYYVoMCql/7IYBQrxmi6l7/bIRyciD1EBEJybgqhcLDcxj0MqwZ+8a2DBYlOlQLKBOl6Cfqb73Ydwys4s0e97H0f9rQI3+kngFan9yOwJpMujHp+IpYpwy6qj5wcut7Zm4TM3YwVSAeCJ2fLhAFtDlno/CdonqPjv9UwDgjepPMZ4inqxOzMeo8RXOfj4huQzAhk+9znejdtRZYFPTLv14KggxBsjzFIzxlBY2BEbEue7sEBAHqjfghZwTOIN0n9/jsenwxufhwdn96eXF/c6szh479tvb6YHCcqF9xi7cnnKOV5yafA2FMpIiZ+PMoR3AmDNvkT3S0Q6ZTpJvHNrreRToD6Ne2EZl5AzA2OpInaCXGROnTc8KFhBHZYJHQ3PyoLIAZeW25bzlLrnMxNgWXjD0UOZjaj1GuT++DV/0Nwc+WSoxTew/Ai9GLQSd8XLB5EwqIkc30hIIv8QpgD67kdmnJ0QzfYZSkakhTffppBWS2xrJcupsE4/zsSWI48XvPgqjv4NHhjsgGzEUDATJ7XCHo1k0I3p6c/n4//t9Xb28uQSjXFg7jvwDckir5zQUkb1gDhMSZXlTUCVUYl1daBMi9exOc+s73pbg4P7g6vQWzfFKLexX7Pkm4v1cNQ4r7e3e6tLoJ5zA3GBV/b7tpxuKHCNlDZ3ynIOFkiXkpbeQcwbrtKxAmy5r62zxAx/ctsy8BdI5M8oJwcF2Ruf2uk0fE8Q4o4XQqqyvUD1KJn8AYVjvAsCWntkD/4WRaSO+trRrZjDxp/4dwr0YOIlWPcVLqePvsm9AOGQXG0JSbWC78hPS6XlRuERnI8YEcfYBqEolPaURsWuKBFy94MT9DYoLSKEeUxAMtXtBCaMy0FpM4EuqjGVI2EpJIsILHOJqm2ginLCp4OhAGhjDFVoTpMiqowMO4BI83xdowevnOHs5yuXJ3A0tesGTJiBhNV5HuXNo0f1oN5HhBTlwI/fUunIrm2cCLF7yUGX2jGVe/4iazUUL4wI8fSs0cxh7p8sHV4LerIcqEuhvY8Wm8ceqNDerM207D6JwN7HjBToJzTHWi6KHf+KbOqi0h6idQMkw8vV2zGzjxgpOlklJ/HhYbn4GndiMqOP9N36h/BU9/efOvGUnxL98oWpffJNN/wWOQMvu7Iir7l92R9VF1OCbkXL0zWNv+c6VIIhIPPPnOU7YauhOM7qQz5+HBMPe/Rw0zW29oGqK1/F8UWiFOB2I8JCYflus8H26GGREUoobpEACShrkQiI40TIS8WjuaoSItEyYNpHhBSqYYIW6xKNIOYXEwxJV6G3yFuPYc6NgrUUyT8ljogSufokuTqdZw+sfFig7bWF6Bm7LTHPypT7bzf3f4NrndJZQaJ1RyJnKll8afUnD1via9MiFHhPudvbEVjBNJnb9E6O8WSkwZ6XAqEXOSy4iIyAztAGj5LEz26UQ9HJuHF+KDfgTlCPLPwvyIRHZlmDQwf+j8A9Reh3HSAxJcvvyCpMk7LP+sGheMPDefD4sXVJKsvw8FxJ7WFmASlKyBNL0ty2YQ22FT9tHV1fmvJv8eIP2gAbheEknE51gKqDz0wBBFnjMucXJBJeYUpXf2HeFtYsddkeWIC+zQTEzxOWfZe/pA2SP1N99jLzztnoqwznqqAx3Btr8eGIald24akuiTv87K54ajI8AUGWwXme5fYQGbN/m6Rhm+Qnnu8rdBxkUqrkICRWeYb2yFYFSgBqXHpwkrR6oRYItoMxo1Tp0yNWqdzOccz/Ux3mbRSDdIWEPyZoj9T4ANyWbKAbX5VcKr1jZWAsV1+/r2u87/vgfHSAXKntR8hejqhCZ3WBacBonTHWMWMM4LGqdFgsNEFX4zdUDDb6c9VNrxWzvnA8LZw2SQOG8yEtrQWBmWoXU9bTXXjTAwdO84K/K3q9Da4nIeanMcF1mo0K4IDRYaegpaP1bgLmjTqRAiwo7fJLDB2/AXmLHlxrgTPhdhjt63aJUylITaJgMkrsL2DgerSsbqaxEPD+A5wWmi2mRoJor+9RKbCBFceJyFqfhNI7zDMxHgfDsw00qxdJKm7BEnoXGlF+lpMn4geUiU4Septfst4ijbgAnMSmlVAHW1tAXg1nzo1Lw6Ee/KR8ACGo3cJBa6kV3QGYNKTR8OV1YWAWNGKWsdJgu3r1Tia7un0Vl0MTgubJybBQBcfTVQmEB5ewsrpmgdygjTVUpEdYA4pBAiQhP8FF4E25bwrkOIW0z6G167BDa6qiHK0oSGD+Vdi5+bXH+lCKIRPmeHgkbYtB6cxdCDB4yKt3o9mjGeIbAGxBoIs7HB7rA7N4VgdxrvBq+7cSgYpGZvwLNEworJtttAIc+hemCYG7eZbYQkMn5yYLMpC8vt1LMbUmAztAalVWBdrSA5QklyyzHKpnoHNWSGOkAatxM2NgdD6C1RAiRJVj/gaTG/oEQS9aV/me8MQev1o9r0DCR9Mcsy6GTVGN5xlC/+uLShBBP221jrvgmauuwsUA2mLszfxnWAsXZvNGOwwsFo0TlKN+ID1t90BhDYva1EsJ7mBJYTtweNhqJH4iuUQ9wGao5udGPXqepIgBcLtuFp3gMbc83ZmuNPqcWkdVryR4H5CipN2/B0ikAzdQF5iWQDlPoOKjXlBXhimkDqbqMKQHea0fSMFpkIo9s0wDTvQZvcGxF+0gpbIRABY3SXl0QA9zZXCDNkYg/hd7gmELNrvzm/PQbNi97L3d6gDmeOMRnbZd4Ds8ENaitbR2EugI20FQrbmsCTUcMwetqsK9myW85yzOUKVuffBAx+5zfUnD3ppSUBvtl1wWSNe6gaYWEy28LnpoFD78jCcsGS38YjFr9lyQpWOsTnMcHH88hRXjvl4JNzwudmY1kg9GARoxz/JsAl3KzAzFM2RanOhARetbWh1HfgDi1oodLzafDUlCD0X6hE2GyMLtldEB2mF5FzYJuyyqI+Og6DLjtbUDdhIrNPAsVmok/WEMLTI3rrInjVUYLQfzUbbzVF4E7+qOAYZyh4UioUToerO2Nsg15qWEcXNjD4IVkVMA3lCuXg+1UDh33XFYz0mWgEYJBqhQx2nGoPDHt1qiSYjG1qjc7msh895ag848iGaJk9uHrTszhobgX8XW9SusOfCuz2RHf3Cq69EF4duK1a22qh55Xw6uGuEPIWURL3VkH7aXjo23sEequg55Xw6sEcBbu5DjqPQeHfRd0LE8wVFiac5W5d1ldUzgGuZc5JqorTYk6o0OdTpZG9Mdf6nRzJhUb1kREaHFUcPQaHaex5l3pJ40twTDKURupzaWoTypgCSKQ1T8BUoDk+qE+A0ykVqiPfThmV6pFbaOsWB9dO7Uc/KNnL4+68R5eRuU5aYhDd35vDje/v1ZVr0uo6ZjQxE0qUTvRjM8Y9kLwfH7z5ZtM2AT/r7ILppEQ7TZEQIxY3l++PwTO2hhB0xFUYoVYaBcScERWKjyJhMXguKhQmuAVspJtLZw1fPdc46uhXVwiVm/ICvku9AaS8hkpKnbNfp0sPY0hpwWmXwF3roFqMAOKrW0gmJ2/vxxf/5wwqLWW7CmMJfg1NqwAqR6Bz2W4KQgQZH7UpCAI8FMhBaxuMGZjhaddFmoLe8NqPhJY3QDcdtMBchwRmNNW3ISDR+0BCwXJCVzUUeFpshGeoSM0xOycpQSIAddYPab0UqpFZ5XSv17FA89WDp1MElak6jVg0tXHf8HvXBkwsIxKqWboBUs4VKIGDQ6W/5zZIbCy3S8Jg5xQWV3UCaGyO6whEZfSg6hRBVfMzkuL6sTg4NbEX1Wxd6Jye4EncFWTMsRm4W08h5hffiNyu7OvTQ4X6EvyWs0cFJ0iSt0O1VG9+x6tIjq8WDncMvwWH3GR726ivjfKrwbSdMJT2aYyCMIfNNjTbOuuyUIZItxAeKn899IXEXmdE3wfLZqtJExK3tjjMGUkLmpuHVGWBjPttkGEN+yYjcpBNs4XMtsyqKBzNgkSgro4mslKvuKJg1EoDYt/+DE91DEpQLjGPMiE+pY29v763wW1yx4wuMZcjTtSfxonukOo+Q/ma/AAaj6p6io0zOhKSEzqH1456IeAnydUvjtVXZEif43tavTU2L0FpYb3ozEnF/YhgtLml3ZwJsrE1ZM90Ct60yKjHMYo7YLgQLDXfdImXOIWL44TP4Qp/xx59XcVdlx5E2Pe62OaqnkZe6dsT+9a5+lHm7alpW6AMDPwjUAhVw2+hf86+rMFYDBftJ75z8iIgvQ8AMaTjLJZ4okxBZSD9ahZEIfKzAUZPMSBuwOy6e1b4D2d344ubaxA5R58Fc31ydRYGkqub0fvLs/uNgED0EhCW1lcZUzycjm8lhOM5Ecpu6SDx1XFIqJKVIpcw0LncTjlOlABEFfvfxp6XP65vJ+w9J0D02PPACk4mrFEWDLCcM8lilip01p3FOJw0122A+jB76288o3NC8SVDCQRzczcMj71PvDU3u6BMxts7o7H9P/19B/HXCkEwoRsRrMovJbZv2Q6g676ZXfDoGEati0b3hYqhy4OnwjfzOY471W5SqXbKfPX8tkl4Vy6fw+rDLbH1Tuy7PK7KfJ14bARwQW85i7EQHQietx31VSxd4reEImgD8JroAs3wXbMQoDm+BspebTS+gaHBRrWe0eUHxK9QDnE+kbL5HNr8oZZZormdpR5+f/TT8Y+N/0KpdbFghcuhBBaDuoIN4BFxChsBoTMGGwGuItrAQvhUYDdKr0HwfBTI9SQf1iBQiUxEddgQiElmQ/DKvwJL8DmWWvI6BhWM5N2W4nm3BLIs13LAp+RAvRU/vKeiyHPGJU5GSOrMKE/GZt740J4x8e3Pnf8DwpAspzTf/nTY+j8oAEaEm4WRVXVcPTw2dONL2jiccYR5KPiU8q18MuMi1j6aK/X/6m2nmjc8hQzYOjLrbUL2/hbJRZnWGLDmeFfiu8nrlX3wRFU3fxK50EwFCuummRsLPDz1OnW3Zuk1gaw8qh4WgrpwVJmcUDEnufxQx/X3lYMFuUBigcs0ZqeXF5q2X1VZGICUpftRmSGgAekYYBMuZI851jnJlBTg4ei/jVNqASKxS+/tcxit7tOTLMEKHmPVAJfExtQEAlKfpzRuFoYDLbdrsBbdHRZFKkMYiaHzZBJvajiIz+GDmDGeoQDIIAKw9t490DgMaNsicsNA2BtMDQ2aDXCIYmviiQOO9RbuJfkL29nU7fjSdDq7U6H/GUjgrWCodgyU/1BcmhpHXnl2tx2IFcicY/XfgzpNTQtjI9QXtFOtA+eMQsWkjPhmSqGmh1d0Xb7BAxQhILSJ22fkyUXDKTMS282E3bJw0BrPYkVjvTbTVw4V9a16gpNb+7x0+DTLQAJbkPkiVf8v6yuNrbrRvoXMnf4dHrrxpzBxTcawB3hjWp5wjEDC2BxKAxZJNwwLMJB2WBZYILD5qHp6Z8sAWBx9mwWggVnbAcHXNqgAhXT7MG/gUXcgwTQ3X7p1OetJRNT52SZM22tTJHBYAE1cUJDQEs5y0MA6qz8W4dkTkafqd2FShWlyWw6z1Q1IKHZ2joQSUJ6kj2hlF7Ya9+CdnvVynUF1jZdAl7+rjjRt+Iju8Bw/AW566sPpDY1tEnh3fUNd7CpsmtSoqw8EzSVkehbq927TQvyXDd4v7wBDSjh6fMue7NhqLgGDcSnIbzleEvx4rqyggttos/4ngKHaQIWsEbSQwYczQVN7OkTjFjAoHbNpbVcdIH32hOPCLaL2P4Gt4JeAY20tXwv1qymubNnGLWhQ4uZRD725MvdWFlezBHajI+KUACZHiV9wriR4S6hOaqlkw8m7lE3Vxcrh2/wCaOAX2gkjkZqf2D37zQLgwK7z7JLMcLyKU/wrYw8lvm459K53oR8gkxEbDJSdM30ToacrROBL8oBBN8gP6uPJb+LCBN/NSAlvrRiWbyM2p78boCNizuRxXvgHvHoLWTWmhBqNof+Cdzd9FIxGZXyrO3blZqp3/ajmV4CegWXoyQJ6At3cahh6KqJmJTmCGz1XQlpN8QV9R2Q5+rZLYI+7akwSaqSqwsQg70p14XD6bLWTP8fX6sc+ijurPuzacGNj5/NvQa8CA0ZpxQptK/yxfBocyiCAyYXdfkfVK8a3w6iO/L/leEaeAkCm/07YLROw0ZDYjAf6L2QYOk7Yhgf/iThVo4GowofbxbBBqndUi5Nz58TXU7JmWdDgRngJ2065vbsYX53c396MJ+/uzsb3SrTJzenNZXCoPlyMzu4At0Uba6MP5jYZQdbO8jU7lGkQm60rkLDBXBWpJHnqUj8BC0px7oHINT6FixZpanK22Agiexj8NcogW4SSOXJaXu710nAhWneCNkZGBPjSph2ZnWWlYNUZRADTt9T+XyTxZnBmVffZt8CvWsc4vX2Y69ka3PCxCo/O3q2jxqCj2HD0FQRMestnniKpg1iq3ZDu3gV/NB0754y7Nd7ypQ04vT9pyrY8aKdN1VI3+o7/B3tt2NMIp+ZftpUW1uEou26kDQuV20YL7NCXGpV5D2onqoQ3lhqEM7Z6ZJ+wB0xBHK5VCy+VmYKhtppKeHMBbOBLEZ0X5o0kS6EysAZC/QHLg/gUAA8OhPgEg4eXpCWDQ8xXSrYGjz5zblK98ZVRAZu4fjwF1eFtE5zllZlf5cX3/QCd3RC6Tdh4WsxNY6xyNoQEz/poPlgfofodOKcg7YbSxKf8UT9q4gOmVzLM5+WCEWyN0kXSvIcw73kOz1Xjvm5w0NrbHEvbZxohfHDbXB8afSbxu045SJOjAicu6IwFQlSFpV0CkqC0OogGNjltHPWdHVEhc2L3il6qssaJipABqV6j0bTiCEMCdCIm5akLoGE9WjwTNpZc/bWAgKm3MsYAtnJroiivIZqjTRxuZodBm6F1fmXQZk0N4115A9fLpfCMsmwGnpQSxDt7CZcQgKcrdyHYpDH10Ni8tyE1P7f/dwhYlVU3MJC52N8qE34kq0Txo6urc4dIXwbC1HOT0AAxunSxtjQoiO3jRbsOH/A4d50oBQWzb8YeFMCOewU4tmed/sDxbZw9ruECZlhibRLbtDrA1526SFCSuEFghCUi+lxCY//XCRn8nwY8d9wUHLaeQyIeSH6hJzkQfDLPgTFnTa8fjnX8b4CHYU2rIy1U/zFdTl+DbnzPAet/AlFhVIlOW0bxOeOtMyOBE/kcvG3P4ZKKq4Y5YfWxMwHQuRlY/xO4FG46ZxA4gS8+PvHoOCDy1Ms3nKiGitKWBVDnUAoKrimvgkRt7sDwUHaKTAYEGHGGOx/nClzp7HhCrf8jhYMjollBbd5UYHs2KgDVWTYu1prwi9k1k2dPRLgJ0eH3Rz8d/9j4LxBqKmSPnEiss9aEAYfjjC3xWZbLlWILNkft7mORlZlOQsIUTutTKvoaC4mTc5YmSuwLCp2vJjTN0zZI/w7iQARow9QXn/AAxaDYfNgNNMo+49geKCStp52ERs46gq0ZGY+OYdKyNXkmVFC9+VtDAVPmaz2CMdDulnMdnHb4epnkwah0l6AbHlX9icWPQ8n3DkMPNI4BhtiKOuK3DzUGZJX1pXMHaJrtnpUeCjebznODNw990bl0UOhpHF8MjZHek5chdYtW2meI/WHrAZSA/C5l2Aln2a199TcB037fCmYJzjZvnSEJs5d0AHRPxYTCRLxQv3ebFuK/INLQlr6+A9UVTglQ/z1pHDQNpbrdAS5qOrok+PEcI1kAdfhuRtL/BBBJ/QdoQCPoRSedHAd5sAkkV89J+ohWAq6vp5a/eQ/J2+POIATn3mmfnQhpplodUw91ptoC0CoAxMSGg4shcrIFyrbjmWEd97Ar1Cstz37BvGJ0zkZvIR53YeEukLh5pGoun6shFGRg1TqCdgkgxThtxJCbI8gg8tELYq0QECs9x6JC42T3k13BbFswOZ0ykPOXpuzlNaCqp+wRYq07sdUfsLaJg6CjlJQEWT5hozI7CGA4HNME841IgEwuTYbM38RFosQgMwJ1MbQXRk8xIH1VUPKpADm7rCW3V5DW2ZA2wLMcpLnUEr66ARULyoUNZE1htvw1AK0CSPGhfThae4XboCA58NoHhAN13bVBrBXCCgB6R+SvxfRCiAK/5ynQwJ91EGuFkJzdKP8dw1xna4juLmHlNag2xQaZ0uAIeA6Do4C2jR8FsE8cyH61DK2m+ILq8QBoBP46gnYJICVbJqi1OyDd3g4iF7Atw91QPf8WnGnKbohted8hn8eA1gwmaJpiuMsGlfiNW0iLaVianGbXKANJQlf+5j0o91ya3lCY6rkpe3l9Q8dFHGMhYM0MbRZD4/6BOkPsQugUgeLjCSYHT7ben2w8cpajMuEwEOujRvB2BciceMCrt95HTLnzlmKTmMAIPyI2sxs3shsQkGYcWBmj6e3DXCdZABsj1Y9ivRQQMSmhIGfjpdz6L6DqZhkBubRayq3/gqhupUB1iOkCmoHWllsnrLu80HrlV1UGpuL1ITvwqr2UuqDmeBaXKRCCPdaUXv+F4+HRkjdPx3HTQZBbS57HsvkpmK6tINRH1IHjphbdrs/Ze61fTYA1lL7eQmLyM9nbS4YSnDS38kDo/wDXe1tiW48uwHDeFgrE59AhEFEPfMDCkTWOhHAcq5FhBfGgnw0ACJ1hPmqXgxnrRL3J5knCo2NN/GrYqNcHbzlbkgRIXLgGpd6KH95TUeQ54xInGooC8bSCx89WKGpQmZIkwfQ0S8olXfPwPEXz1ggPnLOND0HYL/f3Egsp7u/V1Yw8mQw26qajCQ90cGqKI9sjoxlJy+/9Jgah62MHQyFO8IxQXGv45j0ILbIjZY+q00UWd6SeHVATQhYllepssel4LFkd6HxtOqux7qCgCu5Sb4DS5+JEOvVzNDORgAfJdOiGnvFmJ1MDLT7QYiZWmhNHDywT6zkk5bX2/nhKTZJlM2tFaQ3GvZ+D9MmblEd/ntEim7gcbPra1zrnRIkeoQTlqjVFLnxMYcqY/3m/nhVe/z2xT42vxNc9CS8BEgCEc2RMT8hIrsjcftfJI+K4Fxecvq70l5BgO3sl/SlLi4zqM9AhKtwp0QkmwLJQi6+v2t1j/Cnt6SG+u953hBo0uOaY4/0aw0ZMCZ4Wc7A9q5J+pC+gqTX1rUUKd3CpxTdb3jx0QO8gOua+hsdsFF5roSewraaSvqtDv/25/b9DeITsOrwHAjVYcGvWchCoyjESMhisXRUGjHmj6cAIBRkRwWFbH25DwOKsngA0g1SaLhQsd4affjT/hqcNQNp4z+uy42BGHP8mDiWGfF4D8H7FbqPQbgHJ1n5Z7T5O8zsIjOsVqd8GVvMtuc8v7saT++ubu6uTy/ubt0a2ixEYApb1SfGwGGgIPiM4TSasnpJ4ujS0FURcCKlPAeVaYIgAMpSfuLB4YJI3AiqvkT5nSIdVNtqR790YhLerI3NufNI2F9PtfM1HAkB55vMQqtxPU/NljcVHCzMzPs4hcvkVqryMVTuYcvaA6UDBK1KQEUoGAl6zD6RsPhDwzxOgxbfrXN5vzN8gsrsEUM9lmOxcN47LC0j13SO6vfHYD/iM/J0iz+0zDQJYm3Hi2rr1vW+CmJs2BY5tJhtxMJq6pDbGsz1tZrj59vvDH1r/vveZggaiEWe5haOvYGM5e8JxYYeq6gY2otsiTS0cfQUdi1iUWEwyLsBYxhg7JaCvIGNxNl1DsbVLAsA2wnnKVg1otiAIZMsWrGUImMhs1gSlbgNAdae+WDZgmfswcLF0idvIdEkA2MYSyUI0oNkCgMh65/DQQOw4sYQL6k8ksi4qXQYQVnWqnV43nSKBP9i11TGalZkce54AAWqSQymQc5uLEuuN85yJHMdy/Cm1absaBQDpW49xPDw6BiHwRbPmG1HAMKu/haZOsRkCmmbE6Rqcf0NT2RCdy1uGG99diO6UYZ25tW5UOIGRWfdFQDY8AsORyAml/u9C3yq4y3VsC8DUPBGuY2e5XMGr/zXxWwVgWIARR75N7s3HHx5+f/TT8Y+N/0Ki49qlUjpnBU0CwWQ96xdzyrgayTkldC508lOd8zQQiM59cY1xIs4Zj3FYuIxb8Iwurxm90NnY1C+TZWAYR3gZKkK7iLpT4wQwdhWUPI1Z/IAlvPGrLbvOZmpuzjnLSsfTKceJTmuKUgFrylOnHxdA5zodBN0y/4OcdsBiBLFnggIIeGoAqnJxXCRAm1cHQbcMVPN6BosA07YQiQSaYYhz0ZboiJzMlShmWqRzLavvO9U5+HOmmAEzkFD2CI8HJ7T6AyIl3kYAkmRY/X6WT9ioXIsFC4Zjnd9vIw4oo945ScGaU5Xs9R2oMa5Hfm2ogxzm7KbtU5aCdPt1pReSMzp/xzGmQLVUP6I7F7QZCp63aQFW/casUCat/kFxQhO9yR5ix+kH0VMMxkSMUa43DI5lwgqAHqA18U+bBXAWkKhQQpc+q7MnIiTE5aQNKHKd3KT2oFzQGQOqlzch1JFu00sWmy8NDFvOsVS/u2qcgghyBJqV62MAe1Zb9rOnHHOixUFpe9UPXqtrI7vleEnwY1igzhBPVyfmIPPtwAB0ooX6zRSfLVFa6EU+pSxSJgB2qM047JP3FJudhWiaKlsC52AXj8CvHfUsHQHgonmu2gKnSl/ra/sJGCdXvxyNTeDhjlLWfziZFpJxsHQJM4m41octpuQv85V3BTAH4suRbXoGlsYYxtnkLwJio1VHeIaKVE7Uu67bQSYpIfb0WQ1HBMHWGiIlbTmNss7uw86/MIgTn1Ii8Q1NVwGDVN8n5+p3A4dJWSu7d8jNNmbxA2fqC5Np4KSqDjrGXLEaOM6M0TkLns1spfgMHGOCRazmE/gKqWnFUy9QiFYP1NWXHeFAW42pYdWbu/UXDIk0X5mOKq+pfT2yGCOqHuOkRDyw5AtLwuy6ipgakyIzOh2IBUrYYzId2PGRnaHn+MKNXX6IckRJPNDiT5cxHo0oORw48U2NVdRER98fffvTQXI4kOMtOUPv8YWg1gQnmrE0wVzZ049OokciFxFppCQZqPOGOqxjswidR8k0enQZACLn6hpo8oYmyREVxo+licoLsYiG04FgqcGBKG+IilNWJLMUcWNNMKr+DMrOY3svK2SBUvWbM8wxjSvX3UCWZw6gwW7wjB1qziI124iiTAzuOT/NhYEUj+ZDEnOqBhsTrj0MNP4yYweee45T890DRd7YAm7m4+y3rNyUH80QSXFyYB8PfPlluyVIoijn7Gk16DwvzbdGROHAkJddSCk8YSIhhwgF7xkaepCPKxCH5RrEwI+n/FTW3MCQlxquaSUMo5D/HA29yHeGCF3qowyigqcDTa9P05SzB0yHcchDamw/ceH0uh8N3Pg6CyLmEEJD2MCOl+wMXcdjcrA5Y2rgxs+OY5MiRIhzNJDkAUn6u4c1bo/jq+IFonMcKXHrGCttyKVFRoclcF83rOoFcapPwh4o8knXoTR6ZDxNIvVeov2mKM8Hgrx0Zy/UJeMEiyjRaWnmg9Xt67JD0cihGbnxy45aA2Xe2hXD9kk/aRl6jJ9KLuFoJqPDQbH5vyGlXH1QlgOLKJPqpwqBbRCdzv48qD6oxA29zp/ZrnPkiUci40VUJsn8lEaSDW5yr3e/HjTIqv0UqsPVdxGhSug0HdIBACBxoMh/ivRpJyKamV6W28NPBtrg0DZwBauLmeuBNP/tj6xIJbEzgYEuT+karHl41vzAlr+dye5yGlQfALaGrLkg+tLAkKcMDbtpfA/MbEygzIA0Ns8Glrxladg46D1Fg6bznKBh26C3mVSGbuR9KIxNFTXs8gSS5MsVDvR4Ss/Qe3w+c6xkaTh6zGeyBl68tBWmnD0qJDgdwog8IighWq8pMWxQ80CNzyHnAzt+HyHCccaWeDhFxLdMREjgVGEYjGwIvWigx6M90tEzEXYuC2h0dBQN29VAEnc80Aazvx0NxPlLXOkoGs4v89oFi9Xcd8bVr7QdSKbc7UX8OIRPwiJMigiLbCANFGnigeQiSnDOcYy0R8p9uep+w5oiOI2pY885ihCfD8oTmvIcCIOlOBcDYf6fKz0se/lFlGJmOJbda1bq/C/6l749/Pbw529//u7n775XE20yLIT5uUzpvFODDeH5SZ+KKkObGI749Nt2cLHpQ3/y0SZveigGjyFcvkoVufZSXAgt3rAsDY/TwQkMUW8OfkOg1KV4juLVoEmDpXbgDBJnrrtJnf4sGTxcwCyXgS9Qs4dhAQYSXwNZkMgSLMOD1Qh3QjAYIgCybAyK0bclNVpk9lDUSCqGujHhA09e7tCsVqxNmE5K4mGV2vNl0JqxYTXU31xdQy96HVZilmXqB8XBlS2804dD+179OwFo3kMiYjQdKxMbJAW16PZKif3tN8e+1frunVcJD6rzjvASctd14td3APXnCOcpW8FmoUTQKoClQkec5UBVaCm6vYJV7beFWACt9lJ0ewVQ84wlkoWArHlqBK0CaF0gTcF2ASu6vYI4+JLZDPTQ6+SfY3lnkkwlE8TVzS3iKMMS818JlX4a1bvAatxCMq5H01N7CbRbN6SvbmB6Jli6xMB9EyWEdglAOiD3iXUI7RJYFsfZE44LiYFqp4b01Y2n9Y/pnFDttlYICE3wk+9V3iuwsifObPktkgs/rYlewV3hByWm+gJPLQjxKdWNW/0c5tGnAvOVPlidzBcSULvZGYT94B/6jQv3gqd99zlIeWlik79w6wY6V1uB3Z7cnVzd316enJ79enM5OrvzUx18EcbmvWmpQDWHWKAc2/9Cb5MdKOaipAai8pgxniHp/kAnZw2MZG+RwD98/56nMNXDGiJ71Ry2PNUJ04Im+uCljyJKOFlqwcAYEc/Jrr5m/Mm2qKNjaBVPsbNA4Ymez6EKniKK5Vh9H3YIvOuvMyzjRWQnKnaiu1A/dpsW4r98767PiF7feTpGr8lfSJIKcLVeSa2m6SP2SFOGEjvwgqj0xIkMrt6bgivVE+P09mGuHSR3eI6fjL75rvMPFBmqOb0lFPHVtZoMwYeTO020DsP/PpKyObju4WTWrQhxKMoIhJm8JrVe7+XsaXUyVyK4Sq8LYHbd5qh2qj8yIhw4EqZGiUdOJD4nKQaqiTBdguseTmZbckaXHxC/QrmnU5pN0tcp0KEiqOwJC6BaSoKDQMlz1mhEYowlmGmlqv1fkf+hltvkdpdQbIm1UTksmwIEB/UOsvt7Mw6rKwVED8DwJvrPgSmvPSWHUCF5oX+u2g0rufpu29xSNkXeR8HuCEER8c7cTNRDQue/4jTHMKzXHRGK4BHGqfqJXTF619filKifipSqxup1pk+gnROFe1XuYUNF6v2YtDMId3nnHnuq/7bDKW9gk9JE8a58xXNe7PKvXiqKsAkmZByOL+hZ4ZeN2Ldvvz/8ofXveyhc2OV3cZAU9ltclI7AI1cQCD6qBiZO4greBZV47gYd+OhEHV8l8FjdAMeVsrneGi7xkxmGHolcnMQ6f9Ilm8NnTaPTv8GsOo85NuHuVLA0DICVjtTJlKwj5+cWlh/BIVG8nJvOFkLbq4KvjL6ABo3o2DKKUhe/aPLWWO+h2zIiHGGXeInTAPhS/x+lGkuTshDAVb2rVn5BwVJ4bnJzpBYQRG4OwgsqSYYj4wuzfnrOmZLy1rx/at76oM/JMd95ph9qvLDAbqJPiahse/dHwxqbK1gUWu9myaTBJTmiAtnTjpSaVG/zvjKNeFIXX9nSULrk+FM6MgGNJwnKZTi4JjjLGUebVCcY34C0LkHz17ZFiE6CdRT2ys+Y/d1RKHVyQe1MbJwjX/f9PYdHKNGht6wSgxKZqO/8y/DxO6EJzCZWwtEozGIo0Kal1xEjENHOL0NC8eNFUvmdPY0ueRmkOZYTVTAxyk21uSVJcIDIgkA0IkJ9FZqmuJcucGoiZqkSVDLwBk4LiCs8LctOrQcX5ojUQjbpIAM6Oi2Q3tUFvtE1YJQRBLYE2DpoiYck0BmxCK7fX17eT+5OTs/uL0ZAxx2LxDhZzVBzkYAGYigZ355cB8GInh1UhIDr5sx6R6H39QYMqpeNysln7fyFpIPLFfQFj7SjFCo5PTB0OB6icsJ+5ROSYaC8NOI2IPOyOfwEIikCQC6mzwmZgchFM3ALMh/bAtAg8ZKyOYkPUJ5DJaQF4CTPYda/Xd0DzkENwsaI1WuW8BhRX80KHuMoJRmRAjYzPWDuXNGlLjEREcBocmEPC4wSJSxUftZRmMGkxY445yz71b4Byzn5UnR/ErkY2T0cApjPsozCMeF90JtjA4XJdHeH1QeEfMuSFcgG2MDTCBUaSyXCGrR/g437gtzg1oPXAI5FGUmSFD8ijiEk6nkxGPXnqioEz1AgBt5OwHhrwA2IRBc9Ko10ADZNfhkyWzYpi1o8whuUnwFrLMXTNmJrJsIcpxtwZ0rEqfpYlJrdU+E02h5gZZHdKAZW9ditBbjcOQCRrg4E/GSyHZipv56CvacPlD0CdF+29xsBddK0QSz1XpVydxGwOf8OO8COQTWvGUlhu2YbCDAtMhDJWXaDIxfqRxYs1X3l3JQGBC4hIuZY4u3Y/g10jzzUvtSAMMdybZf/cUgpC4Dp6TpFAVhF/VyWBYCm2Rz22FkjAEsCjLOFPjsDxNExTDJsD6+wSHB7X9pwfhOMhoFkosbELhJQHV4Q+gC5u5fyu9FvrG4tDRBJOEW5LDihc9gwRpzlOXgUpyxTX0Ak8DZl54MtNkApKLwEkAl7JwBq+D5b+psH+5nJBkow8OmSQ5DgaTGH159rAJ+q02WBAiB0xiDL/4g4hSw/diGcPg4Fa6mCPwqzYV64N7+JGZ0R7wNmrJRlzmmTv68Uu3kPJev0R5sqLcmyGbhc0x3ZR1dX51VWdkiVr2aaJjfkhF24LJEjwHRsRqPP7mIFlSfzOcdzJPFNIfNCVgcKHsMnrP+Jp370TfBApAJ6VnjV2sZYZ76o2te33x0eHYMjocJxalyFV4iuTmhyh2XBaSjQ3udJeNAuaJwWCQ4GSJDtz2ELsgH2EGZH3EmZ4RwstB6+QoF2k5EAhqzKxoMP5R1nRf52FQAny3lAtIyLLCA0V4SGhAY9BYSmPWm9oM05ayCgOjNx+MOOYQm+MeDGnhM+F8EMpLdolTKUBNTYwqCngvMOh6QJxuprEQ8C0znBaaIaWwAGgv71Eo4IBE8QzASjnU3rusMzoa0A+HDg2zKKi5M0ZY84CYARlOeYJuMHkgMnBj9JrYJvEUdZDQPMWlVVAHW9qgWgeVTZb6J5dAWk9WwjN4mFblcXdMagUtOHw5WVRcCYUVpYR0nA7SuV+NpSaXQWXQyMC52OJV3iJoqwwjBhdQxTgGHwsDuKEaarlIgqt6P/26J3x0b04YF299cPnX9g2l11FCKo5ia/IAzq8Pujn45/bPzXe6rkpgbYLgGKrtsQq9PP4UN51+Knec4vWGw7zhZAd7OmjefsOsCM2YRLulcJE6k8YdphYKbejdt+jLAiRg+mBdEet08F4fgWyQXoENJeNN0yYFZuAxjkaWAPDEuMPTd8hCQy/niQ7LjDzy+McQuboTUorQLrBgbJEUqSW45RNk0xbIY6QBq3E/bb+JykWMDamfEcLIg7MZym016VC0qkOTkbxOk5n49q0zOQ2iJmWQadrBoDxdgsDgv1SeznXtmXQBGBYHnHUb7449IGu2jlrQfXCSpVHlhcv43ruH7tTWpG9QEGZeE40mpAEAemd1ia40F0VhVlMPA/kciujJoLYHzaDs68suE5yKGq100Bl8IdvC5QOTJNT7W6DPBy1TY8zXtgNGlAyfhTajHphmZ1BFSatuHpFE0E6DXGFyA9/bg3UM9EBiPp9G5YL0AuuW6HUt8F1QN78IXV73oAhtPbygvwfa0JpNaNqgC0YTKantEiE2FowgaY5n1AqqKB0IThKQQiYIzu8pIIGYg6zFAOekrdC8RkUGn65I5B86LTb7TTiMBZK5qMbSTQgdnZDbWVraMwF8BG2gqFbU3gyahhGD1toits2S1nOeZyBavzbwIGv/MvTAJMAb7FNXDo7bVYLljy23jE4uqM7iPI3LQxwcfzyFFee2vhk3PC52b/cCD0YBGjHOvDWYCtM1Zg5imbolTnRgOv2tpQ6juQiaMrVHq6Bp6aEsSZPSETJBE2o6rLaxlEh+lF5DympqwOoDgOgy5rjKqbMJHZJ4FiMxFYawjh6RG9xR286ihB6L+ajbeaInAHBFRwjK8NPCkVCqfD1Z0xtkF7stfRhQ2s0m1gPfMVMNgB2j0w7MZQu6ew8w8wOfbqVEnw2zg0bJTJcZHrbVE39C1nj8KdORokfZPg6LMf/aBkJ87FEhC40fS6SNPQUGlnWIi4TugqRFh1WorOP3jmBqSMTy8GM8fyks0v8RKnYVi9XYDN+9MUCRE+zEDMfLNqDb7DVShMRlV98M3GmRhchsr0DcFhGinZdFLyQLrUR5GwGHyXqlCY1V4B1TnoMnfDNylqHHW0kSuEyk15AZ6cJpA1GwFMkrH1zL5YyHJzKNQ1qSY15TXY1af6gAidwj8Mq60Fp10CVa/FjGoxpAjAe95AMjl5ez+++D9nUGkp21UY64VraFoFUDkCnfp3U8RUAD5Hm0fVpQ5zazGhLDi1sAUJCuraktwxiiAwYJNNbn1wuHp8V4FhavmuwGPbOFuCv8A0wjNUpOZYp5OUIIHhW+f9kNZLoRqDrTEMNFN9JgZ4J/4WmzAsbJNxICsT1dkPjEr8JAPpVi08nSKoqq/OAhdNbXQ2/OFqA6acs4yIQBZrN2LU33O7B0iZOVAGpYFoTIuyOss4NqflBNITe1B1ijzVnihBucQ8yvO5PXJLn+PmPSubpY4ZXWIuR5yoP+WhdBAq3gouAGTd3y45ESw1X2JC9CbMZjFTs97uEXqwCHHtSs8EQ4BjNxGesrTI6vAu4Jhm2oc5YWGB0vaAJPQWcS1yCIjeU2E3ouhjHqRS0/o4pc10ea+41V9oGtuJbMNrbpmQc/X1J/YlIMMliMXNF9a7/zOZjSxIKCHCGxH0klJlTAEw/1LzDX1ytpwxnhloU0IRX00QV0+8t+ifl75V4KmWWkORsvkcc3CVX4stkTN4/YtX3CK1WLDCrWeDkltdwRP6EXHqaxjomtgg7IbNUsM5PHszhrcNRQ4dS3dQgghGFdy6e+e3bDJ0zvhpwbmSrnwpGJgsHMbKW73XAAYoQpV9TVHaPKkpJfTBDIPqL5ADy5/jBtQw05E9106nERGSMz8zlO4E4CbHdDy+bObOgAnkkkyh44hZlhfSIRnnOCYzEutz7gVMPM+OlRdOy3maFXfdqncaGNZstT1sgHAM6P2AkR31lkTfAIkjehGQVgGQHr4THsFSHBqssUxYERxZt5zFWIizJxIQtHwDKFBq72MYSq8D42NX4R0D5uTjBm0HHVOPqoMMaZM6OAalD5qutDs8B+ilfQ7MWiFAYxWm/7wPgPQ3O/xO8r9FoqWVD4Hi2DDIAIcTBI71cRIqGjcNcFDGWEpCy0hOoJA2jPqH3ibjsaJHU7u77ZuPEAL/12XOy9Tn/u6FMs1FHGQ4Y3x1EHOMJL5CdOVe/yY2UU3e77wwUprmn+AZofi0Ert5D4iJe9uDHSGmbOLSggHoCbtC6ZYBJMgkhS4HCcj0rAH58+Tu6v3t/cXk7O5kcnFzPYbHTt2yRoQDJmcNR6sAEC+SIyqQ2eU2jDCvS8UUCRIPJLwyCWQeCfWyfm9gwg/T94QmNpf5QMnrUvKpwHyYiLwWCfgIH2RFKolTUNEjkYsIP9kglYGWV6TFWYX2vcilHSCZ3igJawqyCxgl6E3uc1qETYgyFj9Ebg8ZVFa6GPS92+9mEiZAOnDmRehCxXWuflqNrZDSxDTwiU+p9lNgHSkZGfMg0pvOhsHoFTlx/u5oWtAkxQMVr0gFx58KwnFEaCQXOMpIMjDyuoz0WjWRUmNEYhOaU9LyEZh98BJgrlkGwZn7dFwI/cOskDqB9NC1PKUpsTl5B5585UmDpCxKcA5uhvQCXLieKh2FxFfcONYpJFwojpWoJp1toAjV96YkRqHCSw7XjoM7CkBTuuEsPFXZANbQld4nr/sioA3lGTbQXm0aNuR19Ro23irl8T503J7Bxf9MlJ+DOA9xoAnQIA/SGg/cFA/ZDg/bCMciixhNV1H+MBfBOi82oVQ/qN7qEBuGH6oNOdi51kaYe0RtHj6tQfbWbKXgBLhu1osriGUzi2xYNQPE0rBo5jdNwa2Z9cEKYIbeByuAOXofrKBm6X0Aw5mn96HLU0Sx1Oc84XCm7DXQsKZyvbgCXDXrxRngolkvzqDXzHoRh7tk1gs30BWzXqzbhpdgVs6ayPMAh5rwrPIQTfKw7fGAjfEwLHGdJzHRXmm3OUvn8CeqIZab0SLrkB62pLwiR64Jqv/nq5wR9Wxg4/V3z2FaZAMRr0hEmdggkmia4mFL6WtykXCyrAcNEbl1o2Ra5sophxOKhzxSgJgyeWKxLODNj74AZ6yGWcmCIzSfg16H/wKcwNblX4J0UKWvaIDQZbREPBI4LjiRQ+IrD6brhBKpfk19VL05EPKKhBRUFLl2muAkquZM2hs5sOIlKyYkUc1pnasLnMH3ImTqZ1IolLVSKEmOYqx+1BwJMPSkV3U/oCwfkvW8ri/OZLDiUYIlNimqhxHGA6u40rQ6rRVO5kMf8Y0PjQ3EWV8vRzPDMl78x/968z//Td+of4pMId+4CfOb//sNxY9v7Drd6PA/3Dtv3pxe3rwfnV+e3J3dj04mJ29Pxmf3F6Nf3vzrX1B9BvV68tD5XnNWWkxTImwSZqpPdh+WKTyjQxBtxekSwFrxBbhs+Vn5Ihjm5tE8ZVO92rfKcZQjbqQFvbFsJ0jQ9pT1gxqU3utRUq4WJIcRkU9uhgS54+wCCFi36YU0dBo/5hkFLQROBjo88YEORLwmEfZkmRlLE6WuWrl7B0JeM0zZohqY8IWJGpUrsacxtV4aCPKPoP8cGHrF08sYnbNkGlFmY3pjREHPVHbAA2yi0odoGHRe3R5TdCibrKBJJISMlESx5EOgtYf7x9QXyLn6oQBTYm2CFkRWrArckBgLFlFDbizvmQouPdYGZM2UL98f/XT8Y+O/YXHYTPoSNtL+tC9hY+5J/BI2YL1FbD0PSviYf5Uy3zfc+fx5xEGMuGHlWNsErTnmHh0HxltzmA0OXP/IGhzMnsE0OIzd1GnBAew3EIKE2W8TBAe1zww4CmXgz8Mc9Pdikr0nM+y9m17v19x67ybWezmrDmpKXWVKHFZVfdkMb1NWEirIfCGHTQavyUs1xSuDqXR3GSh55a04AqezSPUOqjRXjLkMYPPHzqjgbZzagGvoQ6+YepdR6jJLpCQjUn29/mACugvtCgpYD9oIa+hAr58tuZmdybpoBlpeczIjoqUST39wiiUauPCDCzok9fKGi+NvfgBGxUvBJEgiwQoe41/KdDkFT395868ZSfEv3xwk03+B5O3HoQv5QUWKdPHAhi8d4zgkhXa8Pwrt+5B4+z5o3lr7QqIV4sMmLH8WqbJCFkq0VYSf4rQQZIkjlkuTLiuc7Vi7gwS9MWsLzKHDveL6XKZEqU+RmxYkTUrKPg7UvGqOqSqWZlic8+q4imlB3ZMOI1pdD7S83hhTLWqbdGAikoINrlLP6dFQUQ49wvU5aOpPYJzpIy04S1ON5I8CF7pluoJQuXwG8h8FU19Zl0EnnKpfVuCfIiyyKBvitfwmKR6sdS8JyhjVp5uxiBZpau14NRgMVHmu8AaC/CWoyAeGPHQbDYS8JiGSF7EsOE7cWsaQaNafs35cSqtyTW3g4vW40BFbH0XUTcN4cPjdfW2psTHmiqxTpd4Y1aK6I51v7Cohx2dPOjRyRDiOh3CJ0Ogsf0zhXpJYCWHuUE7M74JbbXydKkJiRWPwrejbuorE1gqi7M5VUU/lDPohUGb1RN5EzP2/JPn/TCdQTf8pEPXwd9ZQGNrhp11rqFSfFzQxCjTSztTy95LpoCGCZhfmEYX/YL0k06GxPKc1ZTDjyj9SVUEMMD/c28M/XzgGD4NJIEyGbF5+1RoJord/v7VGKDsd+nvwXIbc479ynYQxhfx5qw+O4sd3VZ6eYRK53/wGNo38O2omgInk16qWcn6kfwjqNsTXqqR40D19tdRZ5Bla0871FIat8uPL1wsHW2U/+Q3MVvk7aiYAW+VrVUvoA8zfX09hDDDfv3RlYAjACpDMvQqy+LtrKQjF8F3Tc9hnog++8f1gM8xAzK9ZIUH09593t5eGuMv9pDZMTfC31U4QamFb4NA2HTmohX2hNuSpwt9bRWE4EI4/39EyuKf3gtzQ93T9zZUUhpr44XMjkAclsQfU7oXf8e+vpyBUxdG2TXBDdN7AbpDr3X9DvcBf7f5KlRJyXN7fW0XxoHP2a6fgP1NVLrsYHksle3yLOMqEOfL6eGhjO22xVDU1dMewI5j+9loKYrJwLxaI4yQs6rugrm6ub+7Obm/uT25v70cXd/fjs7sPZ3dGD3zX+RcMk6Oz85P3l5O9wKr/dh2HvYjhdtTjZwIuhp31e8BlmAsAX686wnD1H27f29NeNx3c/XtKb+irgn97NYWhLI52D7EYVMVekrsXa4P/RE0FoTB+fIlaHUIS95XcMI2Kv7F+QCkHIkShyg9/+OHbbyMp4ijmSCwiVWuYiuF4W+/Z0UhhLt+/EJv9PiBLW5+F7dR8C5QlqQri94c/RSJlj+44HfNd0ZTMnc4d9AcEkgJQIy+CeLW6LfUJKCJ//O7b7yJCJebql/Qh9JIjKvS1Aos5Z3wYsD3gifEsOvzu8Nv68LdIGaGfYmVJRpjOFayBpddn6ejHw6OfSopw9Iik+oGBl9fXcj//9MMPkV7u0TMyQRQ3CY5T5L5zYMh3huBbEy/AN8dyNK1sd1gsqn9melJPTCLGhqNJfeYmgL61C7LqmZkPH4VF25P9ug8EjUwLTc6eZNg4L2iqcAYKU7AMnxfUTMJCxDdW+E5TJMSfHOU55hYjHDP/p6OjwygrUknyFEc5Z0uSYO7O5xbV9zAh50qAYfQDQ1m2Ep/SgS//+TJwkURTJDBUu+WlGE3jbPr0QyWzVJyw1i8KKopcL+niJMLJHFvv6aBM/KNEw3tk/AFzcKpjJ0QHB2+wUOaxjBIi0FR1OR20EGmD+c1/ylWORcxJLiP70gHHnwrCcYQeEZH/Td+8MfEGb2ZYxov/+F+/vLnlLCMC/193WOTKnMP/z5v/0W+9eSP5qrx880b96GRBxBuxYEWavOFIfeQNom+MgFAajH0hst2gduQmDAtVmxSrWl+qL0+igg9mAhiiNOg2WYUgdB5huowWOM0B6IGBvQZ7yoCIsRCav4G4f9ago5YX90a0VLIOKyivx8nMOYlQeoDFtCBpYtfvZ4xnSqtBiq18HkrjFhg3HD1GnwrMiXpH21+J/hk1HRIRSpaIxqpAyRZRZCMwtIV2cJ8hyQksp3wD8n0hSSpcB7uqoDTv94BE9933NmIIKpdfB7n+WvDEZ4zO9TYQdU8lQWkkn4aeCo2w8HrlbiiD6IEtBTT0PThUBT4WhtrfBFZDu0YaLQgdehwsssLrc88jBNvrTMREojTK4wJzPHQ0z/kJo289Cwpsd3INUGBZ5BOdxKsgEtslZeB9ahOkvvIRV3NyfpKgXLo4q+NACJxjedvY5nih9zCpj53wuYAQMrAOlCTnjN+64AjgTXQNS6sAZDtcgzRjHJM5/R2v1qDBVpJnANbVPgNPu3A0fX93EcKQdhWCmbgJUl85TNLUcFXhuKAzBpywPjjNsvMiTa9Rho0+PAyAq2bZLcdLgh/PMZKFkiNIjOcsVcPZLZKLIOGNzQQnWHjWMg4Wno3QEAG3zCChXWEZJjA1BQ0Zm/p4DQ+a4VVuNxDALa4WDmQdOqI78zyCTA7HNsnOlRJCI2t6rUADUzKWLAn4aMSnkNAQ0XKRlsgu0RSnEPalPr/kMqweeTra3qaIBuQGKOF0y2ASpT4SP1wRoXeK3AZiQmzE1PsAKG92U4mJIAe/jLIOxly6dS+I2xQcMFuufhytgFPUQWIuYHLSNL8PdJ6qIpDFhe3AWgVBMEcTYp+f6b23YZG3ju20UxZO57OewF8xgj+Q7QKvpzgcLu/wDHMbnH9iXr9UE5kASd2Ic9tzYDQnOCaZ+psSIYcwTa/ZCSNI8xlIYEM0S1w5VxdmI/nQm7ynKKwutQ0X+H4l1DchPnQqz/kJq0dtBAV3O1zDzo0Ofzw6Po4EynBkT8kYtsSBI6zdNu/1s3v3DOweuS+D3FMcNOf7QTNorSs5igmdD9rVV2LC6FGb0YDtOSiOlRgmpd4UmSR65UleQ18CQ1UYvesl+MD2twzLBUvUc46RXkikq6GjAeAojB62EzDwXUu1u+SccCFv+GTB2ePQwXxlqsgT1w5PaHKHZcFpVOUsH2iDSVtYqvKlWAMyTIY+GQxtoZove9Ini1wJKw8EyfJ0SPYFhKbQxsHt2ELpYy4xtf49Eg9dDRRbQfa45yDCNzhZQYfQSM/pCcyA3IApyMlb4xi4oZdBJS78Cdx2tEE4pd9T8qnAg1caoMtvUKIBEBe+ZzpQJVpGskUpQ0kkpI4RmA8L52B4ilmWMQo9jnIzqipJ0Nj2PkLnd+5DvzFCBawc1i/Ae83kVsjQW25YgcDPggtj1wWhkcA5MoFk84ULdx4GC4CcdTYiHN5Ldk+DCMd/Id6yQDK6Hywf7hnLh22WD4NnOduzvpx1+3K2B335/2fvXZsbx5FE0b/S0XE+3BuxLFtv6X5z+VHtHrvssVzdu2djw0GRkIwySbBA0rZmY/77RQJ8E9SrZIlAsSfGJYIggMxEAolEPn4Z8iotPM3M0HoWCdRbWUkVEunBaJvApa7qP3JCbAhAWpZqNHU00QyvBkld715I4WojyzHjVlpmajqFNPH3XQ+Wskz1yhqwWfNtyJ8Gk0YPNloFj+ohJ4w5dkJEkW0EvtnG91GGTloFpFgPnMI3OxbxPGSFxtzETtTmuleBRLpoAdfDpSxffQ+IZ3iR4xgg5Lb7VuMJpAdPrYdK/Z2q5aXmkkaznUkn/vFMF0RZSGPkYOAiSF8UXnuQGVzZUJtrgco/K04wDgpcl/Kl3XgNDORFbrsaKko3PZbKnYHVZh2tQszH1PKlqoT7VRizDlptOFOMoGVIRemlJx+uBVJZ9sMev4hiG/6rwX5FrSpZARLpwWSbwKUsX4l6hk1Cw3bdectVTSeQHjy1HiplOWoeOU6I3kMjbrvlqIYTSA+OWg+VulnuzND0KXlfsi14wWbdySsbc2tKqhKlNMl8tzl46jIbDkLstRehDaaMJsxUD466pykShAvW8hM1355+RIgun8D50EUhok+trY6qNNPkzLULoMqyokMWC9CNtlynAHn0YLB1MCnLSxZx2UeYlYP1UsRk3tdW/64GlfTgrA1B04HByOy7BmaoKwEKUBj5j+yTacRqqBVfbyVghfmnUgQ9CVRQ58IMTY1mYB4kiIfIvoPHM06s7kATYuUg+6wlZDc40JhuCXQJ7RReQ7STPWrh0kHwcNjE00jsKIOjidBRBksHkUPApJHAUQVIunUNtKCVdN9Sch4GbDxtDD11qKSdfLEKNGVFDH7TYMRhZFrmUoFCejDWBmApy1Tg99beajWULHqwTx0s6oZKXrIiI87M2rJOk6mjSYDk1SCpHXMcLrpneIHb9L/NJ5BG8cZXQqWu0S2am5EDtvutBkIZEmlihrsBXOpebzxH3gssGfws2DJV0+nDAVRWkVcHzO3Zfz59vv568fTX2c23y+nT5/96YuP+6/ri8oEry3ul/5Sn3uV/nl9Op78WzA+XN2eP13dfn/68u/46ffp693T+x7ev/7j++uXp8uHh7uHpdvpFCrmqzKqJ9n0dUOr6ITsRKzdMH7f7XoNpo4n38SqA1E0TQIjhmt7SwB6MwkIBdB/HLog/anlLQaJpkkBgJ0iV5cbIC0S6cmS3eaHVoZEevLYRYGpnO/Qd1HpLKkEfjTIergJK4Z0Kv7PPrGfDDQzbDFGI3dZhUhEy6bJfbQabsjxGfAYRhBCxIPypFVGKPGsJv0NK2ni8qtFLD67bGkh1tzhu1cLadngjfARGAl/Le+oQS5PtbisI1be84k4DkWe3vNZ8EmlmfbUCLnX5yiELI/JBTm45qsnE0YSXVkKkrlPKe4g8iIfaahCbTBtN3FNWAaS0X5dhUmq2xopNpo0+Hl61AKmrGHRxa5XRTKpoouSTg6Jw7utYaeIQ0zaCkLWFFksjd+PdspOCNNMlW/YOgCrLisEL9ltmayRV9GCnGlDUNXLHns0WA/wjQgahRvhMyZuRqCpbTlKLXJqYwm8Jo7oZFky6QMacbcxhq/BrNnU0ya+wGiR1rW/N96cZWzWe2sTGKtBHE+vbdUAprM+YI8reYNM542WBEaDwQsQ5aLlLLXIV5+VT5ykkT566yoydQE0KQuJpT9vOr0PbTpG2HY1p+ysQVe1LM2ojasyWhhc5rfF8w8mjyTXaGpgUD3iNKCXUiFMCthylApF0Cnu9DjJ1Y3IsfWQbwQ/nhP0fh8gIWJMmDfgyYs6cVn+iIMk0icexA5za8WHLfspQSm+u05PZkiTu7banBdF0Y8FtINWAG90l+9vufKoRSjeuWwedhvtey2wK0Ur3Xe4X2NxaOVNdimm93WkuYaZLDSTebXc9dSil7Z5XB57yQXVa5mosZfQKoaMT8zyhd9P1W7GwwZTRg3lWgKP2zmOE1PQCEVPcwAFJ/F3RK2otsRQkmUZ71ZZwapAqqbV/VIJAuiVN0s4GMsvVCzmwW4ZqOH10SxBdA5Sy7IS9V9YEV8SAhUsrJapNLz3YbWsgFY4y4oSIsv4iL4sx3u5qqtBJl7giGwKnMJshxzZinzsL8fiULZMpQSVdWGwj0LRhMAYeothqeUwVQunJZvXQacNp34M2W60iVNKTx2pA04bBwCqlZTAlqKQng9WApg2DBQyG1kZKGTrpyWS1wKlr6UtNC64sPGIEYN/S8pgiRNLEvncjyNQNBRl5kPfawC7kCmgZq+H00SRo3DqglGWnZ9azwwDzQoO8Ijp3yFvLUyoQSQ/G2gwyZblL1DN8SlwctAb1TaePHjy1Fihl2cmiyAyRYYtgrUab21kVIunBWJtBpix3nRoOWpjW0gAZNwCZFxLDu2w8BjVbqVA1eunBc1sDqQv7QUfYYpIxW3VgbGzZiX+1nKgu6bRkyq3g1YU/0TuyIiYNtFujWrTSkgNXA6gLy7mmMyfURbaB2/zVShFLS6ZbA6EuXEd8UZ46KBjCbaF1llGXclry4zbganNKXCwoe27lUAWppedZcA2IujBea/2vCpG0ZDPdbP9L4IlQRWwa2kbk4R9tBm0FKaYl320Cpi5MKLLOtXKlSpTSkulWgafbQa6NQqIasbQ+xukWj6QEJt/I2x1OIUJpyW0roFOW01z8DmkGuHefEUXY5vZy3IsC/GoN7PlRm/1CWbrpwYc7A6ssW4LiyOA+uC3vNZo4ejDYaoiU5SJYMazwmyfmmn3+jKyXlp8UIZMenLUpbMry2MIhM9O5c3Fr8Nxk2ujBTSsBUpaFbIpfETVM2/SFwZaYiFDPCCKI8CxsZgJVybYVgOznXRReUeLeU/KKbfbB3zh8/kpu4yDzF7y1s7gxhoXTTwMtSR17sD2yl1N4dydeCYhVn90usV6SQs3mdRk0eI6n6yWlJJ6zvdJ/mtEzB/QvBu4VGxGhSynUqnOtHy/JmnFsHqwFCos7TLINabHT5CG1C2DCNpPuuIrvMSEyXYNQ1xiOR20iJGVppsehZSdAtTnMIJB4jDmhb2w8bYxFFSmmJxtuAKY2TMjTRYG1P2QUfUVGIgW0zKgs5fRkyi3AVdfkYhn8cIwZDo1w6bcm802njyYmFOuAUpadXjF6a493DSWLHsxTB4u6WW2DIGKvO73T8aRlnUZTR5OMtatBUp6Rxt3R0BBeZ4S2ByuVKKUXg20AnurMNjk9HbX81WTiaMVSNRCpL/tNOj2I6I8WiLZJJRQll2bS4YYwqs573XGXAZrGv/pOsBfv2RY1g+eWCRWlm1bcuD2wym+Jp+y/lvkaTR29NrwakJRnpE6v220ZqdHU0YuRakBSXlDs9Ad94//AlR2Ti402mqFitNJLINwIQA1U+ZMugy/wkRUaDiF+y3HqkEo3Zf56+JTf4k77kwn0ALna0HvIBhC1yZNUI5deG92mMCq/141OTweGSRcBtwpj/XtzB1st9ylHML32vc2hVP8moMO2eH9hPOMgJBSzdnlsq9agUT2Kaab93xxM9UXQUbffMlyjqaOZgCkHSX3dybg/NJDrh0u2fVNz2TKVMpTSTHOyHjz1D2+T/tgI3w1RDw6qyAvawPRqkkyzA9wWcCovPfYmp+1ld7Opo5f0WAOS+lYj3V6vZaRGU0czqxE5SMoz0mQyGRkBG5EFsfEtJ7KRESUhiFsOU5NserHetrCqLyV2WYMe8QwzsDBm/btiaC03KkYwzWTJjaFUflccDnqDZMlBXuS2rKcMpfTa+zYAT3Vm65+etjdqjSaOVixVA5H6Ptqj4RA+ck26NF5Qe5+mDqU088xeD54ezGaGScb4ltXUoJOGjLYKOPVd2oa9jnAkh2ye2DNCanqByau1TKck1TRzc9sOVOX3vcHpuM+69xbEcMhi0cboV4tWeu1/GwGovsFxd9gxFpREvjFbGsEzoaEVtW43qtFLM6PkTYHUYMcbtWGPm00d3Xa1kZZhjzuj8cQIsYtsg7T7lzJ00syKax1w6lv6jyYjwyMG8l4NkbYKe22+deXopZmN/6ZAKn9a6076IyP44UB6bot4lhVRCm4Nkc+AaNlQVbrpdXrbGlgNAgd1u6w1zyOhYQYBXngiXERIDBwGyJm3nKku6XQLKLQ9vOpf9PWGk8TMzYvYIFt2VIVSml3orQdPA01M/zR/UWlA1BZ2Iv4RIdqajSlKNt30NNvBqv4GyBaenO87G4n1AiYFvPmWK9UlnGbb49bQqp/ogx2XW/ZrNHU0S/QhB0l1RhpMBl3DRhZ2TUeYzLVcpQ6ptGKxjeBTfuPqn7IGhXkcT+8Kljpt1GalqabXRrclqOqf8canI8PCIYSJ91DrwaAQpTQ7xa0HT307mP7pIH9Stcyg9VZQj16a2cFsCqQG2UJ6p222EA0Iplu2kE2hVJ4Du6envUyubm1cFKOVXny3EYDKH/BG/cGAwcfeG7iNnakImfQ62q2DTf3IKyBCC6URNd8MHL63jKYQrTSLwLIJgOpLkoPBqGWyRlNHM2lRDpIeLrCx38UbDp+NN5MNhMIx1EO88pOD3dZbTwMKaug2uxvY6geA6Iza3a/Z1NEsAIQcJPUZqTvsGxH2QnYyNcgronOHvLWcpRa5NGO1DWHUgPdO+7BbMxDh5lE44be8pxa5dOO9zWBUX30yHnYFdIFhUmSQ2TwKLDNENtyFsMUHUXByekV5h6c22Y9u9NRMRbMvJKiv1JmM2vQlzaaOZsoYOUjq59zqTU5ZDw5vio/DcA3PsE1v4YCPoY9fSasaVZx8mmXn2hFm1Xn18fbG6Azh7Oy9eOTN46nJjFfTiRDr17Tb86UO5NOKV3eGWf2QhKeTMevViVzvySYoePJI+ITecdBupirSTLNQhNsAqjwrDvptqsuGU0cv9qoBSQNGGne4C4cd/HBEVKjMr6rlMDXJphvrbQer8vqb8XjQzzs32rM2lKeSBNNLR7M5lOqf9IadU8M3KRsfamMsKUgszc52G0Go/r43YEfYOGSwRSIvNELa5oRWjl6a7XqbAqk6+016o27La00mjlaMVQORBgkYBl0wggUdrAGpJ9oLAhXppVsyhg2BVD9WZ2/UExKyEb63t+fqEUuzyJwbQaj+LUJn2BMqWnBu5BYBLdepRCzNbgw2glB5rhtPhuPEmZhv6IFhR76DwXq8ZT8lqaYXH24JqvoMOZh0DNf0YeGBRaf1PVKIVJqx3gbwqR/C7HQyMhaURD74SrVSp2K00iyE2SYAqq9fmQz6hs327/ZWXC1CaaZXWQud6pw2HIzGLXc1mThacVQNROrHazntt44CzaaOZtFY5CApr9voj3sDg7g4bC/V1CKUXnqN9dApb4c1bAW/ZhNHLzusoZ6CX7876rRs1GjqaKaSkIOkfjShzmRgYM9G7waJQhjCjESe3d5tqUcxzWIGbQ6m+qEve61Q2HDqaBaWsqelWNgddwYdY0bJC/IMj1UCEzHUmuerRi/NjDU2BVJ97xh23MybpbSMpwylNPOIWQ+e+sw2mHQN69mk4LLqWaLFluFUopZmTLcZiOqnLx50OuxkajmRjUR4TJNSc9nynmoE0yyl8cZQapBptQ1m0HDq6JZpVctwBp3xZHTK1oxX1p7NDS5brlKHVJpF4tkAPm3yASRw5oKrt3ZXalNOzywAW4CrLHMuHDIznTsXh39OvyAPsbZaTlSFTHqw3aawKctj3I8HUv0kWYBa/mo+ifTgrU3gUpavKJojyt5g07n2QrSgOFwaPiU+ouyHjXyKeLbJlt2UpZweXPgT4CrLnCE1LVh4bByYM6dlQgUopAezbQCWskzlkMWCwdbyUlMJowcL1UOjsKwo5N9byL/aGXUHA8PF78g2kqzjLUupRrHi7HziL5/il+pKij8JtKRcb7r/IpRWevH9HhDPcHAQGn4UtIGVmk4fPRhsLVDqXqh6IaKwTLwig512vKCVYVRY5F3DY0PwFsSeGXMTO3BIfcPhs2GGYK7dUk9p6pUFs6eQPHlaCCc7Q54UhGrLoNvB/wuSXKXNNLAo9kO+TJmREwon60+2IlQLqHVCIy/ELjqxCEUnWc7SeOG9TAqytTctYmCdfhqoRxjxxV9syCkQTZ9eFnEIDT59V2NWVQZtUWSGqNmcPMfvYcQaOsnHAP9kEW+OF41nZz5Kzs6CR8/TYeefFSGAbYamT8n7siXC8YgQsC9NepPlPmupcAQqzByyaPF/PPxzobUlwMEJ8IwcHwY1i7CjijBdGfObGbhqoDk7txlw8Dr5k/05d7BiiF8BRfxTDWp46E0AkPzQW4XX3DPkSoIUNBRNPkLmzvgLFN6QxQ16RY6CGorS6HOPDdcR5WBwEV2gz0sFsZ8befxTHayL0IczSt7YOBXEfcCWGSu89CKXo998QdO0hK8+p5Pi/zoKEEVsDoyLH0RBzNPxk7JgVebambf8GjmOPgBdzFSDx4hhMcScA+g8BsLj0kfcygkHChJpPVA6EurPgHh6sZN+EH1NSNZokBLp3iKujx1W7EQL7LEDDHYcQzzw31DHRhZ22bmSfedw4fNCFOhDs/to5mBLDo8KIt6FGZo3xLSVlO+Kg8+e1JGwmeB2z2ud83dqni7LEJSK1KFG8byg12FHERI8oB8RCsI/WN+OkmtSFYBiiWKnfwUpkI47ZLIU35k7/cG4l/uvrxL2cxJh97QARq+rEhyp/ZMOwOTFPqUBgVPUZ4hO8c8I0aUmACkOCzcpBL+Je0pCYhHnhI0Xswb/hVLouGFvpVRxmHmPJ/cmNbkMI8zf+KPigMUPcEIBw14nu867cN35fRyCQhEgXbygEBsRoHx64reXT0/sV6wYYL8t4tlYXGY+wms+WV+wrzgVQZ4ITtC7TyhECYGN2Z7+cBJxmz9zNrxiAyEqc+NGhzpFYVt/KaQiVInJQLonPJhvDyiIHMF9sheqA7v6CkxpIeazGaCL29srpUBh7bouq5qDqLjhsa3ukTyU3mhArS/FpTE1FFQdrjsfiSY0gEXpaWcgb8FkRSPdwhiE3K/ajw8IpSUezgNsjffZWVut1VByj8lD/QYneQa79nDIAeXtXkIFfiZfXUVDRPzDI29erF6UoqFSQUMkPERBeG962JJioPhWQ/C/eS/rZoGkioaI+AuChNevCKXXGmxpyPWbrjPYxlbAN8NnAOs7wToIHNR80wCK6Q8dBPRACygKtnZKQ5I3sFN3D1plCqkNVFqSqmg6qPx1lyaglMwfNZltd7PvSCiX/4LUNfrIa6ttO9Xen9As0kGB92ZS786z6ibdv1W+PlUxTNDG18CKWIiJ2EdwnH5AbM5RCFY9MwOkbBgnOSjYE1Eez3lgHs5MvdJ/ihNLd/jmGDl2MEW+ybNaSUFUleHCZ0rectqtdwv5YRx5TAMmXAVe3Tu1V1CfojBc3rPf4RldRHx4mhCzDjRZudpEvCLUNcMQ2WBc4i00oZ8EqlKR2lQTh7Ur2C2m0YJ9qNFCWgub9IXadDR931lKLoQ0IGMdaLJytYl4Rqm55EoTTUhXBCh70oDXvnk6slkRqlKRDjudTtxVgij3qDalpjyiqE6UKkGUe1R9w4qPLmnRI0X6bF51wPHAjfLXOumS6hFAeQF7H/w6MG9Bbw0Og/odAUsHPw1OCjoRqghQ9qS4JJNqF/STPmthk75QjI7YwyG4W11yN4RrD4ZiKUu5emgqhYrRKZeFLvaREy7UN8R6OSes5j0lLlb3fnYb+HiY22KxetSEDOonj+LfP7htjsKkkwOT5IcvvGh2iqSNYWNzUALWv9Xyd1c1DJAMhLzjs4LRB2UglcPqaALWN1jetYJoVaRIRSNgTF+wLyyqp2l0D81AUwewnw3LogmbZUHfxsX/dVVdCYX3ZhJtRitipREG7s2lQ0xb3Ti66wIEqSs8bRnvSFXN9wpgcVBgPg0hXAmfquyXScZqMKCxQB7i9snGd+FI9DgVvusn5WBcaoZXlhEpDfanwQKZwpKELFSYLon822Sy/KTEq8k6LjmEaQZZLVyqMhcO38XafYG8JeQK1mQBlMJVKVR8w+JqHF12rBSY9Ng8UJ4uxbB1XfUBunxnPcfA/FvJ+NU4+JviUNl7xzpY4p+KLWgbRBZXnkhbBExXlnQLFPLI/de2FiQrgpM9KUYiar4ZP2Bqwa9z4rpsJGAaemv6Cl/fr4dKVq4y6fjyoBnhJDCxtqyXMyeMjRPUkZbWAVYt1QzAELm+Y4ZI+N3eYtt20JtJkbYABz+cFVCqYxSbqqVPROyXVE+trCnsSohKRaqZMGewcf8/Pi9Vu1nYCSxZudq+LethFuakZ/CWS5/Z26vIs1KdgsYYYMdZ0KmfefY5Gz1HAvyYsaYDxb17SsCfOY4wB9SPm2tAq3un7pL8igMc8lksYNKAgDKQymXqEgw8LJKnc+KF7JUGNKuBSlKsLuUon3ncLFcDipWgYZQ6J64fhcjmfnaBYkenesjYI3Fe0QXywVXNszDSBzZLkEy4bE2xjaZsvJaCNz9bgHjn4iATxdU89t4iukB2Jn+ofAO+AViycnX3AaXdgbbVVCh0Hb6rOKKSQ1r5nKPr+a328Kb4yc3nJg1qLyExDK8i0p6IDJY+qEmPAiwtTY68FnBRT/V9NgYifi/s/4QQCyDln4XLz7D430hZaqV2dH1dIDqzLDYuUAqn+84VCq3nC8Tqp9HU9aEg13k/ZpEm7nhI8UAzKLVkPgFUPv+yNqB9oab//M+bxGhNJ9CuPbhz4hkotGe7TQFUTlwx010Cjp/fqHPm2Wc+/gdaqi7DrIasVKSosJmD8Q9k2oh+hpie6lq9bQJXoUB9usUZkbHHDz4GO/qYAYmohQykdFjunSC9Fu8u0ldKRuyuBT1ONYhC1nFIlxA/Sz/61gDJCh6SZ0UJahHXZW0If5+cRKD8aX8FXOr5l20C1XVAHN7FDXpFjmra9CKAgt8Sv4sH9CNCQRjHZdFkZq4DUf5G7VUmhVl+zLrWjrar4FzxWgcqu2bworQP33qo0gdNuJILprcoCNjXf+Pw+QZ7L7pxZB2MNa90oKwHWfHA0/SGLAKt6FmBrFCgA+3gr1YkSwBi/PYFh39Es+sgiNA36uhALYcstCJWDA+jVbwsqmbLuAIoHDxEQcjWCe1g4vuYXoBZxHtFNEctVdeJWJ/0hv4mkWOf+T5FFjZDdD3/LxKdQ9n02aTo2psTTVaSLSHepJ7aW0WMEFFqeCQ05iTy7JMZ9ky6fDQpW26Dv83g2mNfMySEzvIeex6y9ZoQu8G/tpKecyN8Zp3fEIv3FPxhvqLPCHlTPh7tJ8Z64FfX0HNK8OgEsZGJ6bHyz+gKXmg+GVaBXfdOzwngmaA3/CLi9CL7zrvA8zmirMl7xwzn7CSs+VTYDAHra2kqTrA/DqJ/mMGj6foMYBt0WolVmr/UXZrYAPx1dTSVJQhxIAvULzoxNgF/XR09J4Zp2w/is0fCzlz0c17W1nxWrIV9ZQU958MzeXskV/hdzPuvJOTC1Ff0Hn7XfTqsA33Ve1Ung3gPpyjn8h1ZUai+oV4dTIUCten1gFwC3jBaEawKVLFEbZKVPdD0d6pTmFh/m4HLbTwgJgtmp4UbYmpgjL4eujf5K7WpKS6V4u0earGhub4mxKwHLr4+E/z4mLxR1AR2HbC2GaIrSlwptMpMXN6jiMAgokDdU/Ku7Nm8HppymWLriwCMj/8BzdUmTx4KHCRPaq0SVUiS39eu76i7BpwtFhQt2MoWaLAEFIEpFSm5AIhVzInilIiqL9EpILlHJemidEbHEgg4SFI5qhv0uQSSCHGtHVj8R7rfKBukOrci3MJPDVa2FI7sSd39hg8/gOjoQtuifOi5TWFbXUNFgXU9zJF3tgHUqk3jVOpjpZHyspMEGrHDffOgiTg9zEB9GvEfqs+4BSWR/3mpzZzLwaPVrMvBFf9UfealP7WZewWIbBREC5MCIJAZSwPJvg5SCZ/pCWj6oMWJJgNS3CKkBbemrw1LykHLPyt58hFg2a47fyR/Trk4/NV0FV9JVwBVKVSZamhuRk7I73n+MLntbaAF4Wrgysp9RMPlBQosiv0kSu1AJxLKypUU0wSY34NHcnF7e6XV+iIFqlKo2PoCSWlIgEPEpx7Y8SbspirJVkOUe1SbUhS55BXFsGB17zU3AKtcpjbhxKHnvFCoCfHqQJOVK79O3s2+IyvUjgFrIJMUq01BpXNy/AzNTj91+t3xYJT7q4ewUtza9QGTf1ykbKlIK3Cr6Ve0g6y4E96Yy1j5qc2M3U4O0AfwDaVXCcD/1mdx0kGQ3WTJVUn4oSIKcsyZ9/wrBoyLA2VVM2tAkhRfsRER5aLNJnDiQCuyScApFanmKiV8oQUIwrzonHhBSCOYdX+JFIas9UulU3hsC+RmNdUktVALi4/inF5w1aQDgdeBJn+jDhmf8eLZYf8Ps18KUqwGivThcaoiRXhlpamRQsBXP2VuKyUAPJIX5KlzEZlBED4jJW8dJRDwHyoysmN6i4hXs11HaVpUIGH/qE2R4IcuFIkhYf+oQ5HEGAT5RoBUlDyqAMDvLyhUZrOTQzBFCtnlCxCEoqOcfIWdtUL0ru7UWgvVAoWPyPWdxAEShanJlD6kW1lBtYlqq2mxXxw8Di4SM+6BcpjHwV9xKlWk3ORhrVLMcxM9mG8Zxyu8d9YDVPdOPQEnD8cDCiIn1IViOWhkL1Qj1atQyKK8vjbOaq8swdbAtOK1eoxmqxk6pTx88Us19DNZNA5urCwJiiBkT6qRwg2CH849+9SkyJ6GjL1dlTmjHhz5G9XIJV78xUaqZs70GigKBarRZEoiaqEr7KCpgy11lzQJHKUi1Sgz52E5Q6qmoZUUhtyjiurbc4d4CLz0ldbhFqAoFKhGEzUzyBZzdTo8S6dSaH8zcXhF6GcztJ6VxX8ZiPyzemuThV3T+TO4wS8KK13LUODgIl+kGlU0U2HWg6OH+vKcjWiKFb60yAPAjvTJo2K3F3koLj1z5iC7CEmTZ1R8QIxzQPxN6Auin74rM5/qhh+XwEmq+Vz99BSiIAyenk7ApSw48dh6ZAtjZBPDcMS3nyzizXHz5Uc+Sg6YjeY8o14y7PyzBmQR/nKKZOQ1FiJFKqHG94DD9zgVdwoFa/myTbx6ZIq8Z9P3l4bHSpFtENqyT0Pp0vJPE+kUXzu2fNM4eijFL5vDItilyUL/7rzfcOm/TB+KLELtlvEbQQwGmIes8I6ecyvLliqNpEorxDSRSt8D4hlz7ISIYm9hsDbCBeur5aFGU6flpSZSCy888LxuWacJxEgDfLf0aBg92sWrifSxcRBizwpbdmkWOVpuaSJ5/k9ITS9g/UAjLcc0jiQt1zRTJRB57QbTJFq0fNLMC/QQvyJDPLTs0jiStFzTzHtz9oH1guwpa82k154ftSZBjaZNy0eNVGO6PqEt5zSEGgFnmBsctIJz4wjSrl9NJNDMIYuWV5pDipZLmkiaOIV4yyiNokbLKwqYYbjL4IfTMk5zSdNyUVNJ1XJNc0jRckkj7WQsfjPTql8aRo6WWxppJoN8iiyzNcNoJEV+EZ45/dQr/ac+vaaEhnfUjvOZ6gcfjF44psTRsapAKmXN8Wxijx2A2kWwWeT4ZVbAgeLUgaGr54bKeMS+wrS9G2wcPdrjQjOFAQeF6Nb02nuPxhGk5ZgmEsjH1kvLK80wPGHjsMIH5PBmzltb+kZTpl3OmkUp7IVoEX/N42udUDRHlFXEpnPGvYYCg3gXfENifQWWaaPU4769720gAVsfvCZTx8ZBHALGoKbVuuE3j0Jt+NTGk6iNMdhc2mAvQF6AuV9YKyc0WtATgnm7wDWRNi55RbbhU/SK0Zsxd8xFS6fm0amNE6fMttRGIWsmYZhwgENkvJoUQ+4Lw8EubjV4DTwWkdAIiIHen80o4NJdwFpjDVnEdZVKbvmTUMLHX4RikJ0TNdD41cLcMmHTSGUxArGukLdgABkz7Jm0vbNt4J7GpA3TacXA5lLm6ekZOT4bPqtlga7PZOPUZA9bC+PD5dnFfz3dXk6nZ18uFbJT2wHUy/+8fixCqq5aOgu11B40lbjgYSCxwbYbdPOIhLzIbZmngXR5x6HxTEhrXNU82rSB5FS+gDPmyAwjivhVQku15t34zK1erzdpKaOkQVwb+6SZtCPgq/l5aSR33S2JGkciF3vYNVvmaR5l2lhoipgdtLtPM8k0o+SNjbqlTAM3nXdkG62lvDIK73aJa+jhyHzLs1GrD1LHvIONzFuQX8N8pwLrL2PEE0PesmXjRJDICbERXxW29GkcfdogMg0+WLWGbw21x+FXg4bT5mVpuGnK2zN2kPEjQi0bNVE2gNNubN5rYLulUPMMsZ/ZEFq6NFBqA6W44UWOA95ELYUaRyGHLBZtSNZG8o5DzNDwTB+3xGmeSEBsPF8ace2WPo07+bRh6BSgUmIPafAb9PaYqqzBnfAab4mnKvEYYK+tZUSj6Jf3oQtMD4f4X+jyFengF7katGKJquRDlBI2Wsv0DLgLTBR9ITFsMzRnZtCulg0kl4uDAEz4Yo/+2OZFaP4eTbpArYDSQKphj0cgNDD4QLUEah6BVkkhDEwzckJjTijCC894QUuDf9aGK2z2UskNJtrQNHrxXHsWaDBJAxJRCxmu6RtB5PuEtptdI6URi1AKwr5FnMj1uMl0S6gGns2Iw1Y8tga6ZstIDRbrI9oKgI0/K7cUah6FIo89GHF0/tarqqE0KoRx+aslVoOJ9UYJW/Da0G/KCBChEf9sqaOJgqL1PNVN39QaDjRavG9j9TRZg0Fp5LfUaSp1+J0/5qZtLg7bvauplCKz79w4ow1A0mgJoxjcoiVRA5c8kaj5lY0clj1e2tJJga2pVWM0XxIX14kthZTQC7ayXsO5KWwdUptJIPSOrChED0zaM7n3cLs3NYRYM+RZz65JX4ITHqrC8BHl5hOehU4ChGxu266ke8LmoE0vLy+ezu++Xl1/mSqUrGlzAC/Yv3EsNkJVStK0EsR27WgMcRwSBtBxm/G8gcR5jhZtwtGjkiWwKPZZo8mlGfZs9K7Qplo7/nv+Dd9RhqX/VCSHACcNVnr6qVf6r8mTDDj/W4gdBhfb7m+hy88RdmxEFZppq4GYY+TYUsIoSxc+BL1AopEXYhddJK+U46SFEJXhk0UiNavBQ0Y6XuN7wGGJOJm4AuvEdt35I3mE33wPzR6bfOrJwRQKmNB7iKhnOo/k2hO/LhgoAJL8TUNPPKZt+qAMYdVBsQiQ8Z3I8FhPTZ9vksGLn+noxWZ6g2fTH86ZqH3FOid02VCBTQKS0F8pSIts4EyIfkU0vKCY/XMJxc1k9pVAuKZfAUCF+SN+KsvLNWysDv+WlqR2QW3GBveGZuqSIx58nhp/o5mqBBHbA5h2KEiR4uAXKDzn9+mZSNv0M9VamNjG90DetIHljC7UOA2uZf927TowUGFgzISOQRwC+QEvEBZPwPBNJ8om48elsmZK6ptAci2FpPGTKg5ip9pcyg2buDhUhIOvIo/Pj3M2INUwXh77PPesBteWIbiqQND4CQQLywWyHFN8rNockgw/LBapMZMkcDzK4Gj8fLpnw3VR2PwLs5UD95MHNWZPYez3xbE3fsacEy8IFV6CZOO3SmVqTCMZJOdSSBo/qf6mWME1KBv19deLy6+PT9Pr/3upxtzJhi5+KTJPuEUntpTdtWTjX5TK1JhAMki+SCFp/KS6ReEzsVWbStmoXf5LjWmTjfo2N+rGT5ELYp0TF7pXbZoUR549qTFdiqO3S6NvvqzsmIFymrV00Bb8UE8qToZ/Lh1+4+fMP9CSzFXU7hcG/oKWd3N19PmFsacPquhwKDi/41ek4qypDD4IKfYWKfpPxw2/A14LkBe5M0Q1AmhGiINMTysSOY5G4ESe8BWydZp0eIG9UCsivXjkTScuMr2lRtC8EqwT/4TPONBpxUavWu2phQI5TM1X4iPH+QesadOlOyPK2TdIhv9WLFLCJnEDsEIyFUK2udAFpL83oFTzrYOwo9z5LRnznP2riBVQPOKrdMSNnxhfTRcF7K3Kpj91MHhJuRqzpw4MWbkis+vyHZKwXVHifgIvZ9UmlmT4YJrIkd9XEPcw+A4ffVfR0XeVHn1PjL75pqCR7yip8i0MPEweBNYHSmGdD/46RK6Kg39UfvC5adN4bj2j1FxOfYpM5SxNSkM3s0c1RLbS+M/K41fGa0TFxb489nnuWS2vkQSCqwoEikj4agr2ccQoNmbxrMakycaeH7USigb7L9OJkIrqhWzkXvqkjlYhG/3X0ujVcExmjavpkZwMHCcPytm8FcC4rgWj8fOIz3lFIjiuGzuIB2cBG3CMfxXck/nCo6KUWRi4lzwotPYnY/9aHHvjZ4yw1sPzpWozpjDw9EERPhXXtzfguGU6KvKrFIAgX6jkxbQUrEqhpqBlAqtyF+/fPEW1K4WBR55SepXC2L95amlU7inxmWi3VM/cPhu3H/9WJGhCbuT3hZGroftXcXkpDJzr/RXS+CfjTh8UNMdQ1xKjqLSFMo7+TtNzZqyGiR8tcxpdxcFJjZb0Aekz9mwmkwZ6EUmjOSeezhynfk1QIQaSjeEzNU/fkuFbxSJlAiCV4TiXwdH4+XQ3+46sUMWpVBw5SZ/UmEDF0d+VRt/8azdXxWv9bNRizOJZza0tg4VLhnqAkkqFeoCTSIT6EEeTeXa7lv1VCNaiaKiWXKAWpcK05IK0NHinttEsWqTJ6Jo+Paqjpcglr+h6endhhg2dG9VBB6bHRP9/oUcUhDdkETR+biiRE1cy3AXK8NsdKIBfy2HNqTXkCyhq1gyOUy6czBzzX+iETYKGTl3pONk/zTLuKI4ypKYX2FFjLShXjPYKO0ms18Zw1orh3pq+37ThpguBixesGioltn96iuFhv/OKOnjNN74X7CuD//ShYZ5bxSH72FeDFZOBwr9NXuDYFkciT5H1LT/Y5HeTkRuwHi01tuNsqOJXk9FKkUWorQRas6GKX01G65MSGBWjbPb09JEZKjI9k6GKX41SKdQNNcQuCpp8BPOx9dJ09QF3qmLCapCqaoJ03PBvkxnMNX0luCseJ/unydh8QctACXQmA4V/m4zQyMM/IjUE6myo4lejt1XTW6iB1XSk/EeTcfrMuml+bEPLwayrE652OUFddOKh9/B7YASssmsaHgmNOTsL2iedHoPCI9AWK50i+oroOXF94sFQDSsK2FjuotCPQjYiYfF2gZlkHmadMbhfscUGIfJX+5j3++l78P8JZDWZnBbxLEUkz2yo4lezBXplNMDZUMWvJqN17phhiDwl8Joba/yz0QIyoopslelI+Y9mHzpCit8VOXckQxW/moxWSBKvhvzB2nWZdMHPy8mom5fiPsEuG6yPHb7PzvGi6Qc8yWgtiswQndmmH4IQB+VNdtBeAYmpAQyRN4tA+rVXQNFUFqCRp8j0j0fK/mn2ouI70QJ78OwvIVz7PX9WBMn1gy+WqEECj7V/T0lILOIoSQY5ANVSNciB3oVaXUlSVAdfLFGDBHP8LmzXAyWJIBt+uUwNQhDvklJClaRCZeyFAjXwHwaWkrgvjDt9UAPnrKpjWuhvHD4riXvp+CuFiuzFgTv1HRyes34eyfn3QLXtWDb+SqEqYuoU2+hyPkeWovtyDQSSYlVWqoA4r+jeDJ8DRZcqGQDVUlWkVscxxAP/rajsWgeEQ+KsDo0zhd8cBvaV43yOGKtTLUC5QBZ244ieCsOSPTXUc2EdKFAnSb+hOMOXQZkruvpCHZ9tIRqQIwEj3hiFQ7/C5PhOYkZXGQjfpIH6pJiZAYL4KsoDYmOqBRwB8tWnBXIg5XosY6kMiUcoE6/wv9SfV6wRbkWi+qIbPgsglBRHKLFQEOggkWSQxD/VFRJn/DioAVEyQNITrqIkmevAIwII9I6DMJgu46zZpwNlyeGwwYQ6AKILHJBmlYm9GoGiAxhgfaQLSRzsvWgCiwOiow6wWM9sEHoQBQ7sOkDivuiyDLvaAKIDFJGnywL8ZobWM+yM6pNEG1A4IDrI8qrD4FPi4iCOh6IwHPMEAhVVDhZd+iHRQO2QAfKGZuJBJYelzUCjbDjE/fbt+qLRkdp/Bji2xTjp1q8XgMIv8A8zeNYQuHqw1FWOG9zYSBsVeQZOzhRMg0koh+7cMYNAKW/PVTCiVxiMBlMxA+QSfl26OExuzAdK00X8amZwv00gaXBaiV3AEKcLPBf5ZbsKE8RGPkVWkjVDZUjYe18E6G0OHDVhJS0Hi9CS/IQH5jCh8uiHfwUQKq5PYWNTo+8ABQ7MsGFp0neAImxavvRtYLCFD4E2Mn4FnsxJQlUzdkTnT8+EvGhhOlYABp5gU8myAPwbKPTiES5C/u/v1tJyUPBko5BtmIg7ILH3M2zzmI88WccTshdCexp/+RRYhMb6eVYUmK7P0CVaYqX//T9ZIUPJIimFjk3W3jLEluicoY0Sf8l/U8JV/vlCtoF0uxP2VWomaudLbRyEFM8iGCX/8jreWdlDd3AKdpjnBBoDxLCySY/D7phL/pjvqfNpNOJH0lJPg0m3K+vpm8fw8MY9N3ojWFht4prc6H7Ug2awN6cm+yaywohjijfuA+290IybGQE+fN/BVlICfUFqFPjZg/FziNjkgSa6pxwg3lxnMOKwQH4HNuWWJXAMQZgSMKcySHAeZ5M+bxWU/lVajHv9QbXRuLTSLm/DiQ0XJ6fDpNl5BF0Nx2NBCzxHfN5UeusPTiW9dcd9KT0i7irQ7XE0C/UXPHf4NGEIpQRanYjJD1zkoHccCrSZr4t4brvme/zrGS+en7J67GfkcbkMvn9msluIuLPe//4ekpBxyCtxImEcDzR9XTzZeD7HVuSIjYsVinpoPo8zRrIiNi62bjKme5pFIr8XH96bST1I+plwEmRFcNkKY/NZkhaHz4jQZTzIEHkC1f/7u915ens2wyfG+RZMNhEy8DQmf+eJtRYs2fjdYo0ut1vm68aTi0KT9WYWa4gWXsZ175M+yCuibH1MF4nB4BNXzeWJJoYaLn0UbMa5vIQxGfqczXiuX6ExqtgcSHmSTeQRX2zYeive3dx9+XT19fzTLYxzPBizl3cPXz6dffnCi4Zj4MXL/3z89HB5dv746fS0w0r746Tw2xTKevAxK+JdQ/uwLj5lQGARfwTGe9qHiYje2UrOX3ZHvTFfFl7JiygYTMTw/ZnzxI6QcxzzAFsifIYfPMOOmKADjlQ/ovnHHN+LgjwjDcQuzD6B7p/mGDn5uQpxg8QQxp1kOYwBKK9a3f54Ul23Jt1c81X6iW+K9ONfvGLipHP4NOn6qdBQqavfL3Dgs2q/wXT7jW2vv4kIw78xhqe/8bXL5LvU75W19Pc7tskC6zMOg+q/WSbrhLdhEUJt7MGLeN3Or+C/X77DKERV5DGGtdBvsyjAwGK/0Qi2M9kS//sfYmhsI3322Dic3yBsL0NL3FIcJ+g3wX28DQibzOYvfPwXoni+/G2Gnk2GJ8o/eWUrnw2jZBOJbcYx7th32VT//V5g7ze2Lf+2ROFvsJFTl43V/h1wviD2kwUKymxnTouyVQ1oQd7Y8zOiiI05nSP8A0ghREOGHCYYsX8d/uJ/f4/dgX4nbJ2fojDyYWQv2IO59nvi4Qhl8c6eTRK+BntzbCMhlvTEwpFszGXUMjiy3gKXcRDfIw/RG4SZO0Q/C7Z+w0T9Qk3/+SA9+u4VJS7Itmesc92wGd6YwFvnbOPEIb8xOhB8Dyhgm75W2Hww3+6F7irfHV9BPrCv4OM7Y9NE1tmHIfJgWDwGCi+Qz0RU1gQ+EDaha346PkbP55gy4d6kR4E6mjk4eL6jNqt+iD7/hSi5ixihwZ7tQEB+RW8X6JUJRUHcwYd0WpRuEnGIHb07mZBVloVEYV50YlLawgMV0NMzMh3uQPn732cPX6+/fvk9J4czDoxl+NNPHWHEFRL/6TmalQQqG82Z/BZHEeaS5pONFhTBy373tIAqS1qrd9ot1HqKg5yXqrGjVqGa6PhWXrfT2ajJ02I1drR5ZeSgQbliZ9wvVExvRSoV+71ii+CiWq7THW0MSLlu/Qg7Yz5BCPXZoSN4YkwHFP/vRmgEA9bwjLxDflqLnSBOUiGcB2LMS+SNGK1Fsc8asPCJL1avOK91zebR7DGX1t9GXS4GPxyhLWLcZPyIEF0aobkIignaefkjK1Zz+G84fP6n+iDcQjoPu7mAxDH5jRkCwxmDwYVD1ONwIIjzGsSZiV7Z9nlBMfuHh39VCQ4x+iCOxPSX6URI3eGDWApqaO+RaySVhcM1/QfypvT4z+hCpfEXiwAGcbL6zMunojhOM6IrXFdsOIQuGwue3VF35a2MnbGIQuO2O8ZzGPrCnOai8wf7fW9S0w0UGnisKuGDbzonbzR6RfhVyS1aOvZ4W4YTMVxWiuu6VcdQcbkeX8H+9+n/xBeyT3Dw5kW5m6P/4VeYHnpK0sH+9+l//JZ9kmhbQC1Tus1K9EGyFrMLWV41UTEU7FmSa7lCYayyyeuWDJu42DO98Lf/p3PS+X/55VoZ+kS8L0LekUDOrxr3BXTa2D7gze5tV0E8MwNsxRtrDdhdDcG2+aZlxHwiznQeYvwRL1RFDPR+EQz4jumhMGDLDKrgoP8rzYK3oAL/4BeBnyeALgM//I/fRhL4C1f40/RhQ4x0ixgpNVBETlB490HbQfekuwGP+IsKesa/yvpQBX2i7Z7IvgkXlLt5SIWBU50gj1Xks8j1DeQtwEKqCjEbcadWGPgPYcewG+/XAJ9r8wNx0C3iYAGWO4adu8ioYqLHMCHbECvWP9tMiLU4qW/9w+TjEm6I5ywNdqghb4bv+e6n72XEyHbJsoHSvvhD1u6HHxQSRmEz47k6L9g+2RlpzyHsxGm9JMuEAVbCFNtVibEz1nCFLFwiluCd/Ac37e+ycYOzQZetEt0++/+A/Z/NjO6I/X/M/s/q9Vg98AvosXoQYaTH6vVYPfA56LF6YGTcY/X6rF6f1QNj+T6r12f1wEwfrJL7rB5YNvdZvQGrN2D1BqzegNUbsHoDVm/A6g1YPTCUHrB6Q1Zv2JGuXFJLu4IhXGynVjQjKxl6lUyxchXltcoXxrXGQCtsdSRXuWVLF5khiigDbl8InUrx3XlEKVtWeBNXhPJ/4xpB9jkvrrR7a75nZdeeRbnqJ3tZ7VRSKd9j+fWZ4yRjiUFH9pVQwPJxvYe32CN0GpozB8WlU+QyVoU1k7f8mTGfQE48oeNql4Kvi/MAZkaegHPHDEPk/Z4wW4BSWx4MQzUDxAfwu1AysRplCsWd5hvFwfQF+z6y4eGN4hA9kvuXxZ+BaJiXFPEc3wKkkJgUXSZeEXBaCO7Z6gF22cmcK8AtQLz25oSfXxw2lFsUBGw4Z1Rc4wZsnuXL43ZuAEHw+wvDUDQrtsNVg2nBhksd8HbhMLSSyWq4aj08lfHKhIyNF4ISr7dM3TL18Zl6HctW2fODZMZ+76TfE8LDNiYlUvWL7NQlnONuifUCkgsb4N7EKnnLHy1ab2V3U8IPWz2HTOIZyo4fBRupisWRzH5nQzz21uFxt54/CM+9k/Jk3MQsqIRnJk0OmTQ5ZNLkUKb5kV9lVy+JS484yBdsumWWdsxyE6U5veHIqkP5qOXhpL85PQoXeEWajFhXI8bSIyb5j9iUHDG8gCPzCHS2jFYj2SksNZACBCDLgVvM3CNbce3S9Wb1whN7EDIrLUuL7mbf2b6RFH3zhMsbsqEkj/jYNCg2stmQ6JMS0VNAZP3IDowfDK4Urg+aQZOTyeYzqGJBU5pFDLFj1iU4ko7ZTBqzmTRmM2nMZtKYzaSxTKsxDe1zB8fyS2yK888baF+IilNUfXOLQrNSyBfARKgpvHlk0yHIHENXWzMVvrz2fBAVE+uOjeyFxMZXaCYGcMfpqReG6iSFOoQdfN6XzZNKtzRs1wKP5gnrYtJpd6+P2b0qNj+l+yK2uEAQgAlDwIQtLhO2uEzYNjVhxJkw4nROT+EPXDWcyqReYTr0IHzrUXLWjUvNt+yMSrxvXhBZkHFrHjnFz8T7L6BOx5Z4laKQeOnPOOQKa5azX4zgktmYeC7wpyiSMmbFbmuFQdSm4nynPJU2RdHHDr1kz3MIcnzkMYWdUzqrp/wKIa1zCjdGp334M4A/cFFwOoI/Y/gDE78DE79To5vdQBgJrqd3FxAuJXk/DSGkRkFY+Rq5M0SPJ65tJqUdEN5myGvZmvlG6AvPTFe+eu3C5IBJ1IFJ1IFJxG+bOjCJOjCJOhPpcinYPfibnTYFAr/yl8C/gp+u77IVoSCvXHT+5qMpLRCisGaJEC8li0ThRU7kSvh7wwk1rqx1TYZPtgx++NY8Phmvm2bV+QX3Vp2ubPFJAMwDmwWz2tHUZ32jBbQdwuanDlvgNHwCHqOGQyz41AxNyAUtsQroygQW+PQGvrxIPtybnq6m6YMp6izOSvFFsEHZqLGLxNW4+Gsk8VDLiIKFDK5GO3A32oHL0Q7cjna6MmWFjdiyzY7on1Gi4l16VvogjiDCxzpitUBtmeNP8ZqD41OIqHPnp8F3HiLPA76fRlhsIwwE8XtDCg3LlzaFBqsE+zBICgP/IPoPT4Zb0B9n4/xUYyzRlW1YrBWOENekL/vjlGqrjWASl1E4sbCTGBnBmtyTrckwM8RBLzc/oDC/a+24NG/c9vFW6FUoDdgZgocZrJ12vW477di0g31MghxYmXurTNvA3oqJzLGWVJR9RQET6WEX2rut2wbdNWLeAToNdobwV0y8wa878UCS+h4Qz/ApCYlFHAl6QAoA26cOGD91wPqpA+ZPnb5sCUzDicJF8n3cKL8NiG+dH83FAtnp/UBav1TOSCZOhNm3NkoXEWg8r6XIvcq3s5u4UCVb44A6sigBs6ZGhASDuE6f2+GCHAk2cR0wiuuAVVwHzOI6YBfXGcjMtIEENPyKXlGiNUXIB/WBFV7+iET4IZv8Ay2D28TWxAyS4Nj8IU6HI17ESghWihfX4mxpBkL1wIU8c85xLvQTkF9iN+1Jdb40AY6DKUtWTBGGBWPOPfcMrvuvThewjeyAcWQHrCM7YB7ZAfvIzmAomR+w6Vzx9lINGJNknyl5OwuydzXFD+Zb+hVY3sDvc3aIFNU9O9bO58xTRCkT/CHGKd78tql8/CgPW7IvHBqKBiwgacKx8pSAhQLsYjsD2UHkXCQEjO+C04dcPr3dzESShuVqz7p+DmYUUo/HGSwhEpP30/qbtHPisoaZrMYluL2ZJ9U13gAZR5grgR+lBFOwBklNuXAglGB84713TAs9E8dOFvXcuy9CAt5cX7pWzt6x6yPL3IBqar4Za0RKsAvrDPurxEe2zuWFrbxclNbZSsjrbizkbdd1AzAe/HCM1DJPgm3YT8FErAM2Yp2hTJcn8iJNfzjnop0k2vcyK4oD+M0i7NiVimDcmZXtdtdeJcn+R3Wwa/d6asWxDCR0Arl4JFu2kwiKj+QOwi9wi9uC7eLUN70zz+Z5+PbGENv32gBeeEMzWOZDmDpVFI9kR1aIIb+/+BhJYw3Y9HK63pM40r30EhxMFDtgo9gBI8XOSOosKC7t/kqbEWcYFEzZUzBfPkROTtos2nhnQuq+Fob9jaYBC0KeTNgzXOQSkFUoAaMM6Uox4v6MsJiPQE4GI8EOWAl2wEywA3aCnXFPvo5Amw/IItTm62ZccuchUZgrE9q8at1b01vmSiHpCGa0+cyvjX1zwdM+5H9PMWQousFB4k8hvmbH3x1vl6VLVfMAO9g98mZTK68JrbqEAuODUWkHrEo7kK2lA3Z5HTDM64BlXkdqmgfK3lveZv5UegUJUS69kMY+Q3zPjqumNh3UXN7FVh8F3Vj8wNuIf1cVa6ATeWRQ7myfUBq39NR3YDAaNl/EkSl/X1h1rIWVBqwGO2A22AG7wQ4YDnbAcrADpoOdCXe+Be9bsB3snoL/LRhddU9l4j8XKx7EgBIfF1aLF+duWH9PEne5yMYMhSlicXDp+uFSaMgSxszryswgWw7y1PmTYC/OSsNmABit5FYCMwxN6/n8mYmYbEN5JPcm5QmCgR5sX+WNXHs4jC+4CuV3PqJmPn/OMhZHNz93lxUVP4ukelhlx9AdEfqBOPsoyap30untxClCyhAuUdUoXWBY2AXDwi4YFnbBsLALhoXdDvdJB64AK7Iu0LkrjV4h2k+NKwFPESNoHANVvH1ELoi9iJ13ssIrai6S45A4S5U0CaIaO/DGn4EI9YB+RJiiS9FLTIWkJZgtmY2t9Rx5L6VHviJuPLdPS3Nb0o9MW3p0fKyG/KNm6OlJ53SnGbpIlETVG5su2Cx2wWaxCzaLXbBZ5Gn9ujxmgtT2LNU5PaAF5JzjZPhK3jJdFJisRtguFJyXC745pYKvpkeui0X3lNiRFW6tYBuVJtaxh3woq4zRyWinGZJeNYIrUnWS8LgZPHAGj5zRlR0R0yZi5kmfM37KF6X7UVqYMyTe10Fx32Nqhv4osfdh4rzHalNZmYSGwOM82AmPdiI188oZE/1NuXwM2MiVTsP4EJQruxU9ZsZwINKSKLyeX/A0Ifauzjc/NZo6ryjp4NSha81Nahes0nhK226Px7gBXoXoNV0IX9MFI45ub7Sa4jHm0pNc7tVXEl5BRkzZu3OHIUD65gHC9tifGeyyt4x4NIypIXt/+Y4snst0RZ0E53C9yZZ15FnLtNq1x5Ve+dpBnB/zBr0i56cM3Fu0HW5P2+YEu/HqKIvn0AULp25vsqlpZ8BJ8RG2nZKdTNbXwRTuHmvle2C4xCMQ35r7w5gUpnaSHV1EgCgHnuuCpVgXImV1+125C1XsZ4BpIczIFY6zwIrHe97Jrlf7lTYqqp5VgzjsPT83M+dTWYxB2J1Xp2qfRzGDBR5srLpgY9UFG6su2Fh1+7I5nGS7ZYd/Jt7AQYgduNmWGFGBat+kAcr3On02hTvWU740nwxuBvYQdS8r7SUv03Zd8wWt/Jrt0WbkhGzEkNV7R9lfPvrqPNgdP4dHw+GOD9mEtMUo6mak1KSv8M3ebtmqrR7uuq2Cj0celKsGJ516nGTf7RsvpZaPhJs0xaIELSCigsVfd8ADMcIKBiERu2D81QXjry5ERexCWMQu2Od0pfY56xi2nOdRPOdrl99NrWeUcGFWeovj+GFB+Q0cDIWNQbH8L4zeqpXBB6lSeulFbqUQbhkCElEL5cfNBLUgN4odHdG3X/h+ATwe0D09xyUOMW0xCIgUB+JGlVfAWKoLUbS6Qx6wVGYYe1NphwcR+Z2nnS+/KpY+Bnf0T05lLiaDWvTeDJ+Day9+T85mTP6Pwl2VMrWDkzhO7neshzvUZxRF3quEhLCqQXCuLtj4dCE0VHdU79QrgLn0XtMzGfsNt8owXu+19M+GVBlIZeLarqrEkff8QTgenAzqcfz0BKe34OlJYBuCEdSc58CypTuSmUIwMDPHZgH2NorH8gluVXNHdMijyGbLMzadwAhCdnJbEauvC7Y/Xantz1kUPifMeJ41OYUWd0XY2jaP7sYYaxWEr7RwOY8cHqJMcoky4nGkgc3BIqcLFjldsMjpgkVOFyxyuhC6qzuW3e8JgwHYv3L65/AcsAVBE/g1Q9J1odbFDMrPk8TzYLVaKDjzloVnHIgvxO+kuniK6+4aQUQCwx7GLFPoFxGzKUiHdoepzh4R/So51fNa30Suc7hhZMvXpVyxC1Y53bHUHUZ8zr8rxwur7WBXht29swZysoQWmS1hHR14mHiZ8XTO4X9Fi7sifovWm4tpPka41P8M3irX8h1oLFNaPZtB9s3eDsrVVg9tr7vRpHyIapeFyWm9/Fj8dkekrWjsUPNse+Q5RKJtmMAeDLZqXbBV64KtWhds1bpgq9adjOR66aLVMNzGgOV+vOncmx62xE9AzQ1ZZA8cT3FJ7BOVvudGK/C0mypTqrv++IEe2lahlrz53V9C57HUKiEnMOxr+ag02sjV4x/rhYsJz3kiW0r+sWa3/8e+BIvdOlJDqEgtHFcIFr3TzpqVXNLKPtb0umabu7qXdyS+uNVhtbvB/pg1sK9NstTi8XBZiNbPNwTDEsbC67Ia9E57K9MaPAoHtj+Q4yP6AckNqu03DGkVfEGSqNOB1IF4arq+I5Js8Pa2zAmxgZ/wqh4OHpwvl6l2bebaHhhF98AougdG0T0wiu51eAIuyMAlTWkIpjGzvGHMPe9gCh0U4kXm49PCDWo5KkLuO2lIydz7SlTJ6rstQwOXL6g3hurjRi0PhynF3kElwrqJVRNLvAdW9D2pFf1Gsbr3xZYbd3Z0DoW1QoJGyHkHRuE9ad5EG1nERt/C+RjAitiox8L6HWwhliHaX66WzXo6eG6WMhaTCJISTI5rN9OL+KM976GFZg+2ddZhZkX07R64GfTAzaDX5TkXIeliVyZ8zMEt6JEUI03HkaFTX47Uma5Qkj1t4y84WBuaYK8jOtgtWuoIYjxz8SoLAEd9q0qgbl8q1PDlK42Lsa/ZK2v3YNNXipjUheNeeAhLEATrJBjW98CwvieNk1tuJafQTV+lW4SIif2H6dmO2LzLX+96C/8BozjU4aZ64S6lVloYj1tCLVhveqf1UTTTb4UzGExEe9+hM2v7OJgoIMVedqlexaP0lNirSYkg7M+5xLqvlaHa6nHXhQxXbMO1AUIjYhKKEfgODuvQxTMKS0/WYO5vZZkQxS4+Ddk/PJP2OTgXBnsUTTfu7uDCqWtSbNqzlRI+T8nMczLzpMxSp5Y2Y9AeMgbliRH/llADTu4QE7YHlv49sPTvQQzQXp9nzwZa9WWakVto8GJWON3GZdKTbfyucqotlucSWEDUPtM3Z5ixJM5nKykVUsRTnZ4Tz0Oxfw2Nwy/yg8YtO37EiSp2dBX6cFBl46yGMPwZZBwlLUZ+/q06RYDrQw9cH3rg+tCD8LI9yLvekxpfM1arE9qzpDP7P1CsjTH8EeM6WJRPsMEzZklka4PvjifyfRBMv3tg+t0D0+8emH73wPS7B6bfPTD97oHpd08av9I1MWeU4JlEjv3NB6PlqWf67DlM8kPGoirKCbisFEzir3hu5FzBBaYIuChLbZ1G5079j2jkJS3Gj2kdETuIYTXOdbO3+MEKgPlhq8Fkk6k1MwNsJddFRGCgJrx7byhbBT6bqUvOVokky9c/0naOfoEGdxjEE9E4xV0aj1rEdghHgh9gSDAy70kjctquO38kD6VmxJyIPCR7wYMx3pr+FTvMi9f7UwfubTSHjtybo4llSsO69cC+vye177dMH4c8HgHXgnq5570dC1Z3cejr9Ry6LjAfpikJrtMbyqT/F7T8vNzb4TNr7Yhs7Jj/Wt5Twg6goQwLMrVT/pP9pbYqN3pEnJyb1rPkVhFcLHrSMKr8A4jnxqVm/rSr0UpdU0c3S8nhJ/Lwjwh9lswXqe9JUn1vc6XQ4BHnCasskUNHsutlqLq/ULBJYweDHVqOPexiQamorXp6Ekos+J2r+ygV1CEgbA+cQnqQtr4HHg498HDogYdDDzwceuDh0AMPhx54OPTAw6EHkSR7YLPeg0iSPbCa7kEkyR5EkuxJrVZvzeWMSVEMMBFle2ohttpjkR43TqHHy1EYso0zthBDrxi9xV6KZZuxfM2ktTRWDIOcksBHaSSMHBpi2RekBMkbc86IcOY4SZMi9DRipy5ULg1QGPl5QEJkUpu8efmyOZfUofXCtwuUPmcRCdIacRH4jGfejZ8dYr1kEcyK2Nk81GBVdXE4ykguhH5NQn3UcjE+6Yy3XDBy709Y0+GCjfGHwyok2Tary8akNlOyRKe0p8uBQ+qrtl9180hMdForMdhdh0GeO/xD8Je23EzsLdfOvl6LuxrcBWtx1/+VcBfwCAXGHBRgBriYx3d7gLtv0txmPfAZ6YHPSE/qMwJIEZvFOyzm4JmeuK8jm/u67ksLsllPB9Nw1KESfj4giMJqi3gQXNsowSuIh+CJ0Jd6Isib4Xs3D8CeuBHPsRdXeCAk3B+yd+++ERRYhfo+BOXuS03lS5/m4uSLY+++9E6b9HOwQ3QdHoUnAvICxm1wPyNBpGzjyT7Y26pZavLoyyUTCInzyh4stqdMIa5KiF+xREnVlwZ8F8YHQHlwpXqEnIgiLP+ebSLremgO/iBtGmHY40MNHuJiCRoHwLEyJbG8BaHNBU0MuN/urO+St12n9Em7Ojrnpvi99m55YpV16B0BesfwR+aNnLTyNU65mDw/UlR4rqJph7CFu3d2KDVkvYG0h2LtW40ZTx8cPfrg6NGXOnrsbiezjz2/cVY6GyB6hYlEH7wi+p0+/IHlAwz7+xDtvQ8anz6YYffBDLsPZth9MMPuQ6zvPsT67oOJax9MXPtg4tqH2NF9MKTsSw0pv7H9yQcUIPsrO3i8ctVHYtIgNZpOk6E8mYlhf1bkRS6iwoE5K7RjRV5WAmqgIDRdv6Y4/Ff1RbWkVMklHioN593lV4ohgUAjObfpz9wTIV/1Mw4/2ka9oq2rx/2G9ustKQ5oRSPTx1WYGn5U2RnCfPfBoLQPYb77YBHZB4vIPlhE9iFXex/s8vrSSMZnDw9n//V0e3dx+XT59ezzzeUF19GKjGrXd7ENGcTvYX0XjNag4O+gUiQ1YoMXFQu2XGHOfC1790cY+tKPci+2dLUrxynSCPpDbfLSGEdM4KLYD4MTnyLsMc52qqYlfTAJ7YNJaB9MQvtgEtrv96U3QN8JvcWe2FWzp/skPXpiEcWGTxkKpkzW80Js/SU2vHuThkFqphT7KUJmynccXs/zyyKTpOJvdo2bt3qo9bZcex75h1kDDyS0jm8NwZhI6BklpB7Umevt6yCXNrYP0MFJmoIhPF13mZwBLwTsSojzfn8ozdnEa+8N+nx7h7xLT8HnZlQSusNmA3a3fWnIcYv4S3Hx97cZuIn9Fc+Y5BL7P8VFmA9JmK4wDbhTwh6F+N36PqRlGN/kIRBHFbNgwtwfwOIJJrN9MJntD2SLJ2Q0EptPKvIkGuGLfJzsNCQs9CdytwVwyEnvJu/jhL+7Lo3ZQFb0uyLxdjLqleM6XMDRmDrTaAbp50xPMvvBerkP1st9sF7ug/VyH6yX+1LrZTYFPRAdckn7kiIuTfjutdhJs1wcHNjMXQV55CsJp8mmkL7IxrijPfrhxnYoqaVqpJ4Q9ALNogVcOFXpKbUVTuvvaiRcbOCo1sHCcO7mWgK6TAvDau4KdPLp8cGNIyVKlPZDmdI+qb4r4IXvjw/9FT/MSmCXbSWi8q6Q574+PtyPyEEuCiVGw/2hTFZN6+8KfbGB4yNghiWagyHsVVKj6eSc8sydfq89G7M9NzKd/cZFWd/LB0r33RpMJY4vEnTBhj6c1Dv1J1EXzyMK+W3j0KzbnTC7ck99VOPHV9fTIS2Nxbpap22WGl9viZTKqpr7/Pi8NQ0jG0vkhxGI6xB0vg/Ws/2RbI0V37K/83nFjJK/iqfUN+pw7yJz81u7sivy+q6kU6zc8yGTI8Zx1nB4Ald5BndHlVzTSePUwz3Y3/yDnXewYgvHn2gcE3EMAmSL600JNmBVH41WLFN2alwhNuktcFS3PNU1eVQXiCToXAjq3BPTstimDIM9QfwoI0HdWJoc4ifCV+S/Pv4EkuHCxkENMmQ73YWovfPhJ/d5k9ARhc8QLVomJIFbQx/cGvpj6aHIFNH6YDmF6X8DrYg1dYtjQ6/iUbS21ePd6svRFzyTNwn2ZIeqKau66wxKv23g9CGR5GglTfJxwyvvioPc1w3CAmQBDdhrVDcVBr/AVPAjJ6jfX6SJO3TcXwQaareW8eiX2VqeHDzj1yYSLMikDQh0zNWuu4chKDfRNGy44mJTIrqCV2B/Ahuu1HEIrNqS7H0P3GNKXI6LdEM8qVBSHGRZ5XbYfnfrqEE7MsczRHKUZhHsQ/qLPqS/6EP6i/5EtjKDJU2ap+kBveLYfPQzd5y7h0DAHCVxxJEdD6U79HK8QINyNEOpD8kKEGtCMqknskXfpIs7+vhMd979qmf1UpNHXPwpATY5EcbWEoTIVv9zXnnn+4Xs6ybtgjEi5PKQNEGJdvJQjAKbHTelc0F6yOSVd79gS79uECICRF+xhR7JC/LqOGMg9XjSkTMK2JCyx0CaCEU39ijgoYZHBlKPLB15BHmvmBIPMm7Us0jvF2GRPDJqOKT/C3BIHg21DDLQm0Fc02PPgALD9PFJCKsFT+HLSiXYGP7HbwPwXBqcyiQM/nXwSHJ5duPAv8njI+HrkdDms/MDf5qK7nY9UUnbKcqvWwzsKIerEhVA6SdBPjvBDsCbadDp1CRPTm2hnESpy7W7P6UvLrRbaq7sYbvAXmMQaIgATVU8yt3A+EINsMKEsODa6TZt8+z+es9uoms6OvgyIPyOwZ1RmFJKsNar8d0WH+wv8FuxySNhosaZcCBN+HNpUmd5ZoEr+ZVjLn4qzVttW8ffKgRmuP+AiBQbexFIsDSARUqmm6h+nUQuiq0+t7QuXWsHtFWHB79AFigFY5u8lY0EobDlghveAFwoB115ZokwBgnZhfzNsUGLMPaQvIFY/OD1cUvsyEkj99ZUvCGW6dwLOBKHOIp+RJii2DEYau2ospMaiTQLqIMrBMUUAWcYQ9iy8cSP1SnS7ejqF5NhIcCQgfACzdiQLcm605Xt7MWP9peZt9rskVZk6xlZLz7BMlkHvKsH0uRKNPLO0w8FR/Bnkd5x+UgekGmDjQBMfRE3ZW+L8q59H2l9TsJ/R6EfhYZvyoRzcF4fgPP6oCvPY8d6Zf0hAe0dbypxQ4FYfvxOKBfbL3kGDIDX9JR7QW4na22Q827fozq44B9TSGzi/GAioQ1snBBJYFCTkik8z32fD3J1R9PcxShfB97b5jKYYi926tpSbultFLRsn4M6EmV8X+4BM6jL6nTvL/Yd/S3f5JHWaM9nuxcjUiQ5U/TkCaSJ/dUPpvybG0JeIn/3zNHypppyogDcWKYPAeYkyIENDOIODHoyTdzlK+wd4uMsqS0JwmeyiItzJfnau6pDfrLH41/k5yZkRF/RUoJz2MYguMMAgjsMIOnSADzsB+BhPwAP+wF42A8g6dKgDxsfZMYZgIfuADx0B1IPXTYF442Cu/kFU957Lg5CUsRxJu7sRc4zDt7cFDYTQghOK+cSi5lzlHzBpvz7UlL7mslsIoQHT012hZANppCJbwUfXrLUQsa1bMBJuqL4MYhmLg5L4wW3XyI8UHEAkamwB7E95nB/vzHzlq0Y9oG26qqoMhY/apnqn3T6a1QfxPXD+MFGyL9kvUi8dQfgUT0Aj+oBeFQPBj15xnYfWXiOrdRGxXKIhyql0NE5vEnTEQeMRl/gMLtdzoW1h+09D+lIR+UCleKgAhISyc5EcXSVvVnNZM0dTVmXwwVXhUkwMajT0/2MIrNGE/fh8cu2wgiG0OmX7FmyCQ6GUqZNPthjMuJCk01AS4hcuCOFYIdsLDy/kYyDZOfc7IP9KVqKTR7+htTyT27P7yUIAFFnMKnRrcRHLwjdY/m7ukAln1bVJ8fUWmdxv2WXAbIcHwNpmIrq11yvQPa75NR1cPCJlKHNpCHsp+wIb/hCmytHWkce7yck7OjhvSaJ+vYZ+kfW9BERZcWXkXL0SLW9JuhG/oX2jhxpw0dEzVOi+QIMGZaIpiJBktSmiX+URGDZ1bSp0sjxFQoZeuKI9cHJjHKTFvRugr7eSIxG4TJDgq2+zpcoEuy47BSJjXxM45NXCCtiWBFbC9xY512HrcGvga1YuxzkA/rIVyRQg0iDXmRLqzhVIdPbdoXqbr58y/s4opyQYjAJEiNH33g15va/zx1/f4vxkoUOkmNm8utiJrGJkCJGGgFkJ/Zab7h1KIbaCj08xJYcNZ1aM7fdo23V2bMlLR4cJUnIipO/ISyqJILHAKKkDCBKymDUr3H8g3iX7A1XQf4zQkLJFTf4M35+a9s9/m1Air8sB970hyPBIqj5IfzHAFIzDqTRLApNcK3gD+cC07wqGC6NbfY2SwfOfR25WijYnyJzHwM5pPoSzAtiShBqxCntgxMRn9KAzOQiCrKBA4PLZxICwS3NWLYcnvFWsuv664DvNmm0TFP+fledxcruJErSFb0fOqethARpUc0qO5atsqZtJxsFzLlpfHTcny51ZQeHzoArwZo4m/JIvl8Qj4or7PDqkAhLNCR1HUBS14E0msOt+YKyWcLZNp3BbvUdz5ZM3BkbPKANUvKkNRG3jEhe7exfvGpE5a5lRxvpmGsHeNTlCHYK23XnEtLBlgC5dweQe3cwlt78wi+I3sFX3VuTZ2y4ihxn+c+I8focQxoJQZ+L29urP/idDc+PUK2zI612G4Ikm4V8REcnTpyh1ghNukCSsOkDiHwwkEY+8MERPg5a/cg/52HiK6WgOv3mvXjkzdufdfaOfR91YwB885hx0IMHhxMZvmFJgzAIAwiDMICMjgPI6DiYAK9AIsIBJCIcnp7Cnw786cKfXk24ucukr39gcavwGp8YCy9T7BVK89hLKhSCq1W/FzGXK+9SiB/JNJrP8bu48881BSwRpz1L6VQtv/bmiEr6SGIxcJrKq6x6x7X7OXMJF0Rt7C3+DLLPN92CuxIvswoR1sFRnfFKk+0jafJRUkv3pLMpUyfNP5KkoQvZnjc87QOnDuDPsM6elM2is8WCogXDsLCrTfYXeS+x8Qzgmmct36sd6T4Gc8iTqZQ6kTRX7hC8UYeQR28I/pFD8I8cQra3IXDwEPKRDcGmagg+SUPIRzYEZ5ohONMMwZlmCPnIhpCPbAj5yIZgMT+EfGRDMOkegkn3EPKRDcGKeAhWxMMefAGpkYaQGmkIJopDMFEcQmqkIVjPDcF6btgby2fHFIHZVEKCtED4it+a3vLMsx9QGFGvUie+zKypc+1ZTmSjasnqpuNKq9uWNCGmUpLTC+K5Vluo1LlzcR70dF7mu4IJm32Ye/OFksj/vMx//7qQNTGNXFnxLfakxeZ77TjSF1y2r31bZKs8YPy7HAJiGM7oIqhCdm8uwcRb1k7pg7ScHbBkxVPLdExafHkFudhYO3nQwbIiKQ/KL4p1q4PjHz6geVCiUw5c9vbMccibkLyTOrClePb0BfvbJK3tdTdY7lruarmr5a4yd33U9t096W0qXuVUaeVNHEzMh2BiPuzXuIUUfZPyfpyPwZek4VQOhizCTAiln0EDtcPBtVdxoZD3J12AikNdP56jS1YcHmwFMEelzjpDsPkf9mVn00fyFw5weB0iF6CNm0pa2lWHvEGrR43+XTO/Q9AdSbAHsqE0b13JJRk+jxmb/9yXmmWDbhqAPXEcPZdH7RiCi8kQXEyG4GIy7MOKAXb2Q7CzH4Kd/RAylw2lht0XyFs6OMiSSHHVtOgqt6jChVCsd/ocpy8oDiv1YYAjbqxFTE70cHA6W5iQozLpLnE7jxcMRo8LTJPCuCNYs68IzbRfIhKRWETA9XLH/KNFkKtzQjEMHDLlqHR+uvwCw5jLsxwNIUHbEBK0DSFB2xBsg4dS22C+H4jbkDiNUbJJ5AtLuh+uZ8q/LyvKyg3Oc1oX8W7XXHu1Xddoc7cFbZvhHzIl34Y7pew+aziEdWkI69IQ1qUhrEtD2ASkFnMYRFgR/jeR7HJFTMJLM5rzq2wueeZL499wP7NjUj7ZDfp+x3TI3Hv12iNxIynfpIcyVR6vHy9TEI+Ai+17u8Wtb/2oV7gZuuJbJaHVlaAMVjqp0V4M1OU7fMitK/IticPKrrJhsW2pd4S0q6NLOAKnpm3fs8O+KwteP5Ta+eW+eCQiBIO4Lt6jNUF9Bw2ZioJzhf1tHPyAixNVHEpNAus+3y8v13XQEBy+mYErwRfsU2AkNwQjueEI9ilp1quIAX/JBldKcly18hAynMVWM5Ahh/2zAN4lllfZBEu/hteJPLmbmFIlyOFGe3SpJPbaAysxwSfgHSY9RI1qN7n4k/3yQ77Ro/NAGB9vBIr4YeefEZKk7RyCheNwBBK8NE/V5+L3OVG81HJaJLz1t9J0lza9mj5r8L5+CEfXORWpce3Z6L1KCMiPNZRa2H1OvyqjnxfuKltUm63BcNbL0cWKFJPJDwkeYXWXpsviFmg/HA63dCKDAe2uSjxJ26smbNJVczAqNvXZpRe5kptnsFUcjuHcD0ZwQzCCG0rz7ogWuG2ZaOsGB2GK5riM38azH4/kmxebVPwADv4G+xivsOMBXt57nQSzzWCOvvGlhHJNftMhIxLoCcH4bTgBOQfMsoaTOk6IDR4yYxV+fVe6YStfuck+Ahxts9wPJKxTbLcmNObPju3oJHycCr3iCb/wq9IPrOeG0iRC/IPCbSFdBD9zsBQNrjChybd/9EUqRZwgugRzsCiBteEQrA2H0mwonOe52iG+tEritySLU3FG5YquEt0PiqfTT1jn1qxFex7X0W10U4pxwIT+orpijaSJWtzcJ/vzri03enQZPUVRXdyeEZjKjsBUdnTagz99+FNztXaLwmdi/zm9INZnYi+TNTErFZcZpp+cU+JLfrrgsyitggLL9EVg4H2dTj9udM1Z0RcOmZkOWKRIyCg1nEw/2HNMeWnDzZnssCNLUDSSJvSM3N3TecbfHjVOw2pUCDus2GSqZuqMgeWZWDcCW88R2HqOwNZzBLaeI7D1HIGt5whsPUdg6znqjOtPkLwj2CfuIc1e/hiZvuE5A/kOw8YjqZoUp/UEEJKa2QtuCQ3LrziXp6bQQWFLE1ZGxa9yDUEgWIEofiuTvs3U7pn5GV8zNt86OvKDsQRbNZiRI6L2NF1AdgWrDULeR7EK45WtmQUE0ip/dGSCXiK7crLs7IgobabBqwk/H1UxBBbfI7D4HoHF9wgsvkdg8T0Ci+8RWHyPpEG8eXOpgBnP3ErRlB24HDFlkmkHTdiFwxqveeY4aTXONO+Epr8L1UEMgFCYZ+ENMoONtbTjyl1+frRZD7Vs+VHAyeD5oGkzPhlvO23i07dk4sDWAy4AI3ABGIELwEgavVl0EbdzgeYY7oSEHqXwSsS1W1HhLnxmYvDaFsRCWKzmC3tSCKbPY8XuS3RtKmzNEXwhOIfkZnIEjiIjcBQZgaPICBxFRuAoMoIwyyOwgR2BDewIwiyPwORyBGGWR2A+OIIwyyOwgRuBDdwIbOBGYAM3Ahu4EdjAjcAGbiSNNSt2vDMv2WgBhWkZbLSZTe3T0z0WoXyBP+M4vNdBtkk+PV1iIBwPbMF/TUOKxTvxfEOIsBzL1Xy6RVSk3vmHiDZ8FmafsVUg/eQBWYTy9eYrYVtxHELxKavMFxUwruULydNj5MOtdaqmLD8nNtTVBUrAy42kN5aLupW0hi1m124jFUR/lO6sc9LdWkTI28VWOXYArAemfSMw7RuBad8ITPtGA2A9MPMagZnXSBqKkHtd2kGiuyquYLPYDfKRTbhABAouVuBYgRevqLYO18k/mG/FUvSOrChElfKkNr9sKb7KIopWvirZDp/D5L8gVk4pUXm9q8mqvKHijPolkNoIg9eiurLKG2DVOAKrxtEQGARi343AImw0BAYZAoOMgEHAvmQE9iUjsC8ZgX3JCKIJjSCa0GgkE7SFIRyEzoUfkC91Eec3yRTDSalQmMVI/UoyDyTxAk4stS9jc05+OK2tdIHAmQZ51jIO0pZckn4B9xvwwgLa5y5PF/nyxJXHiRgq/6apKzWvlF7JJ5AVqpVEHspoGKBz03GSYPtw/XVH78WLG/yC4pj6gTCjnucb20Y93ylfR9XTQ4qDVfr845Ot2eT5qMPz4KSztRz7PbBJNdPcCCxjRhBuaiQNN8UV06kqxrTtG+y9PBIoTJxOkE+RxSkC0oe3a0KrfFdSq8YNez66MUwmjYhzTRXnUiOYjKvi7/ZrvVVpuTmKneSHBFEySSypvqvaq/B9g/VdmbspeI1KkNOr22zTj3ZFkaSVBiOqcHaR4KkvjcKT+2ZXNFUbaTCW2A5nsi0Q9uIzB5sBkk2pgdTdrvzhrviqaanBSEsi9JzXRGQfjWVXn6WvdkWXrJkG4yozXDZm4kZBNsPgTAHB5UZgyzWayGQOEmtaYilM/ITz1X1WQLh0ajp7M1LZutPmWKCkeadFHAIBVBX1kxpn/PxX+0zUWGm3OVOVB3xLXwcn51zHm+q+AnAIkCCwWx+DudjAfj161nTRXLQKrUgarfEzJW8BojXI7dUit76ZPaN4TUfNRfRqzPZrMftxqFQHd+JeqgZ1g1rUZZ/tGXOlhhuOuBq8DVfj7aPQpgDWSmtMDf5ASgJD35HU0Fe6WiVebWJEmRlNptkKSrEy8hq+fUQn/IBhNUeZUxEZeLGUfGMIAzs+XZGxIf02d38pXHb3FiVms56aY/hexi93TKlBb70cln6159Wl2G6DBVkApQZrPZiUffgzWDEz4+/r7rUyVt7Oqre36Xzdpf+DrRKmbfqsmuEGwQ9HRJnlKSYk2B4CokfwZwx/pMs48V4RDS8ofo1zVYiQun6ppPSIg3zBjiHUy02UiLHhyKpDOdipuEoKNmgPcSCMgF8HVKkCNsZjMIcdg43xGGyMxx15ljj/OiAOv1u4Qa9MsqDEjS8ZBARw8Tzlmdbg1Xnad1YpjhVX8+IsCp/ZLMbi/iJ34TjHNAjB+mNfJl5NgeVgJl3SqfGaZJ6qzIkBTAJgVzAvH0Mo4TGEEh6DYem425HPjnPiRG566VhBcVx4RuMo2f4DeeMI4UGRLthK9xiHMMhKsif+bkPyjzYg/2EG+0H0HZ2M1tKX/6qSFgyCx2AQPAaD4DEYBI+7sqPJLXzPXezNmdh7eEnOqiQzjeFvzsQQ5KVX7BMivPV5SnU4mvyU2eZhx3coFXOVcSHWHI3AaIZPTk5aMfzr4hsJqYF3u+Pa9KgZJkpN7e5fur7Z40W1lGHyLLGUstjaLXKiSPAIKx/YQ4/BHnoMMZrHYOk6BkvXcU8mOebWe+QtGCanvslzKjySuxA5yROfbtUh8IAtmB0VQ+v5Mv1cNGYnP3FQNrx4JpFjXy88QkX93VbL/NhlY5NYrK2BcE+gHGwtTVoOcvskxK+2YT83JSH6x2DoPAZD5zEYOo97NQqKpIFH8o1igDOi+JHkWubYMkNzZgbcV+iRMMSExCJOfA3Df7NPhNQh/A32dt3zsSM8mBRcJB/EMhJynJh+N8S0ZUwOdunjutjM+QZYg1lYpeo7FxY907PQPmPb7tz/ARfXMtLvIe/7A1pgtuouJfiWKSwq3+16TSxv6HgXxUX0SMOUjaXRp79wx16wp98LXlY11xTsfKmNoj4GR5ExOIqM+ytsDMQ5HPzFH3yrUHbtsdXKQkEpwPkOhnm7dnW8fKhFJAds++VTQIJk2MfA/Wbcn0hdbeIv+Uadf+BhRLg5+K5YzdquLoOrujoSEqnIgPuZVZctceC4NAbHpTE4Lo2ljksMEPF5ktmg0CZHsTlHD+VC11zO0Dnxl4/k0fX3JgHsbzRH2u0dsljIdndwcxmDm8sY3FzG4OYyHshORqwB7r5p0iR2M+HCaqLd494Qe1NDbd7bAc+bkhleE4FnDE5CY3ASGg878vzt8PVXdpYWIkuQhFwvtMvnVUix/4BAA/OKeGaJfSnRf3oQR1pc+CR4QNC3VG8LgbfH4KIyBheVsTTwduSDafP/xTyIfXxrkzWbZGPNFUEaDwhNbwv8sPm3uS/22tVlf6M50urCc9hYL8i+F+8lRKlJl1f4bJ8GZdWGjyS1+XJhAvylxuAvNQZ/qbE0dPFDFITpzo6D0mMqysf7Pjz/1DVP1r4kKvx2vR9pHsYL1/2LZFkAZ7TxqFu/Gt/Rb54NhgYJWyVt7e3AulFHRzqZBrnTcixBSvQ54Mc3Bj++MfjxjcGPbwwxc8fgGTSWxsy9IYv04oD9jgOqJLdBcEIQV0w2W9f5+md6sY7kkVzECpVsXcyX2JT4+Wdw1DS3FLTLOj75aGsSXnzo4I+k1XvGi2eH/T/MflWnAUTnHY+BoSC+7FjqXJJ+DlC6iRthWgohX/PPj9PC49721j0M40iLWUYJblsuoQLwodQL45G8IC89DjqEXhE6XXqh+c5Vz/tazzbo5kirmdC8G1a8kLGNgcuu+F9cer327qc3fLOSIHUo3SHkn+9NYFnZwZEElzIO+Zkr2yBkbgNj8NgYg8fGeCzbCyLPAb9M5PopNybJ8sQKKXS2mdtuajzC19t/ZiPYCv1rj0IfMa5jnY5KVHMhRogYvoReEB55LPX1uM19lxn15Ap3vQutNiwxQyj305BlhMdQhqK/6gxEIMr0eFKj0Cp8myiNvpTL93g9snmHTUOwPBvlGGJCjyeDVegVeSIzuVqU7h+rK/ppCDIZuPElmASRILmD5fgYLMfHE3YGnYAl8gSi7E4gyu7kVDaLb9I2s4CPUHaBzYVHghBbiRIp651LVGxEDoKa+UMjPP9tUo+nmq8WnQWP4MoYKwIhugvJjMngCMoLdw2JtyEoEuXkQSE7WHC81ZMpyfRYmUoTMBOeSM2E4/0SpftH0siue0exwSplCu03Z0kT5j8SzA0BcyP4M4Y/wISdU+n9XdyGRAJJ36UlaY+ViwqRaDPI7PH4Nzvnl9hiWDWx9bce5ZHU/RKiQsrTKknBXnjS6cppCJ/kqfQTmX6LzUmxe/gEv6txxvX2f9REd590evL8d7GQcoFCE4P5DQf4FgXBPvXFm/TTkFOY4IiabX0CMbAnYKQ8ASPlCRgpT8BIeQJGypOubG25yjWYbYT5brJdTtRN97kLYnGzwdgkCra0pCj/WnwFlzXl9nm6tR01dfJx7zqk6pzYCAMlMI6ks2PMnvfr+f/Ze/fuxm1kX/SreM2+Z92ZrFFsUaQec/+4y+1H2ond3WO5k9nn5KzetAjLjClSISnbmrvPd7+oH/hWQS/TohI7a8YtgkABLBQKhUI98qTLnLfJgCJZDsjaeUDWzgOydh6QtfOAwh8P2PDHii8jQOTnR7mOXUeUszsHKrPzJyEckS6lqFoFB5AHd6oyaBXEgTKQO9eTH1co25JANIOujJFlneUB1fUN+0EdSVJNtdPCUFGdXOg3QyycLQDfuL4QVHrwDTFhFoXV87VkDXoLrYExWEMnUARR52Xo8k72Cakim++b4ENGB4vo7HBbGd+4NkQuAb9PKJzKc2TOsHRnD7LYH5DF/oAs9gdksT9gLfY5cErALxVlDpeUjCx0JaZsryTOyzPCLI2U4+e3MXkQZLmlCnUIdu/m2x9JmFEx13eaj6px8A2dVFiSuHOfS5/DkAPt/R1u74/Jb4jknCIEYsyPGVKq4GtTtm3bd0MnHt02UZBEPsx1quNBp7/MDLLcus7NQQu/IaaWkGzUSkdqewyy9KEubuzxWDjDeRSLSb23dMvgN4osNzqZhaE818i5hJuD5wlHmbR7i/a3A5PbPJfCqA2Fq3tpFJG5+TS5Apwh8jcnzen8YZjGdS5VHfhGcZZEvguieBwycSIHlM5iwPpwkHtbsW3q8lYsOxWPtW0nm/TX0BaSoBSO8r8MyTb3tyjJYY9dL9RuHyYXmmA1oNrIc82umiVVuckxmCPlByVYGZg9Fofx/U0g6cPFgd8LJJqiWJlA0K75JRR33CtVXJeJwstH0ZBBgsI8fVkYfxKPguOmnORTaFGfnrcCs2m+mQamSa8FGdQMdEeycsv6lrEGdsPyzYX/aTq5dO/EaD7yxMcgeFjElcWLNYtNa5RmNMAbxZYT2k8fgmcGQXTmtww2SMnzJfkAC3+szJ4SGLVtvUs7aHSvpTmkoMm2HB7Dm6yOhqiyNrVSUxlqo2SkLjx4X8gB+Y0NyG9sQH5jA4vbOD/mAPILlOwRP05dO3H1mhYet/Rf+KjvgLELLleudt+QzW9KkoWwDwzu+xpZOg8VUR9JVqE2SpKj+0ngfPFm0b8YrLAagaxBfUqAMshG8ZGE45JC3qMrns6FHc/YI1j3iE9SxjSuT1uuB98ozuIgMSxdwvQps9uA/AgHXY79L4JA0p+0lI7nSoI6dZXZ7MyL3amXWrTeJBWz1vVFVX2dke3ByeHYe7LnHGWb2qODalLz2aEAtNnDgztiJGDW15Wq1nc8SIE1fh7I0vkxaOguiTy1ZYAQbYazPZDTos9PfpoWkcEGJ5uVG9VGHgzYRnGjvBopRiyf72fQ7et3xpwXbp9ASrsvLgJv9roFhkwTjsNyclVavTaslAA2igk/eFpEAqWzHJAH8YD1IPZVDEzSeEaxPZnC+TMJpeA7IjzdwOZ55R6/dmeNbttuBKPgH6MLREi7czk5q8cfrhda1nie4WE3SnEz3/19xmxjPZN1oaPKtSGkAK5hzXwYifRen0EFaRp6Xd0NR9EgAAUlk4DsbV3KrE37bFS/RdaLbvxxdnsRRTPxNWQu08mDf0Ae/IOexkqtDEGlL5e/CxExnygw5X8GM1IUIDCi5ELHn8QT6m0b9qrUCW+puTCw1QNplC9O7OlPgjvJsBlVk9q1LfcivKbNO/CDwQPtshRWYNAnwzRych/0afn39Xli5Gn24u5TEJ89u5FyHHkK3VgUcgPcBFMVzjxArrkLPzkAUwJhuY0Kh3mBrFlZQSgmwaM4m0zjuSxZe0q66xmVNPUFr0QE3cPuWmthfisFc1rD7IVOv8cuiWKjGlfGAthGF0hqV54ktVAXcm58T7aHUTALR8wuSY73A0qVOCC/7gHr16112EpEo2J/VPzzynGohKYFU3h91W01+9pBrzs6rSRY/dw1v6HR64EklD5Fd1+kAXJAHwyIc7Kp3CJvBgtV+eY8B1PMwpCXbrtrM4CZqJX5QKpdNro/R0LljqFAjwx2OQVbsUlt/GgBaLMXL7bnffY5nkOO5IMBx6iPo7k/OvdVWCTV/LM/nI0o9uu2Xo8pTGYbZbtoVPKWwpYyEMdJgBF1Bn1e5Cu2qlP0W4DbKE1NbMZEgQIRtI+OeFn4Wd1fTORxK/XFkoUf5nVaKSzrolFqogg1C/iSqOI2eapbG+FkwBqlFkq5zH2+ocsJXdfnZ8Aa/fxv32Ip5EffvpGtt/s9PXDY6PDhDSUlk76ixnBVJZB7g5nSrZAGReZbQtHIc+l+6J7ZfSQqLPBaXWTWMKDd4qNsnQaVuLwgS1OU1BhOZ3VHDfFdQh7FK+BQ1wPq+qyC9sEPnvw0lKOsQDA2ckSpSj1lAFUFbqm7htFFegrKiT4K3WmsM1WXiMMuz4Y6UQRBAlzuXMdBrZkC1+ywWdRmDouJiJuEp2AQTGFI5F8DfzXRyDTQ8hNZIW6YKkgCgtd1kfXSMTR0TkwmQxOCQ+LbBNbBXCkKh/wLbkFxOORfkD6lC5R/MUsGZoliMci/aGugrYG2BtoaaGugLev6fCru7JkXXwbBw2x6PfPEue16sxCYLL3LE4WWWqiMbipuj/qyFDMF3UAxFqKKU5lofjJ0qAQq8T1bqCDZXuZHq14j8ZBTmHnZi5NnmBy6/tjLFKHld6duKLL0dOVX1OBzWKqwMKD0E/O70wqOkgtVFn+0T3muZB2Prhz+MDM0KEVg0r5OYCbhRdYVOqohLl5/1nX66ncieBUieC0xsXfY7q1kavyFjGQ4YFMdsKlOR2sNQh9lh0kEu3rjsy7toMFtwEkpSxNlQeKLO264/p3IqXKz3NirTRx0wBs8gkS5sdMzdyjrYMPrYMPrYMPrYMPrYMNj3ZWJYQyLYAv7lFd9t1nhVImDqjznkRnnyO8CkpUdbnkZqP8ILiNOE9/U0PUg0Ywc1ujhqx/NpjQE4dAI5die5wz9sO7YWgA1ugIs66Gh9ZbrQwpCKq8LMcHSTd7E/avvPqe7OLXPd/z6wnus6qSh41aOwpIPlAaJyxVKQ9+eRvdB/AqKpRLoxqltYS/UoIu7QaO6r7Uf6mA3jjB9hF0N5rrvhMbhLYvFqkFb722hzZG4KOZn5lDC6S2dNKjVmT+bpI5A9Ls2zCzvYXcICl2Jl5at8tu3kmt/ibBJMOJu2EwIoRY0NhYnaFC7YwUN94X547mdnTup9Modh7BfOX6yQ1GpU9dZqb7R7OxgpZ2RW9fnclLLeYDkYkFnZkFnZnH7SpIyT+XyLR70R8F0PpxPbgMvgnpBWfbA6s6ewsggfRjS7y3NlvjuGTly89HszABJOzchDhHc3OAYx3qEBw9JFs/aRMgyxJ3Ji1qsxHRtwCEF51nWRxlUciIBzSh84HnyefRZ5TcY2J29dQL1LTvalbPbBkgWbOqm9lEXPJrNuHoKWAmTK9g8MuVbYlcDqWp1qKm2M6Sm2JyOc1RyBNsFh+2Cw3bBYbtQ0nSxurtQ0rDOc4nYob4zzxxkTyslKSqygqHck0RcbFEpcaOFghtvM01jVYFeBMjx5S0/ZfOx7yw2dGX+1Sdqrmm7kHx6WFU9KIF7oIoeqKIHquiBKnqgih6oogdW10PbPtr20baPtn207aNtH21Zu/6CVuUTsg6TbgXhdhHzU3jOTXASeLOJnxb6pCP23H+Lb3YY2vNykRQyRagifeSFTuI2l5dkPnWa4vjfiy8WSyqVJoEvKsN5nnjKL58ySCp5BJT2YR6rqHRZ1Q9ukv93eqw030oVTj5+N0nneUnBmNbdwBS1mhhHj3tGM/8+FetOxWsdcPqH7f7yRT7lbib6WKx9LNY+FusAi3WAxTrg7OqGsXPiuUkqhRuKzWuDFPLCL2PkwoMpNx4LtVCgYi2OCweUStGGx6GqRn3XQ9yVdLSoMZ/g+CYwweooxxmCDMBuB2C3rPF60nQo4tk0u8pNCgtXKknJti4BW/SyK8wuHkeLmB0W0yJfXnAYxtY3wGoaYDUNWCm/kB6ShJ0y3DJiKi+Rc0LyTHChPEH3NgfSFwyCc1FYGNPOjqXFOWLnpc3akKcfskUAEBYHO1VcFb9Zc85sU/o++Zfj3tfTUaKQiKZy+OB+XyOwM3noe9HZZ13QzZ0li7i7dX0Ocx3W58D1a/TAcOuzIqS73TDwPLnLr0szxRVNKYs4JJggHwt/u/jL6XGKkK5EfB+ojO7VDvQMBRmTamNr9QxnfxlcIV7sBc16NBWjOLUn4maxrwsau9i83sCxGviNsMhEXzR1fS7Gm8SSPoXAUDWqOXFAEWqDGPHcKM50/9wewtpll1vV6Fy0ALZB1LiJgQx85DnMtNl4NYVGNUaqqUJtEC86LWEbFubtdgd/sXfA7rkNu+c27J7b7f4mbuifknvBc4koJzdbvf0yi+4vxvIwLtKw1GTAee7Zed7T5PRACd6i8yAcieobKZ5QLqzHT4Ff8BSq1joVj/o6p7enYTCtdrGl9vHPh4RdCXiLes1FoiW7ADu2b+0ozXw2tO8ER8SaoDdM6zqTeejAN7jO1T6V8WMGV3BcaMNxoQ3HhTYcF9pwXGgbnIbhpAw0E8AqnVHRLxTzJCsZwv0mq//EvFxsdBmMHu7SeH+LzdLX2+qXdB+zdOTLRqgTFkp40X36km9rRA+VxTN7VrcdHAFp3A1VA9jzJ+tCohpB2mwvqnPZre6oSWmVjihX8+h3j0MdtlM2I2feTllS2uFp8OSrgrqu2lf10chZvnA0yk2YOUkFvlPtDthXp607HxVgIMhZMhwqVlYZWZpDNhHgtmHONN1oDlmVQWpH0ojCNKVj4TCT0DHYaKuUyUoMZZOiF2s9sVZZ0A0ucExWvn2wSMKGyjqOVFtn018oqy/74vq9Nbj0yeqzVdJVJ3ahHGatP7uKr7iLDIf/vOSQgKMZvGzaupSTaJsHxcrhlTg/Cmp0Bt6w1wbZm+22IimuszoC+Cy1WZ8l2z0eiyS7El0N070kuZBMA1fdTToilsz7WFWrbR1v0W2DC1pNe+CPAwa5Jg4e8Ftps34reWsY2fjQRWbPGRGhoC7S3bTPBgmXC24tMYnDmwnNDetl8MbjW2u2cUTX5NAJ3mpqlfBol22meKLjyOvt4et22PQ2vizjlETo4G3s3m52hzJkj4HwRGhb4ISwg2+zOcryqxjlPJ87fZY6qBSgKgxkEiPF+VQ4stqZTwYzzrY3dJrBcN7LLxtbg/dzo1kkUXASeLyqHG4KbQtM1uKYbCQ/1B//EAoBnY96vBZO/vDBm9XHZjfortGDpNxbtbmFJSbBa2Fd32at60sAivtxsSyc+aCrrKxW0WCr3hvEOb7uipQJ0bHv3GgsTWBs3+7yMYYlABUxZhHUtjYmCVDOSpvvo8HdbARXCjGMnWDGKUG7nB7kpNhoayulBSD7Ya+U3CP6kRxcqndVsc459EADAq+DNrwO2vA6aMProM16HSADQzHq8x2Eb9XhiU15NX25h0CWROcwAVkIOsUNMA3WcnsZjDKN/DQUcezezV8aAaIyBE2uiU0/7GWf0eDVgQpRnwfKYaljwDr0VhrW6M/LQW76juAkGD2EgT26ZxAEh412r63bDbO2xQ0pL6z1vmCNvprUNdiriI1N91RpVl/Mb3uvCO0utStgEQMeDR+gdo/1vX2eilCe4f3Y9koWCmlG0GLZmR1682Owwrx8y9uUejreD/PzVNsQTKbxeRBmJ3Y2Or2cCGyTvZ5Gq1tsncRRVJtC6c22ApqmB17Vu9Bhg1xAqR3OHm1vRpYvctf0goil+T6bSZFaf/XVXROdRIexmEY1plTUw2/6ImtJMhKJrcHqW9Z6rU93k6RjOXbyOCXY/xi8sIme/kQRqHlshFNdBKV2v80iZOrZJO8mqYlrRAsDuGHk5EZ3WhxxcsjIkwLVF2wOFz5d+28QF3m1zbIOeMO4+vbtXnhyh6ff00KWHg5pkFH6ptb+tBI179x9psPzZgGoDNaoM4XMB/Jb7KiR7Y9H6ijwHVcFab0R/AEdjttt1nHbQdTsW3Flx6H7DGXigzut7VCxBPw+oXCF/odNbPan1v/keCIrZs87jH73IhE+kmeGhuOxdm62L0nz32L4z8shWl849WZdWgK/YbzdKZ4REebcWLScdsL+vh9p+R/viLqtiJE13TeSylAjSNPl+uOWc9t6SizkWxO6eHdutfIY3N7bA626pHCpX69upAq4YQaWE5gQTutO7vwtRWAtRWCqPKG+36KE+pSp32+LWDX+7Le1W2IujloimpSwx9Bk5x17LPZot49ajpiGYiRBOa0EuCTIwC8itVCHo07zHb8vwy+HVOsdqRpm2ZKDCe2WHY5X8s3uOxI1fHMVz+z92TGXhbwtuvJxmOjrA72gzbYC4AKM/ZAEM7yc3g41tMFJwqr2trgotN4zLBS1SVVMGGxYlLzFCykjhbCvGJl6wZxDSnsZUqjRi/GSAdm7JUO+vBxODHbJUO3tl0zWeu+wQK7VHBY6LBao9vZYyFrv5zIZxnY8izhkmEsCiKHRC5dJAcgeEojncTixNATieS8hEM/bZz7q3t1xqKDbZ4MNGFRomFw5X8OsxrmRIrGIv9ihrCpH9dHd2u+l1Ad76byiy0bULwUCSxzXOMT2WRp7mbdkBcB+UpqUNAPvUXA4GSyVcanVy6XcDMp+YkdPMe0lUt4LyYaBsne8+kz5/XKIYYODpw22X0pFAPuBDjJ1Sm1bfqbfF585fJADiYEAPgYC+BhtbkP7WAQD1gl70hL0PKZHscATtn8p7uKAwkzLsi0dSLgB6GxlNh7PzpxGVOoaFcSeUls8czOCXRShk4y2xj9XeTpHaeasM5j7DoOJ+CC7Dl0RweQ3iz+izIEpXo9wSjW2NrFb1iG791ZGvHxEOzO1K86HSvYcHXrByJYoiWKblffaf0ovNA4REkSsxwMCARkIBGQY2ruebAlSbJo08ynW4GyaFdWW+WajHl9N3KsSWfS7R1uToLqt38nRpyXR6o7v4xIjYG/BDURXMhBdyWCjKyXRguSXFYxZSJX6wY5E1/waqky75EUAJ6ML1XVtSH9J/ztb52tOwSL2u7wJYzSxix8T1WnGyMLemQSxClPT9Njk/luUHjjsYQ9D6nID4XcMhN8xkE/YQD5hA8FOjI7GRCulJze6scdj4fxsk0uiSqchPGWTdmWHDyLLsREmuf4S/xbKwXzvek4xE2ph0NXnJHhOpVS5nK45xf1FczCNIdi+fNQr0Vb/sP8S2sIdEVm+T0UYu+SbwTNIpA42ENTEQFATA6mDDYThMEwQHKJGGIgaYZggOEQ8MBDxwDDRFk77hom2yPhmwM/agJ+1YbHml7YUXOZJzohYbj7RSV6CX5ja4/BWJS3x5Kd9lp8jwYRJ4dO9CMU55dAoVo3klHjiF3qXlITCg7n8OYAUG5949ixKq1GGPTXdSYHc05O8tKpjyvaWDGfmId5U2mVKeclzEDoi/DBPnkazMMrGjJkrDuGfhQIaQfFZDSCj6+zVlrlJmP3nfRJeNAk7zEqyav1H9/ZUqL/MQkeyPwNe9Aa86A0kmjPgAW5Y3ElJzoJioTkLdCMVUFdxVkxxhhdMAfWecWQ8bcT+q/6dNASO9dc0op25aq6aO5XrJvlHx6st8NUup5uqT2JdaXvXrHC6qA7eELULWO1ih2JdyuOg9KEKxKsgdb2edobTOxGP7lvqVKuUg/eTwPnizaJ/cRjssOnj0xY15osvgdyZUL+ADbhwcYgAd4XLvQGXewMu90ZXo4e6DoL4xB7dCymfppJp+ZHcfcnjIaEL0rohaG16Mlfe1fR0cZf4qa+JbWuNiHKvNr5Xmjrr0Fo1dU4y4P/pcpf2yNhn9FgOS5AQ9y2aIfdGAVJ9vHVVJ81xgHQkDNaQ29BAbkMDfs0G/JoN5DY04FRrILehgdyGBnIbGshtaCC3oYHchgb8jQzW3whKznlKbT8Gt0XkpKRJejpEWv9ggz5v0UhWjm4CBYD0p1H+CiHY5TuRAhYprCSoePKkGsOTQRb8kKwCpXmdF/JvjctvUm1tCn2hvlN6AfnEVqvlJgAglTBvfitOgun8JrhR6fymG3HV6lUAi0r9N/GDZzyLmpkMDcpfjNnX2lzMw7a5aql5AeONYvQtfhMh/NYY3zsF19zuKnzO8K4PNoKsiwayLhqsew4RAAXnO/MfM6E/IxoUhimN4FqFCm6Cryrui+15SYo3lEfD9U09q6tsYRw8sl80rJ3duy1MkRzjR5s1+Boc8VRK1esk0wxec3Sa3IqAnXCYaGtcjtM2tboal4A2hxOyDAqD5zlC4XJIwUaPrJoGsmoaAwgJrNm+OgV9DKLYT7g9jpqfAnTxPwMfZbPQvfCTsmT94Detvq/XF8WijeICrxSQX3F4zcnHRYdcHHPkLzk+TXwfY6CJlVJvYJ8SwJ0RN13ehjMEwqGhkFNFTKl8FKF7wa3t6TQ1rAdBftV3EyKx40c4PNecJY2Hv19IW8QXnQg6R0f428ZfTh/zA9rf3LvI26TSCl+UO0zWU1KzhAcVE13zBuEauHdb7v/rDJUl9HpHvjMRYYQE0S3JwdTdQCsUY3ncD+eY+PRhceo7rIX4DymY66ThtpZlPKDmLMyUfnLq2X5LBSQKQpWPVs0c/uWyLXZY2/Fw5l/4xzhlDad2fSY0HNy9QVEkR8QhyALb6OJvD3/5TD9JTlL6sJ9cH2dM+o0d+CTAEqX85IUjcPY6jasOQ62b4GOYJaffJuvqup0uSaxa/Ah+YDtjACspmyKUaxSnnSPw/zb4fxv8v83xf188XTjZkoZ2wo3kKCmq1w1WThaIU20DFIBlxYttp0/bMxORf2HYGwxtbyZwpDQ6Aced2hwTT3ajk7TdtjychbO/LFwZ0bJYMkHZYFTtrh5jylg3TLnAcBRMEwMXiiflRuLSfdjW7G9pH9xNa7XLnRmdrcKz63AoBudva0McY2ElqZjomb79wqkvXcSKPnamvl+FvGCqyV7cYQ10fTrqphtOUQdch7ShBd74klYn/OjwPmzR7spgy+DUXbD69TcWEFbnNGbg7g2OfHmwCbnEIx2jrVuN1PG4xhPwAtC9wU7Emnh2WMtvxTTIErFWvGQQ9wYpzkyXJ7djdLRB6pNG9SKnBLVxBHnB2B0d2tMphxkIEawt+/F0qkIxjjeyuao6ghIYLu7i+NXtptbfxxIMOfY0ZkUtA+dAWFB3YEHdgQV1BxbUHVhQd2BB3el0tKq6YwWecHpuk+Q5VyYN8X0YPA2TUHd5fvE0+F1WoKAkGQYo8XAcupQjZiyeVfZhe1qAS4+FHulRShJ+ZG8Ul7RqP512oFMXFnps8MN2ZkO9nJ5CocIftzx34nKROzuspf110uySWm0Ue7161NFA2r/Djoo9eXgvbHlwZRGFUw7syjuwK+90tEJ56auRWu2jgpuJ0Cl75t7RvsaVa6GSQvZU3Nkzb31rKXOtXaTpD2lcV5CQRRqZdJEqwIThVdCBV0HH5CQgFTuUEPAx8IP8SfGdchldl9NCkViaysnYXh3H9anjmmsMYV/mYuI68qD/ZIci1dHHwhMTwWvj4d7RgXtHB+4dHTahpco/dyaH70epwhK0eoIubtIeFKEuf/s5vKFt54PtXAv5LRGsuuXbH0T8YxT4L53XhaFq1u4rj7xxckgySBGdcvPeYzOL4+oOtI3rav/BD578GtOL6+HvgwxO/2954lF4HMa029llML6kRvWeUEpQ9wI7I+U/x+EGbN7SmAKpiyX5PeNEIJTbWKmsLm3cun3tw2nm8E4JzAw2rbb2hEJXR4G3Id7WNCRYhL0va3LMyhasj+GLMFNsvX8iOIhG49TSgbdXB95eHXh7deDt1YG3V8daxrvOAbMYCCApSs5vtLWVCs5De0xGDTCpFeFYpAUQC24kEvLqW7qBLe1zsQeefa76sMrYd+oftmySI9d/4KYYTBZpRDvwYep0odBgvXGSxTyUoOhTVZoDeWZPCyiw4LTwfBLIL4/cOGuhnDbTGtuZ0L3GKHa1LhdN55ZNmdyoOfPHDhyEOl2L51RnjwlFZ/f7EFsd4RzHcejezuLt079m4JdYE2h625ftUYrcHErB1+Bn1elC0wcnng7rxOOI29k48/9VCQRUQlBKd4DIOpuob6zV6VbW729nhLtgqvVblIQLyIo0do0dNimm7ThD355G90FMNuyp/rA+eWRpBzvbhzm0wTFqMrnjUAVmDHeoDtyhOmyaR/JjiWQfApmXr2xo8M9nnjf/50wuyjtXOKmry+nV1Xlu9ne3WGfLE/J2Q2DsofkRNWeCmExQCvwmSMGcaqYMrASeap2exmUTabSPx+NQjKUIoXI0ptjhO0pzRNrY2urLjV7bYHZm0aGbIJ1VGPwEO/AT7MBPsAM/wQ78BDt9LCqk0urAOagD56AOnIM6fbRFbprOAG3hetCB60EHrgcduB50Bmg7QNsB2sIa2YQ1sglrZPPIwN8O/pr4a+FvF397+NvH3wFPNyomQcFrTRWcKJtt258f+861kOKQv1Dn69RZUufCH3kzRyyWLAedVFoOmwGhiIwYRVKHgbBQ5/PELX56RrGFsh/CYDb9UHTrO34ccxWHswlXfOX6bLH9zBWXFw6sJrVvy8uqOHxlbZl/ZvINx+E4WvyyL/acHBI5OJUGWfkPgu12OLI9Oyy/RPgVCaf46YEjvLQ8qr4o110cHBpei7uIvq9QXvhc+fbY84IntW+kdSRnkULk8MGdouq63G4dH5D3NfS+ht7qGnqtTbp92FlX0C2cDqpbtQnTbROm2yZruq08YNQ1yo9RZgxdMHjX1MivYILJ1PVE+GHmes4W1xFVQ9jtR6S7QVo2wMaFLAzfHUVEyBfyEMpNIuSbNmficBP87EZufBGLiQoXAGAprG2VEmtA3ZV+Z1EboV8GMR2DOPxBJmQtu+HimVMTAUgjqNDPGm88VnXTOP5CFRe+OE4Ol5Cp25CpWZNkBoyKUOc7JRRkoWq+qIGdTJzajmAvHUPjTCEpENppQJhiE2GKTQOHIETUNWGFaBogeNjambC1M2FrZ8LWzoStnQlbOxO2diailZodtO1w2hAlJ5wKifUwc+c8Ff7cc6M4Mz+7JQabozvZUZ3h7961nDh3IiiWVkr3yj5GAnbSWSh+sjJISwIWJaoPN/rFjiYq4sJwNqUpUqFIHm3PJUGNDtLHY4qVGKdjS8O/JJuEHLmcdBQ+SpZ2N08+DGFIMztCJFJPSCLd+ol2VGVSdVUwQbFKkk8sbFOjvFR5SSdCpe/+PiuBX1cftxCEb61ZYQa3uGLe7NRtNEmvpdPsHra7W4sLrEbYhIWfCQs/E5FjTdh4mbDxMs026x4hUaQCOKaScKFISsQKmVJ2xl0IJPViafKb9K5b3idyrhX1jmlnF4dLdWqHWG5knCSpl4iSmUDWAK/arjZVPgu4cRV+AVka0c7saLGkFjWFocWhsGZUcdD3BF+hGtsFRsPhDPu8ye3zyWedPVNTcNQiLHUY3vZQUYbNOrezXTUuGCus2o6UHYU9ufUEh1OwW9Zar9DwJvhxmO0yhfLazhnr9rUnOFUrm+5iL+jqkC67NY5HJmvWp2tf71rXdbAny52C7PIoYz1GKZpfdrNYn6/oIth92j1+ECpob6oKImlU8u0Zu5ZZ+0iA0cCol9yWdbInOI0lb45wwX4TEJ+OOCxyImahSW1Iq8LcKxypc5UKg80hSSvkJW3qJa0i0MbRFCcHTIUjHDdB+hyaoJ+A1aQJq0kTVpOmxe23H8rgCgfySkc3eaFyRkhPGJV6J79xrc+iybbmdpoRaiat7gE3as+0OPEXfI4i08KhFcaUZlfLkdG6gBc8F78fBRvMVWethbRZt42rEzOMpz8YfMNU1WTD7RMNyUYgW3Y5yZdbXzUwsJcthLSrxiXYMhWf3p75swm3D3bBu2BgaiICvQnLSBOWkSYsI83ugM/e6atg4wnwS1d5MhU7zJ5/JkXahSOHSlZeYfnlhf+oeS3kj5vgq59ow2AO+VXOjaqw5pz2FtOGMiPXSde7+pBXopjeYW9TipnYU53U1IN6DoHbTVgqmrBUNHumZl0mFmMngX/njjP7h4qJQtVmgWtEiNrkeG8xC7kMl70Ge/nYGt+/boZK0X0IWwpuErHMe13W3n+WadiVKUY4jl6iVVEAl1ghFuE3zjQz1Klp53AHtoh8BCbsDM2+dvOH5i3R7KuEavOMU5TpqlB0niqLRUJULzDR1bC0msfVuKFuNmv3MDHm+BbMQE2YgZowAzVhBmrqguNfifg+cH4cngajD4GTBmAulKYRKdIjS2InFI6Bp6yKiEb2VJAbUp35VV5pdPvDuVTAXzJd4+aSNZTIWhS4ey0xpDnAjR9OM0zR1sPhiDt5QurZ0qUxa9ucQ+NKXCiTzcS6Ukc84Nyw8jZh5W3CytuElbcJK28TVt4mrLxNWHmbsPI22ejcH5Tchz6JLeZZ2m8rb6hMnSPk0JiqaXFWT30PUzN/Af9DYufVcAUlDq6sFsutCoA+hynOsux4eJtfs+RGq2Ag6yvH2pxqgcWWBjM8IrTH3hKyF7C6R8h7rVUjl83G64ZkMGapDLhTXyqvYV6295DmwOwxZ8GpYBFFFnw9LPh6WPD1sODrYcHXw4KvhwVfD+uIY8gAmwlWCQkvFA3lccNTtJPSH4FwSkcV1Dz2vKwaVs9zEGa/S9VJOKAwQMfxpbCjeNsoYeXR5j1o1+drfRz3PTsLDraSfHRXYBZ8fyxEsbZgCm3BFNpqg5ZgV2sh+q8FG1GrDVqCjaMFG0erjbYwt7NgbmfB3M6CuZ0FczsL5nYWzO0smNtZMLezYG5nwdzOgrmdBXM7C+Z2FsztLMTjsmCtY8Fax4K1jgVrHcs8YqMwEV889lN2jFjBaRmx49xG+tu3L+4IHto0ecEMr/71+RrUVEjW+u3bmXyvHBjVLwodp96p58sgUAZgCzXRmx2P7r/6jriTNA7i+3ZFXvv06ycBAfo4/mBH7kj9zKFLgsogX4tREKL1p0Cyd1vFT09Jjmrk7U6SIpBslrHsB0pA9ChJPtkJqM3NbEq34ZlqqPp8RdnGqoWEtjOETqVI4vjYZ+VU4lOELzlOIb8rykZwLe4WV9Snmeed0GrOStSswIGAK/xxfS/EzkKYrHei2Gui0LDsbWnkte4UOoedzqbsd7nJuIWAchbS1FuIY2bBAslCHDMLljMW0tRbSFNvIUqRhTT1FtLUWxba4hbQwi2ghVtAC7eAFnsLqAadKCWhkIlOiRDdzPBzsYISU8vVpsp76CZQLxdafiZqXwa6/CopPLnN6+VicV41Sj2FfSdKVUhlQLe0uCRNFyJ2liuAImyEVNLWgZb82n4ql6oYD2KhPK2Ne5jyq3DmkypELs6FVkXiyAi9apkvRfiNo3P1eAW0Qu3qXrl0bXtJMm+CSqoE8FpHk95hu7cpe8NMM3wNN9QWbqgthPuxcIdqIdyPhXs/C/d+Fu79LNz7Wbj3s3DvZyEiioU7Hwt3PlaPu39VFqa0K9GPU7mrk6tktjeUSpWSMkHppyB3HFUv6FyofZnYlkMHoK10KsgHUvij+c/Kdj8lxB/Ia5JcZGnmy8l38/LUA9ObScz+EpJDZZhVWjBpKFWrLDKV/uLE9rxbW0kzdL/2OSzmxSCT8NltJJT3TxHYRn4X1asu/XywOFh2S9D8tO339LwWH7AO2xsrzX+LnIDJo2DhhtZCLBmLjSWD+4BM6WU7zqXrP9wEVJi51ExDMbLzmN3bOs8WumKtg9fsuXGLlVy2VJsph/bu0nvBpGG9BnQLkPdHhZb+4DCFLQd3qlZvoDf7Tx2mUlCszLQFUW4CfldKyi1IMQ86QLEDGDyzN9XlVtvqcxkoe6zOLZ1+OURxtsGlRtviaRHIHqMpcaSkzf3Yc+1IsETFSYSLLbdFmAbSHmNN+YOybjgWTA8smB5YfX4rxqVXGDxFIlQPN8PabEP10PeHi/2QOuvqokRb7P1/pdkL876WwOwxreWm/K1bdZPGLlHsr7j5tvrc/ppIw0owpg3vS16gMr7ZXm1EuHZn+0OTCs1Z+J6RJgeeNdBELi82qzO5+QLcnVFmkkGpNZ2OVaxE8uZnUQK1AawrrAGbMinwH0UYn4au/CcLCjCxp5USNyoW1EWM2/e+M+qsoloNOWLdEC2YrlgwXbFgumLBdMVCgEILAQq7uLTu4tK6i0vrLi6tu7i07uLSuotL6y4CFHZxSdnFJWUXl5RdXFJ22XhNbhR4OK1BV3YTkD08whgAz6meAL7vN8FJ4M0m2cH+qx+loRc+2aTxI+/l7FI4Tfb47TYIvHKJHYb2vFyUZBUsFzqJFiQvIbE/iu3JVFMc/3vxxWJJpdIk8EVlOM8TDDkOYGuXRqb6Mv4wj9X9dVaVSuzj9IMStDHV3PW3uEFlj9PjmcvjuvV0vs8YO2OvxaIHh+3BCs4h/11kGV1YGXRhZdCFlUEXVgbddk8bju1LEMXjUESF7GzlF3mKt8V3xRxuuZ7+n4lavqy6H8aSADbxM7TYYG21jZfLRbP28HdmXislA4qGHlOWhzQQOpv7ogsbki4bJ0u2yeKN1+X+X4W5M3v/BYxQTK3kmUELzGm6MKfpwpymC3OaLsxpujCn6cKcpgtzmi7Mabowp+nCnKYLc5ouzGm6MKfpwpymC3OaLsxpujCn6cKcpgtzmi6C33TZ4Dc/iPhzcpt36fqz50Q9GhRSxLlRHAYqzBDCi+UFeP95Kvzh8PJnJTtkxZfubblUZW2MRLmUHL4lUavaw6kYuXek0o/vo9xWc6Stk9w9lIeQXz9SaNFSbxQSSYG58C+DUX4bkL9I2n2Qcx7Ob+yQrgWC8GQWhnK9pXObZD9Pnige0Wlu7VGggYskun6l6EpMAspouVZfKSEino8bjewwz4QJbxfcLCpniswgf3SvAj4mqkc3kh8XRV77ee01ZyycYBcJZZ3J000Pe/DYGdktJ6l3uuHp5rX4qmSsKzmrx2ad6bLhorwNcsKsPA9nwHZ2CF74dop11lLKgkeXHrRKrC4MjbowNOrC0KgLQ6MuDI26bDSZBBj9gzQrikTu8oS5SZqcVHcFSSYYiSgqlHxK5FEsjeuZMhNLqp09u/GG+rPuYqYeZox1D6ySP6KQqnhn8dOWzf1vy2ceWz3Mx7owH+vCfKwL87GuZb7P/B975tOUM8M0PVL4/W8LRAD7wC7sA7vIrdaFtU4X1jpdWOt0Ya3ThbVOF9Y6XVjrdGGt04W1ThfWOl1Y63RhrdOFtU6XTbiTnUWTA066jWbll8G4XHAzmSZBaOWkTrAtLbaCBerzYvkPbvxxdks3+pX6kVKrytPR6EGerkZCSQ+T4FGkm2L17EwbKEULQ+y/4qsrd0z6+pv0/F9ueHr7NSyrHq5nhdCjpdKTwBGpzFB6eRySL/9ITuYXKaOUNRQ3iXphGgop1ojh6F5MbLnHp0RQ9E345yzYIBFX1X6QiWn1Pp17Mp07twZM8m5NJJLD+eEoSxVxyEdb7fb0ofVfFCJsEUbTl2VlzHzLIk5eoeBGgx5wV1hIdREcocsa75TAJAaj9DPZqxTZ2w4VqcMTihwRi1H8JYgi99YTCsClsB9q8+l/hWHt2KWfnbSEqpfOG3Y/GA51WcOhEnmSx8lISNbjBsUo2JVuXpYWQt+VLl1upecdX3qymFemZMsQvyTmxcaIXNOybSdo2oirpGHF1dC+RrL+teBj2nYRf6LL2spowSSH/Y/xxLsRExI5RY0JHzbsdMehWXRs/NjzckqIOER3eMZdblgbbfKQ94E68zFJkY9DFHfQLDXa2hZwAcheCgXlJUDD1RmodjVRYvj2NRp4LOlgHzDo2LF9a0eCwxhOpzA86sLwqMsaHkUink0L9JIAhHwSBpo3T1L4/hSUFKIFFG0U/WWlbPWqA2xUyorza03dqYE1Z3oDp4Zb8vnVIqX9RpHijlsRzsNazLzRQ+ZoMVOjFkWdt4kiOF1qkWK+MaQIQxxO5DncTRZUizaMVtoPdMrkqsahihNEJrZbX0aBDFgdqMFlQOB5ItwMOYl88UTf4rGGK7Bt7A44E6Un26Vb1l+SxtfCVhHyojiYpiqRuo5R6/bVzOmpgMpQxFzk8i4b0gyV6zsiZdCaW20JFhLLrGEsptzZkQ14VWxTG04WgDaOmkkwemglBoOLqOnBZrh3xMk+1LJgWFd4PC9cz9Wx2tbrqfm1NvM5DBrAYAd/Tfy18LerY+nKpEZ+l/gcumM5DA/2hInjhB/TBYoy/kh/DeVmMr2XDbY1lywDYHaGDcf0qqcca9V8hCpfWMv1W/G9aE1cx/FEsr2yQf17bJS2P9/+qvxuWonfSzKSVvS758YiFdzkODW5+3pwCOgdcdySXJFO7oXyqCc0hPGnABd09W26q/pojgHweJ3MI0ptsBKt8K3otdvvaK2gFYHpiTxbOEe0RknyoXS/annuLaFYof8wEsLh0AsGDGv3Hqzde21rCetVp7rzme+rWBpTd/Rwbfty4MMsJoSqc/YohxvVpnJ60QBe7frIrGuSlrHfdvdNsN+EP8j/h/NpILtejpS3sSelcFsx+U5HS07BvXb/bWDEf2w92mErkmeF0I3nySstnQx451MkWbwJwNov/O3vdVhDcB54c6eZWe7b1rpVfu4t+KYqL1V/Nkm2ZQaBBqfuHtlefalZM2D7iiBfPCXSC4ef9hvAj3i2J9MVpwTDeBP853bmO2gESyE5tgKhaFHDKbijYJLYKJ7USS0M2OboJtHk3gUUhCE9Si3FlPkmiCjBix/EEjeSoFpRJCUfivsbBv5yBFlvlJT4U+Q0cUdd4yAJ18Se0Xs/SOrOKMsJ722IlxINI5UeSLZUZzbXj9zxfRwtRw+5GfTg5tqDm2sPbq69Dsf6HTEKHJFGpMvc6EHh8JlOQsRSjNdK6Z03i+7pyVWe9I/y1908Lagrm9KrDnDHCZW0PGQyi2eSr81bguKBR+6jaKlIO+twEzgu9zrWOzfZFse0muzRSO56ZM7Fobj7BtXOKxDmqMBvHLZ679iqYktMpvGcw1X/HVf6pbjkwrMzeEfcAuK02GLzwPwJRaaJxE6u2YZjQoq735ZLTWxQjz8fhgprizbuFTgx3uAay6IMQhsZteIosNO4bgn46FAKkTOR98fhDvdYJmvEP4drIslLykcxB7RtFt9VIHdlWLexVJZj25divkT2c2uUprvmxV3TetNEOQn8IBTToOXPPE8tYXs6XYqw7ptGWEZXIposRVPvzW6RyzeBtyGh+hLwb1Grqg49bHe+5UsuGIrwUYQUrinw6U6/NZpF8luVK0krFCqp6KkbilF8mHUmz8SP7kiSqIr6N3UVDf62iGuobixOWHOCinbj3ibtf23H+GXwm9sstLNylM9KtHRO/OA6mZXF+SDG6dnzYEZz8VydDIuTCK+DIL5Ek9rIvwKyOb326yP7XtgOi2pO0Pwoasy+kQH7M6OX+jr8X67zv8FpWERDKkUKvJ61zGmSrEaTlEAqGkGVPXyRPdQW5XnzXptxw186jf11pzHdJi58BxuFlE6WLJeYmcXuW14u9eM52QM4TPfe94DXwnqFW3HYhx0zQm71ukfv3KpGbtX9FrlkR7PZrrNcYOq+C0wvRa5OQOq+ZQFpe3SuFogQt6+HuH297rtAVCeLMZdOmx+cbMdkuu9M5sXo1bKZ3htmMy9B6BqMBrIMQoD2eu+yTK0nr8FSFZ0vnn7IMketJZ1W9HSLOlHkWu6xQRvf9XSlqeltrj194dRgQ++Z71OzamrMTU90OrX28g2bzWj8Jo/QtSJct4X33rRuqFYUr97UEd+0h/imvd7gfVOvcVPvFKUxblfXymMrb9n6MI1mcwi/bxHFORisv3kvu5pYPSGwT2cjg75PSHFClilhly2IjTZsNvDoW9ywa8S2brdmA5e+ld26Rvyu3qoR8LSHgKe9fv99q67z/G1tf8jbZreADmXwbiSzcl66297ZbbplDN5vfl4H5bp9Y/CmDWZqRvLqzWMApRJyd/cG77dEdW4exjLrp81Vt8vMZgZvWTXyCnjWm80gp32PjV36JQxU0qjNtwdjIXxwMOXytuxml3jBxvwKc7HamGZAYlMfcUL7R238NfCXDXmd8ZL1eUw6sZuwuIV04Bl83eTuDc9bw8l7R/O/6k6kj3Cm/SPrXWJeMTHfons7FI4Wj13gsYe/ffzFokJgyD4fGDJJ+YWUPfGUkt7RIyWaKOS4olrVc1Na/inwda/OfAfh6bZNCVocBePYzw+9jrHuLBfo2jNvrVA3j7ZUNvcR1bLfftdtrpTq28tv8csKoZfrEfqIMdpvv3PFlTNjrK+oe6Emod9+N+96LaRrdAn99ls2+qofzSu1Cf02RIc2RAfj3RSsTm1Cb5M95CV3ln0DRyjj3QQsnRI3imayvN012/1W5AVPiZMxEjy3Ctmpljgb99nwlFdz9b1b5zsstt+jFEMpxgb9brdFMiZRauTGouUIOf4QmFuOLpMPKXx6W3uqwzLMPUCa/E8ibYS0TH5EI20FwWQ5uiysWU7EGAYTcUIY+CWUTFzlL6Ggk+cJGrbVUS3A5WNblrppfA0bkq+1W8iAJY9ErWkYPLoUNVXVj5bj+G0F/0KyyDTahFy4gYh8ubMI4bQebc91WrPQO/wW8QmN+mwkS7klSeFCOIihty3PWwSyJ4wvHYbtHYpIBWhCpsu7IJyIkNtoObs6QnB0Q+3SHaY28tKAbh5bxOccSVdP9yIUkqYo8ylDU50jXR7X+qLxZtAax0qS0gkjInXWcCb3T12e4D7CofYRDrXPhkPl4GArYMpPQ1eKl4V8V3KTTGIU4336XcfhOKpNSH/VATYjzy/OpuucB+GXZNfhphGaGzbiaakpgsDK04A79n8S8+KLukTxDbprZldftVTO/EcOwVB0d6Do7uC02sFp1YSi28QqMrGKEOasb2JCTIhXJtqaaMvGDioPAAkqkConmEo5XUxVVkaBWL9C7qEz5G4du6MTFQx5kdqHOFcslhdTPvNvTtvJsjhtX7ljJXAPR6E7jdME0iywqRymHcrWS3q4/Xp9kQK//Rp6xd/nYTA59+zHIFT52pAFTc7Ez3boUnKVtRn1huziHdcaXL/WNtY5bHdesjqv7Dh0OSnbHKxcWKptvXs+B3xfRAA54dnwLvy7gMGaBfZlgX1ZYF+Ih9NHPJy+BfZlgX1ZYF+IP9FH/Il+F227aNtF2y6rqwBikpTGigzz5TfzvE+yZrVcrsRHVzydCzuehSJaaIaUFV/s+L76Ri1G7o3a5rk3Kr39QidQ9wk5C9FQfoA/5ruqll6JeKFMyhaaYjl76Zs4Lf5oRzcU9H/4u6fSUiqHnA2ykrbNqrqnOAWsKuN9Rrafkdda7uZh29xswf8+Fa2nIHxgRUREdOh3saTZkAFKZ3oltz/SZmdK1GFsh3Hh8X4WO8GTX5v8vkW3+yKVp2ogTpHBBg6QpFM8gaTS8KV9K+rLDLOyk33ZnxxxJz9Xu6MjPkAf8QH6Pew1cDLvs07mVyIcC0fByi9qFEegBDm3tkrHcFros2BuQiwgSlIynyOXZXFw29pu1TsoLhNIZYzNGHYtziyi8DJT2uMFhAeR0Oqx7xxn4bilqKqQYXtb33OsCXr/NIFF4ReHlOM7CY0/m/bA2Vmv8sj23dj9t7iUuPs0m9xKXpVubddiKjfz2s796/W0L0f+kljh2T6HVYi98Gfuw5+53wMrgq9svw9W1OdYUQaUNOnyYxbEGPkqKTt7ntqkwSy9+8WN71Omrc5p0arq12ISxOKfU3UUvA9mnjN8cKcFYYpeQLe8OLAzlTlBTiSdDCWJrUsTverNTvXDl4uafww8vBLF9g57m1HsiBIKXblRJAXfL0vkDtZnmG1cXw5MLfR9YaPJpRQmnhWO+2ChrO+pohalJK6QUKEwHWVt/HSLbveFuaryJ9uNzwMW2dzpI6leG1EW4e0LGapyR3j2nENLj81GJyvXhpQc2n6hhCaLw0hfQyi1Usle4SMU6ob1KnDEIZm/zJboPOH322f9fk+KTZWCu1iwpe3GyQKQyk6w8H5feFIFr77jqvewBmBQO4B8N4BaE76Offg69gfQnwwgGw7YUMiFjnCIs+UZECLGSaXXoW9PpYwSJ5kBZQ0SYZbV5N59UHsa92pbOW7fPmFXp7ONZTJusarTPdn3soIG6wHINK1PONPA3meGdy3uRCgbubZ3jOp0qOSQSfxvcLSE/7GQCuyQf/8y7qiHyc6Mvvp+8k4S9i/uzvjsjYOjtu74kbSp99RRBNo4RRfx1KJs4FYrkjho2aNC4loOZ5wWYRQKOxb/uojFpMaTWhXo3uNMWRUeflOW0t/o3bfkHYdJ1oJpsWl9d8Aa2I3jlbI/y+O4nuY4O+mbUIhtVa1Z2/3TpU5EfB840eFsSqmYD31JcI+SwuTXuCM9gjhdwFdAQG7nrbdoBsj+oay0LF2/FZHJCZnzju+TpanafJu04qDlc/jr6pnal0A2JUnROJGP44Cyjw//eXl6WzejW97RHwHL3yaaw9/gaOXpY0v6XIDxhyfP1lXgj4PTDxwW+5uRaQJpF4Ra7OqPg/E2YbzNYXqgx/RXyRHx+cdfwuDO9UTd+OU7+INhlWOz7aM1sGqAvF4NpwXwfwSMVkTK9rc4+Maitq0XJttxjf4VVZh/VCRyq75tLEVi+xWQ2P6jInGipcQlx5rJK1DiZG8oUX6uPMXAqcxzR/EhXYDFhE1YmLQeo9ZEotfTSvGIaDFgI1rITuypG9ue+29ohAgtYUyz5f0k5rXd463RTeN6Hi8YjwnNKnm2Fpdd4JITOy+DcdGNhr6zWrSlTm1NyHuSzb14ACdcwphfj9A+EMpHyY+PPS+zbyDzUxwYF2xiT91o6tlzmOzWRbJbd9440jN/8egwuP2NAlJ8ozrkKMHg3yBLngHCFgwMA387vHaePD8IyHGiOk6fPxSeL91ooU5atvZ5wVxDnV/PYF5prsxDc/O58uTIls8U2Lhh6WenFuwba2K/MeyuvxJmvvsspsHovjWJWo4UO2J3IrScyNAra2oOm7AAdD+8iGH2lRgkn6UFHKJ6IEQwbgO3Tx0wEbjRDuBGO+h08Bck27HwFzsnnAcHcB4cwHlwAOfBAZwHB3AeHMB5cGByylk1/mxwRfvhyqvPYH30AsIR26T8Jm8Rimjm8b1UXuVtNCP72bVPxZ0t22jHWK7Cj3ZZHS0UxIt0R+sAq1blYKrBr1Pzd4pAs05FN36ms7PrVysvmYUyBHY+ylVku2vUilYOad0F3l+5wt/p9J1OX5dOX2vP6B+2+5vvGur7mM3C5OQVdeYnlOaYrGtz1cHepz0WhMchC3uk+X66XFO5VDEaiVqRiJM1sraGkw9G8DY0nJvij1Nu8j7nb0G5OfaCW9v7PHFjTWTogXWklWGJQVHT+g4Vi2Abx5ADH8yWrbzPotSWahKMHtJCDms4C1ic0pxaFiLXFB4TF8HaTrnr9dQ4D9RgeKqNkjOwOprggEV/2WjTkDhrhQrU99A4pabxA4/kf0vsDRASYmBZa9g8L5g0Rttu0GtC3r8NOo0b2G53usWAjLSYSNXuubehHc61GhkE3Rgg6MbA4rbpqyD1HRZT+i1p6nmeKGg/S1oLJYFtLGF2qv6zbCcshfN9Nu6pnxK3YVm9ZcQ9eLvGNCmKTKPXXoIihHsZdNvv638juuv0+suQarxdustlyB+HWX4XnTjJhhZ6Q+JkckWr3S8Q3WXQtd6Pz1tanU/cZ+GsNNXvdt9N9bVIq5qz0MslxvpshBymbe3WLVXY+4XZScuXUqI/Dpzb1p3teiQtPkle1LLj1sSermvY2n03bK0f9+sabHUHb8Rg6859Rjy4wzTeN4OM3tGfOP55hgDhzybRIY2EQ0H7LaDAsWN7SidELRqMt4CGaGR7dkj2IFo8dN4CHm6lzKrFgPkWMICtRIsC60+MgnvhTUkni4A13MdDvYXgWgME1xoguNYAwbUGCK416MMipg+LGMTnGbDxeUqq1eFsSp8qnGIEchX49DwI5TGcnpEl6ASpeIQKPkAmjqnubBaXrrh9KRdcS4S7E4GqeTCeJzuafHB9iS4/qVAI1BMGT1ECvBDNlJpQNLeb4IMdia6Zlp1JIJpOQrKzjKNrgbRMa9PGUeWoVhuWeOXf/iPttSSjo8P20fI1kAubLWRC+1H+kadjZlWwgZGS6tsqgorNG9cB6VASzvyW7sjd770BPumLJ4WJ9AeHCPBJxPwZDLQyNeKGTqbyUCPS2zq6w3s438CrrrOQFbcMUIPCcj+vpuTRqP4pBVOo2AGFd7wMxpfiUXgMIhHbZ4DYPoNBh9eYoW2i0EJ4VkSlSfaI7P2W+NTDZ7lrqbtd36gU0TqheLYfOOudASvPqer1rdMCvF1zriIayMz7MuAD/AwQIGowYDl5cIvLtKz5tnpXHlDjatbKCizqgTlEQfgbgKlRIB/j6OgIf9v4yx0VixCvZvHM9rx5ErXzURQCJ58liaHOHmXFVLbDQ9FOtDJERKsNshjvKc9ToeaPw3D9MHzVpOI1DpvlD1t8xa7TjRdJI5JjGcVn/myyQBVy3vmj8QO+QLWqcd9fANskW7kWv8/kzv8R8e5DDjcmVoaFv1387eFvH3/5K+wizNR/i1K5Kf13gfrki4v4mX/nRldEYvHoXlLRB/r3gpIdqlc/U1Y/6FBVyDb4xPjytBFX32y5fiofwUcVbvKbmlxNoyAU6QNtCPAsZYinDebaBnNlnbKV88vpZHInT4VSKI0hOFYhq0MY1cri0Z5eXZ2Ttqu2jBD1jKRJQQmTIog+romjE+89pExN3Lx02Oh1XhCeb3vCKTVv/My3Ci/2dOrNK6vqe/YIJJHFiZkhQFH8KbpnOrm3vYeNpPOV+8TSDvYNnfF9GDwV0Pk8EuB5HDaxk7S7bMbVpFmetkIHeFshttrFIt6X9tikcMvhfRqKOKa02n58HI5n5BIacTjvsT4hi21rdArRAN83ylWqx1g4SljlkMfdaVeabcszOTB7zzvl4pixmwonC6LytujJG+89UpTL2LkrPGc4G8uGGvZncDo0tvG2SNMD+4Puyos4hDxJwRPk3w7+4pBiYGsxcEgxcEgxcEgxcNDvQBbtoG0HbTto20HbDtp20LaDth207aCtibYm2ppoa6KtibYm2ppoa6Ktibaspw73jfBGpPKFgzqmMSpXuvDlS0d89oe48y2/RGTaofDEaBE68w62hkveq6dlNX7IDCqzWl/9Bz948rN6+IjqNyAte1YFK71cJYGSbh/sywt/OovL4GflZoUUb2h4rTKPOtl7lUEka06HNwJKmpA0JWFxxGk7es9+UlqB+SIU3QTBJYU2L78aBpNkrqsDwmvZ6Mr256rGD5IuCjPr5FjM13uUvAKtROwrOWUR/ybbsSuvvGBEWp3StGb9SJxVqkdTz43TTIv2o+16lOg1OQwX5uW3wE3S7gjE5shV3pszQ1rqyyWT9/X3vv7e199W6++1Tj+DQ2OwncAA3bJOHmWdQfMW28pXFQh/DKHqq79EnrIg11iQayzINRbkGgtyjQW5xoJcwzqFfQr8HHyBQxSL7jw65lTq4WpNt64jxUzc32dkrDGy04RpHygOmPzOCtM4CSa3ci4dovdL4Y+z/L6oRFCp0dqTXgk4UvlGza6yx5/8SkTZP+y/5LikXbkQurvc+s243xc7TG6eCrC2VQutAXWvLjo5lCppRIdS1oWu0GRbblgFsffsMNtcsyLSsXIYAz/sgh92wQ+74Idd8MMu+CHr75BsrQo+kRLfZXaBsOI1tvY8nlBeppBeKlJ3rQh/Q6Ak5GiT9Aq9hVTC632JJpHgjj5s14mZNlAFcWQ1WK4AqkHt80dZiHJKdVjqaWW3FyGpAuEPy6z4iyrW4WNKOvgX5FhhAz4VIO4byvIzy3IZo8dnUWYab701aoHtH92RKSCZT535Y/mhF34U2/6IRZsmmkm5YZ1RTBjIjaMrzo07DpNkv/A8vAxGDyf0bV9CCZW9emedUGBvWW5aJwpZ2PuARGSLulH/foRVspa3WVrPUooRUoJRszspD39f0beIOcirPe4K+HROoe5H5Y/LzLU2R2j1WMXC11lS7Qa/6x+vVFx65cwhnEM6TzvD3zkrpx5ue3o4tPZxU9TnduIUQpY+m6zmkzLoBuwHhD134ARTsKN3o6zadhG9l3fN2yiuM5Jdh/NeNUcw6mAmqM/a9VLl2lhFDq15xlBGyvDBnXI4wcG2z+1G1ELNNn5tq1NJ25YRVQDa+BL/LQp8uSXGwSjwDiMpPyJhxo+y9J8qYCi/F/WhB2D9pobymzz3ziWtXGrDlAHeGpNVoIxLfqmP/UKsG/1CrnEcIrlNKale28oswmt8ba6kuEUcYXPpY3MZYHMZQF0/gHpqgFU8gHpqALIcYLsfQD01QFv4ObTh59CGn0Ob9XNYHE2JeJVBSaonLb3K779Uwm4lNl0Q0Y7cuNQmvRJzhJMGi8IakahUuosoB3D2zADIOs2Oxpm2aPFVrlxafJdplNzo2n7CwhIUJlEV/Tj8/OlE2V67tx7AP6o748L9WxB+9ZXZsJOkEY8l8eQLf5h2mrxZm6StBdPadSBrOML7dG4xna/JLKzDtrUNu6CbIHgMMAqz9lEHC1tzuEzaZTrVn8Q82sxycZ38PSt6aXxXCu2nFiKB0y8sCdIjX9lT9uDUhs9LGz4vbfi8tPm8nZSl6NhL4tZeL0CG/hq+7q7jeOLJDoWsBA12yU+KrfICmf+VRsLkQ1cfvxcHgg3yqsjpHGg9UuoPk8/BbV53mqMLN9ggmGyMjCl5Gx49bXj0tNsG/oLzUM47+ZfT0kjhi4I0HfsOeRSqCA+Ja2GUmQtUeqZysJOzZzGaxaKU0APbyTG1Sqqkrc4TjKsUEsVeUbHUq8oEJU5mkRwt+fcgzOy5kPW2dRljB8wIpFviYzff3bhbWZUmj9M0HcvpEmyadXQ41kDJxSldP9se2Fb0qDEf0Q2geUODfEYe3ciNQZvXfAISOQd9zAQOHQa4Bey124bBBpR2hPczAVVmLfiZT0y1u6zKJ3kyL56xH/PCdSfNWgg7vXQoi90uTiM33OrIXmk2rUNr89mk25UsjY46STATauiufCpNa7304WDv03ap8u98pbsfDmXYDeGP0IY/Qhv+CG34I7QNTfJNinsktw4nPznJXgLvUZyKKd1v+iNXRLnxV6HueRhMQL9FDq9qpCXyp7pJG7qOKJ3BFt6mlqnRlhshO6P7+XH7tNtdkW2gkzN/cipmaAt+LO1Om7U8WoTwKQlizr3bdn/bqp89NKCrSBpriBlwHGrDcagNx6F2x9KJHDkgOj8VLOArezy9CMUnIZzoKtG4JPSfeqJf2vP1L+FMThipjEUjgbxoaI2f/aazW88dHSaKHc7SuQ3/rjb8u9rw72p3OF6cgSgoipY+1JVod6uOmz90g7nKRTQaSdZLpw+SLL6GnjyEHE/dnwSj126bR/wmWGxWp0SxALd5aWIRbR8FBVZCYEFWJQUPxLbJSdKlpoWII6XybRn++sD3kMsvohkmY9Ghq+zwKVOxHQWzcCRagneRaJucDJzY8Z9mzTcKOFM1F1sCbQ/tFLVIzUv0yOS01MdZuxdhkQPzR0KfsiaLRNwKRRzOyWOLw6DFXuDF12mb+mK9V4HuDe4oBXrgJ9YOSl2GNxy6sO2zaT6RtzRzvsmf5F5RlzZo0y72l4UmKFc0ml74JIGyvthzL7C5qyk24Sffus4NXwd+3wg4wyaAklHpoygED2Nv+0yNBkEHok68Lu1jP5E7saMHjX1F2+KD2iYNagz7V4S4tzQIzpS4/RCnunT9Bw5pbY1KkGleq1pQB38/EepTeB8yU7gMxpw2gU25WmpUG/IWoe4nyugvhymNDvoHN/44u72gvHfygFcnqTGQ9xNjXjDmEAblFDy42/DgbsODu21pNuNCPAA3up5FFP85f8C6S0qSkJTZe3A1etru3oVFfk2jaf6upTxhiYz/JH4JZp5zPJ2GYuSSbdXdfwazEyob3tuhuPDvAm5KuU1/HVi1LYu1O9u3lZIgXpW2/CBu3clvdg5vJeBwfkPxQOLoFzu68GVr+W2xN//i+r7gZC/WLX0loNrmYL2e/igTEN+LiLymlOngR/tRfBDCHwo7HN3z2Ockj+VQakP9Gt38UfD+e35ePrF9Wf5BnNMLDuOckKJrXxuul3bwR8Gyb9MpKUkzK5zP/ql7p1IJf/Hs+E6KZBy+OVFnNaT6JMX1uvrDsPgZAnh/tKMbezKV3+FAA6MoK5hyR8Iup59cBac+Br9OR38Y/h4ElM9yI+xzus1VcOrj8et09EfBvu04Sa6qm0AKauGHouzAoR4HBTZF7lJQidlGlk/7gxeMHrYI3rcydt9LB7FvmlTdxN0HTzfBufus6O5TEGPv+ySH9hs7b9yhbhmM2pbLyk72Z6mo9yS+ecpGl72bYsOzlBptezO1CGR/76WS99diEpDjjhZbPdgisXFHym1xWRzH05elfl8Jc4+vTtR7NVbtRVUP5kU9mBf1oMHpQYMDH/52DxoceJu3exydqligiOVo++6okIDlJJBHw5EU51TXyPGjTOJiW5nRpVj9yfWVN1thpMW4clXta+pylbmYjVT2xqxoy4h7r/Yt6yuW1/q05iPrlSlMKQWTHYVqRbEUZBhaQ6SCNhupIFGqKYTdpDAIA+QxR/aY1Vd17fDb9dz4Kp+QeaoyIlQ2q3Cq4JBu6EKCF9rVtjuzgBvfZBSyMKxrccchCfyPDU2QtiJvVLU+05Jt95QSRM57vNTBPlHa8XgcirFcFpxIyGYtrjSrl84qcPeEzNQS8GZcOkCJJeyrfeyrcLRv9zU36yTSwlvKzsKsUtHXSAUjzKx7VVdpWucnn3xgazMPrWMcjVuLqnnRhGppI8RBGyEO2gNt2JZ8+au4K5l33EZBXaoZUnPQHB/Q9tR4zq8CpWsSsbURJ6KNOBFtxIlos8lCcxgISEQ/jhUSlJ13nqYuW+1pkPa7dJt5scW6hr/UO6w9WQb5l5E5WCKnLnNAQGCPNgJ7tBHYwzg6WjqRHFx43wRBnGEPg8mROfOPl7evf2JfbZj7MtHZ7ngI7CxOrYHYLMaRgb8d1jU9mo3tsMjrFS/66tMoRJIxcubXmRVxoy73hRXmyB6HwWzKZI+WKDaBaAt/u9uiO4G/W4QXO90/lGc/OaT3gO4+/oJ9tY/WQ31ShDCWF/5y/GQjqI1R1TqgPWFJSlPgTCZ3N8GPQ3BR2jWZWWtzSoKFhvWFymAh78mBIsGauLNnXoxTdaKaijjEaXLeLrStM8wID3yv0PdbdBNQ3tylRMdtgQsNa0McD7lxrCl/Z1eeN2hG6UYvlWU5lJn8zV2W0bi2A38F5r6hKRST4FEkQ3QFuzQtNqtvuV2N2XwZwPuGNbVvnZQKOcx1sW9jJ2eTo3JwVIDbKakhbgJI8OmF7dmzG8WuP95EU9JZL3Lz1kNoXKhaXPYq+N1ykh7wy7/atE42wMLeO8K2R/fLuQGblrXSrL6w4gzcxlEWKk+phAl8Cd1oYmuj2BsI6WOwIX0YAIUI0o8qB9+GQe6N9db7Bp02H4wwwbcbrcR1h42SW2pWY7TcRbj7keIjOlQjS7Q8vG+xYXAi0ELDbW04eEB7mkamjLATOb44nNGaWJlh2TCsFVjUQ6sDtSug7y2+1eFmii/5IbSn9/+8pHOsFssQpIwen7WHgZGIKz9RgtWixUJtbHSLbptkpPfu+N6T/4/zXxyaoW1ig25lzW6G9JHZY20IXdrBfqAOc86gDXGmDDbO1E3wIPwsVpcXhOdBOJz7sf0Mi5u6kLdGN02isJj4p2o/pI2mZyCClIEIUgYiSBlIPW8gNJGB0EQGQhMZSD1vsHFygA2cXtBx0lsaxbcc/Voi79p+0r7jX9xJBCuOrC7aKIRolp7ZSW6WI0QLdu/mJaZQfJE6y1z4564Ku70UXetSzmAhPvqa6GCv1P9Q2Hklgh8cDtYleIfX7CM0kcGGJnKj08QwL7mlPd1ANW+sllh10PeeObDpRQwTvIENkjOhRF6S2Ohoqy5ERw+gnbqQubSD5vHpiCzyfynKP4dFcFVEfjFMcFUTXJUNnbGQMkDXkXo3CpycIyQL/zgcU26kNHM60uKiYMtwtOVu2RupOkfYpKs0N7cqMg43sRbkEuQsN5Cz3LA0l+UpuCylxGleRqF3phKXYnG289i9qVZBUDqD+GwyjZMQiUkmii0jMrLDWDrD2Re8ZKRNXjuqKU5zbhTPekk0OW6iIR0hhIGBEAYGQhgYFtYxcoQbXRAD6xT8eeLG1dNjIe9HGnY2LoSzWzK+ZNWcus5/BrMrYadyKXIfKJfJpAQXSJ+xsj7MKdhgIjBkDyqFMTO8aFtbee5TtcEl9/fLmzSlT3mQwxqKGl3+ItfZwJlljavbDFyTCo0sFlDiasdhAxIKkqIbrLumI7edUQqAZv6HDNznWZxkIcm72NZgcwEqh9TKSCq9NnnTozA9RLBHErKGnjti0c1mmis32zpJMQNmr/RrCkl38PyQByf29ob1WC00qW2JVmE2jxhHiOmJF/iUCYtFDTbLLjZLeOsZrLdeCQwECnpIEpPidzFTaVZ7o/zYaxhZvXAQzUs4bDAmA259Bps6u7DJyi/cNh1XBoa5GfOC8Z6c3p5sNz4PQgRm5LDEnXiLbeqLY1QFug/reORObO/H6NJ94PYANv+1G50Wm9V4CbgIt3kUrX30h7esAW9ZA96yBnIzG/B4NFiPR/1Zmn9TTKQs/IXTtqvyEX6YUeQUoJC+MBTTMBiJqJDIMC8DF7vwNztZdleH792/72oy54aiJNJwDdmUtEYfrBoeiAbrgXjqRhQL2UlhKPfjhSK6skgft5Ru1+mJT7VSfNuEgJsoP5W3dPhLED6I8PvfFnFtsb7HaLWJVnO1wU0FZhO8LAvsPZtezSMuj7wBb0SDTYqctyMqiIUdngZPviqoS/e7qo8mBIj0MKqCUV345wGfGcHo83Ety+1qjA/KAG6aqobDf15ymMHeN9Ck20Crk8C/c8dqV0gh1ZkYdnknzdEVBvIliOJxyJ4r4YZqDAzdgkybFtdLVlbrslzZU3NILDBXDoXYSQcme4mdNSyegjbn/8bCdfAC4Mb2hLW4W3wjolgpXTkUQgOOvO7GoMcv4xyA0rYp9pSXlnS51Zfbq9903bBcoDxGzTCaEFe+faOb2OjbN+0Rg7+oHfSXnSRqTMFRhNjELpMjSH8Bq0ERd9saUoywm9Cd1udeUYLYLIpUQhL81WClc0QH0c4RdxCVB5WbyEnvaGe3p25Y31aiBd4E86tijHDgKMtPWw5AolCDPINN2OD6NeZqcOsLF0jGHmHgyXPQtqQ08+/t6XTe8pFEthWEWsx03hhmsjx4WoyYbwwjoRgFoaNFh/XG0DFSoeI+hyewj9DipfvG8PJbFPitO5du8F1/3JomJwktfnpvDD/u2Cezfh06+m8MHVn4Ai1GBm8MIw4cRkexDiHtozeGkP8rznOBaZHSfnPbjxy3FhtvTY5VtmKt5HykQUrnzQn3o3sxehCOsse98Kcz/dGn/dbE2WQUWny8NXk2ApFcys1Hi5K3JsreesFYIcNzb0Oby/HYaffeLFIYZPTfLDJU7iwOJ29Nfk0iyOloxDh62wfiCV16a5HTfoPI0SLjrUmx9ggj18okxluTYB1B2SDtZQc/463JraN7OR7JSLQIeWuCK7kBnbuhXm41um9u2XgiFle2r9+E35rUOnVHD1pkvDWpNZL0MYqvhQfOerJMk2S8HemVOhyHarPBrejhGnrHDhvczSNXxtosTDNozRofLOJnw6seNt5LJL+oPnOWFNi+YUqK/G4sWo926JKRdctzJ652zXV4h1CyKpPYjWo1X2bA7h3u3LGEpKcqsgLsdDgxMJraT/7JvevBLoU8c5JIGZ/9YewEs/piMa3XU7OmMCvX79KTacd6u4sXmlG5ZvUiZqers+OlhDo1musVIe4Pnr59uxfeVISwc7R9N3b/Lc4eZZuIwxXrhFBqVR/CFsHuJ9YmLpWK01sOYax8mjaoTxArQdwfNCUBECN4k7cm9rQVzaY0OO1i5GTWf23rxf6v/fFbz/FzK/zR/cQOH6JDZLNvSTKi9Om2PxJSvBdOy5FcgsGNCfNQBNTqsAG1hrKxcK5tX44JcW0knCzvsfKwEBQGy761o63dz5Z3wvG9Sp/NmnIvxb4y/gfpfo+K3CxAZjFN/LV0WwewPfdHHwgKYpzM/A9Z17XFM1+3rz3G+UKJHvNd4LyHv338JR+mjnW0bBZUCKTh6F5MbOVOL49k6pUj7iSDEs7LJslae5JeNpQmQnGxc+gFcdQK7lphooSIDim6FOt/17HezqVIAUP3s7FoRZjn4m8tZSNeWYeNVzaV4n08JC+PxDx/AxeSdeL68sCbPe1oMJm4ZnH4M986lS1ZgRZoC7wTgdI6FieTPoWJK3meT5E+Of13y5B2ChgTaSPtbaGTV6O8JbFaolHoTuMse1PL9R3xzKES2w1iy3XY2HLFMGkJV5c4yzIPZmlFkucNw9t2loRGZ0Ncrd15E+IBEfTXNHKsDUL5oCXiLhgk4ot1utxiRz7PLBdksoFSaIfTFHhtMteaXe0Mp7ZjT2W1lufekg6IcKuOXRwewQy6YAZsdKwk0fpp6Mp/suCI8uBWKXGjYkFt6Xm27r1JbKufHLYhpCLIVgdBtjo9HN4Q96nDxn0axk7OPm7yO4y88NK9Hf7u/ZOkZlJH50WF2lSouIN6dawGrSlOMqJ82OBQ2K0eCvdg2Ls65i8GlNHSRMuX7IAhjJ4+Gwn3iS/LnaGF2JxeZMki4tVCPWsjhF0Fo4f6kZZB3SvEKZ5JOzqHN3B6hLzqIORVByGvOgh51emDGyG0UafP2ydNT8XIS8NDJ492SA653mzi04soz8RQLHF9eaDNy7IiFfApLfrqi+epfBYOlRQ5/nXwlPw6DsfbBsDlwHOy/St/Jfs5O4tqq+dOT4JTWfdXMadfxG39/IkH2txKi6NWcqaKgDI0igRGQ/PKIQ7CVZ+7Tqq2/ks69mLZlmFNLjg4lcB9XJWdnfGrqExuTjgMciKphFzfRWUGrDFCOk/GQ9HYOBSAS/e5a5Biy78UvgzPWxLPeRVG5axTfd0Y0RDZKras1POLmBtgTxuwiYnKjREtqVK0Jf5uGDBlFHIdNYbFLDILhz/IAQNODigFe5xmD1vi7EsJQEUjWXrXKLXptRFs2KpCk233wyqI/dn9EH9lxfLD7jfoshG9yq1VPK9K2dZBvRg4C1qFxSqNkdYvpPpkqYrb/FTtbQmq0Hp/aAmXxe5oKSvCJsgGiaq2zmKGFcu2pKUfODhMhMdqlcZo6UrE94GziEATkaRMNpKUaoPDiPq1JbKu8taV41T+ojHEnAajk2AyYQPnmUcGkNPBXxN/Lfzt4m8Pf/v4S4dlsw1kslEK8n6g7t/i6cZG7Ms4dCdIz3MpZyJLJgfXiE+Bn71JX1zai+VuVHrMk86tyzyOqoGG8yEztwv7+62vxdmODttHq/ZJQh9Dcm2QXBskx3rro+FFLGBSg4fqflkt2/LSaHlHnAU7U2Vn2vYqfn8S8+COP36bbSxi1tE9a0Yf/SDmn+9ecuDOoS2iqwy8OTk/JCN191HocNXjdTx5oxfodCpA9kfy+EV4HrIVD+eT28Dj8AK2z7p9VxrDVrxStCU9/cKAqVyXMzUaoy0+oq9pYJdknaDTNKZ3Lwjem7k4VC9jvYaX2if6TPl2uXbCNLADsF7AHARCl5+Wb4szFvAiDsv9NHfmnk09Hb8yIKYZ4PBIj26yXpAAkW5uGTzIHAsPqLalWYumH0b5o+92Z0mJqnhGqo7hNBQ2d3JAVnSTdR0sNKTPsQuPWxLocQVEGXnVDprjeMmwNMSJjOgm6yFXbFlU2b5E/DivwuBVts0LIWfP1DGHMPDCDscLVZvEumbmieR5S1QVWlfzGVeAN7p9OEiGwyEKbI9138rbpVuFs1HWNW6vKEBY3CGcV8+nthpZaHRnj1hcYVvo4PTOet1kjVPGnRVU9l2XK9/yuLVep5obO65aY0cvTL9WJ252oCoxOVP8YktsmJIzHUsMhS/R+64Guqtzx5prXLN5wJ3HZN15smbZCn/JtvGpBIBZ381vGFFMvqzu3ZzDE3QnpsnazCXNCtksMlDbomsBKOPXUeqjMaypkV6Spt/2dFQGyRkONKbZ0+KwAISQWCrM9pqoWLq1F9ma/emwXuy+MZb41dcLhXBQMk1Ojs6a0TfP/BeKg199vSxYBt6gNiqYSsbMLWsLsrPFG9OrVipvYPJ72yvnYvuqD0zhVWMowklIQ0rwDjJZ76CsWXYge9FRTENGOeCGzxLnYTDhEAQxGY4uJhxdTDi6mBbWoDVYpnPJDxwfXN+RnCXKS7Bl5o/q17Hn0TCqR5S0zC+02dKY+uVjW37g0Q11Z/bSjHWB49JYtfsXfG7MLmQl+IKY8AUxkWveZHPNV4DiuqNcVJAe+Te/uPH9CYVhXg6AqsGtxolWV7wJZ5lCaFQZ4pb0su9fylpkLHx4Y9SX2+pyhAd20gU76XKnyrx1esIr2/4G+dOWotLSHhgLx/LLxoSji4lG+wN/GBP+MCb8YUz4w5g9rGjWNSLjiApokSPmJeCI+eMVOF7+PKk8+4XqL2XU2w5Lx6f1o2xslfwkdOJJD/tuT3PvWrh1feGdq/7GdfcSriNuZ+MsVyOHFHCMHscxQjEJHsXF8POprXxg00A3lPLwMhjXmNdtrZ4aQJrGwdaEc4oJ5xQTzilmn4+nJgGp1E3qq+5EdlxPzEHwdUmIhXATpJqro65t2flrX/h8P5ab7uz28CkIH+684CnK/JrtWRy0Rp6E0VJ1Wo4bjWYROQ1Fiwm4TdYXKJzV502fwnptSwA9ShwRy12y9VtwG7UkcuSAODz8mcIKpLhIMaCCkRBBtGJ7/P2E+Xw2Dzua/eDCmKu2MJlVoK9NGIkLyuGtZ/9bUKZdhhmxjjyyao3ZwuMGPhaBUZ0Ze4fSx64FFxQT+cFNNj/4cO6P4LZLIXvUseKYKct6onelgmMKV7Tt5fs6vTM38WsM5rU5dHkipi4rTiG5uMkmF6cW6fDp90ZoXB0MRgv9tSWEMl7kBiuHzNIn65yS1q8xrmoB4G4Xp4ruzH05FB0DPt4YtaHkPyrEGz2pE2KNueaXdrFb+lC5TDkcdVlpm2rXJ7nk4HZLGaGYyj2S+2rw7AF/0qA2YHYuldV3rliEu1saoJDwHC5oz7Lg/GCxzg/yGHllTxWHGz2kBE2/N1sxncXjKcHlmKq2m9fWzJQxNrGniwiz4AphwRXCYpMiJ9iSrdOvkD9fhiseUdoedoumBzGPODxxjJfq1sZYMmC7ZSsz3/2dMz2y2NzHqnZt31wAt2NmSuPmPrqHhcDx0uRbKdoTftTFSzm4u+Wl97bveCw2wE3ZlLWqTSotqqd6pdHlPewWQ6PAH3F7r8X6hKna9Z2Nc3C7XSR3nh3Hwuc+G7sGvJks1pvpKVTbRgKCfp4nP7fcNIrNq6EEy301sLWKkOUmfBpSqlyf/iiDtlvamNhx6D5z39wFUXAmRt9UI7XD41dtPJSFvFseQYFFOHz0gQ9wUjZ7Yi6REoRUBKLfrySRLulmt8tmhuCPKqsRadC5c6/F+hOp2tt6qBVa79w1LcVAEsqWdpY7d8xJnPAXslh/oSRO0pkfh/M8rHRSegKIW1sBFUHr9LSLPe1qqaVoI3U9gzLzT3JtUf1cXMRyH2yBRsByDYiu8N6xDLAbuKVYnTb+gpqQbsdi0+2omYX1RsGKlgYwi0WhxHacLILsOQVsj5PSUxU79/MsPnWhkxXPYiTbnkUASiW36Q8vGA9jO4yzN2NRaKgeUp9B+fQlDIhFnSUYjbZ1aNfR8x/oq1/ftb1Ke1NvNnZ9sgcYfcFPhg47oEM2j87tjAR3FSXpzvXdDKXyC1XpVJDn/mj+RV0Tk7lEbYLB9r3vmqOlaA7F1LNHguyn9OjGUmd9XK5V8zT0gj2devNC2bYqwBJcxj6U7aYpFPrB0HXE2d2dXD2RHomcVSjTtLbNQwd715tJTmlR4D2KL3Z8r8cSUs5YJhtTLUoEAFJdFGC9TAC5Kbavap3ZTpoiszvX81rqAb/1OMTeC/8VC2ljLHhjWPDGsJDOxDK5xXwZ2M6JPbrHjiB3Bk8OI/2peituWtjKlKXYOdLCqaua+ML/TQV+jI59p8IGA/9aIVU9UIfrTlyvMnHrD1a3Ddc09leih95hbzN6oDpTSascRUA+g+uDZUE+g4m/ZYFG2GQWYf6tvwUqZcLUDiMUUGYlqolgO26Y/vRJUPE2SBfSXX3v88JBvLb14iZzc8eduuBDYMGHwIIPgQUfAguZHyxYoVuwQrdghW7BCt2CFbqF2PoWDIYtGAxbiP9uwd7Vgr2rBXtXq8dd7otneSiPUoWnF8V2nD4Uf5M3vMRv5TH9SfJj8ZWc9YfCs0cEmT6P7ieBk7+kkaRPk4diF5PSQ/pr5heBP9nx6D6VXmd+6REP6XesvZ/2V1HjW0LYawkJ/cN2f/OlMwrn0zhglg9MuK0elgPMgi3WLDhE8rivXy9Ok3sP+UT7RIZo7Acf7QhIwL9b2gplbSuMbP0B7NIuaB3c386kBBm2ogkbPtiC3bGFUO8WrGktWNNasKa1EOrd6mOW+pglxKy2WFO3D+gJIcJyt8+bQBUrP3k3vpZrRkUCjNRhl15+Cbw5jfc0ENGnIJYbu5cfSeCj/VXisA+Xs0KZT9mChZOXfJpNblVX6plwOC4WfJDTrjpWz8oQd+uAd8Uv1jme/mEQ0JyqgCNbockoa8Hk0Oqz8q/k7xRuE/5t1P5s4sYvCO+5FN7OowVsgj3eycCCiaaFuNcWG/d6Gsp+o8Qw3RHTUIwSs3XZ03T72wXWi3aNnnZ1wbAOTmPOH9li7S7dyI7jeW2agAK4pg7/HEIcMXLlrqLdWljjy1PVaNu7mGLznV/GfJPDksXi27eFT8XeiIjWFmtV+PHm6vJGSLaeEPm1ygCWXcmQg805hQgmz4O6Fll9fgL01dg67HC+sI7+D87eE1nijhQRxMH0G5khiKnqWZaIcEKgck/WZH67Hdk8f68yfJRqdI5KNT4lB8UshUu39DrTnmd6h17pfZ5gKqtglCtkSqrsmNsvVUBKqtL7dul9KpRn6V7LA8gPuMU6ZqlOIeNrWqE8yNLlQyLJlvFACuHS6zKes2O45v2FP52VsGQalY8UZTSbFSQkLuPZ6/IkqmxsxQqdMpKHv3ult+WPK+UozOpYZUqiiNslDHXM//O/EV6YnGi+Ie2OIKttfO5daEt5bTaKZ6E4/DyNsOA9b/JN+KErD3ICIP6/v8hT3K0nRa5/HNzZXiSyrH6YWRVcWOJWrgRPRLLtPSUodpIlZcs1No/c6Bsd02aRahN/I224KytRj7chjc0JnnyP9FOyxn8cnHy+vLw4Pbs+uD778vn65lf/Pw6+XH+++nLzj4Obj2f568uzT8Nf/V/9/wxmB3YoDuJ7cXB8cfB5qlJtHwR3B999dxJ4nuuI8Lvv/n5gy+dT1x77QSQHfHD2HEQzN/7uu4M7WTsK7uInAmOHo3uXnJ8kZr4H9PBgHNjegRsdxMEB7RjoaiblyYNf/3Lnxr/+hQrc8ECyS0F11BPxHh90+z0N8z/+4+BGNjsVj+5IHEiR2J7eB+GvfkuOil5cuZR+6eCvN8E08ILx/G/fffePA/q2iC7FDm7nB44g36RbKcBiAN89utFMjiu6t6fiu4O/0uXZ3yXg6P7vBxeRJw9t0d++lyMkGF4QPBx47oP4/vvvf/1L3il8QlSWYgkgZWp511NhP6AzRUUHEup4Zo8Fwb25lxiR/7MPzok/yo+K5lKAnFS6+BJEkRy058ZzGqOcG5F8HGWmcw5kz9TB9F6Syij6+8HTvR0ffCeJ2HO+k29kB7dCbs/i/00+5d5+VHMt6TeQqBgFctLkXNsHX+SHkH/L3w9uZ/HBPCELSeljImfhYFiYCEzqz4GcCBrnB9m7lMdcIm858fe+O7I9BSQS9kRSNs1g6yAlNEnEB7/NovgABP5vF4NwxP+TdfnddxNhR7MwfZN+3HffAc7XSH3ARJClRSQ7Dx4ljToHf/2JQA/pi/5+cP3lw+XfD2jHDKbzvx3YUQJFzjgpYsiJOqWrC1+tZaK1X/329wd06FI08t0HWmEHp8kKk8RO2UQlSr3gSTY3vj+QZ3pZM5IcWqLw178M5ZKQ7WkXlXRNKyMldlm98/3BnWePafLd8b0c6jSII1ntr1eunGT6WntqY65dEckx+w5VlTQjcUjV6PskUf7qm9/LoRV6pj5+lUzcjw6O7+Xgf/0LEchp4P/fCao9eTY5uHOfRSRHLDwPLe5mWKSy5cUdkC8ZHzqjtxLJozmxpb8nr7xg9CA/MZIYJJ52oLTu8vtBtEQb1vdEC2r1quX4/cEPriK3CXqEx6rE/52n9O5EeCBY+XJ+QJtxjElptVr0j1wBdjgWMX3Mf02x1/8XlSKRglwIDr0wjoxu66jdMjo3R51/HPX/0e6k83p69unm4uY/6TFfbd99J4Wu3gGlTpTTSfRFuuWDJ7kDyndts9PrHUCySciNNujoHwcDo0tPEMEOpoHkTrKwbXXaVHpKBEOgaOv6vv0/kgGcfDy+Pj65kcz2r0SOf6Pi/z44lZIctqOD/1bEKv+9ErZPBPDfskIr/++/K//KXwThWkRTSaspW/jvA+t7OjbLHx9CSaUSweX31OaLXE/luhcTKbSJg79GcvEcCHVx+DdVORXeStUPP0vubT9KNiRn4mGeVL10ZUMilGJdyUtjcTfzDv5KJwNPPKMycHJ8ffLx4ubs5Obr9Vkyx2SiJWeSEJnK0/+AhwWV5F6ncg46qqQoX8qNWoG5tOfymJHA+RRIXiuf1XK1H20XRJuM4aez/5T74NWXz58kgWATvJJ7mpxA30c2PxBHJAd/TwJ1uhoka5Kf5M3/9g+Q6MF/qQzISgL8r4O/msaRrITDzt/wfpS+6RwZ5TeJRaF8JT+z/EoBvcret9vapkfFV/iwj2fHlzcfD4Y3xzdf8V2/zozekXVAKJafJ4UoufmQZurof6h35oijXdUI3DQiApXyCGY2e/VFSfsHj26gdj+5Fo7SCT65ufj86fjD5dnBxZWUPH4+u0qxLMX1IESEAEdxJLn85YlD8m91r/8PBeI/DiQP/l8fL374+L8PvoQzX/z/7V1rb9s2FP0rgoMhzhDZlOWHPKAfUifLvLVJlzTDgKVQ9bKixZY8Pfoa+t937iWlyI9hQ5EUsycHsCyK4eOQvPeQlI5kGdHuwZpNSPJgfh3kxfJYo1ta5E0W1V0XERkvCi9c5HZ3mYLIsP2YZlkRUAJ98Q2VgZ0MjEMRwzWg0cm8tQ1hDrQkXaIPEL7ffvsqDeTDzagvdzOU8pcgjWYf0V80/yOmb6BFagYFk4+icJzTYB7ksLZkR7jaqD0Mp0oag5WdhfQ7JKiAYhTk2QOWTspKTOBrfnt5djq9efkGScLBY1xp54mPvr6By1vblkoftv12tcY/wPEor4jCTigVsjvt751YT4qc+ob5t7U9oRsxtEpiFJ4kTIOQOwBfv0ZiORG3RONZPsYfLc5EPIHxwQZSIm/Sx5IXp2pIsrmkm6vTmB2ml4Ly6F6R55IAgBqlsYIBXfvq5PXZ+XSiTS9en4HKnp9dTM5KjG4L3zJ9fHuOAebEBBK8+zaGPQCc88hD+chELpwl8oIF6ZCBIQsIU8EbwMjyHr6o7omPNYw5aT5BJkMKINcsaQTYDfNbZrdhQba0RoHBNoJ3ybxg1XZVhV+m1zcnL0DPT64vL6YX5+CscI2H18RDD4+kMbukoQo3zYHcpBjTV/YPN8/RnKc8o6ZuBFbroY6UzV3haocMnV2yzENJarWKEndKnFQIs6GXkkZJxjmRqUWfHNXuGPlWT2uLZwsmxsYzotNHKjJsOyYxGLjsh7V2pGizvPyC+iMG+WQOBkJTCBjwcWfAI44NrIx2Ss4w/0iXB52+gLEOS0ssCRmDdnr58mR6AauNVv/1tdZ+XmQSe+U5FW5TmqalQOaUCTcjtzlbe1vDQatSmqgliFuWNIQBGJpHx5pcYsCZKXBGywla2xoeHTNbAeccjfBbLhPgpEcnbPa19tDCCU//8dvAb2ISWnswKq31zzfTyU/oB9+fXZWd+C0NVxrQMKj8Ia5yG58RH1EhzFBuY0VL+MPcRDEToiWKl1xKC8ORyJrdxhNmdPK/YK+JlKgktKtn8N7aK/5+zt8v6FsVibcAIsyCMyKuNBeN4QrpTrcU8zCbmXy1nuMmeT4HRfPu1XJOxFPTLoZ8mnVB/e668As/ggNc2+jk5YkdyF2MrIs+Rr7d13myrCcznSx0lybKsDukOJInCx0GKqCh1n1ggDo6dORKOeNuhyxrZnt010hXssduhoTd5AOpFHjoNd3KgXSAW3VSKiNRqVcC76OYq1Kum1VvnUCYXIy2fbKJgZrCw6KuBpC/ttdjceBGVDfI3wdBTF2zxQ6Y1wpC2IX4vgoAvVoUMYYPQnS5pvLfBbuU5fmOZUlqGJfnDbxfAi+mL5GnZ3/AWQUNxk+Dsc8rkLp617WULIsD+PS7PF82cH8NuJfgFkFOyw9BA/hX69/vswbsrwF2DqZMSGeL5J718+pwrwQ2mD825tfbML/ehrlX3q3UAP5FJnwZNtbkqwDd4PxENBuXc1Qva4j2I6OsZCPdYrHUgzikJZkG3adGl544roGrThtsvwRbXgnT/drmAyEcqq3Kc7pax3rjQoP646HeWI3HxDiJ5x915J2815fxctH5PftuuaBbtqiMJ6G6Qa7EesulBvYvMtboz3dNb34yWBvn93igevRyl5JZ6HSjQRr5zTrd4+McdZfybgZJLvIXDq1iTFD2KC+faHugGFsv/9eRf1OLY+fJstlDfEL4hTCtUb8/HPWGYjQwBmOz2VVsAN+7fcbdRX1Pdh73qwF2ci9yD8fALu1O7hf8u7pfuZ+tsFM7mHvmCnZpr23PoG+Qb/Y99w/3nd4J3R+8d2F5eHfR3q/d0n1rh8bWNDuq/w+jv1t7rHsAdONWm33YvUR+73Zm/01bvKkFgTs8aCOyImj9Ej8ZKpRGm6GOPXU01bGvjgN1HKrjSB0tdRzTUSqJ5Wga0iNy5rYShFHCSyz8wr/ThCGsB4pOr0evMXnQ1/LroX5EapwuP7bN/1nqUrSkMMVx/W3oLRKm4MKw5MRaTkZnNCLR5vWcBmN6Bc9mTjfxfZy8j1nKjDRulQAVKY+ZQ+4D9aeZSU+MQpfUdePcUcmM1MsZAIsK6SnVOPpJ72xpVU/xU4jgCnFyxmDEdXGVvsZadXTZU9YqI7bVJKpjNu5XzbXZFpZJkvXriarQjXQ5jbnst8ZYDMtkZ8Wc5dcs2RalLslGbv2B2JJbz+pvbY+CRe16JsMshXvp3OBuEpCIEqU6/syZKrUTOTz+bDnvQjXaFs4H9esuCu/sh3jViBGsp+jMszxgJS+SxcvRqUk9YFEOWiRo+9FsFnnFnPOgQBkvmM2SNC8l+jAiFqQQYLtFyOObi0c6PIEtZUlUAZUwinwxtZPes9Y1PePdUmWFoSRJgEwqbPryhTRkkMrYXjJPUjXo/DBYb/rWwUiMhWO1asqBHOwIC39Snlopv/sqPv4G8kI5FloHaDQxGLRWy3DQF/jjULJy2Vp+VHSMnTLYwQVOViogUhHGyKu1ontYzz+K74I0yrN6eQnHd9En1ULJPI+WuhsylQldp01vtKBuS0rvojMeHPFrjFW8HABUMXs06tRXPTJJI+ghpgZVTIPeOGyQnLBBL11CX5UxCe5/iGnImPKV2rJLq5iUsUGlNSyOaR6VLS6bvyqmKONwbNEZHUm443dOpmp+AGhdMatKP0NbuI53X8Ep25nLu3LNtEyrz9fCNCmWOvp/8tCGEmw0YlYa8KzwPDnw0SGcsSMbLyCpKQ5zqemE1DhPSRaiauahbOZ4tpF+RuqJyj9hgJBR4N8rUBzMZpYnRF2vTwU7jgz2o4Wskgn8q+qqSMOhUJmRVm1aLLbkIITfn802cuj7MyGDyxyEMIxebyUHISzL8zgH2hfdWn4htqRORVtNnUpvGCupe6i5Sl29/3Bb6SmHjfQtC8BZ66Vfw4dSV/iwd0sDf2sN+vhsqYFlreZA6a/l4Hlw7D3OIfECZxtApul5rruRPMETBKsV4LTqyfd6jjMetz7T5y/6FtmYLpxmAA==";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>