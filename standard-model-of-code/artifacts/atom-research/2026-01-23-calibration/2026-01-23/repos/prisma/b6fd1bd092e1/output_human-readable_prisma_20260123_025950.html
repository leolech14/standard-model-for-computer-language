<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>