<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>