<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>