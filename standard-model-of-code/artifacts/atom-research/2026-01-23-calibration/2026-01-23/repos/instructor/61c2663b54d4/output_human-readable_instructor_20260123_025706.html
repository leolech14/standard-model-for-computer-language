<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Codome Boundaries</span>
                    <div class="toggle" id="cfg-toggle-codome"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>

    <!-- INLINED MODULES FOR GENERATED REPORTS -->
    <script>
        /**
         * @module HardwareInfo
         * (Inlined for standalone report generation)
         */
        const HardwareInfo = (function () {
            'use strict';
            let _info = null;

            function getInfo() {
                if (_info) return _info;
                _info = {
                    gpu: 'Unknown GPU', vendor: 'Unknown Vendor', renderer: 'Unknown Renderer',
                    memory: { jsHeapSizeLimit: 0, totalJSHeapSize: 0, usedJSHeapSize: 0 },
                    limits: { maxTextureSize: 0, maxCubeMapSize: 0, maxRenderBufferSize: 0 },
                    context: 'webgl'
                };
                if (performance && performance.memory) _updateMemory();

                try {
                    const canvas = document.createElement('canvas');
                    let gl = canvas.getContext('webgl');
                    if (!gl) { gl = canvas.getContext('experimental-webgl'); _info.context = 'experimental-webgl'; }
                    else { _info.context = 'webgl'; }
                    const gl2 = canvas.getContext('webgl2');
                    if (gl2) { gl = gl2; _info.context = 'webgl2'; }

                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            _info.vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                            _info.renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            _info.gpu = _info.renderer;
                        } else {
                            _info.renderer = gl.getParameter(gl.RENDERER);
                            _info.vendor = gl.getParameter(gl.VENDOR);
                        }
                        _info.limits.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                        _info.limits.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                        _info.limits.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                    }
                } catch (e) { console.warn('[HardwareInfo] Failed to detect GPU:', e); }
                return _info;
            }

            function _updateMemory() {
                if (performance && performance.memory) {
                    _info.memory.jsHeapSizeLimit = performance.memory.jsHeapSizeLimit;
                    _info.memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    _info.memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
                }
            }

            return { get: getInfo, refresh: function () { _updateMemory(); return _info; } };
        })();
        if (typeof window !== 'undefined') window.HardwareInfo = HardwareInfo;
    </script>

    <script>
        /**
         * @module ControlRegistry
         * (Inlined for standalone report generation)
         */
        const ControlRegistry = (function () {
            'use strict';
            const STORAGE_KEY = 'collider_control_settings_v1';
            const MOUSE_BUTTONS = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
            const ACTIONS = { ROTATE: 0, DOLLY: 1, PAN: 2 };

            const DEFAULTS = {
                mouse: { LEFT: 0, MIDDLE: 1, RIGHT: 0 },
                damping: { enabled: true, factor: 0.1 },
                speed: { rotate: 1.0, zoom: 1.2, pan: 1.0 }
            };

            let currentConfig = loadSettings();

            function loadSettings() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return {
                            mouse: { ...DEFAULTS.mouse, ...(parsed.mouse || {}) },
                            damping: { ...DEFAULTS.damping, ...(parsed.damping || {}) },
                            speed: { ...DEFAULTS.speed, ...(parsed.speed || {}) }
                        };
                    }
                } catch (e) {
                    console.warn('[ControlRegistry] Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(DEFAULTS));
            }

            function saveSettings() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(currentConfig));
                    window.dispatchEvent(new CustomEvent('controls-updated', { detail: currentConfig }));
                } catch (e) {
                    console.error('[ControlRegistry] Failed to save settings:', e);
                }
            }

            return {
                getMapping: function () {
                    return {
                        LEFT: currentConfig.mouse.LEFT,
                        MIDDLE: currentConfig.mouse.MIDDLE,
                        RIGHT: currentConfig.mouse.RIGHT
                    };
                },
                getConfig: function () { return JSON.parse(JSON.stringify(currentConfig)); },
                updateMapping: function (button, actionId) {
                    if (currentConfig.mouse[button] !== undefined) {
                        currentConfig.mouse[button] = parseInt(actionId);
                        saveSettings();
                        console.log(`[ControlRegistry] Updated ${button} to Action ${actionId}`);
                    }
                },
                resetDefaults: function () {
                    currentConfig = JSON.parse(JSON.stringify(DEFAULTS));
                    saveSettings();
                },
                CONSTANTS: {
                    MOUSE_BUTTONS,
                    ACTIONS,
                    ACTION_LABELS: { 0: 'Rotate', 1: 'Zoom (Dolly)', 2: 'Pan' }
                }
            };
        })();
        if (typeof window !== 'undefined') window.ControlRegistry = ControlRegistry;
    </script>

    <script>
        /**
         * @module SettingsPanel
         * (Inlined for standalone report generation)
         */
        const SettingsPanel = (function () {
            'use strict';
            let container = null;
            let isVisible = false;

            function init() {
                if (container) {
                    console.log('[SettingsPanel] Already initialized.');
                    return;
                }

                console.log('[SettingsPanel] Initializing...');
                createPanel();
                createToggleButton();
                window.addEventListener('controls-updated', () => {
                    if (isVisible) refreshUI();
                });
                return true;
            }

            function createToggleButton() {
                const actionsSection = document.getElementById('section-actions');
                if (!actionsSection) {
                    // If section-actions doesn't exist (e.g. older template), try to create it or append to sidebar
                    console.warn('[SettingsPanel] #section-actions not found, attempting fallback');
                    // Fallback logic omitted for brevity, assuming newer template structure
                    return;
                }

                // In template.html specifically, section-actions content might be collapsed or structured differently.
                // We append to the .section-content
                let contentDiv = actionsSection.querySelector('.section-content') || actionsSection;
                if (actionsSection.classList.contains('section-content')) contentDiv = actionsSection;

                const btn = document.createElement('button');
                btn.className = 'btn'; // Re-use existing styling in template (btn vs nav-btn)
                btn.innerHTML = `<span class="icon">⚙️</span> Settings`;
                btn.onclick = togglePanel;
                btn.title = 'Configure Controls & Settings';
                btn.style.marginTop = '4px';
                btn.style.width = '100%';

                // If entry is a grid, we might want to append to the grid or after it
                const grid = contentDiv.querySelector('.btn-grid');
                if (grid) {
                    grid.appendChild(btn);
                } else {
                    contentDiv.appendChild(btn);
                }
            }

            function createPanel() {
                container = document.createElement('div');
                container.id = 'settings-panel';
                container.style.display = 'none';
                container.style.position = 'fixed';
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%)';
                container.style.backgroundColor = 'rgba(20, 20, 25, 0.95)';
                container.style.border = '1px solid #444';
                container.style.borderRadius = '8px';
                container.style.padding = '20px';
                container.style.zIndex = '100000';
                container.style.width = '400px';
                container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
                container.style.color = '#eee';
                container.style.fontFamily = 'sans-serif';

                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';
                header.style.marginBottom = '20px';
                header.style.borderBottom = '1px solid #444';
                header.style.paddingBottom = '10px';

                const title = document.createElement('h2');
                title.innerText = 'Settings';
                title.style.margin = '0';
                title.style.fontSize = '18px';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '×';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.color = '#fff';
                closeBtn.style.fontSize = '24px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.onclick = hidePanel;

                header.appendChild(title);
                header.appendChild(closeBtn);
                container.appendChild(header);

                const content = document.createElement('div');
                content.id = 'settings-content';
                container.appendChild(content);

                const footer = document.createElement('div');
                footer.style.marginTop = '20px';
                footer.style.display = 'flex';
                footer.style.justifyContent = 'flex-end';
                footer.style.gap = '10px';

                const resetBtn = document.createElement('button');
                resetBtn.innerText = 'Reset Defaults';
                resetBtn.style.padding = '8px 12px';
                resetBtn.style.background = '#444';
                resetBtn.style.color = '#fff';
                resetBtn.style.border = 'none';
                resetBtn.style.borderRadius = '4px';
                resetBtn.style.cursor = 'pointer';
                resetBtn.onclick = () => {
                    if (confirm('Reset all navigation controls to default?')) {
                        ControlRegistry.resetDefaults();
                        refreshUI();
                    }
                };

                const saveBtn = document.createElement('button');
                saveBtn.innerText = 'Done';
                saveBtn.style.padding = '8px 16px';
                saveBtn.style.background = '#2196F3';
                saveBtn.style.color = '#fff';
                saveBtn.style.border = 'none';
                saveBtn.style.borderRadius = '4px';
                saveBtn.style.cursor = 'pointer';
                saveBtn.onclick = hidePanel;

                footer.appendChild(resetBtn);
                footer.appendChild(saveBtn);
                container.appendChild(footer);

                document.body.appendChild(container);
            }

            function refreshUI() {
                const content = document.getElementById('settings-content');
                content.innerHTML = '';

                const section = document.createElement('div');
                section.innerHTML = '<h3 style="margin-top:0; font-size:14px; color:#aaa; text-transform:uppercase;">Navigation Controls</h3>';

                const config = ControlRegistry.getConfig();
                const { ACTIONS, ACTION_LABELS } = ControlRegistry.CONSTANTS;

                ['LEFT', 'MIDDLE', 'RIGHT'].forEach(btn => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.justifyContent = 'space-between';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';

                    const label = document.createElement('label');
                    label.innerText = `${btn} Mouse Button:`;
                    label.style.fontSize = '14px';

                    const select = document.createElement('select');
                    select.style.padding = '4px';
                    select.style.background = '#222';
                    select.style.color = '#ddd';
                    select.style.border = '1px solid #555';
                    select.style.borderRadius = '4px';

                    Object.keys(ACTIONS).forEach(actionKey => {
                        const actionId = ACTIONS[actionKey];
                        const opt = document.createElement('option');
                        opt.value = actionId;
                        opt.innerText = ACTION_LABELS[actionId];
                        if (config.mouse[btn] === actionId) opt.selected = true;
                        select.appendChild(opt);
                    });

                    select.onchange = (e) => { ControlRegistry.updateMapping(btn, parseInt(e.target.value)); };
                    row.appendChild(label);
                    row.appendChild(select);
                    section.appendChild(row);
                });
                content.appendChild(section);

                const hint = document.createElement('div');
                hint.style.fontSize = '12px';
                hint.style.color = '#888';
                hint.style.marginTop = '10px';
                hint.innerText = 'Tip: Changes apply immediately.';
                content.appendChild(hint);
            }

            function togglePanel() { isVisible ? hidePanel() : showPanel(); }
            function showPanel() { refreshUI(); container.style.display = 'block'; isVisible = true; }
            function hidePanel() { container.style.display = 'none'; isVisible = false; }

            return { init, toggle: togglePanel };
        })();
        if (typeof window !== 'undefined') window.SettingsPanel = SettingsPanel;
    </script>

    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function () {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false,
        renderer: null, // Three.js renderer reference
        hardware: null
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;
        if (_state.hudElement) return; // Idempotent

        // Hardware info
        if (typeof HardwareInfo !== 'undefined') {
            _state.hardware = HardwareInfo.get();
        }

        // Create Enhanced HUD
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(10, 12, 16, 0.95); color: #eee; font-family: 'SF Mono', monospace;
            font-size: 10px; padding: 0; border-radius: 6px;
            border: 1px solid #333; min-width: 300px; /* Wider for 3 columns */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            overflow: hidden;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Link a renderer for deep stats
     */
    function setRenderer(renderer) {
        _state.renderer = renderer;
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        let frameCount = 0;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;

                // Low freq updates (memory, hardware)
                if (typeof HardwareInfo !== 'undefined') HardwareInfo.refresh();
            }
            _state.framesThisSecond++;

            // Throttle HUD DOM updates to 10fps to save CPU
            if (frameCount++ % 6 === 0) {
                _updateHUD();
            }

            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display (Enhanced)
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // 1. Performance Colors
        let fpsColor = '#4ade80';
        if (_state.fps < 30) fpsColor = '#facc15';
        if (_state.fps < 15) fpsColor = '#f87171';

        // 2. Memory
        let memString = '--';
        if (_state.hardware && _state.hardware.memory) {
            const used = (_state.hardware.memory.usedJSHeapSize / 1048576).toFixed(0);
            const total = (_state.hardware.memory.totalJSHeapSize / 1048576).toFixed(0);
            memString = `${used} / ${total} MB`;
        }

        // 3. Renderer Stats
        let renderInfo = { calls: 0, triangles: 0, geometries: 0 };
        if (_state.renderer && _state.renderer.info) {
            renderInfo.calls = _state.renderer.info.render.calls;
            renderInfo.triangles = _state.renderer.info.render.triangles;
            renderInfo.geometries = _state.renderer.info.memory.geometries;
        }

        // 4. GPU Name
        const gpuName = _state.hardware ? _state.hardware.gpu.replace('ANGLE (', '').replace(')', '') : 'Unknown GPU';

        // TEMPLATE
        _state.hudElement.innerHTML = `
            <div style="padding: 10px; border-right: 1px solid #333;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">PERFORMANCE</div>
                <div style="font-size:18px; color:${fpsColor}; font-weight:bold; letter-spacing:-0.5px">
                    ${_state.fps} <span style="font-size:10px; color:#666">FPS</span>
                </div>
                <div style="margin-top:2px">${avgFrameTime} ms</div>
                <div style="color:#f87171; margin-top:4px">Drops: ${_state.droppedFrames}</div>
                <div style="margin-top:8px; color:#aaa; font-size:9px">MEM: ${memString}</div>
            </div>
            <div style="padding: 10px;">
                <div style="color:#888; margin-bottom:4px; font-weight:600">SCENE & HARDWARE</div>
                <div style="display:flex; justify-content:space-between"><span>Draw Calls:</span> <span>${renderInfo.calls}</span></div>
                <div style="display:flex; justify-content:space-between"><span>Triangles:</span> <span>${(renderInfo.triangles / 1000).toFixed(1)}k</span></div>
                <div style="display:flex; justify-content:space-between"><span>Geometries:</span> <span>${renderInfo.geometries}</span></div>
                
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid #333; color:#666; font-size:9px; line-height:1.2">
                    ${gpuName.substring(0, 40)}...
                </div>
            </div>
        `;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        setRenderer,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;

// BACKWARD COMPAT: Expose logResistance globally as some modules expect it
window.logResistance = PERF_MONITOR.logResistance;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: CODOME boundary nodes (external callers)
        // Always use their explicit color_hint, regardless of color mode
        if (node.is_codome_boundary || node.kind === 'boundary') {
            if (node.color_hint) {
                return node.color_hint;
            }
            // Fallback color mapping by codome_source
            const CODOME_COLORS = {
                'test_entry': '#4CAF50',      // Green
                'entry_point': '#2196F3',     // Blue
                'framework_managed': '#9C27B0', // Purple
                'cross_language': '#FF9800',  // Orange
                'external_boundary': '#00BCD4', // Cyan
                'dynamic_target': '#E91E63'   // Pink
            };
            return CODOME_COLORS[node.codome_source] || '#FF9800';
        }

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            // For boundary nodes, always apply their specific color
            if (node.is_codome_boundary || node.kind === 'boundary') {
                node.color = getNodeColorByMode(node);
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        const BOUNDARY_NODE_SIZE_MULTIPLIER = 1.5; // Boundary nodes 1.5x larger

        const isBoundaryNode = (n) => n.is_codome_boundary || n.kind === 'boundary';
        const sizeWithBoundaryCheck = (baseSize) =>
            isBoundaryNode({ is_codome_boundary: arguments[0]?.is_codome_boundary, kind: arguments[0]?.kind })
                ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER
                : baseSize;

        switch (mode) {
            case 'uniform':
                Graph.nodeVal(n => (isBoundaryNode(n) ? 1.5 : 1) * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'fanout':
                Graph.nodeVal(n => {
                    const baseSize = n.val || n.fanout || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            case 'complexity':
                Graph.nodeVal(n => {
                    const baseSize = Math.max(1, (n.complexity || n.loc || 10) * 0.05);
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
                break;
            default:
                Graph.nodeVal(n => {
                    const baseSize = n.val || 1;
                    return (isBoundaryNode(n) ? baseSize * BOUNDARY_NODE_SIZE_MULTIPLIER : baseSize) * scale;
                });
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

/**
 * Convert HEX color to OKLCH
 * @param {string} hex - Hex color string (#RGB, #RRGGBB, or #RRGGBBAA)
 * @returns {object} {h, c, l} OKLCH values
 */
function hexToOklch(hex) {
    // Parse hex to RGB
    let r = 0, g = 0, b = 0;

    if (!hex || typeof hex !== 'string') {
        return { h: 0, c: 0, l: 0.5 }; // Gray fallback
    }

    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle different hex formats
    if (hex.length === 3) {
        // #RGB -> #RRGGBB
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length >= 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
    } else {
        return { h: 0, c: 0, l: 0.5 }; // Invalid hex, gray fallback
    }

    // Normalize to 0-1
    r /= 255;
    g /= 255;
    b /= 255;

    // Convert sRGB to linear RGB
    const toLinear = (x) => x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    r = toLinear(r);
    g = toLinear(g);
    b = toLinear(b);

    // Linear RGB to OKLab (via LMS)
    const l_ = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const m_ = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const s_ = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);

    const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
    const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
    const bLab = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

    // OKLab to OKLCH
    const C = Math.sqrt(a * a + bLab * bLab);
    let H = Math.atan2(bLab, a) * 180 / Math.PI;
    if (H < 0) H += 360;

    return {
        h: H,
        c: C,
        l: L
    };
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // OKLCH Conversion (for UPB integration)
    toHex: _toHex,
    hexToOklch,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {},
        codome_boundaries: null
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};
        raw.codome_boundaries = data?.codome_boundaries || null;

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Merge CODOME boundaries into main nodes and edges arrays
        _mergeCodomeBooudaries();

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // CODOME BOUNDARY MERGING
    // =========================================================================

    function _mergeCodomeBooudaries() {
        if (!raw.codome_boundaries) return;

        const boundaryNodes = raw.codome_boundaries.boundary_nodes || [];
        const inferredEdges = raw.codome_boundaries.inferred_edges || [];

        if (boundaryNodes.length === 0 && inferredEdges.length === 0) {
            return;
        }

        // Mark boundary nodes with _fromCodome flag
        boundaryNodes.forEach(node => {
            if (node && typeof node === 'object') {
                node._fromCodome = true;
            }
        });

        // Mark inferred edges with _fromCodome flag
        inferredEdges.forEach(edge => {
            if (edge && typeof edge === 'object') {
                edge._fromCodome = true;
            }
        });

        // Merge boundary nodes into main nodes array
        raw.nodes = raw.nodes.concat(boundaryNodes);

        // Merge inferred edges into main links array
        raw.links = raw.links.concat(inferredEdges);

        console.log('%c[DATA] CODOME boundaries merged', 'color: #60a5fa; font-weight: bold',
            `+${boundaryNodes.length} boundary nodes, +${inferredEdges.length} inferred edges`);
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getCodomeBooudaries() { return raw.codome_boundaries; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    /**
     * Get min/max range for a source property across a specific scope.
     * NOT cached - calculates fresh each call (scopes change dynamically).
     *
     * @param {string} sourceKey - Property name (e.g., 'token_estimate', 'in_degree')
     * @param {string} scope - 'global' | 'visible' | 'selection'
     * @returns { min: number, max: number } Range object
     */
    function getRange(sourceKey, scope = 'global') {
        // Get node set based on scope
        let nodes;
        switch (scope) {
            case 'selection':
                nodes = (typeof SELECTION !== 'undefined' && SELECTION.getSelectedNodes)
                    ? SELECTION.getSelectedNodes()
                    : [];
                break;
            case 'visible':
                nodes = getVisibleNodes();
                break;
            case 'global':
            default:
                nodes = raw.nodes;
                break;
        }

        // Extract numeric values
        const values = [];
        for (const node of nodes) {
            const val = _getNodeValue(node, sourceKey);
            if (typeof val === 'number' && !Number.isNaN(val)) {
                values.push(val);
            }
        }

        // Return safe range
        if (values.length === 0) {
            return { min: 0, max: 1 };
        }

        return {
            min: Math.min(...values),
            max: Math.max(...values)
        };
    }

    /**
     * Extract a value from a node for a given source key.
     * Handles nested properties and computed values.
     */
    function _getNodeValue(node, sourceKey) {
        if (!node || !sourceKey) return undefined;

        // Direct property
        if (node[sourceKey] !== undefined) {
            return node[sourceKey];
        }

        // Nested in metrics
        if (node.metrics && node.metrics[sourceKey] !== undefined) {
            return node.metrics[sourceKey];
        }

        // Computed values
        switch (sourceKey) {
            case 'in_degree':
                return (getEdgesTo(node.id) || []).length;
            case 'out_degree':
                return (getEdgesFrom(node.id) || []).length;
            case 'degree':
                return (getEdgesTo(node.id) || []).length + (getEdgesFrom(node.id) || []).length;
            default:
                return undefined;
        }
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getCodomeBooudaries,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,
        getRange,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getCodomeBooudaries() { return DATA.getCodomeBooudaries(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    getRange(sourceKey, scope) { return DATA.getRange(sourceKey, scope); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.2) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.4); // Less aggressive dimming (was 0.5)
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                // Only update timestamp if we actually dragged, to prevent blocking valid background clicks
                _lastMarqueeEndTs = Date.now();
                selectNodesInBox(rect, additive);
            } else {
                // If it was just a click, do NOT update timestamp so maybeClear() can work
                _lastMarqueeEndTs = 0;
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // NOTE: btn-2d binding removed - dimension.js is authoritative for 2D/3D toggle

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const INFERRED_OPACITY = 0.04;  // Lower opacity for inferred edges
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;
    const DASH_PATTERN = [5, 5];   // Dashed line pattern for inferred edges

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Check if an edge is inferred (from CODOME boundaries).
     * Inferred edges are marked with:
     *   - inferred: true
     *   - family: 'Codome'
     *   - _fromCodome: true
     */
    function isInferredEdge(link) {
        return link?.inferred === true ||
            link?.family === 'Codome' ||
            link?._fromCodome === true;
    }

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Check if UPB has edge color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasEdgeBinding === 'function' && UPB.hasEdgeBinding()) {
            // UPB handles edge colors - return null to signal deference
            return null;
        }

        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // EDGE LINE DASH (for inferred edges)
    // =========================================================================

    function getLineDash(link) {
        // Return dashed pattern for inferred CODOME edges
        if (isInferredEdge(link)) {
            return DASH_PATTERN;  // [5, 5] = 5px dash, 5px gap
        }
        return null;  // Solid line for regular edges
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // Inferred edges have lower base opacity
            let opacity = isInferredEdge(link) ? INFERRED_OPACITY : baseOpacity;

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return opacity * dimFactor;
                }
            }
            return opacity;
        });

        // Apply dashed line pattern to inferred CODOME edges
        if (typeof Graph.linkLineDash === 'function') {
            Graph.linkLineDash(link => getLineDash(link));
        }

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        getLineDash,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex,
        isInferredEdge
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function getEdgeLineDash(link) { return EDGE.getLineDash(link); }
function isInferredEdgeGlobal(link) { return EDGE.isInferredEdge(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-color-model.js ═══
/**
 * FILE COLOR MODEL
 * 
 * Pure color generation for file visualization.
 * ZERO external dependencies - fully testable in isolation.
 * 
 * Extracted from file-viz.js God Object decomposition.
 * 
 * @usage
 *   const colors = new FileColorModel({ strategy: 'golden-angle' });
 *   const color = colors.getColor(fileIdx, totalFiles, fileName);
 */

const FileColorModel = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const GOLDEN_RATIO = 1.618033988749895;
    const GOLDEN_ANGLE = 360 / (GOLDEN_RATIO * GOLDEN_RATIO); // ~137.5°

    const STRATEGIES = {
        'golden-angle': 'golden-angle',
        'sequential': 'sequential',
        'hash': 'hash'
    };

    const DEFAULT_CONFIG = {
        strategy: 'golden-angle',
        saturation: 0.7,
        lightness: 0.55,
        lightnessRange: { min: 0.35, max: 0.75 },
        hueOffset: 0
    };

    // =========================================================================
    // PURE UTILITY FUNCTIONS
    // =========================================================================

    /**
     * Clamp value to range
     */
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Convert HSL to CSS color string
     */
    function hslToString(h, s, l) {
        return `hsl(${h.toFixed(1)}, ${(s * 100).toFixed(1)}%, ${(l * 100).toFixed(1)}%)`;
    }

    /**
     * Convert HSL to hex color
     */
    function hslToHex(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;

        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }

        const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Hash string to unit value [0, 1)
     */
    function hashToUnit(str) {
        if (!str) return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash % 1000) / 1000;
    }

    // =========================================================================
    // HUE CALCULATION STRATEGIES
    // =========================================================================

    /**
     * Golden angle distribution - maximally distinct colors
     */
    function hueGoldenAngle(fileIdx, totalFiles, hueOffset) {
        return (fileIdx * GOLDEN_ANGLE + hueOffset) % 360;
    }

    /**
     * Sequential distribution - linear spread across spectrum
     */
    function hueSequential(fileIdx, totalFiles, hueOffset) {
        if (totalFiles <= 1) return hueOffset;
        return ((fileIdx / totalFiles) * 360 + hueOffset) % 360;
    }

    /**
     * Hash-based distribution - deterministic based on filename
     */
    function hueFromHash(fileName, hueOffset) {
        return (hashToUnit(fileName) * 360 + hueOffset) % 360;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class FileColorModel {
        constructor(config = {}) {
            this.config = { ...DEFAULT_CONFIG, ...config };
            this._validateConfig();
        }

        _validateConfig() {
            if (!STRATEGIES[this.config.strategy]) {
                console.warn(`[FileColorModel] Unknown strategy "${this.config.strategy}", using golden-angle`);
                this.config.strategy = 'golden-angle';
            }
        }

        /**
         * Get hue for a file based on current strategy
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file (used for hash strategy)
         * @returns {number} Hue value 0-360
         */
        getHue(fileIdx, totalFiles, fileName = '') {
            const { strategy, hueOffset } = this.config;

            switch (strategy) {
                case 'hash':
                    return hueFromHash(fileName, hueOffset);
                case 'sequential':
                    return hueSequential(fileIdx, totalFiles, hueOffset);
                case 'golden-angle':
                default:
                    return hueGoldenAngle(fileIdx, totalFiles, hueOffset);
            }
        }

        /**
         * Get color for a file
         * @param {number} fileIdx - Index of the file
         * @param {number} totalFiles - Total number of files
         * @param {string} fileName - Name of the file
         * @param {Object} overrides - Optional overrides for saturation/lightness
         * @returns {string} CSS color string
         */
        getColor(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToString(hue, saturation, lightness);
        }

        /**
         * Get color as hex string
         */
        getColorHex(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hue = this.getHue(fileIdx, totalFiles, fileName);
            const saturation = overrides.saturation ?? this.config.saturation;
            const lightness = overrides.lightness ?? this.config.lightness;

            return hslToHex(hue, saturation, lightness);
        }

        /**
         * Get color as numeric value for Three.js
         */
        getColorNumeric(fileIdx, totalFiles, fileName = '', overrides = {}) {
            const hex = this.getColorHex(fileIdx, totalFiles, fileName, overrides);
            return parseInt(hex.slice(1), 16);
        }

        /**
         * Generate a palette of N colors
         * @param {number} count - Number of colors to generate
         * @returns {Array<string>} Array of CSS color strings
         */
        generatePalette(count) {
            return Array.from({ length: count }, (_, i) =>
                this.getColor(i, count, `file_${i}`)
            );
        }

        /**
         * Update configuration
         */
        setConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            this._validateConfig();
        }

        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
    }

    // =========================================================================
    // STATIC UTILITIES (for one-off use without instantiation)
    // =========================================================================

    FileColorModel.hslToHex = hslToHex;
    FileColorModel.hslToString = hslToString;
    FileColorModel.hashToUnit = hashToUnit;
    FileColorModel.GOLDEN_ANGLE = GOLDEN_ANGLE;
    FileColorModel.STRATEGIES = STRATEGIES;

    return FileColorModel;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.FileColorModel = FileColorModel;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FileColorModel;
}


// ═══ MODULE: modules/layout-forces.js ═══
/**
 * LAYOUT FORCES
 * 
 * D3 force simulation manipulation for file visualization.
 * Extracted from file-viz.js God Object decomposition.
 * 
 * KEY DESIGN: Takes graph instance as argument - NO GLOBALS.
 * 
 * @usage
 *   LayoutForces.applyClusterForce(Graph, nodes, targets);
 *   LayoutForces.applyCohesionForce(Graph, nodes, config);
 *   LayoutForces.clearForces(Graph, ['cluster', 'fileCohesion']);
 */

const LayoutForces = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const FORCE_NAMES = {
        CLUSTER: 'cluster',
        COHESION: 'fileCohesion',
        RADIAL: 'fileRadial'
    };

    const DEFAULT_COHESION_CONFIG = {
        strength: 0.3,
        radiusFactor: 1.2,
        minRadius: 15,
        maxRadius: 100,
        centerPull: 0.5
    };

    const DEFAULT_CLUSTER_CONFIG = {
        strength: 0.15,
        decay: 0.02
    };

    // =========================================================================
    // CORE FORCE FUNCTIONS
    // =========================================================================

    /**
     * Create a clustering force that pulls nodes toward target positions
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to apply force to (must have x, y, z)
     * @param {Map|Object} targets - Map of nodeId -> { x, y, z } target positions
     * @param {Object} config - Force configuration
     */
    function applyClusterForce(graphInstance, nodes, targets, config = {}) {
        const { strength, decay } = { ...DEFAULT_CLUSTER_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Convert targets to Map if needed
        const targetMap = targets instanceof Map ? targets : new Map(Object.entries(targets));

        // Create custom force
        const clusterForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach(node => {
                const target = targetMap.get(node.id);
                if (!target) return;

                // Pull toward target
                const dx = target.x - (node.x || 0);
                const dy = target.y - (node.y || 0);
                const dz = target.z - (node.z || 0);

                node.vx = (node.vx || 0) + dx * effectiveStrength;
                node.vy = (node.vy || 0) + dy * effectiveStrength;
                node.vz = (node.vz || 0) + dz * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.CLUSTER, clusterForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    /**
     * Apply file cohesion force - pulls nodes together within file groups
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - All graph nodes
     * @param {Object} config - Force configuration and physics settings
     */
    function applyCohesionForce(graphInstance, nodes, config = {}) {
        const settings = { ...DEFAULT_COHESION_CONFIG, ...config };

        if (!graphInstance || !graphInstance.d3Force) {
            console.warn('[LayoutForces] No graph instance or d3Force not available');
            return false;
        }

        // Group nodes by file
        const fileGroups = new Map();
        nodes.forEach(node => {
            const fileIdx = node.fileIdx;
            if (fileIdx === undefined || fileIdx < 0) return;

            if (!fileGroups.has(fileIdx)) {
                fileGroups.set(fileIdx, []);
            }
            fileGroups.get(fileIdx).push(node);
        });

        // Precompute centroids
        const centroids = new Map();
        fileGroups.forEach((group, fileIdx) => {
            if (group.length === 0) return;

            const centroid = { x: 0, y: 0, z: 0 };
            group.forEach(n => {
                centroid.x += n.x || 0;
                centroid.y += n.y || 0;
                centroid.z += n.z || 0;
            });
            centroid.x /= group.length;
            centroid.y /= group.length;
            centroid.z /= group.length;

            centroids.set(fileIdx, centroid);
        });

        // Create cohesion force
        const cohesionForce = (alpha) => {
            const effectiveStrength = settings.strength * alpha;

            fileGroups.forEach((group, fileIdx) => {
                if (group.length < 2) return;

                const centroid = centroids.get(fileIdx);
                if (!centroid) return;

                // Compute group radius
                let maxDist = 0;
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const targetRadius = Math.min(
                    settings.maxRadius,
                    Math.max(settings.minRadius, maxDist * settings.radiusFactor)
                );

                // Apply force toward centroid with boundary constraint
                group.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

                    // Pull toward centroid
                    const pullStrength = effectiveStrength * settings.centerPull;
                    n.vx = (n.vx || 0) - dx * pullStrength / dist;
                    n.vy = (n.vy || 0) - dy * pullStrength / dist;
                    n.vz = (n.vz || 0) - dz * pullStrength / dist;

                    // Boundary constraint if outside target radius
                    if (dist > targetRadius) {
                        const overshoot = (dist - targetRadius) / dist;
                        n.vx = (n.vx || 0) - dx * overshoot * effectiveStrength;
                        n.vy = (n.vy || 0) - dy * overshoot * effectiveStrength;
                        n.vz = (n.vz || 0) - dz * overshoot * effectiveStrength;
                    }
                });

                // Update centroid for next iteration
                let newCentroid = { x: 0, y: 0, z: 0 };
                group.forEach(n => {
                    newCentroid.x += n.x || 0;
                    newCentroid.y += n.y || 0;
                    newCentroid.z += n.z || 0;
                });
                newCentroid.x /= group.length;
                newCentroid.y /= group.length;
                newCentroid.z /= group.length;
                centroids.set(fileIdx, newCentroid);
            });
        };

        graphInstance.d3Force(FORCE_NAMES.COHESION, cohesionForce);
        graphInstance.d3ReheatSimulation();

        console.log(`[LayoutForces] Cohesion force applied to ${fileGroups.size} file groups`);
        return true;
    }

    /**
     * Clear specific forces from the simulation
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array<string>} forceNames - Names of forces to clear
     */
    function clearForces(graphInstance, forceNames = [FORCE_NAMES.CLUSTER, FORCE_NAMES.COHESION]) {
        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        forceNames.forEach(name => {
            graphInstance.d3Force(name, null);
        });

        return true;
    }

    /**
     * Apply radial force - arranges nodes in a ring
     * @param {Object} graphInstance - The ForceGraph3D instance
     * @param {Array} nodes - Nodes to arrange
     * @param {Object} config - { radius, strength, center: {x, y, z} }
     */
    function applyRadialForce(graphInstance, nodes, config = {}) {
        const { radius = 100, strength = 0.3, center = { x: 0, y: 0, z: 0 } } = config;

        if (!graphInstance || !graphInstance.d3Force) {
            return false;
        }

        const radialForce = (alpha) => {
            const effectiveStrength = strength * alpha;

            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * Math.PI * 2;
                const targetX = center.x + Math.cos(angle) * radius;
                const targetY = center.y + Math.sin(angle) * radius;
                const targetZ = center.z;

                node.vx = (node.vx || 0) + (targetX - (node.x || 0)) * effectiveStrength;
                node.vy = (node.vy || 0) + (targetY - (node.y || 0)) * effectiveStrength;
                node.vz = (node.vz || 0) + (targetZ - (node.z || 0)) * effectiveStrength;
            });
        };

        graphInstance.d3Force(FORCE_NAMES.RADIAL, radialForce);
        graphInstance.d3ReheatSimulation();

        return true;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Force application
        applyClusterForce,
        applyCohesionForce,
        applyRadialForce,
        clearForces,

        // Constants
        FORCE_NAMES,
        DEFAULT_COHESION_CONFIG,
        DEFAULT_CLUSTER_CONFIG
    };
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.LayoutForces = LayoutForces;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = LayoutForces;
}


// ═══ MODULE: modules/hull-visualizer.js ═══
/**
 * HULL VISUALIZER - SDF-Based Organic Membranes
 * 
 * Renders file group boundaries using Signed Distance Functions.
 * GPU-accelerated via WebGL shaders for smooth, organic membrane look.
 * 
 * Advantages over Metaballs/Marching Cubes:
 * - Implicit smooth blending between overlapping groups
 * - Real-time performance with 100+ groups
 * - Distance queries for hit testing
 * - Smooth normals for lighting
 * 
 * @usage
 *   const hulls = new HullVisualizer(scene, renderer);
 *   hulls.update(nodesByFile, colorProvider);
 *   hulls.setBlendFactor(0.5); // Membrane smoothness
 *   hulls.dispose();
 */

const HullVisualizer = (function () {
    'use strict';

    // =========================================================================
    // SHADER CODE
    // =========================================================================

    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        void main() {
            vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Fragment shader with SDF smooth union
    const FRAGMENT_SHADER = `
        precision highp float;
        
        uniform vec3 uCenters[64];      // Up to 64 group centers
        uniform float uRadii[64];       // Corresponding radii
        uniform vec3 uColors[64];       // Group colors
        uniform int uGroupCount;        // Active group count
        uniform float uBlendFactor;     // Smooth union factor (higher = more blending)
        uniform float uOpacity;         // Overall opacity
        uniform vec3 uCameraPos;        // Camera position for fresnel
        
        varying vec3 vWorldPos;
        varying vec3 vNormal;
        
        // Smooth minimum (for organic blending)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }
        
        // SDF for a sphere
        float sdSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }
        
        // Compute combined SDF for all groups
        float sceneSDF(vec3 p) {
            if (uGroupCount == 0) return 1000.0;
            
            float d = sdSphere(p, uCenters[0], uRadii[0]);
            
            for (int i = 1; i < 64; i++) {
                if (i >= uGroupCount) break;
                float di = sdSphere(p, uCenters[i], uRadii[i]);
                d = smin(d, di, uBlendFactor);
            }
            
            return d;
        }
        
        // Get blended color based on distance to each group
        vec3 getBlendedColor(vec3 p) {
            if (uGroupCount == 0) return vec3(0.5);
            
            vec3 colorSum = vec3(0.0);
            float weightSum = 0.0;
            
            for (int i = 0; i < 64; i++) {
                if (i >= uGroupCount) break;
                float d = length(p - uCenters[i]);
                float weight = 1.0 / (d * d + 0.01);
                colorSum += uColors[i] * weight;
                weightSum += weight;
            }
            
            return colorSum / max(weightSum, 0.001);
        }
        
        void main() {
            float sdf = sceneSDF(vWorldPos);
            
            // Only render near the surface (within membrane thickness)
            float thickness = uBlendFactor * 0.5;
            if (abs(sdf) > thickness) discard;
            
            // Compute normal from SDF gradient
            vec3 eps = vec3(0.01, 0.0, 0.0);
            vec3 sdfNormal = normalize(vec3(
                sceneSDF(vWorldPos + eps.xyy) - sceneSDF(vWorldPos - eps.xyy),
                sceneSDF(vWorldPos + eps.yxy) - sceneSDF(vWorldPos - eps.yxy),
                sceneSDF(vWorldPos + eps.yyx) - sceneSDF(vWorldPos - eps.yyx)
            ));
            
            // Fresnel effect for glass-like appearance
            vec3 viewDir = normalize(uCameraPos - vWorldPos);
            float fresnel = pow(1.0 - abs(dot(viewDir, sdfNormal)), 2.0);
            
            // Get blended color
            vec3 color = getBlendedColor(vWorldPos);
            
            // Edge fade based on SDF distance
            float edgeFade = 1.0 - smoothstep(0.0, thickness, abs(sdf));
            
            // Final color with fresnel rim lighting
            vec3 finalColor = color + fresnel * 0.3;
            float finalOpacity = uOpacity * edgeFade * (0.3 + fresnel * 0.5);
            
            gl_FragColor = vec4(finalColor, finalOpacity);
        }
    `;

    // =========================================================================
    // FALLBACK: Simple sphere-based visualization (when shaders unavailable)
    // =========================================================================

    function createFallbackMesh(center, radius, color, THREE) {
        const geometry = new THREE.SphereGeometry(radius, 24, 24);
        const material = new THREE.MeshPhysicalMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.0,
            clearcoat: 0.3,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(center);
        mesh.renderOrder = -1; // Render behind nodes

        return mesh;
    }

    // =========================================================================
    // MAIN CLASS
    // =========================================================================

    class HullVisualizer {
        constructor(scene, renderer, options = {}) {
            this.scene = scene;
            this.renderer = renderer;
            this.options = {
                maxGroups: 64,
                blendFactor: 2.0,
                opacity: 0.25,
                paddingFactor: 1.3,
                minRadius: 5,
                useShaders: options.useShaders !== false,
                ...options
            };

            this.meshes = [];
            this.shaderMaterial = null;
            this.uniforms = null;
            this.boundingMesh = null;

            this._initShaderMaterial();
        }

        _initShaderMaterial() {
            if (!this.options.useShaders || typeof THREE === 'undefined') {
                console.log('[HullVisualizer] Using fallback sphere rendering');
                return;
            }

            try {
                this.uniforms = {
                    uCenters: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3()) },
                    uRadii: { value: new Float32Array(this.options.maxGroups) },
                    uColors: { value: new Array(this.options.maxGroups).fill(new THREE.Vector3(0.5, 0.5, 0.5)) },
                    uGroupCount: { value: 0 },
                    uBlendFactor: { value: this.options.blendFactor },
                    uOpacity: { value: this.options.opacity },
                    uCameraPos: { value: new THREE.Vector3() }
                };

                this.shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: FRAGMENT_SHADER,
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                console.log('[HullVisualizer] SDF shader initialized');
            } catch (e) {
                console.warn('[HullVisualizer] Shader init failed, using fallback:', e.message);
                this.shaderMaterial = null;
            }
        }

        /**
         * Update visualization with new node groups
         * @param {Map|Object} nodesByFile - Map of fileIdx -> [nodes]
         * @param {Function} colorProvider - (fileIdx, total) -> color string or number
         */
        update(nodesByFile, colorProvider) {
            this.clear();

            // Convert to Map if needed
            const groups = nodesByFile instanceof Map ?
                nodesByFile :
                new Map(Object.entries(nodesByFile));

            if (groups.size === 0) return;

            const groupData = [];

            // Compute centroids and radii
            groups.forEach((nodes, fileIdx) => {
                if (!nodes || nodes.length === 0) return;

                // Compute centroid
                const centroid = { x: 0, y: 0, z: 0 };
                nodes.forEach(n => {
                    centroid.x += n.x || 0;
                    centroid.y += n.y || 0;
                    centroid.z += n.z || 0;
                });
                centroid.x /= nodes.length;
                centroid.y /= nodes.length;
                centroid.z /= nodes.length;

                // Compute radius (max distance from centroid + padding)
                let maxDist = 0;
                nodes.forEach(n => {
                    const dx = (n.x || 0) - centroid.x;
                    const dy = (n.y || 0) - centroid.y;
                    const dz = (n.z || 0) - centroid.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (dist > maxDist) maxDist = dist;
                });

                const radius = Math.max(
                    this.options.minRadius,
                    maxDist * this.options.paddingFactor
                );

                // Get color
                const color = colorProvider ?
                    colorProvider(parseInt(fileIdx), groups.size) :
                    '#888888';

                groupData.push({
                    fileIdx,
                    center: new THREE.Vector3(centroid.x, centroid.y, centroid.z),
                    radius,
                    color: this._parseColor(color)
                });
            });

            // Limit to max groups
            const activeGroups = groupData.slice(0, this.options.maxGroups);

            if (this.shaderMaterial && this.uniforms) {
                this._updateShaderUniforms(activeGroups);
                this._createBoundingMesh(activeGroups);
            } else {
                this._createFallbackMeshes(activeGroups);
            }

            console.log(`[HullVisualizer] Updated ${activeGroups.length} group boundaries`);
        }

        _parseColor(color) {
            if (typeof color === 'number') {
                return new THREE.Color(color);
            }
            if (typeof color === 'string') {
                return new THREE.Color(color);
            }
            if (color instanceof THREE.Color) {
                return color;
            }
            return new THREE.Color(0x888888);
        }

        _updateShaderUniforms(groups) {
            groups.forEach((g, i) => {
                this.uniforms.uCenters.value[i] = g.center;
                this.uniforms.uRadii.value[i] = g.radius;
                this.uniforms.uColors.value[i] = new THREE.Vector3(g.color.r, g.color.g, g.color.b);
            });
            this.uniforms.uGroupCount.value = groups.length;
        }

        _createBoundingMesh(groups) {
            // Create a large bounding box that contains all groups
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            groups.forEach(g => {
                minX = Math.min(minX, g.center.x - g.radius);
                minY = Math.min(minY, g.center.y - g.radius);
                minZ = Math.min(minZ, g.center.z - g.radius);
                maxX = Math.max(maxX, g.center.x + g.radius);
                maxY = Math.max(maxY, g.center.y + g.radius);
                maxZ = Math.max(maxZ, g.center.z + g.radius);
            });

            const width = maxX - minX + this.options.blendFactor * 2;
            const height = maxY - minY + this.options.blendFactor * 2;
            const depth = maxZ - minZ + this.options.blendFactor * 2;

            const geometry = new THREE.BoxGeometry(width, height, depth, 32, 32, 32);
            this.boundingMesh = new THREE.Mesh(geometry, this.shaderMaterial);
            this.boundingMesh.position.set(
                (minX + maxX) / 2,
                (minY + maxY) / 2,
                (minZ + maxZ) / 2
            );
            this.boundingMesh.renderOrder = -1;

            this.scene.add(this.boundingMesh);
            this.meshes.push(this.boundingMesh);
        }

        _createFallbackMeshes(groups) {
            groups.forEach(g => {
                const mesh = createFallbackMesh(g.center, g.radius, g.color, THREE);
                this.scene.add(mesh);
                this.meshes.push(mesh);
            });
        }

        /**
         * Update camera position for fresnel effect
         */
        updateCamera(cameraPosition) {
            if (this.uniforms && this.uniforms.uCameraPos) {
                this.uniforms.uCameraPos.value.copy(cameraPosition);
            }
        }

        /**
         * Set blend factor (higher = more organic blending)
         */
        setBlendFactor(factor) {
            this.options.blendFactor = factor;
            if (this.uniforms) {
                this.uniforms.uBlendFactor.value = factor;
            }
        }

        /**
         * Set opacity
         */
        setOpacity(opacity) {
            this.options.opacity = opacity;
            if (this.uniforms) {
                this.uniforms.uOpacity.value = opacity;
            }
            // Update fallback meshes
            this.meshes.forEach(m => {
                if (m.material && m.material.opacity !== undefined) {
                    m.material.opacity = opacity;
                }
            });
        }

        /**
         * Clear all rendered hulls
         */
        clear() {
            this.meshes.forEach(mesh => {
                this.scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material && mesh.material !== this.shaderMaterial) {
                    mesh.material.dispose();
                }
            });
            this.meshes = [];
            this.boundingMesh = null;
        }

        /**
         * Dispose of all resources
         */
        dispose() {
            this.clear();
            if (this.shaderMaterial) {
                this.shaderMaterial.dispose();
                this.shaderMaterial = null;
            }
        }

        /**
         * Check if a point is inside any hull
         * @returns {number|null} fileIdx if inside, null otherwise
         */
        hitTest(point) {
            if (!this.uniforms) return null;

            const count = this.uniforms.uGroupCount.value;
            for (let i = 0; i < count; i++) {
                const center = this.uniforms.uCenters.value[i];
                const radius = this.uniforms.uRadii.value[i];
                const dist = point.distanceTo(center);
                if (dist < radius) {
                    return i; // Return group index
                }
            }
            return null;
        }
    }

    // =========================================================================
    // STATIC FACTORY
    // =========================================================================

    HullVisualizer.create = function (scene, renderer, options) {
        return new HullVisualizer(scene, renderer, options);
    };

    return HullVisualizer;
})();

// Export for both browser and module contexts
if (typeof window !== 'undefined') {
    window.HullVisualizer = HullVisualizer;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HullVisualizer;
}


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ CONTROLLER
 * 
 * Thin orchestrator for file visualization modes.
 * Delegates to specialized modules:
 *   - FileColorModel: Color generation
 *   - LayoutForces: D3 physics manipulation
 *   - HullVisualizer: SDF-based boundary rendering
 * 
 * DESIGN PRINCIPLE: This module coordinates, it does NOT implement.
 * All implementation details live in the delegated modules.
 * 
 * @usage
 *   FILE_VIZ.setEnabled(true);
 *   FILE_VIZ.setMode('hulls');
 *   FILE_VIZ.apply();
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS & MODES
    // =========================================================================

    const MODES = {
        OFF: 'off',
        COLOR: 'color',
        HULLS: 'hulls',
        MAP: 'map'
    };

    // =========================================================================
    // STATE (minimal - delegates to child modules)
    // =========================================================================

    let _enabled = false;
    let _mode = MODES.COLOR;
    let _colorModel = null;
    let _hullVisualizer = null;
    let _fileGraph = null;
    let _expandedFiles = new Set();
    let _graphMode = 'atoms'; // atoms | files

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function _ensureColorModel() {
        if (!_colorModel && typeof FileColorModel !== 'undefined') {
            _colorModel = new FileColorModel({ strategy: 'golden-angle' });
        }
        return _colorModel;
    }

    function _ensureHullVisualizer() {
        if (!_hullVisualizer && typeof HullVisualizer !== 'undefined') {
            const scene = typeof Graph !== 'undefined' ? Graph.scene() : null;
            const renderer = typeof Graph !== 'undefined' ? Graph.renderer() : null;
            if (scene && renderer) {
                _hullVisualizer = new HullVisualizer(scene, renderer, {
                    blendFactor: 2.0,
                    opacity: 0.2
                });
            }
        }
        return _hullVisualizer;
    }

    // =========================================================================
    // COLOR FUNCTIONS (delegated to FileColorModel)
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const model = _ensureColorModel();
        if (!model) {
            // Fallback if module not loaded
            return `hsl(${(fileIdx * 137.5) % 360}, 70%, 55%)`;
        }

        const overrides = lightnessOverride ? { lightness: lightnessOverride } : {};
        return model.getColor(fileIdx, totalFiles, fileName, overrides);
    }

    function applyColors(graphNodes) {
        if (!_enabled || !graphNodes) return;

        // Check if UPB has active color bindings - defer to UPB if so
        const UPB = typeof window !== 'undefined' ? window.UPB : null;
        if (UPB && typeof UPB.hasColorBinding === 'function' && UPB.hasColorBinding()) {
            // UPB is handling colors - don't override
            console.log('[FILE_VIZ] Deferring to UPB for node colors');
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        const boundaries = dm ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                const fileName = boundaries[node.fileIdx]?.file_name || '';
                node.color = getColor(node.fileIdx, totalFiles, fileName);
            }
        });
    }

    // =========================================================================
    // HULL FUNCTIONS (delegated to HullVisualizer)
    // =========================================================================

    function drawFileBoundaries(data) {
        const viz = _ensureHullVisualizer();
        if (!viz) {
            console.warn('[FILE_VIZ] HullVisualizer not available');
            return 0;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return 0;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Group nodes by file
        const nodesByFile = new Map();
        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!nodesByFile.has(node.fileIdx)) {
                nodesByFile.set(node.fileIdx, []);
            }
            nodesByFile.get(node.fileIdx).push(node);
        });

        // Color provider
        const colorProvider = (fileIdx, total) => {
            const fileName = boundaries[fileIdx]?.file_name || '';
            return getColor(fileIdx, total, fileName);
        };

        viz.update(nodesByFile, colorProvider);
        return nodesByFile.size;
    }

    function clearBoundaries() {
        if (_hullVisualizer) {
            _hullVisualizer.clear();
        }
    }

    // =========================================================================
    // PHYSICS FUNCTIONS (delegated to LayoutForces)
    // =========================================================================

    function applyClusterForce(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const boundaries = dm.getFileBoundaries();

        // Compute file centroid targets
        const targets = new Map();
        const fileNodes = new Map();

        nodes.forEach(node => {
            if (node.fileIdx === undefined || node.fileIdx < 0) return;
            if (!fileNodes.has(node.fileIdx)) {
                fileNodes.set(node.fileIdx, []);
            }
            fileNodes.get(node.fileIdx).push(node);
        });

        // Create spiral layout for file groups
        const totalFiles = fileNodes.size;
        let fileIndex = 0;
        fileNodes.forEach((group, fileIdx) => {
            const angle = fileIndex * 2.4; // Golden angle
            const radius = 50 + fileIndex * 10;
            const target = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: (fileIndex - totalFiles / 2) * 5
            };

            group.forEach(node => {
                targets.set(node.id, target);
            });
            fileIndex++;
        });

        return LayoutForces.applyClusterForce(Graph, nodes, targets);
    }

    function applyCohesion(data) {
        if (typeof LayoutForces === 'undefined' || typeof Graph === 'undefined') {
            return false;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return false;

        const nodes = dm.getNodes();
        const physicsConfig = dm.raw?.physics || {};

        return LayoutForces.applyCohesionForce(Graph, nodes, {
            strength: physicsConfig.fileCohesion || 0.3
        });
    }

    function clearCohesion() {
        if (typeof LayoutForces !== 'undefined' && typeof Graph !== 'undefined') {
            LayoutForces.clearForces(Graph);
        }
    }

    // =========================================================================
    // FILE GRAPH (map mode)
    // =========================================================================

    function buildFileGraph() {
        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return null;

        const boundaries = dm.getFileBoundaries();
        const links = dm.getLinks();

        // Create file nodes
        const fileNodes = boundaries.map((boundary, idx) => ({
            id: `file:${idx}`,
            name: boundary.file_name || `File ${idx}`,
            fileIdx: idx,
            isFileNode: true,
            atomCount: boundary.atom_count || boundary.atom_indices?.length || 0,
            val: Math.max(1, Math.sqrt(boundary.atom_count || 1)),
            color: getColor(idx, boundaries.length, boundary.file_name),
            x: 0, y: 0, z: 0
        }));

        // Build file-to-file links from atom links
        const atomToFile = new Map();
        dm.getNodes().forEach(node => {
            if (node.fileIdx !== undefined && node.fileIdx >= 0) {
                atomToFile.set(node.id, node.fileIdx);
            }
        });

        const fileLinkCounts = new Map();
        links.forEach(link => {
            const srcFile = atomToFile.get(link.source?.id || link.source);
            const tgtFile = atomToFile.get(link.target?.id || link.target);

            if (srcFile !== undefined && tgtFile !== undefined && srcFile !== tgtFile) {
                const key = `${srcFile}-${tgtFile}`;
                fileLinkCounts.set(key, (fileLinkCounts.get(key) || 0) + 1);
            }
        });

        const fileLinks = [];
        fileLinkCounts.forEach((count, key) => {
            const [src, tgt] = key.split('-').map(Number);
            fileLinks.push({
                source: `file:${src}`,
                target: `file:${tgt}`,
                weight: count,
                opacity: Math.min(0.8, 0.1 + count * 0.05)
            });
        });

        _fileGraph = { nodes: fileNodes, links: fileLinks };
        return _fileGraph;
    }

    function applyFileGraphMode() {
        if (!_fileGraph) buildFileGraph();
        if (!_fileGraph || !Graph) return;  // Guard against null AND undefined

        Graph.graphData(_fileGraph);
        _graphMode = 'files';

        if (typeof showToast !== 'undefined') {
            showToast(`File Map: ${_fileGraph.nodes.length} files, ${_fileGraph.links.length} connections`);
        }

        // Enforce strict centering on Origin (0,0,0)
        if (Graph.d3Force) {
            Graph.d3Force('center', d3.forceCenter(0, 0, 0));
        }
    }

    // =========================================================================
    // MODE APPLICATION
    // =========================================================================

    function apply() {
        if (!_enabled) {
            clearBoundaries();
            clearCohesion();
            return;
        }

        const dm = typeof DM !== 'undefined' ? DM : null;
        if (!dm) return;

        switch (_mode) {
            case MODES.COLOR:
                clearBoundaries();
                applyColors(dm.getNodes());
                if (typeof refreshGraph !== 'undefined') refreshGraph();
                break;

            case MODES.HULLS:
                applyColors(dm.getNodes());
                applyCohesion();
                drawFileBoundaries();
                break;

            case MODES.MAP:
                clearBoundaries();
                applyFileGraphMode();
                break;

            case MODES.OFF:
            default:
                clearBoundaries();
                clearCohesion();
                break;
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = !!enabled;
        apply();

        // Update UI if available
        const btn = document.getElementById('cmd-files');
        if (btn) {
            btn.classList.toggle('active', _enabled);
        }
    }

    function toggle() {
        setEnabled(!_enabled);
        return _enabled;
    }

    function setMode(mode) {
        if (!MODES[mode.toUpperCase()] && !Object.values(MODES).includes(mode)) {
            console.warn(`[FILE_VIZ] Unknown mode: ${mode}`);
            return;
        }
        _mode = mode.toLowerCase();
        if (_enabled) apply();
    }

    function isEnabled() { return _enabled; }
    function getMode() { return _mode; }
    function getFileGraph() { return _fileGraph; }
    function getExpandedFiles() { return _expandedFiles; }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        clearBoundaries();
        clearCohesion();
        if (_hullVisualizer) {
            _hullVisualizer.dispose();
            _hullVisualizer = null;
        }
        _colorModel = null;
        _fileGraph = null;
        _expandedFiles.clear();
    }

    // =========================================================================
    // RETURN PUBLIC API
    // =========================================================================

    return {
        // Mode control
        setEnabled,
        toggle,
        setMode,
        apply,

        // Color functions
        getColor,
        applyColors,

        // Hull functions
        drawFileBoundaries,
        clearBoundaries,

        // Physics
        applyClusterForce,
        applyCohesion,
        clearCohesion,

        // File graph
        buildFileGraph,

        // Getters
        isEnabled,
        getMode,
        getFileGraph,
        getExpandedFiles,

        // Cleanup
        dispose,

        // Constants
        MODES
    };
})();

// Register globally
if (typeof window !== 'undefined') {
    window.FILE_VIZ = FILE_VIZ;
    // Backward compat aliases
    window.drawFileBoundaries = FILE_VIZ.drawFileBoundaries;
    window.getColorForMapping = FILE_VIZ.getColor;
    // Global getter for EXPANDED_FILES (read-only, like SELECTED_NODE_IDS)
    Object.defineProperty(window, 'EXPANDED_FILES', {
        get: () => FILE_VIZ.getExpandedFiles(),
        configurable: true
    });
}


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/upb/scales.js ═══
const UPB_SCALES = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - SCALES MODULE
     * Pure functions for mapping data values to normalized [0,1] ranges.
     */

    const SCALES = {
        // Linear mapping (standard)
        linear: (v, min, max) => (v - min) / (max - min || 1),

        // Logarithmic mapping (good for power-law distributions like LoC)
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },

        // Square root mapping (good for area/size to radius)
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },

        // Inverse linear (higher value = lower output)
        inverse: (v, min, max) => 1 - ((v - min) / (max - min || 1)),

        // Exponential (emphasizes extremes)
        exp: (v, min, max) => {
            const norm = (v - min) / (max - min || 1);
            return Math.pow(norm, 2);
        },

        // Discrete/Categorical mapping
        // Assumes value is an index or exact match in domain
        discrete: (v, min, max, domain) => {
            if (Array.isArray(domain)) {
                const idx = domain.indexOf(v);
                if (idx === -1) return 0.5; // Fallback
                return idx / Math.max(1, domain.length - 1);
            }
            return 0;
        },

        // Rank-based/Percentile (placeholder - requires sorted dataset context)
        percentile: (v, min, max) => (v - min) / (max - min || 1)
    };

    const SCALE_NAMES = Object.keys(SCALES);

    /**
     * Universal applicator
     * @param {string} name - Name of scale function
     * @param {number} value - Raw value to map
     * @param {number} min - Domain minimum
     * @param {number} max - Domain maximum
     * @param {Array} [domain] - Optional domain for discrete scales
     */
    function applyScale(name, value, min, max, domain) {
        const fn = SCALES[name] || SCALES.linear;
        // Clamp result to [0, 1] for safety
        const result = fn(value, min, max, domain);
        return Math.max(0, Math.min(1, result));
    }

    return {
        SCALES,
        SCALE_NAMES,
        applyScale
    };
})();

// Export to window for browser
if (typeof window !== 'undefined') window.UPB_SCALES = UPB_SCALES;
if (typeof module !== 'undefined') module.exports = UPB_SCALES;


// ═══ MODULE: modules/upb/endpoints.js ═══
const UPB_ENDPOINTS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - ENDPOINTS MODULE
     * Definitions/Schema for all Data Sources (inputs) and Visual Targets (outputs).
     */

    // =========================================================================
    // AVAILABLE DATA SOURCES (Mappings FROM)
    // =========================================================================
    const SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Structural
        token_estimate: {
            Type: 'continuous',
            domain: 'file',
            label: 'Token Count',
            tags: ['structural', 'quantitative', 'size']
        },
        line_count: {
            Type: 'continuous',
            domain: 'file',
            label: 'Line Count',
            tags: ['structural', 'quantitative', 'verticality']
        },
        size_bytes: {
            Type: 'continuous',
            domain: 'file',
            label: 'File Size',
            tags: ['structural', 'quantitative', 'weight']
        },
        code_lines: {
            Type: 'continuous',
            domain: 'file',
            label: 'Code Lines',
            tags: ['structural', 'quantitative', 'density']
        },
        complexity_density: {
            Type: 'continuous',
            domain: 'file',
            label: 'Complexity',
            tags: ['structural', 'qualitative', 'entropy']
        },
        cohesion: {
            Type: 'continuous',
            domain: 'file',
            label: 'Cohesion',
            tags: ['structural', 'qualitative', 'unity']
        },

        // Temporal
        age_days: {
            Type: 'continuous',
            domain: 'file',
            label: 'Age (Days)',
            tags: ['temporal', 'quantitative', 'decay']
        },

        // Graph / Topology
        in_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'In-Degree',
            tags: ['topological', 'quantitative', 'popularity']
        },
        out_degree: {
            Type: 'continuous',
            domain: 'node',
            label: 'Out-Degree',
            tags: ['topological', 'quantitative', 'dependency']
        },

        // Categorical
        tier: {
            Type: 'discrete',
            domain: 'node',
            label: 'Tier (Layer)',
            tags: ['architectural', 'categorical', 'hierarchy']
        },
        role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Role',
            tags: ['semantic', 'categorical', 'purpose']
        },
        format_category: {
            Type: 'discrete',
            domain: 'file',
            label: 'Format',
            tags: ['technical', 'categorical', 'syntax']
        },

        // Boolean
        is_test: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Test',
            tags: ['functional', 'boolean', 'quality']
        },
        is_stale: {
            Type: 'boolean',
            domain: 'file',
            label: 'Is Stale',
            tags: ['temporal', 'boolean', 'risk']
        },

        // =====================================================================
        // TREE-SITTER ANALYSIS (T2-T6)
        // =====================================================================

        // T2: Purity Score (D6:EFFECT - continuous)
        D6_pure_score: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity Score',
            range: [0, 1],
            tags: ['theory', 'D6', 'purity', 'effect', 'tree-sitter']
        },

        // T3: Purity Rating (D6:EFFECT - categorical)
        D6_EFFECT: {
            Type: 'discrete',
            domain: 'node',
            label: 'Purity Rating',
            values: ['pure', 'mostly_pure', 'mixed', 'mostly_impure', 'impure'],
            tags: ['theory', 'D6', 'purity', 'categorical', 'tree-sitter']
        },

        // T4: PageRank (graph centrality)
        pagerank: {
            Type: 'continuous',
            domain: 'node',
            label: 'PageRank',
            range: [0, 1],
            tags: ['topological', 'centrality', 'influence', 'quantitative']
        },

        // T5: Betweenness Centrality (bridge nodes)
        betweenness_centrality: {
            Type: 'continuous',
            domain: 'node',
            label: 'Betweenness',
            range: [0, 1],
            tags: ['topological', 'centrality', 'bridge', 'quantitative']
        },

        // T6: Topology Role (categorical)
        topology_role: {
            Type: 'discrete',
            domain: 'node',
            label: 'Topology Role',
            values: ['orphan', 'root', 'leaf', 'hub', 'internal'],
            tags: ['topological', 'categorical', 'structure']
        },

        // =====================================================================
        // CONTROL FLOW METRICS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity (McCabe metric)
        cyclomatic_complexity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Cyclomatic Complexity',
            range: [1, 50],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Complexity Rating (categorical)
        complexity_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Complexity Rating',
            values: ['simple', 'moderate', 'complex', 'very_complex'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // Max Nesting Depth
        max_nesting_depth: {
            Type: 'continuous',
            domain: 'node',
            label: 'Nesting Depth',
            range: [0, 10],
            tags: ['complexity', 'control-flow', 'quantitative', 'tree-sitter']
        },

        // Nesting Rating (categorical)
        nesting_rating: {
            Type: 'discrete',
            domain: 'node',
            label: 'Nesting Rating',
            values: ['shallow', 'moderate', 'deep', 'very_deep'],
            tags: ['complexity', 'control-flow', 'categorical']
        },

        // =====================================================================
        // RPBL SCORES (P4-05/07/08) - Theory Character Dimensions
        // =====================================================================

        // Responsibility (R) - How much does this node do?
        rpbl_responsibility: {
            Type: 'continuous',
            domain: 'node',
            label: 'Responsibility (R)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D3', 'quantitative']
        },

        // Purity (P) - How pure is this node?
        rpbl_purity: {
            Type: 'continuous',
            domain: 'node',
            label: 'Purity (P)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D6', 'quantitative']
        },

        // Boundary (B) - How exposed is this node?
        rpbl_boundary: {
            Type: 'continuous',
            domain: 'node',
            label: 'Boundary (B)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D4', 'quantitative']
        },

        // Lifecycle (L) - What lifecycle stage?
        rpbl_lifecycle: {
            Type: 'continuous',
            domain: 'node',
            label: 'Lifecycle (L)',
            range: [0, 10],
            tags: ['rpbl', 'theory', 'D7', 'quantitative']
        }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Mappings TO)
    // =========================================================================
    const TARGETS = {
        // Geometric
        nodeSize: {
            category: 'geometry',
            range: [1, 30],
            minOutput: 1,           // Prevent zero-size nodes
            blendMode: 'max',       // Multiple bindings → take largest
            label: 'Node Size',
            tags: ['visual', 'geometric', 'magnitude', 'importance']
        },
        xPosition: {
            category: 'geometry',
            range: [-1000, 1000],
            blendMode: 'average',   // Blend positions via average
            label: 'X Position',
            tags: ['visual', 'geometric', 'spatial', 'horizontal']
        },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500], blendMode: 'average' },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300], blendMode: 'average' },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400], minOutput: 50, blendMode: 'max' },

        // Chromatic
        hue: {
            category: 'color',
            range: [0, 360],
            blendMode: 'replace',   // Hue doesn't blend well
            label: 'Color Hue',
            tags: ['visual', 'chromatic', 'identity', 'cyclical']
        },
        saturation: {
            category: 'color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Saturation',
            tags: ['visual', 'chromatic', 'intensity', 'purity']
        },
        lightness: {
            category: 'color',
            range: [0, 100],
            minOutput: 10,          // Prevent invisible (black) nodes
            blendMode: 'average',
            label: 'Lightness',
            tags: ['visual', 'chromatic', 'brightness', 'fade']
        },
        opacity: {
            category: 'color',
            range: [0.1, 1.0],
            minOutput: 0.1,         // Prevent fully transparent nodes
            blendMode: 'multiply',  // Stacked effects multiply
            label: 'Opacity',
            tags: ['visual', 'chromatic', 'presence', 'ghost']
        },

        // Physics / Simulation
        charge: {
            category: 'physics',
            range: [-500, 0],
            blendMode: 'add',       // Charges accumulate
            label: 'Repulsion',
            tags: ['simulation', 'force', 'space', 'isolation']
        },
        collisionRadius: {
            category: 'physics',
            range: [1, 50],
            minOutput: 1,           // Minimum collision body
            blendMode: 'max',
            label: 'Collision Body',
            tags: ['simulation', 'force', 'substance', 'barrier']
        },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1], blendMode: 'average' },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10], minOutput: 1, blendMode: 'add' },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5], blendMode: 'max' },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2], blendMode: 'max' },

        // Edge-specific targets
        edgeHue: {
            category: 'edge-color',
            range: [0, 360],
            blendMode: 'replace',
            label: 'Edge Hue',
            tags: ['visual', 'chromatic', 'edge', 'cyclical']
        },
        edgeSaturation: {
            category: 'edge-color',
            range: [0, 100],
            blendMode: 'average',
            label: 'Edge Saturation',
            tags: ['visual', 'chromatic', 'edge', 'intensity']
        },
        edgeLightness: {
            category: 'edge-color',
            range: [0, 100],
            minOutput: 10,
            blendMode: 'average',
            label: 'Edge Lightness',
            tags: ['visual', 'chromatic', 'edge', 'brightness']
        },
        edgeOpacity: {
            category: 'edge-color',
            range: [0.01, 1.0],
            minOutput: 0.01,
            blendMode: 'multiply',
            label: 'Edge Opacity',
            tags: ['visual', 'chromatic', 'edge', 'presence']
        },
        edgeWidth: {
            category: 'edge-geometry',
            range: [0.5, 5],
            minOutput: 0.5,
            blendMode: 'max',
            label: 'Edge Width',
            tags: ['visual', 'geometric', 'edge', 'thickness']
        }
    };

    function getSource(name) {
        return SOURCES[name] || null;
    }

    function getTarget(name) {
        return TARGETS[name] || null;
    }

    function listSources(typeFilter) {
        if (!typeFilter) return Object.keys(SOURCES);
        return Object.keys(SOURCES).filter(k => SOURCES[k].type === typeFilter);
    }

    function listTargets(categoryFilter) {
        if (!categoryFilter) return Object.keys(TARGETS);
        return Object.keys(TARGETS).filter(k => TARGETS[k].category === categoryFilter);
    }

    return {
        SOURCES,
        TARGETS,
        getSource,
        getTarget,
        listSources,
        listTargets
    };
})();

// Export
if (typeof window !== 'undefined') window.UPB_ENDPOINTS = UPB_ENDPOINTS;
if (typeof module !== 'undefined') module.exports = UPB_ENDPOINTS;


// ═══ MODULE: modules/upb/blenders.js ═══
const UPB_BLENDERS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BLENDERS MODULE
     * Functions for combining multiple normalized [0,1] values into one.
     * Used when multiple data sources drive a single visual target.
     */

    const BLENDERS = {
        // Last one wins (Default legacy behavior)
        replace: (values) => {
            if (!values || values.length === 0) return 0;
            return values[values.length - 1];
        },

        // Average of all inputs
        average: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;

            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / Math.max(1, weightSum);
        },

        // Additive (clamped to 1)
        add: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = (weights && weights[i]) || 1;
                sum += values[i] * w;
            }
            return Math.min(1, sum);
        },

        // Multiplicative
        multiply: (values, weights) => {
            if (!values || values.length === 0) return 0;
            let product = 1;
            for (let i = 0; i < values.length; i++) {
                // Determine effect strength by weight
                // w=1 -> full effect, w=0 -> no change (multiplier 1)
                const w = (weights && weights[i]) || 1;
                const v = values[i];
                // Interpolate between 1 (no effect) and v (full effect)
                const effectiveValue = 1 - (w * (1 - v));
                product *= effectiveValue;
            }
            return product;
        },

        // Maximum value (dominant signal wins)
        max: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.max(...values);
        },

        // Minimum value
        min: (values) => {
            if (!values || values.length === 0) return 0;
            return Math.min(...values);
        }
    };

    /**
     * Apply blending mode
     */
    function blend(mode, values, weights) {
        const fn = BLENDERS[mode] || BLENDERS.replace;
        return fn(values, weights);
    }

    return {
        BLENDERS,
        blend
    };

})();

// Export
if (typeof window !== 'undefined') window.UPB_BLENDERS = UPB_BLENDERS;
if (typeof module !== 'undefined') module.exports = UPB_BLENDERS;


// ═══ MODULE: modules/upb/bindings.js ═══
const UPB_BINDINGS = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - BINDINGS GRAPH MODULE
     * Core engine for Many-to-Many property binding.
     * 
     * Dependencies: UPB_SCALES, UPB_ENDPOINTS
     */

    // =========================================================================
    // CLASS: BINDING
    // A single connection between a Data Source and a Visual Target
    // =========================================================================
    function Binding(source, target, options) {
        options = options || {};

        this.id = options.id || Math.random().toString(36).substr(2, 9);
        this.source = source;      // e.g., 'token_estimate'
        this.target = target;      // e.g., 'nodeSize'
        this.scale = options.scale || 'linear';
        this.weight = options.weight !== undefined ? options.weight : 1.0;
        this.range = options.range || null; // Override target default range

        // Metadata
        this.active = true;
    }

    Binding.prototype.apply = function (node, sourceValue, dataMin, dataMax) {
        if (!this.active) return null;

        // 1. Normalize
        const SCALES = window.UPB_SCALES;
        if (!SCALES) {
            console.error('[UPB] UPB_SCALES not found');
            return 0;
        }

        // Get domain for discrete scales if needed
        const ENDPOINTS = window.UPB_ENDPOINTS;
        const sourceDef = ENDPOINTS ? ENDPOINTS.getSource(this.source) : null;
        const domain = sourceDef ? sourceDef.values : null;

        const normalized = SCALES.applyScale(this.scale, sourceValue, dataMin, dataMax, domain);

        // 2. Map to Target Range
        const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(this.target) : null;

        // Use binding override range, or target default, or fallback [0,1]
        const range = this.range || (targetDef ? targetDef.range : [0, 1]);

        // Interpolate
        return range[0] + normalized * (range[1] - range[0]);
    };


    // =========================================================================
    // CLASS: BINDING GRAPH
    // Manages all active bindings and evaluates them against nodes
    // =========================================================================
    function BindingGraph() {
        this._bindings = {}; // target_key -> [Binding, Binding, ...]
        this._dataRanges = {}; // source_key -> {min, max} cache
    }

    BindingGraph.prototype.bind = function (source, target, options) {
        if (!this._bindings[target]) {
            this._bindings[target] = [];
        }

        // Check for exclusivity (replace existing if 1:1 implied, or add if N:1 supported)
        // For now, simple append. Blending logic handles the rest.
        const binding = new Binding(source, target, options);
        this._bindings[target].push(binding);

        console.log(`[UPB] Bound ${source} -> ${target} (${options?.scale || 'linear'})`);
        return binding;
    };

    BindingGraph.prototype.unbind = function (source, target) {
        if (!this._bindings[target]) return;

        if (source === '*') {
            // Unbind all for this target
            delete this._bindings[target];
        } else {
            // Remove specific binding
            this._bindings[target] = this._bindings[target].filter(b => b.source !== source);
            if (this._bindings[target].length === 0) {
                delete this._bindings[target];
            }
        }
    };

    BindingGraph.prototype.clear = function () {
        this._bindings = {};
        this._dataRanges = {};
    };

    BindingGraph.prototype.getBindingsFor = function (target) {
        return this._bindings[target] || [];
    };

    /**
     * Set data ranges explicitly (usually calculated by data-manager)
     */
    BindingGraph.prototype.setDataRanges = function (ranges) {
        this._dataRanges = ranges || {};
    };

    /**
     * Evaluate all bindings for a single node
     * Returns: { nodeSize: 12.5, hue: 200, ... }
     */
    BindingGraph.prototype.evaluate = function (node) {
        const result = {};
        const targets = Object.keys(this._bindings);

        for (let i = 0; i < targets.length; i++) {
            const targetKey = targets[i];
            const bindings = this._bindings[targetKey];

            if (!bindings || bindings.length === 0) continue;

            const values = [];
            const weights = [];

            // Calculate contribution from each binding
            for (let j = 0; j < bindings.length; j++) {
                const binding = bindings[j];
                const sourceKey = binding.source;

                // Get safe value
                const val = this._getNodeValue(node, sourceKey);
                if (val === null || val === undefined) continue;

                // Get range
                const range = this._dataRanges[sourceKey] || { min: 0, max: 100 };

                const calculated = binding.apply(node, val, range.min, range.max);
                values.push(calculated);
                weights.push(binding.weight);
            }

            // BLEND using UPB_BLENDERS (Phase 6: Robustness)
            if (values.length > 0) {
                // Get target definition for blend mode and minOutput
                const ENDPOINTS = window.UPB_ENDPOINTS;
                const targetDef = ENDPOINTS ? ENDPOINTS.getTarget(targetKey) : null;
                const blendMode = targetDef?.blendMode || 'replace';
                const minOutput = targetDef?.minOutput;

                // Apply blending
                const BLENDERS = window.UPB_BLENDERS;
                let finalValue;
                if (BLENDERS && typeof BLENDERS.blend === 'function') {
                    finalValue = BLENDERS.blend(blendMode, values, weights);
                } else {
                    // Fallback: last wins
                    finalValue = values[values.length - 1];
                }

                // Apply minOutput clamping
                if (minOutput !== undefined && finalValue < minOutput) {
                    finalValue = minOutput;
                }

                result[targetKey] = finalValue;
            }
        }
        return result;
    };

    BindingGraph.prototype.evaluateAll = function (nodes) {
        return nodes.map(n => ({
            id: n.id,
            visuals: this.evaluate(n)
        }));
    };

    // Helper to traverse node properties safely
    BindingGraph.prototype._getNodeValue = function (node, key) {
        if (node[key] !== undefined) return node[key];
        if (node.dimensions && node.dimensions[key] !== undefined) return node.dimensions[key];

        // Dimension alias map
        const aliases = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };
        if (aliases[key] && node.dimensions) return node.dimensions[aliases[key]];

        return null;
    };

    // Default singleton instance
    const defaultGraph = new BindingGraph();

    // =========================================================================
    // PRESET BINDINGS (T8-T9)
    // Recommended mappings for tree-sitter analysis data
    // =========================================================================
    const PRESETS = {
        // T8: Purity → Lightness (pure code appears brighter)
        'purity-lightness': {
            source: 'D6_pure_score',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],  // 30% dark (impure) to 90% bright (pure)
            description: 'Pure code appears brighter'
        },

        // T9: PageRank → Node Size (influential nodes are larger)
        'pagerank-size': {
            source: 'pagerank',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 25],
            description: 'Influential nodes appear larger'
        },

        // Bonus: Betweenness → Saturation (bridge nodes are more vivid)
        'betweenness-saturation': {
            source: 'betweenness_centrality',
            target: 'saturation',
            scale: 'sqrt',
            range: [20, 100],
            description: 'Bridge nodes appear more vivid'
        },

        // Bonus: Topology Role → Hue (different roles, different colors)
        'topology-hue': {
            source: 'topology_role',
            target: 'hue',
            scale: 'discrete',
            // orphan=red, root=green, leaf=blue, hub=purple, internal=gray
            range: [0, 360],
            description: 'Topology roles have distinct colors'
        },

        // =====================================================================
        // CONTROL FLOW PRESETS (P3-09)
        // =====================================================================

        // Cyclomatic Complexity → Node Size (complex functions are larger)
        'complexity-size': {
            source: 'cyclomatic_complexity',
            target: 'nodeSize',
            scale: 'sqrt',    // Compress outliers
            range: [3, 30],
            description: 'Complex functions appear larger'
        },

        // Nesting Depth → Saturation (deeply nested = more vivid warning)
        'nesting-saturation': {
            source: 'max_nesting_depth',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Deeply nested code appears more vivid'
        },

        // Complexity → Hue (simple=green, complex=red gradient)
        'complexity-hue': {
            source: 'cyclomatic_complexity',
            target: 'hue',
            scale: 'linear',
            range: [120, 0],  // Green (120) → Red (0)
            description: 'Simple=green, Complex=red'
        },

        // =====================================================================
        // RPBL PRESETS (P4-05/07/08) - Theory Character Visualization
        // =====================================================================

        // Responsibility → Size (high responsibility = larger)
        'responsibility-size': {
            source: 'rpbl_responsibility',
            target: 'nodeSize',
            scale: 'linear',
            range: [3, 25],
            description: 'High responsibility nodes appear larger'
        },

        // Purity → Lightness (pure = bright, impure = dark)
        'rpbl-purity-lightness': {
            source: 'rpbl_purity',
            target: 'lightness',
            scale: 'linear',
            range: [30, 90],
            description: 'Pure code appears brighter'
        },

        // Boundary → Saturation (exposed = vivid, internal = muted)
        'boundary-saturation': {
            source: 'rpbl_boundary',
            target: 'saturation',
            scale: 'linear',
            range: [20, 100],
            description: 'Exposed boundaries appear more vivid'
        },

        // Lifecycle → Opacity (stable = solid, transient = faded)
        'lifecycle-opacity': {
            source: 'rpbl_lifecycle',
            target: 'opacity',
            scale: 'linear',
            range: [0.3, 1.0],
            description: 'Long-lived code appears more solid'
        }
    };

    /**
     * Apply a named preset to the default graph
     * @param {string} presetName - Key from PRESETS
     * @returns {Binding|null}
     */
    function applyPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) {
            console.warn(`[UPB] Unknown preset: ${presetName}`);
            return null;
        }
        return defaultGraph.bind(preset.source, preset.target, {
            id: `preset-${presetName}`,
            scale: preset.scale,
            range: preset.range
        });
    }

    /**
     * Apply all presets
     */
    function applyAllPresets() {
        Object.keys(PRESETS).forEach(name => applyPreset(name));
        console.log(`[UPB] Applied ${Object.keys(PRESETS).length} preset bindings`);
    }

    /**
     * List available presets
     */
    function listPresets() {
        return Object.keys(PRESETS).map(name => ({
            name,
            ...PRESETS[name]
        }));
    }

    return {
        Binding,
        BindingGraph,
        defaultGraph,
        PRESETS,
        applyPreset,
        applyAllPresets,
        listPresets
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB_BINDINGS = UPB_BINDINGS;
if (typeof module !== 'undefined') module.exports = UPB_BINDINGS;


// ═══ MODULE: modules/upb/index.js ═══
const UPB = (function () {
    'use strict';

    /**
     * UNIVERSAL PROPERTY BINDER - INDEX (AGGREGATOR)
     * Public API for the visualization intelligence layer.
     */

    // Dependency check
    const SCALES = window.UPB_SCALES;
    const ENDPOINTS = window.UPB_ENDPOINTS;
    const BLENDERS = window.UPB_BLENDERS;
    const BINDINGS = window.UPB_BINDINGS;

    if (!SCALES || !ENDPOINTS || !BLENDERS || !BINDINGS) {
        console.error('[UPB] Missing dependencies. Ensure all UPB modules are loaded.');
        return {};
    }

    // Public API
    return {
        // Version
        VERSION: '1.0.0',

        // Modules Access
        SCALES: SCALES,
        ENDPOINTS: ENDPOINTS,
        BLENDERS: BLENDERS,
        BINDINGS: BINDINGS,

        // Quick Aliases for Legacy Compatibility
        DATA_SOURCES: ENDPOINTS.SOURCES,
        VISUAL_TARGETS: ENDPOINTS.TARGETS,

        // Core Actions
        /**
         * Create a new binding
         * @param {string} sourceKey 
         * @param {string} targetKey 
         * @param {object} options 
         */
        bind: function (sourceKey, targetKey, options) {
            return BINDINGS.defaultGraph.bind(sourceKey, targetKey, options);
        },

        /**
         * Remove mappings
         * @param {string} sourceKey 
         * @param {string} targetKey 
         */
        unbind: function (sourceKey, targetKey) {
            return BINDINGS.defaultGraph.unbind(sourceKey, targetKey);
        },

        /**
         * Evaluate visual state for a node
         * @param {object} node 
         */
        evaluate: function (node) {
            return BINDINGS.defaultGraph.evaluate(node);
        },

        /**
         * Bulk evaluation
         * @param {Array} nodes 
         */
        apply: function (nodes) {
            // Note: Data ranges should be set on BINDINGS.defaultGraph before calling this
            // usually by the DataManager
            return BINDINGS.defaultGraph.evaluateAll(nodes);
        },

        /**
         * Initializer - call when data is ready
         */
        init: function (dataRanges) {
            if (dataRanges) {
                BINDINGS.defaultGraph.setDataRanges(dataRanges);
            }
            console.log('[UPB] Universal Property Binder Initialized');
        },

        /**
         * Check if a target has active bindings
         * Used by other modules to defer to UPB when bindings exist
         * @param {string} targetKey - e.g., 'hue', 'nodeSize'
         * @returns {boolean}
         */
        hasBinding: function (targetKey) {
            const bindings = BINDINGS.defaultGraph.getBindingsFor(targetKey);
            return bindings && bindings.length > 0;
        },

        /**
         * Check if any color-related target has active bindings
         * Convenience method for modules that set node.color
         * @returns {boolean}
         */
        hasColorBinding: function () {
            return this.hasBinding('hue') ||
                   this.hasBinding('saturation') ||
                   this.hasBinding('lightness') ||
                   this.hasBinding('opacity');
        },

        /**
         * Check if any edge-related target has active bindings
         * Convenience method for edge-system.js to defer to UPB
         * @returns {boolean}
         */
        hasEdgeBinding: function () {
            return this.hasBinding('edgeHue') ||
                   this.hasBinding('edgeSaturation') ||
                   this.hasBinding('edgeLightness') ||
                   this.hasBinding('edgeOpacity') ||
                   this.hasBinding('edgeWidth');
        }
    };

})();

// Export 
if (typeof window !== 'undefined') window.UPB = UPB;
if (typeof module !== 'undefined') module.exports = UPB;


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;
    let _interval = null;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                    <optgroup label="Tree-sitter Analysis">
                        <option value="D6_pure_score">Purity Score (0-1)</option>
                        <option value="D6_EFFECT">Purity Rating</option>
                        <option value="pagerank">PageRank Influence</option>
                        <option value="betweenness_centrality">Betweenness (Bridge)</option>
                        <option value="topology_role">Topology Role</option>
                    </optgroup>
                    <optgroup label="Control Flow (P3-09)">
                        <option value="cyclomatic_complexity">Cyclomatic Complexity</option>
                        <option value="complexity_rating">Complexity Rating</option>
                        <option value="max_nesting_depth">Nesting Depth</option>
                        <option value="nesting_rating">Nesting Rating</option>
                    </optgroup>
                    <optgroup label="RPBL Character">
                        <option value="rpbl_responsibility">Responsibility (R)</option>
                        <option value="rpbl_purity">Purity (P)</option>
                        <option value="rpbl_boundary">Boundary (B)</option>
                        <option value="rpbl_lifecycle">Lifecycle (L)</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear (even spread)</option>
                    <option value="sqrt" selected>Sqrt (compress giants)</option>
                    <option value="log">Log (heavy compress)</option>
                    <option value="exp">Exp (emphasize extremes)</option>
                    <option value="inverse">Inverse (flip)</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        _interval = setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // CLEANUP
    // =========================================================================

    function dispose() {
        if (_interval) {
            clearInterval(_interval);
            _interval = null;
        }

        // Remove listeners by cloning/replacing (brute force clean)
        // or by removing specific named listeners if we refactored attachListeners
        // Here we just remove the container from DOM which unhooks DOM listeners
        if (_container && _container.parentNode) {
            _container.parentNode.removeChild(_container);
        }
        _container = null;
        _visible = false;

        console.log('[CONTROL_BAR] Disposed');
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Set Data Ranges for normalization (Phase 6: use DATA.getRange)
        // Map control-bar scope to DATA.getRange scope
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        if (dm && typeof dm.getRange === 'function') {
            const dataScope = _config.scope === 'selection' ? 'selection' :
                _config.scope === 'all' ? 'global' : 'visible';
            const range = dm.getRange(sourceKey, dataScope);
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = range;
            }
        } else {
            // Fallback: calculate ad-hoc if DATA.getRange not available
            const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
            if (values.length > 0 && window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = {
                    min: Math.min(...values),
                    max: Math.max(...values)
                };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                // Use OKLCH color space via COLOR module
                const hueOklch = window.COLOR.hexToOklch(node.color || '#808080');
                hueOklch.h = value;
                node.color = window.COLOR.toHex(hueOklch);
                break;

            case 'saturation':
                // Map saturation (0-100) to OKLCH chroma (0-0.3)
                const satOklch = window.COLOR.hexToOklch(node.color || '#808080');
                satOklch.c = (value / 100) * 0.3;
                node.color = window.COLOR.toHex(satOklch);
                break;

            case 'lightness':
                // Map lightness (0-100) to OKLCH lightness (0-1)
                const litOklch = window.COLOR.hexToOklch(node.color || '#808080');
                litOklch.l = value / 100;
                node.color = window.COLOR.toHex(litOklch);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES,
        dispose
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.ungzip(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let SHOW_CODOME = false; // Default: hide CODOME boundary nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// File color config - strategy, lightness, saturation, chroma
let FILE_COLOR_CONFIG = {};
// EDGE_RANGES, NODE_FILE_INDEX - provided by modules (edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => {
                // Boundary nodes get 1.5x size multiplier
                const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
                const baseSize = node.val || 1;
                return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
            })
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    function onWindowResize() {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    }

    // Remove existing listener if function already exists (unlikely in pure script, but good practice)
    if (window.onWindowResize) {
        window.removeEventListener('resize', window.onWindowResize);
    }
    window.onWindowResize = onWindowResize;
    window.addEventListener('resize', onWindowResize);

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // Hook up Advanced Observability (if available)
    if (typeof PERF_MONITOR !== 'undefined' && PERF_MONITOR.setRenderer) {
        PERF_MONITOR.setRenderer(Graph.renderer());
    }

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Use Registry if available, otherwise fallback
        if (typeof ControlRegistry !== 'undefined') {
            controls.mouseButtons = ControlRegistry.getMapping();

            // Listen for runtime updates from Settings Panel
            window.addEventListener('controls-updated', () => {
                console.log('[App] Controls updated from registry');
                controls.mouseButtons = ControlRegistry.getMapping();
            });
        } else {
            // Fallback: Map generic names to integer constants
            // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
            const defaultButtons = {
                LEFT: 2, // PAN
                MIDDLE: 1, // DOLLY
                RIGHT: 0 // ROTATE
            };

            if (navConfig.mouseButtons) {
                controls.mouseButtons = {
                    LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                    MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                    RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
                };
            } else {
                controls.mouseButtons = defaultButtons;
            }
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // Initialize Settings Panel
        if (typeof SettingsPanel !== 'undefined') SettingsPanel.init();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }
    // Filter out CODOME boundary nodes if toggle is OFF
    if (!SHOW_CODOME) {
        visibleNodes = visibleNodes.filter(n => !n.is_codome_boundary && !n._fromCodome);
    }


    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    // Filter out inferred edges from CODOME if toggle is OFF
    if (!SHOW_CODOME) {
        visibleLinks = visibleLinks.filter(l => !l._fromCodome && !l.inferred);
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // Show CODOME Boundaries Toggle
    bindToggle('cfg-toggle-codome', SHOW_CODOME, (active) => {
        SHOW_CODOME = active;
        console.log('[CONFIG] CODOME boundaries:', SHOW_CODOME ? 'ON' : 'OFF');
        // Re-render graph with updated filtering
        const filtered = filterGraph(FULL_GRAPH, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        if (Graph) Graph.graphData(filtered);
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => {
            // Boundary nodes get 1.5x size multiplier
            const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
            const baseSize = node.val || 1;
            return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
        });
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => {
        // Boundary nodes get 1.5x size multiplier
        const isBoundary = node.is_codome_boundary || node.kind === 'boundary';
        const baseSize = node.val || 1;
        return (isBoundary ? baseSize * 1.5 : baseSize) * APPEARANCE_STATE.nodeScale;
    });
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>